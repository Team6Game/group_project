1508344647
3 2
12 libp3linmath 4 Ns0b 12 panda3d.core 
1537
1942 11 MathNumbers 0 4 3479 24 MathNumbers::MathNumbers 0 2 1 2 0
112
inline MathNumbers::MathNumbers(void) = default;
inline MathNumbers::MathNumbers(MathNumbers const &) = default;

1943 12 ~MathNumbers 0 4 3479 25 MathNumbers::~MathNumbers 0 0 0
32
MathNumbers::~MathNumbers(void);

1944 9 deg_2_rad 0 1 0 9 deg_2_rad 0 2 1852 1853 0
67
inline double deg_2_rad(double f);
inline float deg_2_rad(float f);

1945 9 rad_2_deg 0 1 0 9 rad_2_deg 0 2 1854 1855 0
67
inline double rad_2_deg(double f);
inline float rad_2_deg(float f);

1946 10 LVecBase2f 0 4 3480 22 LVecBase2f::LVecBase2f 0 4 3 4 5 6 22
/**
 *
 */

/**
 *
 */
205
inline LVecBase2f::LVecBase2f(void) = default;
inline LVecBase2f::LVecBase2f(float fill_value);
inline LVecBase2f::LVecBase2f(float x, float y);
inline LVecBase2f::LVecBase2f(LVecBase2f const &) = default;

1947 12 operator new 0 4 3480 24 LVecBase2f::operator new 0 1 7 0
124
inline void *LVecBase2f::operator new(std::size_t size);
inline void *LVecBase2f::operator new(std::size_t size, void *ptr);

1948 15 operator delete 0 4 3480 27 LVecBase2f::operator delete 0 0 0
108
inline void LVecBase2f::operator delete(void *ptr);
inline void LVecBase2f::operator delete(void *, void *);

1949 12 validate_ptr 0 4 3480 24 LVecBase2f::validate_ptr 0 0 0
61
static inline bool LVecBase2f::validate_ptr(void const *ptr);

1950 10 operator = 0 4 3480 22 LVecBase2f::operator = 0 2 8 9 0
133
LVecBase2f &LVecBase2f::operator =(LVecBase2f const &copy) = default;
LVecBase2f &LVecBase2f::operator =(float fill_value) = default;

1951 4 zero 0 4 3480 16 LVecBase2f::zero 0 1 10 40
/**
 * Returns a zero-length vector.
 */
55
static inline LVecBase2f const &LVecBase2f::zero(void);

1952 6 unit_x 0 4 3480 18 LVecBase2f::unit_x 0 1 11 35
/**
 * Returns a unit X vector.
 */
57
static inline LVecBase2f const &LVecBase2f::unit_x(void);

1953 6 unit_y 0 4 3480 18 LVecBase2f::unit_y 0 1 12 35
/**
 * Returns a unit Y vector.
 */
57
static inline LVecBase2f const &LVecBase2f::unit_y(void);

1954 10 __reduce__ 0 4 3480 22 LVecBase2f::__reduce__ 0 1 13 0
62
inline PyObject *LVecBase2f::__reduce__(PyObject *self) const;

1955 11 __getattr__ 0 4 3480 23 LVecBase2f::__getattr__ 0 1 14 0
93
inline PyObject *LVecBase2f::__getattr__(PyObject *self, std::string const &attr_name) const;

1956 11 __setattr__ 0 4 3480 23 LVecBase2f::__setattr__ 0 1 15 0
99
inline int LVecBase2f::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

1957 11 operator [] 0 4 3480 23 LVecBase2f::operator [] 0 2 16 17 10
/**
 *
 */
96
inline float LVecBase2f::operator [](int i) const;
inline float &LVecBase2f::operator [](int i);

1958 4 size 0 4 3480 16 LVecBase2f::size 0 1 18 0
44
static constexpr int LVecBase2f::size(void);

1959 6 is_nan 0 4 3480 18 LVecBase2f::is_nan 0 1 19 91
/**
 * Returns true if any component of the vector is not-a-number, false
 * otherwise.
 */
43
inline bool LVecBase2f::is_nan(void) const;

1960 8 get_cell 0 4 3480 20 LVecBase2f::get_cell 0 1 20 10
/**
 *
 */
47
inline float LVecBase2f::get_cell(int i) const;

1961 8 set_cell 0 4 3480 20 LVecBase2f::set_cell 0 1 21 10
/**
 *
 */
53
inline void LVecBase2f::set_cell(int i, float value);

1962 5 get_x 0 4 3480 17 LVecBase2f::get_x 0 1 22 10
/**
 *
 */
43
inline float LVecBase2f::get_x(void) const;

1963 5 get_y 0 4 3480 17 LVecBase2f::get_y 0 1 23 10
/**
 *
 */
43
inline float LVecBase2f::get_y(void) const;

1964 5 set_x 0 4 3480 17 LVecBase2f::set_x 0 1 24 10
/**
 *
 */
43
inline void LVecBase2f::set_x(float value);

1965 5 set_y 0 4 3480 17 LVecBase2f::set_y 0 1 25 10
/**
 *
 */
43
inline void LVecBase2f::set_y(float value);

1966 11 add_to_cell 0 4 3480 23 LVecBase2f::add_to_cell 0 1 26 164
// These next functions add to an existing value.  i.e.
// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
// scripting languages:

/**
 *
 */
56
inline void LVecBase2f::add_to_cell(int i, float value);

1967 5 add_x 0 4 3480 17 LVecBase2f::add_x 0 1 27 10
/**
 *
 */
43
inline void LVecBase2f::add_x(float value);

1968 5 add_y 0 4 3480 17 LVecBase2f::add_y 0 1 28 10
/**
 *
 */
43
inline void LVecBase2f::add_y(float value);

1969 8 get_data 0 4 3480 20 LVecBase2f::get_data 0 1 29 155
/**
 * Returns the address of the first of the two data elements in the vector.
 * The next element occupies the next position consecutively in memory.
 */
53
inline float const *LVecBase2f::get_data(void) const;

1970 18 get_num_components 0 4 3480 30 LVecBase2f::get_num_components 0 1 30 0
58
static constexpr int LVecBase2f::get_num_components(void);

1971 4 fill 0 4 3480 16 LVecBase2f::fill 0 1 31 129
/**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */
47
inline void LVecBase2f::fill(float fill_value);

1972 3 set 0 4 3480 15 LVecBase2f::set 0 1 32 10
/**
 *
 */
46
inline void LVecBase2f::set(float x, float y);

1973 3 dot 0 4 3480 15 LVecBase2f::dot 0 1 33 10
/**
 *
 */
60
inline float LVecBase2f::dot(LVecBase2f const &other) const;

1974 14 length_squared 0 4 3480 26 LVecBase2f::length_squared 0 1 34 69
/**
 * Returns the square of the vector's length, cheap and easy.
 */
52
inline float LVecBase2f::length_squared(void) const;

1975 6 length 0 4 3480 18 LVecBase2f::length 0 1 35 72
/**
 * Returns the length of the vector, by the Pythagorean theorem.
 */
44
inline float LVecBase2f::length(void) const;

1976 9 normalize 0 4 3480 21 LVecBase2f::normalize 0 1 36 127
/**
 * Normalizes the vector in place.  Returns true if the vector was normalized,
 * false if it was a zero-length vector.
 */
40
inline bool LVecBase2f::normalize(void);

1977 10 normalized 0 4 3480 22 LVecBase2f::normalized 0 1 37 160
/**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */
53
inline LVecBase2f LVecBase2f::normalized(void) const;

1978 7 project 0 4 3480 19 LVecBase2f::project 0 1 38 152
/**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */
68
inline LVecBase2f LVecBase2f::project(LVecBase2f const &onto) const;

1979 10 operator < 0 4 3480 22 LVecBase2f::operator < 0 1 39 0
66
inline bool LVecBase2f::operator <(LVecBase2f const &other) const;

1980 11 operator == 0 4 3480 23 LVecBase2f::operator == 0 1 40 0
67
inline bool LVecBase2f::operator ==(LVecBase2f const &other) const;

1981 11 operator != 0 4 3480 23 LVecBase2f::operator != 0 1 41 0
67
inline bool LVecBase2f::operator !=(LVecBase2f const &other) const;

1982 10 compare_to 0 4 3480 22 LVecBase2f::compare_to 0 2 42 43 332
/**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */

/**
 * Sorts vectors lexicographically, componentwise.  Returns a number less than
 * 0 if this vector sorts before the other one, greater than zero if it sorts
 * after, 0 if they are equivalent (within the indicated tolerance).
 */
148
inline int LVecBase2f::compare_to(LVecBase2f const &other) const;
inline int LVecBase2f::compare_to(LVecBase2f const &other, float threshold) const;

1983 8 get_hash 0 4 3480 20 LVecBase2f::get_hash 0 2 44 45 100
/**
 * Returns a suitable hash for phash_map.
 */

/**
 * Returns a suitable hash for phash_map.
 */
116
inline std::size_t LVecBase2f::get_hash(void) const;
inline std::size_t LVecBase2f::get_hash(float threshold) const;

1984 8 add_hash 0 4 3480 20 LVecBase2f::add_hash 0 2 46 47 100
/**
 * Adds the vector into the running hash.
 */

/**
 * Adds the vector into the running hash.
 */
146
inline std::size_t LVecBase2f::add_hash(std::size_t hash) const;
inline std::size_t LVecBase2f::add_hash(std::size_t hash, float threshold) const;

1985 13 generate_hash 0 4 3480 25 LVecBase2f::generate_hash 0 2 48 49 120
/**
 * Adds the vector to the indicated hash generator.
 */

/**
 * Adds the vector to the indicated hash generator.
 */
170
inline void LVecBase2f::generate_hash(ChecksumHashGenerator &hashgen) const;
inline void LVecBase2f::generate_hash(ChecksumHashGenerator &hashgen, float threshold) const;

1986 10 operator - 0 68 3480 22 LVecBase2f::operator - 0 1 50 0
53
inline LVecBase2f LVecBase2f::operator -(void) const;

1987 10 operator + 0 4 3480 22 LVecBase2f::operator + 0 1 51 0
72
inline LVecBase2f LVecBase2f::operator +(LVecBase2f const &other) const;

1988 10 operator - 0 4 3480 22 LVecBase2f::operator - 0 1 52 0
72
inline LVecBase2f LVecBase2f::operator -(LVecBase2f const &other) const;

1989 10 operator * 0 4 3480 22 LVecBase2f::operator * 0 1 53 0
61
inline LVecBase2f LVecBase2f::operator *(float scalar) const;

1990 10 operator / 0 4 3480 22 LVecBase2f::operator / 0 1 54 0
61
inline LVecBase2f LVecBase2f::operator /(float scalar) const;

1991 11 operator += 0 4 3480 23 LVecBase2f::operator += 0 1 55 0
61
inline void LVecBase2f::operator +=(LVecBase2f const &other);

1992 11 operator -= 0 4 3480 23 LVecBase2f::operator -= 0 1 56 0
61
inline void LVecBase2f::operator -=(LVecBase2f const &other);

1993 11 operator *= 0 4 3480 23 LVecBase2f::operator *= 0 1 57 0
50
inline void LVecBase2f::operator *=(float scalar);

1994 11 operator /= 0 4 3480 23 LVecBase2f::operator /= 0 1 58 0
50
inline void LVecBase2f::operator /=(float scalar);

1995 18 componentwise_mult 0 4 3480 30 LVecBase2f::componentwise_mult 0 1 59 10
/**
 *
 */
68
inline void LVecBase2f::componentwise_mult(LVecBase2f const &other);

1996 7 __pow__ 0 4 3480 19 LVecBase2f::__pow__ 0 1 60 0
60
inline LVecBase2f LVecBase2f::__pow__(float exponent) const;

1997 8 __ipow__ 0 4 3480 20 LVecBase2f::__ipow__ 0 1 61 0
70
inline PyObject *LVecBase2f::__ipow__(PyObject *self, float exponent);

1998 4 fmax 0 4 3480 16 LVecBase2f::fmax 0 1 62 10
/**
 *
 */
66
inline LVecBase2f LVecBase2f::fmax(LVecBase2f const &other) const;

1999 4 fmin 0 4 3480 16 LVecBase2f::fmin 0 1 63 10
/**
 *
 */
66
inline LVecBase2f LVecBase2f::fmin(LVecBase2f const &other) const;

2000 12 almost_equal 0 4 3480 24 LVecBase2f::almost_equal 0 2 64 65 210
/**
 * Returns true if two vectors are memberwise equal within a specified
 * tolerance.
 */

/**
 * Returns true if two vectors are memberwise equal within a default tolerance
 * based on the numeric type.
 */
154
inline bool LVecBase2f::almost_equal(LVecBase2f const &other, float threshold) const;
inline bool LVecBase2f::almost_equal(LVecBase2f const &other) const;

2001 6 output 0 4 3480 18 LVecBase2f::output 0 1 66 10
/**
 *
 */
51
inline void LVecBase2f::output(ostream &out) const;

2002 8 __repr__ 0 4 3480 20 LVecBase2f::__repr__ 0 1 67 0
52
inline std::string LVecBase2f::__repr__(void) const;

2003 20 write_datagram_fixed 0 4 3480 32 LVecBase2f::write_datagram_fixed 0 1 68 332
/**
 * Writes the vector to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the vector, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */
74
inline void LVecBase2f::write_datagram_fixed(Datagram &destination) const;

2004 19 read_datagram_fixed 0 4 3480 31 LVecBase2f::read_datagram_fixed 0 1 69 114
/**
 * Reads the vector from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */
70
inline void LVecBase2f::read_datagram_fixed(DatagramIterator &source);

2005 14 write_datagram 0 4 3480 26 LVecBase2f::write_datagram 0 1 70 205
/**
 * Writes the vector to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the vector using the standard width
 * setting, especially when you are writing a bam file.
 */
68
inline void LVecBase2f::write_datagram(Datagram &destination) const;

2006 13 read_datagram 0 4 3480 25 LVecBase2f::read_datagram 0 1 71 67
/**
 * Reads the vector from the Datagram using get_stdfloat().
 */
64
inline void LVecBase2f::read_datagram(DatagramIterator &source);

2007 14 get_class_type 0 4 3480 26 LVecBase2f::get_class_type 0 1 72 0
51
static TypeHandle LVecBase2f::get_class_type(void);

2008 11 ~LVecBase2f 0 4 3480 23 LVecBase2f::~LVecBase2f 0 0 0
30
LVecBase2f::~LVecBase2f(void);

2009 10 LVecBase2d 0 4 3483 22 LVecBase2d::LVecBase2d 0 4 73 74 75 76 22
/**
 *
 */

/**
 *
 */
208
inline LVecBase2d::LVecBase2d(void) = default;
inline LVecBase2d::LVecBase2d(double fill_value);
inline LVecBase2d::LVecBase2d(double x, double y);
inline LVecBase2d::LVecBase2d(LVecBase2d const &) = default;

2010 12 operator new 0 4 3483 24 LVecBase2d::operator new 0 1 77 0
124
inline void *LVecBase2d::operator new(std::size_t size);
inline void *LVecBase2d::operator new(std::size_t size, void *ptr);

2011 15 operator delete 0 4 3483 27 LVecBase2d::operator delete 0 0 0
108
inline void LVecBase2d::operator delete(void *ptr);
inline void LVecBase2d::operator delete(void *, void *);

2012 12 validate_ptr 0 4 3483 24 LVecBase2d::validate_ptr 0 0 0
61
static inline bool LVecBase2d::validate_ptr(void const *ptr);

2013 10 operator = 0 4 3483 22 LVecBase2d::operator = 0 2 78 79 0
134
LVecBase2d &LVecBase2d::operator =(LVecBase2d const &copy) = default;
LVecBase2d &LVecBase2d::operator =(double fill_value) = default;

2014 4 zero 0 4 3483 16 LVecBase2d::zero 0 1 80 40
/**
 * Returns a zero-length vector.
 */
55
static inline LVecBase2d const &LVecBase2d::zero(void);

2015 6 unit_x 0 4 3483 18 LVecBase2d::unit_x 0 1 81 35
/**
 * Returns a unit X vector.
 */
57
static inline LVecBase2d const &LVecBase2d::unit_x(void);

2016 6 unit_y 0 4 3483 18 LVecBase2d::unit_y 0 1 82 35
/**
 * Returns a unit Y vector.
 */
57
static inline LVecBase2d const &LVecBase2d::unit_y(void);

2017 10 __reduce__ 0 4 3483 22 LVecBase2d::__reduce__ 0 1 83 0
62
inline PyObject *LVecBase2d::__reduce__(PyObject *self) const;

2018 11 __getattr__ 0 4 3483 23 LVecBase2d::__getattr__ 0 1 84 0
93
inline PyObject *LVecBase2d::__getattr__(PyObject *self, std::string const &attr_name) const;

2019 11 __setattr__ 0 4 3483 23 LVecBase2d::__setattr__ 0 1 85 0
99
inline int LVecBase2d::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2020 11 operator [] 0 4 3483 23 LVecBase2d::operator [] 0 2 86 87 10
/**
 *
 */
98
inline double LVecBase2d::operator [](int i) const;
inline double &LVecBase2d::operator [](int i);

2021 4 size 0 4 3483 16 LVecBase2d::size 0 1 88 0
44
static constexpr int LVecBase2d::size(void);

2022 6 is_nan 0 4 3483 18 LVecBase2d::is_nan 0 1 89 91
/**
 * Returns true if any component of the vector is not-a-number, false
 * otherwise.
 */
43
inline bool LVecBase2d::is_nan(void) const;

2023 8 get_cell 0 4 3483 20 LVecBase2d::get_cell 0 1 90 10
/**
 *
 */
48
inline double LVecBase2d::get_cell(int i) const;

2024 8 set_cell 0 4 3483 20 LVecBase2d::set_cell 0 1 91 10
/**
 *
 */
54
inline void LVecBase2d::set_cell(int i, double value);

2025 5 get_x 0 4 3483 17 LVecBase2d::get_x 0 1 92 10
/**
 *
 */
44
inline double LVecBase2d::get_x(void) const;

2026 5 get_y 0 4 3483 17 LVecBase2d::get_y 0 1 93 10
/**
 *
 */
44
inline double LVecBase2d::get_y(void) const;

2027 5 set_x 0 4 3483 17 LVecBase2d::set_x 0 1 94 10
/**
 *
 */
44
inline void LVecBase2d::set_x(double value);

2028 5 set_y 0 4 3483 17 LVecBase2d::set_y 0 1 95 10
/**
 *
 */
44
inline void LVecBase2d::set_y(double value);

2029 11 add_to_cell 0 4 3483 23 LVecBase2d::add_to_cell 0 1 96 164
// These next functions add to an existing value.  i.e.
// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
// scripting languages:

/**
 *
 */
57
inline void LVecBase2d::add_to_cell(int i, double value);

2030 5 add_x 0 4 3483 17 LVecBase2d::add_x 0 1 97 10
/**
 *
 */
44
inline void LVecBase2d::add_x(double value);

2031 5 add_y 0 4 3483 17 LVecBase2d::add_y 0 1 98 10
/**
 *
 */
44
inline void LVecBase2d::add_y(double value);

2032 8 get_data 0 4 3483 20 LVecBase2d::get_data 0 1 99 155
/**
 * Returns the address of the first of the two data elements in the vector.
 * The next element occupies the next position consecutively in memory.
 */
54
inline double const *LVecBase2d::get_data(void) const;

2033 18 get_num_components 0 4 3483 30 LVecBase2d::get_num_components 0 1 100 0
58
static constexpr int LVecBase2d::get_num_components(void);

2034 4 fill 0 4 3483 16 LVecBase2d::fill 0 1 101 129
/**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */
48
inline void LVecBase2d::fill(double fill_value);

2035 3 set 0 4 3483 15 LVecBase2d::set 0 1 102 10
/**
 *
 */
48
inline void LVecBase2d::set(double x, double y);

2036 3 dot 0 4 3483 15 LVecBase2d::dot 0 1 103 10
/**
 *
 */
61
inline double LVecBase2d::dot(LVecBase2d const &other) const;

2037 14 length_squared 0 4 3483 26 LVecBase2d::length_squared 0 1 104 69
/**
 * Returns the square of the vector's length, cheap and easy.
 */
53
inline double LVecBase2d::length_squared(void) const;

2038 6 length 0 4 3483 18 LVecBase2d::length 0 1 105 72
/**
 * Returns the length of the vector, by the Pythagorean theorem.
 */
45
inline double LVecBase2d::length(void) const;

2039 9 normalize 0 4 3483 21 LVecBase2d::normalize 0 1 106 127
/**
 * Normalizes the vector in place.  Returns true if the vector was normalized,
 * false if it was a zero-length vector.
 */
40
inline bool LVecBase2d::normalize(void);

2040 10 normalized 0 4 3483 22 LVecBase2d::normalized 0 1 107 160
/**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */
53
inline LVecBase2d LVecBase2d::normalized(void) const;

2041 7 project 0 4 3483 19 LVecBase2d::project 0 1 108 152
/**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */
68
inline LVecBase2d LVecBase2d::project(LVecBase2d const &onto) const;

2042 10 operator < 0 4 3483 22 LVecBase2d::operator < 0 1 109 0
66
inline bool LVecBase2d::operator <(LVecBase2d const &other) const;

2043 11 operator == 0 4 3483 23 LVecBase2d::operator == 0 1 110 0
67
inline bool LVecBase2d::operator ==(LVecBase2d const &other) const;

2044 11 operator != 0 4 3483 23 LVecBase2d::operator != 0 1 111 0
67
inline bool LVecBase2d::operator !=(LVecBase2d const &other) const;

2045 10 compare_to 0 4 3483 22 LVecBase2d::compare_to 0 2 112 113 332
/**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */

/**
 * Sorts vectors lexicographically, componentwise.  Returns a number less than
 * 0 if this vector sorts before the other one, greater than zero if it sorts
 * after, 0 if they are equivalent (within the indicated tolerance).
 */
149
inline int LVecBase2d::compare_to(LVecBase2d const &other) const;
inline int LVecBase2d::compare_to(LVecBase2d const &other, double threshold) const;

2046 8 get_hash 0 4 3483 20 LVecBase2d::get_hash 0 2 114 115 100
/**
 * Returns a suitable hash for phash_map.
 */

/**
 * Returns a suitable hash for phash_map.
 */
117
inline std::size_t LVecBase2d::get_hash(void) const;
inline std::size_t LVecBase2d::get_hash(double threshold) const;

2047 8 add_hash 0 4 3483 20 LVecBase2d::add_hash 0 2 116 117 100
/**
 * Adds the vector into the running hash.
 */

/**
 * Adds the vector into the running hash.
 */
147
inline std::size_t LVecBase2d::add_hash(std::size_t hash) const;
inline std::size_t LVecBase2d::add_hash(std::size_t hash, double threshold) const;

2048 13 generate_hash 0 4 3483 25 LVecBase2d::generate_hash 0 2 118 119 120
/**
 * Adds the vector to the indicated hash generator.
 */

/**
 * Adds the vector to the indicated hash generator.
 */
171
inline void LVecBase2d::generate_hash(ChecksumHashGenerator &hashgen) const;
inline void LVecBase2d::generate_hash(ChecksumHashGenerator &hashgen, double threshold) const;

2049 10 operator - 0 68 3483 22 LVecBase2d::operator - 0 1 120 0
53
inline LVecBase2d LVecBase2d::operator -(void) const;

2050 10 operator + 0 4 3483 22 LVecBase2d::operator + 0 1 121 0
72
inline LVecBase2d LVecBase2d::operator +(LVecBase2d const &other) const;

2051 10 operator - 0 4 3483 22 LVecBase2d::operator - 0 1 122 0
72
inline LVecBase2d LVecBase2d::operator -(LVecBase2d const &other) const;

2052 10 operator * 0 4 3483 22 LVecBase2d::operator * 0 1 123 0
62
inline LVecBase2d LVecBase2d::operator *(double scalar) const;

2053 10 operator / 0 4 3483 22 LVecBase2d::operator / 0 1 124 0
62
inline LVecBase2d LVecBase2d::operator /(double scalar) const;

2054 11 operator += 0 4 3483 23 LVecBase2d::operator += 0 1 125 0
61
inline void LVecBase2d::operator +=(LVecBase2d const &other);

2055 11 operator -= 0 4 3483 23 LVecBase2d::operator -= 0 1 126 0
61
inline void LVecBase2d::operator -=(LVecBase2d const &other);

2056 11 operator *= 0 4 3483 23 LVecBase2d::operator *= 0 1 127 0
51
inline void LVecBase2d::operator *=(double scalar);

2057 11 operator /= 0 4 3483 23 LVecBase2d::operator /= 0 1 128 0
51
inline void LVecBase2d::operator /=(double scalar);

2058 18 componentwise_mult 0 4 3483 30 LVecBase2d::componentwise_mult 0 1 129 10
/**
 *
 */
68
inline void LVecBase2d::componentwise_mult(LVecBase2d const &other);

2059 7 __pow__ 0 4 3483 19 LVecBase2d::__pow__ 0 1 130 0
61
inline LVecBase2d LVecBase2d::__pow__(double exponent) const;

2060 8 __ipow__ 0 4 3483 20 LVecBase2d::__ipow__ 0 1 131 0
71
inline PyObject *LVecBase2d::__ipow__(PyObject *self, double exponent);

2061 4 fmax 0 4 3483 16 LVecBase2d::fmax 0 1 132 10
/**
 *
 */
66
inline LVecBase2d LVecBase2d::fmax(LVecBase2d const &other) const;

2062 4 fmin 0 4 3483 16 LVecBase2d::fmin 0 1 133 10
/**
 *
 */
66
inline LVecBase2d LVecBase2d::fmin(LVecBase2d const &other) const;

2063 12 almost_equal 0 4 3483 24 LVecBase2d::almost_equal 0 2 134 135 210
/**
 * Returns true if two vectors are memberwise equal within a specified
 * tolerance.
 */

/**
 * Returns true if two vectors are memberwise equal within a default tolerance
 * based on the numeric type.
 */
155
inline bool LVecBase2d::almost_equal(LVecBase2d const &other, double threshold) const;
inline bool LVecBase2d::almost_equal(LVecBase2d const &other) const;

2064 6 output 0 4 3483 18 LVecBase2d::output 0 1 136 10
/**
 *
 */
51
inline void LVecBase2d::output(ostream &out) const;

2065 8 __repr__ 0 4 3483 20 LVecBase2d::__repr__ 0 1 137 0
52
inline std::string LVecBase2d::__repr__(void) const;

2066 20 write_datagram_fixed 0 4 3483 32 LVecBase2d::write_datagram_fixed 0 1 138 332
/**
 * Writes the vector to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the vector, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */
74
inline void LVecBase2d::write_datagram_fixed(Datagram &destination) const;

2067 19 read_datagram_fixed 0 4 3483 31 LVecBase2d::read_datagram_fixed 0 1 139 114
/**
 * Reads the vector from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */
70
inline void LVecBase2d::read_datagram_fixed(DatagramIterator &source);

2068 14 write_datagram 0 4 3483 26 LVecBase2d::write_datagram 0 1 140 205
/**
 * Writes the vector to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the vector using the standard width
 * setting, especially when you are writing a bam file.
 */
68
inline void LVecBase2d::write_datagram(Datagram &destination) const;

2069 13 read_datagram 0 4 3483 25 LVecBase2d::read_datagram 0 1 141 67
/**
 * Reads the vector from the Datagram using get_stdfloat().
 */
64
inline void LVecBase2d::read_datagram(DatagramIterator &source);

2070 14 get_class_type 0 4 3483 26 LVecBase2d::get_class_type 0 1 142 0
51
static TypeHandle LVecBase2d::get_class_type(void);

2071 11 ~LVecBase2d 0 4 3483 23 LVecBase2d::~LVecBase2d 0 0 0
30
LVecBase2d::~LVecBase2d(void);

2072 10 LVecBase2i 0 4 3486 22 LVecBase2i::LVecBase2i 0 4 143 144 145 146 22
/**
 *
 */

/**
 *
 */
199
inline LVecBase2i::LVecBase2i(void) = default;
inline LVecBase2i::LVecBase2i(int fill_value);
inline LVecBase2i::LVecBase2i(int x, int y);
inline LVecBase2i::LVecBase2i(LVecBase2i const &) = default;

2073 12 operator new 0 4 3486 24 LVecBase2i::operator new 0 1 147 0
124
inline void *LVecBase2i::operator new(std::size_t size);
inline void *LVecBase2i::operator new(std::size_t size, void *ptr);

2074 15 operator delete 0 4 3486 27 LVecBase2i::operator delete 0 0 0
108
inline void LVecBase2i::operator delete(void *ptr);
inline void LVecBase2i::operator delete(void *, void *);

2075 12 validate_ptr 0 4 3486 24 LVecBase2i::validate_ptr 0 0 0
61
static inline bool LVecBase2i::validate_ptr(void const *ptr);

2076 10 operator = 0 4 3486 22 LVecBase2i::operator = 0 2 148 149 0
131
LVecBase2i &LVecBase2i::operator =(LVecBase2i const &copy) = default;
LVecBase2i &LVecBase2i::operator =(int fill_value) = default;

2077 4 zero 0 4 3486 16 LVecBase2i::zero 0 1 150 40
/**
 * Returns a zero-length vector.
 */
55
static inline LVecBase2i const &LVecBase2i::zero(void);

2078 6 unit_x 0 4 3486 18 LVecBase2i::unit_x 0 1 151 35
/**
 * Returns a unit X vector.
 */
57
static inline LVecBase2i const &LVecBase2i::unit_x(void);

2079 6 unit_y 0 4 3486 18 LVecBase2i::unit_y 0 1 152 35
/**
 * Returns a unit Y vector.
 */
57
static inline LVecBase2i const &LVecBase2i::unit_y(void);

2080 10 __reduce__ 0 4 3486 22 LVecBase2i::__reduce__ 0 1 153 0
62
inline PyObject *LVecBase2i::__reduce__(PyObject *self) const;

2081 11 __getattr__ 0 4 3486 23 LVecBase2i::__getattr__ 0 1 154 0
93
inline PyObject *LVecBase2i::__getattr__(PyObject *self, std::string const &attr_name) const;

2082 11 __setattr__ 0 4 3486 23 LVecBase2i::__setattr__ 0 1 155 0
99
inline int LVecBase2i::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2083 11 operator [] 0 4 3486 23 LVecBase2i::operator [] 0 2 156 157 10
/**
 *
 */
92
inline int LVecBase2i::operator [](int i) const;
inline int &LVecBase2i::operator [](int i);

2084 4 size 0 4 3486 16 LVecBase2i::size 0 1 158 0
44
static constexpr int LVecBase2i::size(void);

2085 6 is_nan 0 4 3486 18 LVecBase2i::is_nan 0 1 159 91
/**
 * Returns true if any component of the vector is not-a-number, false
 * otherwise.
 */
43
inline bool LVecBase2i::is_nan(void) const;

2086 8 get_cell 0 4 3486 20 LVecBase2i::get_cell 0 1 160 10
/**
 *
 */
45
inline int LVecBase2i::get_cell(int i) const;

2087 8 set_cell 0 4 3486 20 LVecBase2i::set_cell 0 1 161 10
/**
 *
 */
51
inline void LVecBase2i::set_cell(int i, int value);

2088 5 get_x 0 4 3486 17 LVecBase2i::get_x 0 1 162 10
/**
 *
 */
41
inline int LVecBase2i::get_x(void) const;

2089 5 get_y 0 4 3486 17 LVecBase2i::get_y 0 1 163 10
/**
 *
 */
41
inline int LVecBase2i::get_y(void) const;

2090 5 set_x 0 4 3486 17 LVecBase2i::set_x 0 1 164 10
/**
 *
 */
41
inline void LVecBase2i::set_x(int value);

2091 5 set_y 0 4 3486 17 LVecBase2i::set_y 0 1 165 10
/**
 *
 */
41
inline void LVecBase2i::set_y(int value);

2092 11 add_to_cell 0 4 3486 23 LVecBase2i::add_to_cell 0 1 166 164
// These next functions add to an existing value.  i.e.
// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
// scripting languages:

/**
 *
 */
54
inline void LVecBase2i::add_to_cell(int i, int value);

2093 5 add_x 0 4 3486 17 LVecBase2i::add_x 0 1 167 10
/**
 *
 */
41
inline void LVecBase2i::add_x(int value);

2094 5 add_y 0 4 3486 17 LVecBase2i::add_y 0 1 168 10
/**
 *
 */
41
inline void LVecBase2i::add_y(int value);

2095 8 get_data 0 4 3486 20 LVecBase2i::get_data 0 1 169 155
/**
 * Returns the address of the first of the two data elements in the vector.
 * The next element occupies the next position consecutively in memory.
 */
51
inline int const *LVecBase2i::get_data(void) const;

2096 18 get_num_components 0 4 3486 30 LVecBase2i::get_num_components 0 1 170 0
58
static constexpr int LVecBase2i::get_num_components(void);

2097 4 fill 0 4 3486 16 LVecBase2i::fill 0 1 171 129
/**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */
45
inline void LVecBase2i::fill(int fill_value);

2098 3 set 0 4 3486 15 LVecBase2i::set 0 1 172 10
/**
 *
 */
42
inline void LVecBase2i::set(int x, int y);

2099 3 dot 0 4 3486 15 LVecBase2i::dot 0 1 173 10
/**
 *
 */
58
inline int LVecBase2i::dot(LVecBase2i const &other) const;

2100 14 length_squared 0 4 3486 26 LVecBase2i::length_squared 0 1 174 69
/**
 * Returns the square of the vector's length, cheap and easy.
 */
50
inline int LVecBase2i::length_squared(void) const;

2101 10 operator < 0 4 3486 22 LVecBase2i::operator < 0 1 175 0
66
inline bool LVecBase2i::operator <(LVecBase2i const &other) const;

2102 11 operator == 0 4 3486 23 LVecBase2i::operator == 0 1 176 0
67
inline bool LVecBase2i::operator ==(LVecBase2i const &other) const;

2103 11 operator != 0 4 3486 23 LVecBase2i::operator != 0 1 177 0
67
inline bool LVecBase2i::operator !=(LVecBase2i const &other) const;

2104 10 compare_to 0 4 3486 22 LVecBase2i::compare_to 0 1 178 97
/**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */
65
inline int LVecBase2i::compare_to(LVecBase2i const &other) const;

2105 8 get_hash 0 4 3486 20 LVecBase2i::get_hash 0 1 179 49
/**
 * Returns a suitable hash for phash_map.
 */
52
inline std::size_t LVecBase2i::get_hash(void) const;

2106 8 add_hash 0 4 3486 20 LVecBase2i::add_hash 0 1 180 49
/**
 * Adds the vector into the running hash.
 */
64
inline std::size_t LVecBase2i::add_hash(std::size_t hash) const;

2107 13 generate_hash 0 4 3486 25 LVecBase2i::generate_hash 0 1 181 59
/**
 * Adds the vector to the indicated hash generator.
 */
76
inline void LVecBase2i::generate_hash(ChecksumHashGenerator &hashgen) const;

2108 10 operator - 0 68 3486 22 LVecBase2i::operator - 0 1 182 0
53
inline LVecBase2i LVecBase2i::operator -(void) const;

2109 10 operator + 0 4 3486 22 LVecBase2i::operator + 0 1 183 0
72
inline LVecBase2i LVecBase2i::operator +(LVecBase2i const &other) const;

2110 10 operator - 0 4 3486 22 LVecBase2i::operator - 0 1 184 0
72
inline LVecBase2i LVecBase2i::operator -(LVecBase2i const &other) const;

2111 10 operator * 0 4 3486 22 LVecBase2i::operator * 0 1 185 0
59
inline LVecBase2i LVecBase2i::operator *(int scalar) const;

2112 10 operator / 0 4 3486 22 LVecBase2i::operator / 0 1 186 0
59
inline LVecBase2i LVecBase2i::operator /(int scalar) const;

2113 11 operator += 0 4 3486 23 LVecBase2i::operator += 0 1 187 0
61
inline void LVecBase2i::operator +=(LVecBase2i const &other);

2114 11 operator -= 0 4 3486 23 LVecBase2i::operator -= 0 1 188 0
61
inline void LVecBase2i::operator -=(LVecBase2i const &other);

2115 11 operator *= 0 4 3486 23 LVecBase2i::operator *= 0 1 189 0
48
inline void LVecBase2i::operator *=(int scalar);

2116 11 operator /= 0 4 3486 23 LVecBase2i::operator /= 0 1 190 0
48
inline void LVecBase2i::operator /=(int scalar);

2117 18 componentwise_mult 0 4 3486 30 LVecBase2i::componentwise_mult 0 1 191 10
/**
 *
 */
68
inline void LVecBase2i::componentwise_mult(LVecBase2i const &other);

2118 7 __pow__ 0 4 3486 19 LVecBase2i::__pow__ 0 1 192 0
58
inline LVecBase2i LVecBase2i::__pow__(int exponent) const;

2119 8 __ipow__ 0 4 3486 20 LVecBase2i::__ipow__ 0 1 193 0
68
inline PyObject *LVecBase2i::__ipow__(PyObject *self, int exponent);

2120 4 fmax 0 4 3486 16 LVecBase2i::fmax 0 1 194 10
/**
 *
 */
66
inline LVecBase2i LVecBase2i::fmax(LVecBase2i const &other) const;

2121 4 fmin 0 4 3486 16 LVecBase2i::fmin 0 1 195 10
/**
 *
 */
66
inline LVecBase2i LVecBase2i::fmin(LVecBase2i const &other) const;

2122 12 almost_equal 0 4 3486 24 LVecBase2i::almost_equal 0 2 196 197 210
/**
 * Returns true if two vectors are memberwise equal within a specified
 * tolerance.
 */

/**
 * Returns true if two vectors are memberwise equal within a default tolerance
 * based on the numeric type.
 */
152
inline bool LVecBase2i::almost_equal(LVecBase2i const &other, int threshold) const;
inline bool LVecBase2i::almost_equal(LVecBase2i const &other) const;

2123 6 output 0 4 3486 18 LVecBase2i::output 0 1 198 10
/**
 *
 */
51
inline void LVecBase2i::output(ostream &out) const;

2124 8 __repr__ 0 4 3486 20 LVecBase2i::__repr__ 0 1 199 0
52
inline std::string LVecBase2i::__repr__(void) const;

2125 20 write_datagram_fixed 0 4 3486 32 LVecBase2i::write_datagram_fixed 0 1 200 332
/**
 * Writes the vector to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the vector, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */
74
inline void LVecBase2i::write_datagram_fixed(Datagram &destination) const;

2126 19 read_datagram_fixed 0 4 3486 31 LVecBase2i::read_datagram_fixed 0 1 201 114
/**
 * Reads the vector from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */
70
inline void LVecBase2i::read_datagram_fixed(DatagramIterator &source);

2127 14 write_datagram 0 4 3486 26 LVecBase2i::write_datagram 0 1 202 205
/**
 * Writes the vector to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the vector using the standard width
 * setting, especially when you are writing a bam file.
 */
68
inline void LVecBase2i::write_datagram(Datagram &destination) const;

2128 13 read_datagram 0 4 3486 25 LVecBase2i::read_datagram 0 1 203 67
/**
 * Reads the vector from the Datagram using get_stdfloat().
 */
64
inline void LVecBase2i::read_datagram(DatagramIterator &source);

2129 14 get_class_type 0 4 3486 26 LVecBase2i::get_class_type 0 1 204 0
51
static TypeHandle LVecBase2i::get_class_type(void);

2130 11 ~LVecBase2i 0 4 3486 23 LVecBase2i::~LVecBase2i 0 0 0
30
LVecBase2i::~LVecBase2i(void);

2131 9 LVector2f 0 4 3489 20 LVector2f::LVector2f 0 5 205 206 207 208 209 146
/**
 * Constructs a new LVector2 from a LVecBase2
 */

/**
 * Constructs a new LVector2 with all components set to the fill value.
 */

/**
 *
 */
249
inline LVector2f::LVector2f(void) = default;
inline LVector2f::LVector2f(LVecBase2f const &copy);
inline LVector2f::LVector2f(float fill_value);
inline LVector2f::LVector2f(float x, float y);
inline LVector2f::LVector2f(LVector2f const &) = default;

2132 11 __getattr__ 0 4 3489 22 LVector2f::__getattr__ 0 1 210 0
92
inline PyObject *LVector2f::__getattr__(PyObject *self, std::string const &attr_name) const;

2133 11 __setattr__ 0 4 3489 22 LVector2f::__setattr__ 0 1 211 0
98
inline int LVector2f::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2134 4 zero 0 4 3489 15 LVector2f::zero 0 1 212 40
/**
 * Returns a zero-length vector.
 */
53
static inline LVector2f const &LVector2f::zero(void);

2135 6 unit_x 0 4 3489 17 LVector2f::unit_x 0 1 213 35
/**
 * Returns a unit X vector.
 */
55
static inline LVector2f const &LVector2f::unit_x(void);

2136 6 unit_y 0 4 3489 17 LVector2f::unit_y 0 1 214 35
/**
 * Returns a unit Y vector.
 */
55
static inline LVector2f const &LVector2f::unit_y(void);

2137 10 operator - 0 68 3489 21 LVector2f::operator - 0 1 215 0
51
inline LVector2f LVector2f::operator -(void) const;

2138 10 operator + 0 4 3489 21 LVector2f::operator + 0 2 216 217 0
141
inline LVecBase2f LVector2f::operator +(LVecBase2f const &other) const;
inline LVector2f LVector2f::operator +(LVector2f const &other) const;

2139 10 operator - 0 4 3489 21 LVector2f::operator - 0 2 218 219 0
141
inline LVecBase2f LVector2f::operator -(LVecBase2f const &other) const;
inline LVector2f LVector2f::operator -(LVector2f const &other) const;

2140 10 operator * 0 4 3489 21 LVector2f::operator * 0 1 220 0
59
inline LVector2f LVector2f::operator *(float scalar) const;

2141 10 operator / 0 4 3489 21 LVector2f::operator / 0 1 221 0
59
inline LVector2f LVector2f::operator /(float scalar) const;

2142 10 normalized 0 4 3489 21 LVector2f::normalized 0 1 222 160
/**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */
51
inline LVector2f LVector2f::normalized(void) const;

2143 7 project 0 4 3489 18 LVector2f::project 0 1 223 152
/**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */
66
inline LVector2f LVector2f::project(LVecBase2f const &onto) const;

2144 16 signed_angle_rad 0 4 3489 27 LVector2f::signed_angle_rad 0 1 224 92
/**
 * returns the signed angled between two vectors.  normalization is NOT
 * necessary
 */
71
inline float LVector2f::signed_angle_rad(LVector2f const &other) const;

2145 16 signed_angle_deg 0 4 3489 27 LVector2f::signed_angle_deg 0 1 225 92
/**
 * returns the signed angled between two vectors.  normalization is NOT
 * necessary
 */
71
inline float LVector2f::signed_angle_deg(LVector2f const &other) const;

2146 8 __repr__ 0 4 3489 19 LVector2f::__repr__ 0 1 226 0
51
inline std::string LVector2f::__repr__(void) const;

2147 14 get_class_type 0 4 3489 25 LVector2f::get_class_type 0 1 227 0
50
static TypeHandle LVector2f::get_class_type(void);

2148 10 ~LVector2f 0 4 3489 21 LVector2f::~LVector2f 0 0 0
28
LVector2f::~LVector2f(void);

2149 9 LVector2d 0 4 3490 20 LVector2d::LVector2d 0 5 228 229 230 231 232 146
/**
 * Constructs a new LVector2 from a LVecBase2
 */

/**
 * Constructs a new LVector2 with all components set to the fill value.
 */

/**
 *
 */
252
inline LVector2d::LVector2d(void) = default;
inline LVector2d::LVector2d(LVecBase2d const &copy);
inline LVector2d::LVector2d(double fill_value);
inline LVector2d::LVector2d(double x, double y);
inline LVector2d::LVector2d(LVector2d const &) = default;

2150 11 __getattr__ 0 4 3490 22 LVector2d::__getattr__ 0 1 233 0
92
inline PyObject *LVector2d::__getattr__(PyObject *self, std::string const &attr_name) const;

2151 11 __setattr__ 0 4 3490 22 LVector2d::__setattr__ 0 1 234 0
98
inline int LVector2d::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2152 4 zero 0 4 3490 15 LVector2d::zero 0 1 235 40
/**
 * Returns a zero-length vector.
 */
53
static inline LVector2d const &LVector2d::zero(void);

2153 6 unit_x 0 4 3490 17 LVector2d::unit_x 0 1 236 35
/**
 * Returns a unit X vector.
 */
55
static inline LVector2d const &LVector2d::unit_x(void);

2154 6 unit_y 0 4 3490 17 LVector2d::unit_y 0 1 237 35
/**
 * Returns a unit Y vector.
 */
55
static inline LVector2d const &LVector2d::unit_y(void);

2155 10 operator - 0 68 3490 21 LVector2d::operator - 0 1 238 0
51
inline LVector2d LVector2d::operator -(void) const;

2156 10 operator + 0 4 3490 21 LVector2d::operator + 0 2 239 240 0
141
inline LVecBase2d LVector2d::operator +(LVecBase2d const &other) const;
inline LVector2d LVector2d::operator +(LVector2d const &other) const;

2157 10 operator - 0 4 3490 21 LVector2d::operator - 0 2 241 242 0
141
inline LVecBase2d LVector2d::operator -(LVecBase2d const &other) const;
inline LVector2d LVector2d::operator -(LVector2d const &other) const;

2158 10 operator * 0 4 3490 21 LVector2d::operator * 0 1 243 0
60
inline LVector2d LVector2d::operator *(double scalar) const;

2159 10 operator / 0 4 3490 21 LVector2d::operator / 0 1 244 0
60
inline LVector2d LVector2d::operator /(double scalar) const;

2160 10 normalized 0 4 3490 21 LVector2d::normalized 0 1 245 160
/**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */
51
inline LVector2d LVector2d::normalized(void) const;

2161 7 project 0 4 3490 18 LVector2d::project 0 1 246 152
/**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */
66
inline LVector2d LVector2d::project(LVecBase2d const &onto) const;

2162 16 signed_angle_rad 0 4 3490 27 LVector2d::signed_angle_rad 0 1 247 92
/**
 * returns the signed angled between two vectors.  normalization is NOT
 * necessary
 */
72
inline double LVector2d::signed_angle_rad(LVector2d const &other) const;

2163 16 signed_angle_deg 0 4 3490 27 LVector2d::signed_angle_deg 0 1 248 92
/**
 * returns the signed angled between two vectors.  normalization is NOT
 * necessary
 */
72
inline double LVector2d::signed_angle_deg(LVector2d const &other) const;

2164 8 __repr__ 0 4 3490 19 LVector2d::__repr__ 0 1 249 0
51
inline std::string LVector2d::__repr__(void) const;

2165 14 get_class_type 0 4 3490 25 LVector2d::get_class_type 0 1 250 0
50
static TypeHandle LVector2d::get_class_type(void);

2166 10 ~LVector2d 0 4 3490 21 LVector2d::~LVector2d 0 0 0
28
LVector2d::~LVector2d(void);

2167 9 LVector2i 0 4 3491 20 LVector2i::LVector2i 0 5 251 252 253 254 255 146
/**
 * Constructs a new LVector2 from a LVecBase2
 */

/**
 * Constructs a new LVector2 with all components set to the fill value.
 */

/**
 *
 */
243
inline LVector2i::LVector2i(void) = default;
inline LVector2i::LVector2i(LVecBase2i const &copy);
inline LVector2i::LVector2i(int fill_value);
inline LVector2i::LVector2i(int x, int y);
inline LVector2i::LVector2i(LVector2i const &) = default;

2168 11 __getattr__ 0 4 3491 22 LVector2i::__getattr__ 0 1 256 0
92
inline PyObject *LVector2i::__getattr__(PyObject *self, std::string const &attr_name) const;

2169 11 __setattr__ 0 4 3491 22 LVector2i::__setattr__ 0 1 257 0
98
inline int LVector2i::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2170 4 zero 0 4 3491 15 LVector2i::zero 0 1 258 40
/**
 * Returns a zero-length vector.
 */
53
static inline LVector2i const &LVector2i::zero(void);

2171 6 unit_x 0 4 3491 17 LVector2i::unit_x 0 1 259 35
/**
 * Returns a unit X vector.
 */
55
static inline LVector2i const &LVector2i::unit_x(void);

2172 6 unit_y 0 4 3491 17 LVector2i::unit_y 0 1 260 35
/**
 * Returns a unit Y vector.
 */
55
static inline LVector2i const &LVector2i::unit_y(void);

2173 10 operator - 0 68 3491 21 LVector2i::operator - 0 1 261 0
51
inline LVector2i LVector2i::operator -(void) const;

2174 10 operator + 0 4 3491 21 LVector2i::operator + 0 2 262 263 0
141
inline LVecBase2i LVector2i::operator +(LVecBase2i const &other) const;
inline LVector2i LVector2i::operator +(LVector2i const &other) const;

2175 10 operator - 0 4 3491 21 LVector2i::operator - 0 2 264 265 0
141
inline LVecBase2i LVector2i::operator -(LVecBase2i const &other) const;
inline LVector2i LVector2i::operator -(LVector2i const &other) const;

2176 10 operator * 0 4 3491 21 LVector2i::operator * 0 1 266 0
57
inline LVector2i LVector2i::operator *(int scalar) const;

2177 10 operator / 0 4 3491 21 LVector2i::operator / 0 1 267 0
57
inline LVector2i LVector2i::operator /(int scalar) const;

2178 8 __repr__ 0 4 3491 19 LVector2i::__repr__ 0 1 268 0
51
inline std::string LVector2i::__repr__(void) const;

2179 14 get_class_type 0 4 3491 25 LVector2i::get_class_type 0 1 269 0
50
static TypeHandle LVector2i::get_class_type(void);

2180 10 ~LVector2i 0 4 3491 21 LVector2i::~LVector2i 0 0 0
28
LVector2i::~LVector2i(void);

2181 8 LPoint2f 0 4 3492 18 LPoint2f::LPoint2f 0 5 270 271 272 273 274 190
/**
 * Constructs a new LPoint2 from a LVecBase2
 */

/**
 * Constructs a new LPoint2 all components set to the fill value.
 */

/**
 * Constructs a new LPoint2 with the given components
 */
238
inline LPoint2f::LPoint2f(void) = default;
inline LPoint2f::LPoint2f(LVecBase2f const &copy);
inline LPoint2f::LPoint2f(float fill_value);
inline LPoint2f::LPoint2f(float x, float y);
inline LPoint2f::LPoint2f(LPoint2f const &) = default;

2182 11 __getattr__ 0 4 3492 21 LPoint2f::__getattr__ 0 1 275 0
91
inline PyObject *LPoint2f::__getattr__(PyObject *self, std::string const &attr_name) const;

2183 11 __setattr__ 0 4 3492 21 LPoint2f::__setattr__ 0 1 276 0
97
inline int LPoint2f::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2184 4 zero 0 4 3492 14 LPoint2f::zero 0 1 277 39
/**
 * Returns a zero-length point.
 */
51
static inline LPoint2f const &LPoint2f::zero(void);

2185 6 unit_x 0 4 3492 16 LPoint2f::unit_x 0 1 278 34
/**
 * Returns a unit X point.
 */
53
static inline LPoint2f const &LPoint2f::unit_x(void);

2186 6 unit_y 0 4 3492 16 LPoint2f::unit_y 0 1 279 34
/**
 * Returns a unit Y point.
 */
53
static inline LPoint2f const &LPoint2f::unit_y(void);

2187 10 operator - 0 68 3492 20 LPoint2f::operator - 0 1 280 0
49
inline LPoint2f LPoint2f::operator -(void) const;

2188 10 operator + 0 4 3492 20 LPoint2f::operator + 0 2 281 282 0
138
inline LVecBase2f LPoint2f::operator +(LVecBase2f const &other) const;
inline LPoint2f LPoint2f::operator +(LVector2f const &other) const;

2189 10 operator - 0 4 3492 20 LPoint2f::operator - 0 3 283 284 285 0
206
inline LVecBase2f LPoint2f::operator -(LVecBase2f const &other) const;
inline LVector2f LPoint2f::operator -(LPoint2f const &other) const;
inline LPoint2f LPoint2f::operator -(LVector2f const &other) const;

2190 10 operator * 0 4 3492 20 LPoint2f::operator * 0 1 286 0
57
inline LPoint2f LPoint2f::operator *(float scalar) const;

2191 10 operator / 0 4 3492 20 LPoint2f::operator / 0 1 287 0
57
inline LPoint2f LPoint2f::operator /(float scalar) const;

2192 10 normalized 0 4 3492 20 LPoint2f::normalized 0 1 288 160
/**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */
49
inline LPoint2f LPoint2f::normalized(void) const;

2193 7 project 0 4 3492 17 LPoint2f::project 0 1 289 152
/**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */
64
inline LPoint2f LPoint2f::project(LVecBase2f const &onto) const;

2194 8 __repr__ 0 4 3492 18 LPoint2f::__repr__ 0 1 290 0
50
inline std::string LPoint2f::__repr__(void) const;

2195 14 get_class_type 0 4 3492 24 LPoint2f::get_class_type 0 1 291 0
49
static TypeHandle LPoint2f::get_class_type(void);

2196 9 ~LPoint2f 0 4 3492 19 LPoint2f::~LPoint2f 0 0 0
26
LPoint2f::~LPoint2f(void);

2197 8 LPoint2d 0 4 3493 18 LPoint2d::LPoint2d 0 5 292 293 294 295 296 190
/**
 * Constructs a new LPoint2 from a LVecBase2
 */

/**
 * Constructs a new LPoint2 all components set to the fill value.
 */

/**
 * Constructs a new LPoint2 with the given components
 */
241
inline LPoint2d::LPoint2d(void) = default;
inline LPoint2d::LPoint2d(LVecBase2d const &copy);
inline LPoint2d::LPoint2d(double fill_value);
inline LPoint2d::LPoint2d(double x, double y);
inline LPoint2d::LPoint2d(LPoint2d const &) = default;

2198 11 __getattr__ 0 4 3493 21 LPoint2d::__getattr__ 0 1 297 0
91
inline PyObject *LPoint2d::__getattr__(PyObject *self, std::string const &attr_name) const;

2199 11 __setattr__ 0 4 3493 21 LPoint2d::__setattr__ 0 1 298 0
97
inline int LPoint2d::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2200 4 zero 0 4 3493 14 LPoint2d::zero 0 1 299 39
/**
 * Returns a zero-length point.
 */
51
static inline LPoint2d const &LPoint2d::zero(void);

2201 6 unit_x 0 4 3493 16 LPoint2d::unit_x 0 1 300 34
/**
 * Returns a unit X point.
 */
53
static inline LPoint2d const &LPoint2d::unit_x(void);

2202 6 unit_y 0 4 3493 16 LPoint2d::unit_y 0 1 301 34
/**
 * Returns a unit Y point.
 */
53
static inline LPoint2d const &LPoint2d::unit_y(void);

2203 10 operator - 0 68 3493 20 LPoint2d::operator - 0 1 302 0
49
inline LPoint2d LPoint2d::operator -(void) const;

2204 10 operator + 0 4 3493 20 LPoint2d::operator + 0 2 303 304 0
138
inline LVecBase2d LPoint2d::operator +(LVecBase2d const &other) const;
inline LPoint2d LPoint2d::operator +(LVector2d const &other) const;

2205 10 operator - 0 4 3493 20 LPoint2d::operator - 0 3 305 306 307 0
206
inline LVecBase2d LPoint2d::operator -(LVecBase2d const &other) const;
inline LVector2d LPoint2d::operator -(LPoint2d const &other) const;
inline LPoint2d LPoint2d::operator -(LVector2d const &other) const;

2206 10 operator * 0 4 3493 20 LPoint2d::operator * 0 1 308 0
58
inline LPoint2d LPoint2d::operator *(double scalar) const;

2207 10 operator / 0 4 3493 20 LPoint2d::operator / 0 1 309 0
58
inline LPoint2d LPoint2d::operator /(double scalar) const;

2208 10 normalized 0 4 3493 20 LPoint2d::normalized 0 1 310 160
/**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */
49
inline LPoint2d LPoint2d::normalized(void) const;

2209 7 project 0 4 3493 17 LPoint2d::project 0 1 311 152
/**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */
64
inline LPoint2d LPoint2d::project(LVecBase2d const &onto) const;

2210 8 __repr__ 0 4 3493 18 LPoint2d::__repr__ 0 1 312 0
50
inline std::string LPoint2d::__repr__(void) const;

2211 14 get_class_type 0 4 3493 24 LPoint2d::get_class_type 0 1 313 0
49
static TypeHandle LPoint2d::get_class_type(void);

2212 9 ~LPoint2d 0 4 3493 19 LPoint2d::~LPoint2d 0 0 0
26
LPoint2d::~LPoint2d(void);

2213 8 LPoint2i 0 4 3494 18 LPoint2i::LPoint2i 0 5 314 315 316 317 318 190
/**
 * Constructs a new LPoint2 from a LVecBase2
 */

/**
 * Constructs a new LPoint2 all components set to the fill value.
 */

/**
 * Constructs a new LPoint2 with the given components
 */
232
inline LPoint2i::LPoint2i(void) = default;
inline LPoint2i::LPoint2i(LVecBase2i const &copy);
inline LPoint2i::LPoint2i(int fill_value);
inline LPoint2i::LPoint2i(int x, int y);
inline LPoint2i::LPoint2i(LPoint2i const &) = default;

2214 11 __getattr__ 0 4 3494 21 LPoint2i::__getattr__ 0 1 319 0
91
inline PyObject *LPoint2i::__getattr__(PyObject *self, std::string const &attr_name) const;

2215 11 __setattr__ 0 4 3494 21 LPoint2i::__setattr__ 0 1 320 0
97
inline int LPoint2i::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2216 4 zero 0 4 3494 14 LPoint2i::zero 0 1 321 39
/**
 * Returns a zero-length point.
 */
51
static inline LPoint2i const &LPoint2i::zero(void);

2217 6 unit_x 0 4 3494 16 LPoint2i::unit_x 0 1 322 34
/**
 * Returns a unit X point.
 */
53
static inline LPoint2i const &LPoint2i::unit_x(void);

2218 6 unit_y 0 4 3494 16 LPoint2i::unit_y 0 1 323 34
/**
 * Returns a unit Y point.
 */
53
static inline LPoint2i const &LPoint2i::unit_y(void);

2219 10 operator - 0 68 3494 20 LPoint2i::operator - 0 1 324 0
49
inline LPoint2i LPoint2i::operator -(void) const;

2220 10 operator + 0 4 3494 20 LPoint2i::operator + 0 2 325 326 0
138
inline LVecBase2i LPoint2i::operator +(LVecBase2i const &other) const;
inline LPoint2i LPoint2i::operator +(LVector2i const &other) const;

2221 10 operator - 0 4 3494 20 LPoint2i::operator - 0 3 327 328 329 0
206
inline LVecBase2i LPoint2i::operator -(LVecBase2i const &other) const;
inline LVector2i LPoint2i::operator -(LPoint2i const &other) const;
inline LPoint2i LPoint2i::operator -(LVector2i const &other) const;

2222 10 operator * 0 4 3494 20 LPoint2i::operator * 0 1 330 0
55
inline LPoint2i LPoint2i::operator *(int scalar) const;

2223 10 operator / 0 4 3494 20 LPoint2i::operator / 0 1 331 0
55
inline LPoint2i LPoint2i::operator /(int scalar) const;

2224 8 __repr__ 0 4 3494 18 LPoint2i::__repr__ 0 1 332 0
50
inline std::string LPoint2i::__repr__(void) const;

2225 14 get_class_type 0 4 3494 24 LPoint2i::get_class_type 0 1 333 0
49
static TypeHandle LPoint2i::get_class_type(void);

2226 9 ~LPoint2i 0 4 3494 19 LPoint2i::~LPoint2i 0 0 0
26
LPoint2i::~LPoint2i(void);

2227 10 LVecBase3f 0 4 3495 22 LVecBase3f::LVecBase3f 0 5 334 335 336 337 338 34
/**
 *
 */

/**
 *
 */

/**
 *
 */
278
inline LVecBase3f::LVecBase3f(void) = default;
inline LVecBase3f::LVecBase3f(float fill_value);
inline LVecBase3f::LVecBase3f(float x, float y, float z);
inline LVecBase3f::LVecBase3f(LVecBase2f const &copy, float z);
inline LVecBase3f::LVecBase3f(LVecBase3f const &) = default;

2228 12 operator new 0 4 3495 24 LVecBase3f::operator new 0 1 339 0
124
inline void *LVecBase3f::operator new(std::size_t size);
inline void *LVecBase3f::operator new(std::size_t size, void *ptr);

2229 15 operator delete 0 4 3495 27 LVecBase3f::operator delete 0 0 0
108
inline void LVecBase3f::operator delete(void *ptr);
inline void LVecBase3f::operator delete(void *, void *);

2230 12 validate_ptr 0 4 3495 24 LVecBase3f::validate_ptr 0 0 0
61
static inline bool LVecBase3f::validate_ptr(void const *ptr);

2231 10 operator = 0 4 3495 22 LVecBase3f::operator = 0 2 340 341 0
133
LVecBase3f &LVecBase3f::operator =(LVecBase3f const &copy) = default;
LVecBase3f &LVecBase3f::operator =(float fill_value) = default;

2232 4 zero 0 4 3495 16 LVecBase3f::zero 0 1 342 40
/**
 * Returns a zero-length vector.
 */
55
static inline LVecBase3f const &LVecBase3f::zero(void);

2233 6 unit_x 0 4 3495 18 LVecBase3f::unit_x 0 1 343 35
/**
 * Returns a unit X vector.
 */
57
static inline LVecBase3f const &LVecBase3f::unit_x(void);

2234 6 unit_y 0 4 3495 18 LVecBase3f::unit_y 0 1 344 35
/**
 * Returns a unit Y vector.
 */
57
static inline LVecBase3f const &LVecBase3f::unit_y(void);

2235 6 unit_z 0 4 3495 18 LVecBase3f::unit_z 0 1 345 35
/**
 * Returns a unit Z vector.
 */
57
static inline LVecBase3f const &LVecBase3f::unit_z(void);

2236 10 __reduce__ 0 4 3495 22 LVecBase3f::__reduce__ 0 1 346 0
62
inline PyObject *LVecBase3f::__reduce__(PyObject *self) const;

2237 11 __getattr__ 0 4 3495 23 LVecBase3f::__getattr__ 0 1 347 0
93
inline PyObject *LVecBase3f::__getattr__(PyObject *self, std::string const &attr_name) const;

2238 11 __setattr__ 0 4 3495 23 LVecBase3f::__setattr__ 0 1 348 0
99
inline int LVecBase3f::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2239 11 operator [] 0 4 3495 23 LVecBase3f::operator [] 0 2 349 350 10
/**
 *
 */
96
inline float LVecBase3f::operator [](int i) const;
inline float &LVecBase3f::operator [](int i);

2240 4 size 0 4 3495 16 LVecBase3f::size 0 1 351 0
44
static constexpr int LVecBase3f::size(void);

2241 6 is_nan 0 4 3495 18 LVecBase3f::is_nan 0 1 352 91
/**
 * Returns true if any component of the vector is not-a-number, false
 * otherwise.
 */
43
inline bool LVecBase3f::is_nan(void) const;

2242 8 get_cell 0 4 3495 20 LVecBase3f::get_cell 0 1 353 10
/**
 *
 */
47
inline float LVecBase3f::get_cell(int i) const;

2243 5 get_x 0 4 3495 17 LVecBase3f::get_x 0 1 354 10
/**
 *
 */
43
inline float LVecBase3f::get_x(void) const;

2244 5 get_y 0 4 3495 17 LVecBase3f::get_y 0 1 355 10
/**
 *
 */
43
inline float LVecBase3f::get_y(void) const;

2245 5 get_z 0 4 3495 17 LVecBase3f::get_z 0 1 356 10
/**
 *
 */
43
inline float LVecBase3f::get_z(void) const;

2246 8 set_cell 0 4 3495 20 LVecBase3f::set_cell 0 1 357 10
/**
 *
 */
53
inline void LVecBase3f::set_cell(int i, float value);

2247 5 set_x 0 4 3495 17 LVecBase3f::set_x 0 1 358 10
/**
 *
 */
43
inline void LVecBase3f::set_x(float value);

2248 5 set_y 0 4 3495 17 LVecBase3f::set_y 0 1 359 10
/**
 *
 */
43
inline void LVecBase3f::set_y(float value);

2249 5 set_z 0 4 3495 17 LVecBase3f::set_z 0 1 360 10
/**
 *
 */
43
inline void LVecBase3f::set_z(float value);

2250 6 get_xy 0 4 3495 18 LVecBase3f::get_xy 0 1 361 100
/**
 * Returns a 2-component vector that shares just the first two components of
 * this vector.
 */
49
inline LVecBase2f LVecBase3f::get_xy(void) const;

2251 6 get_xz 0 4 3495 18 LVecBase3f::get_xz 0 1 362 105
/**
 * Returns a 2-component vector that shares just the first and last components
 * of this vector.
 */
49
inline LVecBase2f LVecBase3f::get_xz(void) const;

2252 6 get_yz 0 4 3495 18 LVecBase3f::get_yz 0 1 363 99
/**
 * Returns a 2-component vector that shares just the last two components of
 * this vector.
 */
49
inline LVecBase2f LVecBase3f::get_yz(void) const;

2253 11 add_to_cell 0 4 3495 23 LVecBase3f::add_to_cell 0 1 364 164
// These next functions add to an existing value.  i.e.
// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
// scripting languages:

/**
 *
 */
56
inline void LVecBase3f::add_to_cell(int i, float value);

2254 5 add_x 0 4 3495 17 LVecBase3f::add_x 0 1 365 10
/**
 *
 */
43
inline void LVecBase3f::add_x(float value);

2255 5 add_y 0 4 3495 17 LVecBase3f::add_y 0 1 366 10
/**
 *
 */
43
inline void LVecBase3f::add_y(float value);

2256 5 add_z 0 4 3495 17 LVecBase3f::add_z 0 1 367 10
/**
 *
 */
43
inline void LVecBase3f::add_z(float value);

2257 8 get_data 0 4 3495 20 LVecBase3f::get_data 0 1 368 162
/**
 * Returns the address of the first of the three data elements in the vector.
 * The remaining elements occupy the next positions consecutively in memory.
 */
53
inline float const *LVecBase3f::get_data(void) const;

2258 18 get_num_components 0 4 3495 30 LVecBase3f::get_num_components 0 1 369 0
58
static constexpr int LVecBase3f::get_num_components(void);

2259 4 fill 0 4 3495 16 LVecBase3f::fill 0 1 370 129
/**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */
47
inline void LVecBase3f::fill(float fill_value);

2260 3 set 0 4 3495 15 LVecBase3f::set 0 1 371 10
/**
 *
 */
55
inline void LVecBase3f::set(float x, float y, float z);

2261 3 dot 0 4 3495 15 LVecBase3f::dot 0 1 372 10
/**
 *
 */
60
inline float LVecBase3f::dot(LVecBase3f const &other) const;

2262 14 length_squared 0 4 3495 26 LVecBase3f::length_squared 0 1 373 69
/**
 * Returns the square of the vector's length, cheap and easy.
 */
52
inline float LVecBase3f::length_squared(void) const;

2263 6 length 0 4 3495 18 LVecBase3f::length 0 1 374 72
/**
 * Returns the length of the vector, by the Pythagorean theorem.
 */
44
inline float LVecBase3f::length(void) const;

2264 9 normalize 0 4 3495 21 LVecBase3f::normalize 0 1 375 127
/**
 * Normalizes the vector in place.  Returns true if the vector was normalized,
 * false if it was a zero-length vector.
 */
40
inline bool LVecBase3f::normalize(void);

2265 10 normalized 0 4 3495 22 LVecBase3f::normalized 0 1 376 160
/**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */
53
inline LVecBase3f LVecBase3f::normalized(void) const;

2266 7 project 0 4 3495 19 LVecBase3f::project 0 1 377 152
/**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */
68
inline LVecBase3f LVecBase3f::project(LVecBase3f const &onto) const;

2267 5 cross 0 4 3495 17 LVecBase3f::cross 0 1 378 10
/**
 *
 */
67
inline LVecBase3f LVecBase3f::cross(LVecBase3f const &other) const;

2268 10 operator < 0 4 3495 22 LVecBase3f::operator < 0 1 379 0
66
inline bool LVecBase3f::operator <(LVecBase3f const &other) const;

2269 11 operator == 0 4 3495 23 LVecBase3f::operator == 0 1 380 0
67
inline bool LVecBase3f::operator ==(LVecBase3f const &other) const;

2270 11 operator != 0 4 3495 23 LVecBase3f::operator != 0 1 381 0
67
inline bool LVecBase3f::operator !=(LVecBase3f const &other) const;

2271 20 get_standardized_hpr 0 4 3495 32 LVecBase3f::get_standardized_hpr 0 1 382 623
/**
 * Try to un-spin the hpr to a standard form.  Like all standards, someone
 * decides between many arbitrary possible standards.  This function assumes
 * that 0 and 360 are the same, as is 720 and -360.  Also 180 and -180 are the
 * same.  Another example is -90 and 270. Each element will be in the range
 * -180.0 to 179.99999. The original usage of this function is for human
 * readable output.
 *
 * It doesn't work so well for asserting that foo_hpr is roughly equal to
 * bar_hpr.  Try using LQuaternionf::is_same_direction() for that.  See Also:
 * get_standardized_rotation, LQuaternion::is_same_direction
 */
63
inline LVecBase3f LVecBase3f::get_standardized_hpr(void) const;

2272 10 compare_to 0 4 3495 22 LVecBase3f::compare_to 0 2 383 384 332
/**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */

/**
 * Sorts vectors lexicographically, componentwise.  Returns a number less than
 * 0 if this vector sorts before the other one, greater than zero if it sorts
 * after, 0 if they are equivalent (within the indicated tolerance).
 */
148
inline int LVecBase3f::compare_to(LVecBase3f const &other) const;
inline int LVecBase3f::compare_to(LVecBase3f const &other, float threshold) const;

2273 8 get_hash 0 4 3495 20 LVecBase3f::get_hash 0 2 385 386 100
/**
 * Returns a suitable hash for phash_map.
 */

/**
 * Returns a suitable hash for phash_map.
 */
116
inline std::size_t LVecBase3f::get_hash(void) const;
inline std::size_t LVecBase3f::get_hash(float threshold) const;

2274 8 add_hash 0 4 3495 20 LVecBase3f::add_hash 0 2 387 388 100
/**
 * Adds the vector into the running hash.
 */

/**
 * Adds the vector into the running hash.
 */
146
inline std::size_t LVecBase3f::add_hash(std::size_t hash) const;
inline std::size_t LVecBase3f::add_hash(std::size_t hash, float threshold) const;

2275 13 generate_hash 0 4 3495 25 LVecBase3f::generate_hash 0 2 389 390 120
/**
 * Adds the vector to the indicated hash generator.
 */

/**
 * Adds the vector to the indicated hash generator.
 */
170
inline void LVecBase3f::generate_hash(ChecksumHashGenerator &hashgen) const;
inline void LVecBase3f::generate_hash(ChecksumHashGenerator &hashgen, float threshold) const;

2276 10 operator - 0 68 3495 22 LVecBase3f::operator - 0 1 391 0
53
inline LVecBase3f LVecBase3f::operator -(void) const;

2277 10 operator + 0 4 3495 22 LVecBase3f::operator + 0 1 392 0
72
inline LVecBase3f LVecBase3f::operator +(LVecBase3f const &other) const;

2278 10 operator - 0 4 3495 22 LVecBase3f::operator - 0 1 393 0
72
inline LVecBase3f LVecBase3f::operator -(LVecBase3f const &other) const;

2279 10 operator * 0 4 3495 22 LVecBase3f::operator * 0 1 394 0
61
inline LVecBase3f LVecBase3f::operator *(float scalar) const;

2280 10 operator / 0 4 3495 22 LVecBase3f::operator / 0 1 395 0
61
inline LVecBase3f LVecBase3f::operator /(float scalar) const;

2281 11 operator += 0 4 3495 23 LVecBase3f::operator += 0 1 396 0
61
inline void LVecBase3f::operator +=(LVecBase3f const &other);

2282 11 operator -= 0 4 3495 23 LVecBase3f::operator -= 0 1 397 0
61
inline void LVecBase3f::operator -=(LVecBase3f const &other);

2283 11 operator *= 0 4 3495 23 LVecBase3f::operator *= 0 1 398 0
50
inline void LVecBase3f::operator *=(float scalar);

2284 11 operator /= 0 4 3495 23 LVecBase3f::operator /= 0 1 399 0
50
inline void LVecBase3f::operator /=(float scalar);

2285 18 componentwise_mult 0 4 3495 30 LVecBase3f::componentwise_mult 0 1 400 10
/**
 *
 */
68
inline void LVecBase3f::componentwise_mult(LVecBase3f const &other);

2286 7 __pow__ 0 4 3495 19 LVecBase3f::__pow__ 0 1 401 0
60
inline LVecBase3f LVecBase3f::__pow__(float exponent) const;

2287 8 __ipow__ 0 4 3495 20 LVecBase3f::__ipow__ 0 1 402 0
70
inline PyObject *LVecBase3f::__ipow__(PyObject *self, float exponent);

2288 4 fmax 0 4 3495 16 LVecBase3f::fmax 0 1 403 10
/**
 *
 */
66
inline LVecBase3f LVecBase3f::fmax(LVecBase3f const &other) const;

2289 4 fmin 0 4 3495 16 LVecBase3f::fmin 0 1 404 10
/**
 *
 */
66
inline LVecBase3f LVecBase3f::fmin(LVecBase3f const &other) const;

2290 10 cross_into 0 4 3495 22 LVecBase3f::cross_into 0 1 405 10
/**
 *
 */
60
inline void LVecBase3f::cross_into(LVecBase3f const &other);

2291 12 almost_equal 0 4 3495 24 LVecBase3f::almost_equal 0 2 406 407 210
/**
 * Returns true if two vectors are memberwise equal within a specified
 * tolerance.
 */

/**
 * Returns true if two vectors are memberwise equal within a default tolerance
 * based on the numeric type.
 */
154
inline bool LVecBase3f::almost_equal(LVecBase3f const &other, float threshold) const;
inline bool LVecBase3f::almost_equal(LVecBase3f const &other) const;

2292 6 output 0 4 3495 18 LVecBase3f::output 0 1 408 10
/**
 *
 */
51
inline void LVecBase3f::output(ostream &out) const;

2293 8 __repr__ 0 4 3495 20 LVecBase3f::__repr__ 0 1 409 0
52
inline std::string LVecBase3f::__repr__(void) const;

2294 20 write_datagram_fixed 0 4 3495 32 LVecBase3f::write_datagram_fixed 0 1 410 332
/**
 * Writes the vector to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the vector, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */
74
inline void LVecBase3f::write_datagram_fixed(Datagram &destination) const;

2295 19 read_datagram_fixed 0 4 3495 31 LVecBase3f::read_datagram_fixed 0 1 411 114
/**
 * Reads the vector from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */
70
inline void LVecBase3f::read_datagram_fixed(DatagramIterator &source);

2296 14 write_datagram 0 4 3495 26 LVecBase3f::write_datagram 0 1 412 205
/**
 * Writes the vector to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the vector using the standard width
 * setting, especially when you are writing a bam file.
 */
68
inline void LVecBase3f::write_datagram(Datagram &destination) const;

2297 13 read_datagram 0 4 3495 25 LVecBase3f::read_datagram 0 1 413 67
/**
 * Reads the vector from the Datagram using get_stdfloat().
 */
64
inline void LVecBase3f::read_datagram(DatagramIterator &source);

2298 14 get_class_type 0 4 3495 26 LVecBase3f::get_class_type 0 1 414 0
51
static TypeHandle LVecBase3f::get_class_type(void);

2299 11 ~LVecBase3f 0 4 3495 23 LVecBase3f::~LVecBase3f 0 0 0
30
LVecBase3f::~LVecBase3f(void);

2300 10 LVecBase3d 0 4 3497 22 LVecBase3d::LVecBase3d 0 5 415 416 417 418 419 34
/**
 *
 */

/**
 *
 */

/**
 *
 */
283
inline LVecBase3d::LVecBase3d(void) = default;
inline LVecBase3d::LVecBase3d(double fill_value);
inline LVecBase3d::LVecBase3d(double x, double y, double z);
inline LVecBase3d::LVecBase3d(LVecBase2d const &copy, double z);
inline LVecBase3d::LVecBase3d(LVecBase3d const &) = default;

2301 12 operator new 0 4 3497 24 LVecBase3d::operator new 0 1 420 0
124
inline void *LVecBase3d::operator new(std::size_t size);
inline void *LVecBase3d::operator new(std::size_t size, void *ptr);

2302 15 operator delete 0 4 3497 27 LVecBase3d::operator delete 0 0 0
108
inline void LVecBase3d::operator delete(void *ptr);
inline void LVecBase3d::operator delete(void *, void *);

2303 12 validate_ptr 0 4 3497 24 LVecBase3d::validate_ptr 0 0 0
61
static inline bool LVecBase3d::validate_ptr(void const *ptr);

2304 10 operator = 0 4 3497 22 LVecBase3d::operator = 0 2 421 422 0
134
LVecBase3d &LVecBase3d::operator =(LVecBase3d const &copy) = default;
LVecBase3d &LVecBase3d::operator =(double fill_value) = default;

2305 4 zero 0 4 3497 16 LVecBase3d::zero 0 1 423 40
/**
 * Returns a zero-length vector.
 */
55
static inline LVecBase3d const &LVecBase3d::zero(void);

2306 6 unit_x 0 4 3497 18 LVecBase3d::unit_x 0 1 424 35
/**
 * Returns a unit X vector.
 */
57
static inline LVecBase3d const &LVecBase3d::unit_x(void);

2307 6 unit_y 0 4 3497 18 LVecBase3d::unit_y 0 1 425 35
/**
 * Returns a unit Y vector.
 */
57
static inline LVecBase3d const &LVecBase3d::unit_y(void);

2308 6 unit_z 0 4 3497 18 LVecBase3d::unit_z 0 1 426 35
/**
 * Returns a unit Z vector.
 */
57
static inline LVecBase3d const &LVecBase3d::unit_z(void);

2309 10 __reduce__ 0 4 3497 22 LVecBase3d::__reduce__ 0 1 427 0
62
inline PyObject *LVecBase3d::__reduce__(PyObject *self) const;

2310 11 __getattr__ 0 4 3497 23 LVecBase3d::__getattr__ 0 1 428 0
93
inline PyObject *LVecBase3d::__getattr__(PyObject *self, std::string const &attr_name) const;

2311 11 __setattr__ 0 4 3497 23 LVecBase3d::__setattr__ 0 1 429 0
99
inline int LVecBase3d::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2312 11 operator [] 0 4 3497 23 LVecBase3d::operator [] 0 2 430 431 10
/**
 *
 */
98
inline double LVecBase3d::operator [](int i) const;
inline double &LVecBase3d::operator [](int i);

2313 4 size 0 4 3497 16 LVecBase3d::size 0 1 432 0
44
static constexpr int LVecBase3d::size(void);

2314 6 is_nan 0 4 3497 18 LVecBase3d::is_nan 0 1 433 91
/**
 * Returns true if any component of the vector is not-a-number, false
 * otherwise.
 */
43
inline bool LVecBase3d::is_nan(void) const;

2315 8 get_cell 0 4 3497 20 LVecBase3d::get_cell 0 1 434 10
/**
 *
 */
48
inline double LVecBase3d::get_cell(int i) const;

2316 5 get_x 0 4 3497 17 LVecBase3d::get_x 0 1 435 10
/**
 *
 */
44
inline double LVecBase3d::get_x(void) const;

2317 5 get_y 0 4 3497 17 LVecBase3d::get_y 0 1 436 10
/**
 *
 */
44
inline double LVecBase3d::get_y(void) const;

2318 5 get_z 0 4 3497 17 LVecBase3d::get_z 0 1 437 10
/**
 *
 */
44
inline double LVecBase3d::get_z(void) const;

2319 8 set_cell 0 4 3497 20 LVecBase3d::set_cell 0 1 438 10
/**
 *
 */
54
inline void LVecBase3d::set_cell(int i, double value);

2320 5 set_x 0 4 3497 17 LVecBase3d::set_x 0 1 439 10
/**
 *
 */
44
inline void LVecBase3d::set_x(double value);

2321 5 set_y 0 4 3497 17 LVecBase3d::set_y 0 1 440 10
/**
 *
 */
44
inline void LVecBase3d::set_y(double value);

2322 5 set_z 0 4 3497 17 LVecBase3d::set_z 0 1 441 10
/**
 *
 */
44
inline void LVecBase3d::set_z(double value);

2323 6 get_xy 0 4 3497 18 LVecBase3d::get_xy 0 1 442 100
/**
 * Returns a 2-component vector that shares just the first two components of
 * this vector.
 */
49
inline LVecBase2d LVecBase3d::get_xy(void) const;

2324 6 get_xz 0 4 3497 18 LVecBase3d::get_xz 0 1 443 105
/**
 * Returns a 2-component vector that shares just the first and last components
 * of this vector.
 */
49
inline LVecBase2d LVecBase3d::get_xz(void) const;

2325 6 get_yz 0 4 3497 18 LVecBase3d::get_yz 0 1 444 99
/**
 * Returns a 2-component vector that shares just the last two components of
 * this vector.
 */
49
inline LVecBase2d LVecBase3d::get_yz(void) const;

2326 11 add_to_cell 0 4 3497 23 LVecBase3d::add_to_cell 0 1 445 164
// These next functions add to an existing value.  i.e.
// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
// scripting languages:

/**
 *
 */
57
inline void LVecBase3d::add_to_cell(int i, double value);

2327 5 add_x 0 4 3497 17 LVecBase3d::add_x 0 1 446 10
/**
 *
 */
44
inline void LVecBase3d::add_x(double value);

2328 5 add_y 0 4 3497 17 LVecBase3d::add_y 0 1 447 10
/**
 *
 */
44
inline void LVecBase3d::add_y(double value);

2329 5 add_z 0 4 3497 17 LVecBase3d::add_z 0 1 448 10
/**
 *
 */
44
inline void LVecBase3d::add_z(double value);

2330 8 get_data 0 4 3497 20 LVecBase3d::get_data 0 1 449 162
/**
 * Returns the address of the first of the three data elements in the vector.
 * The remaining elements occupy the next positions consecutively in memory.
 */
54
inline double const *LVecBase3d::get_data(void) const;

2331 18 get_num_components 0 4 3497 30 LVecBase3d::get_num_components 0 1 450 0
58
static constexpr int LVecBase3d::get_num_components(void);

2332 4 fill 0 4 3497 16 LVecBase3d::fill 0 1 451 129
/**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */
48
inline void LVecBase3d::fill(double fill_value);

2333 3 set 0 4 3497 15 LVecBase3d::set 0 1 452 10
/**
 *
 */
58
inline void LVecBase3d::set(double x, double y, double z);

2334 3 dot 0 4 3497 15 LVecBase3d::dot 0 1 453 10
/**
 *
 */
61
inline double LVecBase3d::dot(LVecBase3d const &other) const;

2335 14 length_squared 0 4 3497 26 LVecBase3d::length_squared 0 1 454 69
/**
 * Returns the square of the vector's length, cheap and easy.
 */
53
inline double LVecBase3d::length_squared(void) const;

2336 6 length 0 4 3497 18 LVecBase3d::length 0 1 455 72
/**
 * Returns the length of the vector, by the Pythagorean theorem.
 */
45
inline double LVecBase3d::length(void) const;

2337 9 normalize 0 4 3497 21 LVecBase3d::normalize 0 1 456 127
/**
 * Normalizes the vector in place.  Returns true if the vector was normalized,
 * false if it was a zero-length vector.
 */
40
inline bool LVecBase3d::normalize(void);

2338 10 normalized 0 4 3497 22 LVecBase3d::normalized 0 1 457 160
/**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */
53
inline LVecBase3d LVecBase3d::normalized(void) const;

2339 7 project 0 4 3497 19 LVecBase3d::project 0 1 458 152
/**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */
68
inline LVecBase3d LVecBase3d::project(LVecBase3d const &onto) const;

2340 5 cross 0 4 3497 17 LVecBase3d::cross 0 1 459 10
/**
 *
 */
67
inline LVecBase3d LVecBase3d::cross(LVecBase3d const &other) const;

2341 10 operator < 0 4 3497 22 LVecBase3d::operator < 0 1 460 0
66
inline bool LVecBase3d::operator <(LVecBase3d const &other) const;

2342 11 operator == 0 4 3497 23 LVecBase3d::operator == 0 1 461 0
67
inline bool LVecBase3d::operator ==(LVecBase3d const &other) const;

2343 11 operator != 0 4 3497 23 LVecBase3d::operator != 0 1 462 0
67
inline bool LVecBase3d::operator !=(LVecBase3d const &other) const;

2344 20 get_standardized_hpr 0 4 3497 32 LVecBase3d::get_standardized_hpr 0 1 463 623
/**
 * Try to un-spin the hpr to a standard form.  Like all standards, someone
 * decides between many arbitrary possible standards.  This function assumes
 * that 0 and 360 are the same, as is 720 and -360.  Also 180 and -180 are the
 * same.  Another example is -90 and 270. Each element will be in the range
 * -180.0 to 179.99999. The original usage of this function is for human
 * readable output.
 *
 * It doesn't work so well for asserting that foo_hpr is roughly equal to
 * bar_hpr.  Try using LQuaternionf::is_same_direction() for that.  See Also:
 * get_standardized_rotation, LQuaternion::is_same_direction
 */
63
inline LVecBase3d LVecBase3d::get_standardized_hpr(void) const;

2345 10 compare_to 0 4 3497 22 LVecBase3d::compare_to 0 2 464 465 332
/**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */

/**
 * Sorts vectors lexicographically, componentwise.  Returns a number less than
 * 0 if this vector sorts before the other one, greater than zero if it sorts
 * after, 0 if they are equivalent (within the indicated tolerance).
 */
149
inline int LVecBase3d::compare_to(LVecBase3d const &other) const;
inline int LVecBase3d::compare_to(LVecBase3d const &other, double threshold) const;

2346 8 get_hash 0 4 3497 20 LVecBase3d::get_hash 0 2 466 467 100
/**
 * Returns a suitable hash for phash_map.
 */

/**
 * Returns a suitable hash for phash_map.
 */
117
inline std::size_t LVecBase3d::get_hash(void) const;
inline std::size_t LVecBase3d::get_hash(double threshold) const;

2347 8 add_hash 0 4 3497 20 LVecBase3d::add_hash 0 2 468 469 100
/**
 * Adds the vector into the running hash.
 */

/**
 * Adds the vector into the running hash.
 */
147
inline std::size_t LVecBase3d::add_hash(std::size_t hash) const;
inline std::size_t LVecBase3d::add_hash(std::size_t hash, double threshold) const;

2348 13 generate_hash 0 4 3497 25 LVecBase3d::generate_hash 0 2 470 471 120
/**
 * Adds the vector to the indicated hash generator.
 */

/**
 * Adds the vector to the indicated hash generator.
 */
171
inline void LVecBase3d::generate_hash(ChecksumHashGenerator &hashgen) const;
inline void LVecBase3d::generate_hash(ChecksumHashGenerator &hashgen, double threshold) const;

2349 10 operator - 0 68 3497 22 LVecBase3d::operator - 0 1 472 0
53
inline LVecBase3d LVecBase3d::operator -(void) const;

2350 10 operator + 0 4 3497 22 LVecBase3d::operator + 0 1 473 0
72
inline LVecBase3d LVecBase3d::operator +(LVecBase3d const &other) const;

2351 10 operator - 0 4 3497 22 LVecBase3d::operator - 0 1 474 0
72
inline LVecBase3d LVecBase3d::operator -(LVecBase3d const &other) const;

2352 10 operator * 0 4 3497 22 LVecBase3d::operator * 0 1 475 0
62
inline LVecBase3d LVecBase3d::operator *(double scalar) const;

2353 10 operator / 0 4 3497 22 LVecBase3d::operator / 0 1 476 0
62
inline LVecBase3d LVecBase3d::operator /(double scalar) const;

2354 11 operator += 0 4 3497 23 LVecBase3d::operator += 0 1 477 0
61
inline void LVecBase3d::operator +=(LVecBase3d const &other);

2355 11 operator -= 0 4 3497 23 LVecBase3d::operator -= 0 1 478 0
61
inline void LVecBase3d::operator -=(LVecBase3d const &other);

2356 11 operator *= 0 4 3497 23 LVecBase3d::operator *= 0 1 479 0
51
inline void LVecBase3d::operator *=(double scalar);

2357 11 operator /= 0 4 3497 23 LVecBase3d::operator /= 0 1 480 0
51
inline void LVecBase3d::operator /=(double scalar);

2358 18 componentwise_mult 0 4 3497 30 LVecBase3d::componentwise_mult 0 1 481 10
/**
 *
 */
68
inline void LVecBase3d::componentwise_mult(LVecBase3d const &other);

2359 7 __pow__ 0 4 3497 19 LVecBase3d::__pow__ 0 1 482 0
61
inline LVecBase3d LVecBase3d::__pow__(double exponent) const;

2360 8 __ipow__ 0 4 3497 20 LVecBase3d::__ipow__ 0 1 483 0
71
inline PyObject *LVecBase3d::__ipow__(PyObject *self, double exponent);

2361 4 fmax 0 4 3497 16 LVecBase3d::fmax 0 1 484 10
/**
 *
 */
66
inline LVecBase3d LVecBase3d::fmax(LVecBase3d const &other) const;

2362 4 fmin 0 4 3497 16 LVecBase3d::fmin 0 1 485 10
/**
 *
 */
66
inline LVecBase3d LVecBase3d::fmin(LVecBase3d const &other) const;

2363 10 cross_into 0 4 3497 22 LVecBase3d::cross_into 0 1 486 10
/**
 *
 */
60
inline void LVecBase3d::cross_into(LVecBase3d const &other);

2364 12 almost_equal 0 4 3497 24 LVecBase3d::almost_equal 0 2 487 488 210
/**
 * Returns true if two vectors are memberwise equal within a specified
 * tolerance.
 */

/**
 * Returns true if two vectors are memberwise equal within a default tolerance
 * based on the numeric type.
 */
155
inline bool LVecBase3d::almost_equal(LVecBase3d const &other, double threshold) const;
inline bool LVecBase3d::almost_equal(LVecBase3d const &other) const;

2365 6 output 0 4 3497 18 LVecBase3d::output 0 1 489 10
/**
 *
 */
51
inline void LVecBase3d::output(ostream &out) const;

2366 8 __repr__ 0 4 3497 20 LVecBase3d::__repr__ 0 1 490 0
52
inline std::string LVecBase3d::__repr__(void) const;

2367 20 write_datagram_fixed 0 4 3497 32 LVecBase3d::write_datagram_fixed 0 1 491 332
/**
 * Writes the vector to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the vector, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */
74
inline void LVecBase3d::write_datagram_fixed(Datagram &destination) const;

2368 19 read_datagram_fixed 0 4 3497 31 LVecBase3d::read_datagram_fixed 0 1 492 114
/**
 * Reads the vector from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */
70
inline void LVecBase3d::read_datagram_fixed(DatagramIterator &source);

2369 14 write_datagram 0 4 3497 26 LVecBase3d::write_datagram 0 1 493 205
/**
 * Writes the vector to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the vector using the standard width
 * setting, especially when you are writing a bam file.
 */
68
inline void LVecBase3d::write_datagram(Datagram &destination) const;

2370 13 read_datagram 0 4 3497 25 LVecBase3d::read_datagram 0 1 494 67
/**
 * Reads the vector from the Datagram using get_stdfloat().
 */
64
inline void LVecBase3d::read_datagram(DatagramIterator &source);

2371 14 get_class_type 0 4 3497 26 LVecBase3d::get_class_type 0 1 495 0
51
static TypeHandle LVecBase3d::get_class_type(void);

2372 11 ~LVecBase3d 0 4 3497 23 LVecBase3d::~LVecBase3d 0 0 0
30
LVecBase3d::~LVecBase3d(void);

2373 10 LVecBase3i 0 4 3499 22 LVecBase3i::LVecBase3i 0 5 496 497 498 499 500 34
/**
 *
 */

/**
 *
 */

/**
 *
 */
268
inline LVecBase3i::LVecBase3i(void) = default;
inline LVecBase3i::LVecBase3i(int fill_value);
inline LVecBase3i::LVecBase3i(int x, int y, int z);
inline LVecBase3i::LVecBase3i(LVecBase2i const &copy, int z);
inline LVecBase3i::LVecBase3i(LVecBase3i const &) = default;

2374 12 operator new 0 4 3499 24 LVecBase3i::operator new 0 1 501 0
124
inline void *LVecBase3i::operator new(std::size_t size);
inline void *LVecBase3i::operator new(std::size_t size, void *ptr);

2375 15 operator delete 0 4 3499 27 LVecBase3i::operator delete 0 0 0
108
inline void LVecBase3i::operator delete(void *ptr);
inline void LVecBase3i::operator delete(void *, void *);

2376 12 validate_ptr 0 4 3499 24 LVecBase3i::validate_ptr 0 0 0
61
static inline bool LVecBase3i::validate_ptr(void const *ptr);

2377 10 operator = 0 4 3499 22 LVecBase3i::operator = 0 2 502 503 0
131
LVecBase3i &LVecBase3i::operator =(LVecBase3i const &copy) = default;
LVecBase3i &LVecBase3i::operator =(int fill_value) = default;

2378 4 zero 0 4 3499 16 LVecBase3i::zero 0 1 504 40
/**
 * Returns a zero-length vector.
 */
55
static inline LVecBase3i const &LVecBase3i::zero(void);

2379 6 unit_x 0 4 3499 18 LVecBase3i::unit_x 0 1 505 35
/**
 * Returns a unit X vector.
 */
57
static inline LVecBase3i const &LVecBase3i::unit_x(void);

2380 6 unit_y 0 4 3499 18 LVecBase3i::unit_y 0 1 506 35
/**
 * Returns a unit Y vector.
 */
57
static inline LVecBase3i const &LVecBase3i::unit_y(void);

2381 6 unit_z 0 4 3499 18 LVecBase3i::unit_z 0 1 507 35
/**
 * Returns a unit Z vector.
 */
57
static inline LVecBase3i const &LVecBase3i::unit_z(void);

2382 10 __reduce__ 0 4 3499 22 LVecBase3i::__reduce__ 0 1 508 0
62
inline PyObject *LVecBase3i::__reduce__(PyObject *self) const;

2383 11 __getattr__ 0 4 3499 23 LVecBase3i::__getattr__ 0 1 509 0
93
inline PyObject *LVecBase3i::__getattr__(PyObject *self, std::string const &attr_name) const;

2384 11 __setattr__ 0 4 3499 23 LVecBase3i::__setattr__ 0 1 510 0
99
inline int LVecBase3i::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2385 11 operator [] 0 4 3499 23 LVecBase3i::operator [] 0 2 511 512 10
/**
 *
 */
92
inline int LVecBase3i::operator [](int i) const;
inline int &LVecBase3i::operator [](int i);

2386 4 size 0 4 3499 16 LVecBase3i::size 0 1 513 0
44
static constexpr int LVecBase3i::size(void);

2387 6 is_nan 0 4 3499 18 LVecBase3i::is_nan 0 1 514 91
/**
 * Returns true if any component of the vector is not-a-number, false
 * otherwise.
 */
43
inline bool LVecBase3i::is_nan(void) const;

2388 8 get_cell 0 4 3499 20 LVecBase3i::get_cell 0 1 515 10
/**
 *
 */
45
inline int LVecBase3i::get_cell(int i) const;

2389 5 get_x 0 4 3499 17 LVecBase3i::get_x 0 1 516 10
/**
 *
 */
41
inline int LVecBase3i::get_x(void) const;

2390 5 get_y 0 4 3499 17 LVecBase3i::get_y 0 1 517 10
/**
 *
 */
41
inline int LVecBase3i::get_y(void) const;

2391 5 get_z 0 4 3499 17 LVecBase3i::get_z 0 1 518 10
/**
 *
 */
41
inline int LVecBase3i::get_z(void) const;

2392 8 set_cell 0 4 3499 20 LVecBase3i::set_cell 0 1 519 10
/**
 *
 */
51
inline void LVecBase3i::set_cell(int i, int value);

2393 5 set_x 0 4 3499 17 LVecBase3i::set_x 0 1 520 10
/**
 *
 */
41
inline void LVecBase3i::set_x(int value);

2394 5 set_y 0 4 3499 17 LVecBase3i::set_y 0 1 521 10
/**
 *
 */
41
inline void LVecBase3i::set_y(int value);

2395 5 set_z 0 4 3499 17 LVecBase3i::set_z 0 1 522 10
/**
 *
 */
41
inline void LVecBase3i::set_z(int value);

2396 6 get_xy 0 4 3499 18 LVecBase3i::get_xy 0 1 523 100
/**
 * Returns a 2-component vector that shares just the first two components of
 * this vector.
 */
49
inline LVecBase2i LVecBase3i::get_xy(void) const;

2397 6 get_xz 0 4 3499 18 LVecBase3i::get_xz 0 1 524 105
/**
 * Returns a 2-component vector that shares just the first and last components
 * of this vector.
 */
49
inline LVecBase2i LVecBase3i::get_xz(void) const;

2398 6 get_yz 0 4 3499 18 LVecBase3i::get_yz 0 1 525 99
/**
 * Returns a 2-component vector that shares just the last two components of
 * this vector.
 */
49
inline LVecBase2i LVecBase3i::get_yz(void) const;

2399 11 add_to_cell 0 4 3499 23 LVecBase3i::add_to_cell 0 1 526 164
// These next functions add to an existing value.  i.e.
// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
// scripting languages:

/**
 *
 */
54
inline void LVecBase3i::add_to_cell(int i, int value);

2400 5 add_x 0 4 3499 17 LVecBase3i::add_x 0 1 527 10
/**
 *
 */
41
inline void LVecBase3i::add_x(int value);

2401 5 add_y 0 4 3499 17 LVecBase3i::add_y 0 1 528 10
/**
 *
 */
41
inline void LVecBase3i::add_y(int value);

2402 5 add_z 0 4 3499 17 LVecBase3i::add_z 0 1 529 10
/**
 *
 */
41
inline void LVecBase3i::add_z(int value);

2403 8 get_data 0 4 3499 20 LVecBase3i::get_data 0 1 530 162
/**
 * Returns the address of the first of the three data elements in the vector.
 * The remaining elements occupy the next positions consecutively in memory.
 */
51
inline int const *LVecBase3i::get_data(void) const;

2404 18 get_num_components 0 4 3499 30 LVecBase3i::get_num_components 0 1 531 0
58
static constexpr int LVecBase3i::get_num_components(void);

2405 4 fill 0 4 3499 16 LVecBase3i::fill 0 1 532 129
/**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */
45
inline void LVecBase3i::fill(int fill_value);

2406 3 set 0 4 3499 15 LVecBase3i::set 0 1 533 10
/**
 *
 */
49
inline void LVecBase3i::set(int x, int y, int z);

2407 3 dot 0 4 3499 15 LVecBase3i::dot 0 1 534 10
/**
 *
 */
58
inline int LVecBase3i::dot(LVecBase3i const &other) const;

2408 14 length_squared 0 4 3499 26 LVecBase3i::length_squared 0 1 535 69
/**
 * Returns the square of the vector's length, cheap and easy.
 */
50
inline int LVecBase3i::length_squared(void) const;

2409 5 cross 0 4 3499 17 LVecBase3i::cross 0 1 536 10
/**
 *
 */
67
inline LVecBase3i LVecBase3i::cross(LVecBase3i const &other) const;

2410 10 operator < 0 4 3499 22 LVecBase3i::operator < 0 1 537 0
66
inline bool LVecBase3i::operator <(LVecBase3i const &other) const;

2411 11 operator == 0 4 3499 23 LVecBase3i::operator == 0 1 538 0
67
inline bool LVecBase3i::operator ==(LVecBase3i const &other) const;

2412 11 operator != 0 4 3499 23 LVecBase3i::operator != 0 1 539 0
67
inline bool LVecBase3i::operator !=(LVecBase3i const &other) const;

2413 10 compare_to 0 4 3499 22 LVecBase3i::compare_to 0 1 540 97
/**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */
65
inline int LVecBase3i::compare_to(LVecBase3i const &other) const;

2414 8 get_hash 0 4 3499 20 LVecBase3i::get_hash 0 1 541 49
/**
 * Returns a suitable hash for phash_map.
 */
52
inline std::size_t LVecBase3i::get_hash(void) const;

2415 8 add_hash 0 4 3499 20 LVecBase3i::add_hash 0 1 542 49
/**
 * Adds the vector into the running hash.
 */
64
inline std::size_t LVecBase3i::add_hash(std::size_t hash) const;

2416 13 generate_hash 0 4 3499 25 LVecBase3i::generate_hash 0 1 543 59
/**
 * Adds the vector to the indicated hash generator.
 */
76
inline void LVecBase3i::generate_hash(ChecksumHashGenerator &hashgen) const;

2417 10 operator - 0 68 3499 22 LVecBase3i::operator - 0 1 544 0
53
inline LVecBase3i LVecBase3i::operator -(void) const;

2418 10 operator + 0 4 3499 22 LVecBase3i::operator + 0 1 545 0
72
inline LVecBase3i LVecBase3i::operator +(LVecBase3i const &other) const;

2419 10 operator - 0 4 3499 22 LVecBase3i::operator - 0 1 546 0
72
inline LVecBase3i LVecBase3i::operator -(LVecBase3i const &other) const;

2420 10 operator * 0 4 3499 22 LVecBase3i::operator * 0 1 547 0
59
inline LVecBase3i LVecBase3i::operator *(int scalar) const;

2421 10 operator / 0 4 3499 22 LVecBase3i::operator / 0 1 548 0
59
inline LVecBase3i LVecBase3i::operator /(int scalar) const;

2422 11 operator += 0 4 3499 23 LVecBase3i::operator += 0 1 549 0
61
inline void LVecBase3i::operator +=(LVecBase3i const &other);

2423 11 operator -= 0 4 3499 23 LVecBase3i::operator -= 0 1 550 0
61
inline void LVecBase3i::operator -=(LVecBase3i const &other);

2424 11 operator *= 0 4 3499 23 LVecBase3i::operator *= 0 1 551 0
48
inline void LVecBase3i::operator *=(int scalar);

2425 11 operator /= 0 4 3499 23 LVecBase3i::operator /= 0 1 552 0
48
inline void LVecBase3i::operator /=(int scalar);

2426 18 componentwise_mult 0 4 3499 30 LVecBase3i::componentwise_mult 0 1 553 10
/**
 *
 */
68
inline void LVecBase3i::componentwise_mult(LVecBase3i const &other);

2427 7 __pow__ 0 4 3499 19 LVecBase3i::__pow__ 0 1 554 0
58
inline LVecBase3i LVecBase3i::__pow__(int exponent) const;

2428 8 __ipow__ 0 4 3499 20 LVecBase3i::__ipow__ 0 1 555 0
68
inline PyObject *LVecBase3i::__ipow__(PyObject *self, int exponent);

2429 4 fmax 0 4 3499 16 LVecBase3i::fmax 0 1 556 10
/**
 *
 */
66
inline LVecBase3i LVecBase3i::fmax(LVecBase3i const &other) const;

2430 4 fmin 0 4 3499 16 LVecBase3i::fmin 0 1 557 10
/**
 *
 */
66
inline LVecBase3i LVecBase3i::fmin(LVecBase3i const &other) const;

2431 10 cross_into 0 4 3499 22 LVecBase3i::cross_into 0 1 558 10
/**
 *
 */
60
inline void LVecBase3i::cross_into(LVecBase3i const &other);

2432 12 almost_equal 0 4 3499 24 LVecBase3i::almost_equal 0 2 559 560 210
/**
 * Returns true if two vectors are memberwise equal within a specified
 * tolerance.
 */

/**
 * Returns true if two vectors are memberwise equal within a default tolerance
 * based on the numeric type.
 */
152
inline bool LVecBase3i::almost_equal(LVecBase3i const &other, int threshold) const;
inline bool LVecBase3i::almost_equal(LVecBase3i const &other) const;

2433 6 output 0 4 3499 18 LVecBase3i::output 0 1 561 10
/**
 *
 */
51
inline void LVecBase3i::output(ostream &out) const;

2434 8 __repr__ 0 4 3499 20 LVecBase3i::__repr__ 0 1 562 0
52
inline std::string LVecBase3i::__repr__(void) const;

2435 20 write_datagram_fixed 0 4 3499 32 LVecBase3i::write_datagram_fixed 0 1 563 332
/**
 * Writes the vector to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the vector, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */
74
inline void LVecBase3i::write_datagram_fixed(Datagram &destination) const;

2436 19 read_datagram_fixed 0 4 3499 31 LVecBase3i::read_datagram_fixed 0 1 564 114
/**
 * Reads the vector from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */
70
inline void LVecBase3i::read_datagram_fixed(DatagramIterator &source);

2437 14 write_datagram 0 4 3499 26 LVecBase3i::write_datagram 0 1 565 205
/**
 * Writes the vector to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the vector using the standard width
 * setting, especially when you are writing a bam file.
 */
68
inline void LVecBase3i::write_datagram(Datagram &destination) const;

2438 13 read_datagram 0 4 3499 25 LVecBase3i::read_datagram 0 1 566 67
/**
 * Reads the vector from the Datagram using get_stdfloat().
 */
64
inline void LVecBase3i::read_datagram(DatagramIterator &source);

2439 14 get_class_type 0 4 3499 26 LVecBase3i::get_class_type 0 1 567 0
51
static TypeHandle LVecBase3i::get_class_type(void);

2440 11 ~LVecBase3i 0 4 3499 23 LVecBase3i::~LVecBase3i 0 0 0
30
LVecBase3i::~LVecBase3i(void);

2441 29 get_default_coordinate_system 0 1 0 29 get_default_coordinate_system 0 1 1856 0
53
CoordinateSystem get_default_coordinate_system(void);

2442 30 parse_coordinate_system_string 0 1 0 30 parse_coordinate_system_string 0 1 1857 0
72
CoordinateSystem parse_coordinate_system_string(std::string const &str);

2443 24 format_coordinate_system 0 1 0 24 format_coordinate_system 0 1 1858 0
58
std::string format_coordinate_system(CoordinateSystem cs);

2444 15 is_right_handed 0 1 0 15 is_right_handed 0 1 1859 0
57
bool is_right_handed(CoordinateSystem cs = ::CS_default);

2445 9 LVector3f 0 4 3502 20 LVector3f::LVector3f 0 6 568 569 570 571 572 573 46
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */
320
inline LVector3f::LVector3f(void) = default;
inline LVector3f::LVector3f(LVecBase3f const &copy);
inline LVector3f::LVector3f(float fill_value);
inline LVector3f::LVector3f(float x, float y, float z);
inline LVector3f::LVector3f(LVecBase2f const &copy, float z);
inline LVector3f::LVector3f(LVector3f const &) = default;

2446 11 __getattr__ 0 4 3502 22 LVector3f::__getattr__ 0 1 574 0
92
inline PyObject *LVector3f::__getattr__(PyObject *self, std::string const &attr_name) const;

2447 11 __setattr__ 0 4 3502 22 LVector3f::__setattr__ 0 1 575 0
98
inline int LVector3f::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2448 4 zero 0 4 3502 15 LVector3f::zero 0 1 576 40
/**
 * Returns a zero-length vector.
 */
53
static inline LVector3f const &LVector3f::zero(void);

2449 6 unit_x 0 4 3502 17 LVector3f::unit_x 0 1 577 35
/**
 * Returns a unit X vector.
 */
55
static inline LVector3f const &LVector3f::unit_x(void);

2450 6 unit_y 0 4 3502 17 LVector3f::unit_y 0 1 578 35
/**
 * Returns a unit Y vector.
 */
55
static inline LVector3f const &LVector3f::unit_y(void);

2451 6 unit_z 0 4 3502 17 LVector3f::unit_z 0 1 579 35
/**
 * Returns a unit Z vector.
 */
55
static inline LVector3f const &LVector3f::unit_z(void);

2452 6 get_xy 0 4 3502 17 LVector3f::get_xy 0 1 580 100
/**
 * Returns a 2-component vector that shares just the first two components of
 * this vector.
 */
47
inline LVector2f LVector3f::get_xy(void) const;

2453 6 get_xz 0 4 3502 17 LVector3f::get_xz 0 1 581 105
/**
 * Returns a 2-component vector that shares just the first and last components
 * of this vector.
 */
47
inline LVector2f LVector3f::get_xz(void) const;

2454 6 get_yz 0 4 3502 17 LVector3f::get_yz 0 1 582 99
/**
 * Returns a 2-component vector that shares just the last two components of
 * this vector.
 */
47
inline LVector2f LVector3f::get_yz(void) const;

2455 10 operator - 0 68 3502 21 LVector3f::operator - 0 1 583 0
51
inline LVector3f LVector3f::operator -(void) const;

2456 10 operator + 0 4 3502 21 LVector3f::operator + 0 2 584 585 0
141
inline LVecBase3f LVector3f::operator +(LVecBase3f const &other) const;
inline LVector3f LVector3f::operator +(LVector3f const &other) const;

2457 10 operator - 0 4 3502 21 LVector3f::operator - 0 2 586 587 0
141
inline LVecBase3f LVector3f::operator -(LVecBase3f const &other) const;
inline LVector3f LVector3f::operator -(LVector3f const &other) const;

2458 5 cross 0 4 3502 16 LVector3f::cross 0 1 588 10
/**
 *
 */
65
inline LVector3f LVector3f::cross(LVecBase3f const &other) const;

2459 10 normalized 0 4 3502 21 LVector3f::normalized 0 1 589 160
/**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */
51
inline LVector3f LVector3f::normalized(void) const;

2460 7 project 0 4 3502 18 LVector3f::project 0 1 590 152
/**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */
66
inline LVector3f LVector3f::project(LVecBase3f const &onto) const;

2461 9 angle_rad 0 4 3502 20 LVector3f::angle_rad 0 1 591 147
/**
 * Returns the unsigned angle between this vector and the other one, expressed
 * in radians.  Both vectors should be initially normalized.
 */
64
inline float LVector3f::angle_rad(LVector3f const &other) const;

2462 9 angle_deg 0 4 3502 20 LVector3f::angle_deg 0 1 592 138
/**
 * Returns the angle between this vector and the other one, expressed in
 * degrees.  Both vectors should be initially normalized.
 */
64
inline float LVector3f::angle_deg(LVector3f const &other) const;

2463 16 signed_angle_rad 0 4 3502 27 LVector3f::signed_angle_rad 0 1 593 259
/**
 * returns the signed angle between two vectors.  The angle is positive if the
 * rotation from this vector to other is clockwise when looking in the
 * direction of the ref vector.
 *
 * Vectors (except the ref vector) should be initially normalized.
 */
93
inline float LVector3f::signed_angle_rad(LVector3f const &other, LVector3f const &ref) const;

2464 16 signed_angle_deg 0 4 3502 27 LVector3f::signed_angle_deg 0 1 594 259
/**
 * Returns the signed angle between two vectors.  The angle is positive if the
 * rotation from this vector to other is clockwise when looking in the
 * direction of the ref vector.
 *
 * Vectors (except the ref vector) should be initially normalized.
 */
93
inline float LVector3f::signed_angle_deg(LVector3f const &other, LVector3f const &ref) const;

2465 18 relative_angle_rad 0 4 3502 29 LVector3f::relative_angle_rad 0 1 595 50
/**
 * This method is deprecated.  Do not use.
 */
73
inline float LVector3f::relative_angle_rad(LVector3f const &other) const;

2466 18 relative_angle_deg 0 4 3502 29 LVector3f::relative_angle_deg 0 1 596 50
/**
 * This method is deprecated.  Do not use.
 */
73
inline float LVector3f::relative_angle_deg(LVector3f const &other) const;

2467 10 operator * 0 4 3502 21 LVector3f::operator * 0 1 597 0
59
inline LVector3f LVector3f::operator *(float scalar) const;

2468 10 operator / 0 4 3502 21 LVector3f::operator / 0 1 598 0
59
inline LVector3f LVector3f::operator /(float scalar) const;

2469 2 up 0 4 3502 13 LVector3f::up 0 1 599 65
/**
 * Returns the up vector for the given coordinate system.
 */
74
static inline LVector3f LVector3f::up(CoordinateSystem cs = ::CS_default);

2470 5 right 0 4 3502 16 LVector3f::right 0 1 600 68
/**
 * Returns the right vector for the given coordinate system.
 */
77
static inline LVector3f LVector3f::right(CoordinateSystem cs = ::CS_default);

2471 7 forward 0 4 3502 18 LVector3f::forward 0 1 601 70
/**
 * Returns the forward vector for the given coordinate system.
 */
79
static inline LVector3f LVector3f::forward(CoordinateSystem cs = ::CS_default);

2472 4 down 0 4 3502 15 LVector3f::down 0 1 602 67
/**
 * Returns the down vector for the given coordinate system.
 */
76
static inline LVector3f LVector3f::down(CoordinateSystem cs = ::CS_default);

2473 4 left 0 4 3502 15 LVector3f::left 0 1 603 67
/**
 * Returns the left vector for the given coordinate system.
 */
76
static inline LVector3f LVector3f::left(CoordinateSystem cs = ::CS_default);

2474 4 back 0 4 3502 15 LVector3f::back 0 1 604 67
/**
 * Returns the back vector for the given coordinate system.
 */
76
static inline LVector3f LVector3f::back(CoordinateSystem cs = ::CS_default);

2475 3 rfu 0 4 3502 14 LVector3f::rfu 0 1 605 221
// INLINE_LINMATH static FLOATNAME(LVector3) & rfu(FLOATTYPE right,

/**
 * Returns a vector that is described by its right, forward, and up
 * components, in whatever way the coordinate system represents that vector.
 */
109
static inline LVector3f LVector3f::rfu(float right, float fwd, float up, CoordinateSystem cs = ::CS_default);

2476 8 __repr__ 0 4 3502 19 LVector3f::__repr__ 0 1 606 0
51
inline std::string LVector3f::__repr__(void) const;

2477 14 get_class_type 0 4 3502 25 LVector3f::get_class_type 0 1 607 0
50
static TypeHandle LVector3f::get_class_type(void);

2478 10 ~LVector3f 0 4 3502 21 LVector3f::~LVector3f 0 0 0
28
LVector3f::~LVector3f(void);

2479 9 LVector3d 0 4 3503 20 LVector3d::LVector3d 0 6 608 609 610 611 612 613 46
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */
325
inline LVector3d::LVector3d(void) = default;
inline LVector3d::LVector3d(LVecBase3d const &copy);
inline LVector3d::LVector3d(double fill_value);
inline LVector3d::LVector3d(double x, double y, double z);
inline LVector3d::LVector3d(LVecBase2d const &copy, double z);
inline LVector3d::LVector3d(LVector3d const &) = default;

2480 11 __getattr__ 0 4 3503 22 LVector3d::__getattr__ 0 1 614 0
92
inline PyObject *LVector3d::__getattr__(PyObject *self, std::string const &attr_name) const;

2481 11 __setattr__ 0 4 3503 22 LVector3d::__setattr__ 0 1 615 0
98
inline int LVector3d::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2482 4 zero 0 4 3503 15 LVector3d::zero 0 1 616 40
/**
 * Returns a zero-length vector.
 */
53
static inline LVector3d const &LVector3d::zero(void);

2483 6 unit_x 0 4 3503 17 LVector3d::unit_x 0 1 617 35
/**
 * Returns a unit X vector.
 */
55
static inline LVector3d const &LVector3d::unit_x(void);

2484 6 unit_y 0 4 3503 17 LVector3d::unit_y 0 1 618 35
/**
 * Returns a unit Y vector.
 */
55
static inline LVector3d const &LVector3d::unit_y(void);

2485 6 unit_z 0 4 3503 17 LVector3d::unit_z 0 1 619 35
/**
 * Returns a unit Z vector.
 */
55
static inline LVector3d const &LVector3d::unit_z(void);

2486 6 get_xy 0 4 3503 17 LVector3d::get_xy 0 1 620 100
/**
 * Returns a 2-component vector that shares just the first two components of
 * this vector.
 */
47
inline LVector2d LVector3d::get_xy(void) const;

2487 6 get_xz 0 4 3503 17 LVector3d::get_xz 0 1 621 105
/**
 * Returns a 2-component vector that shares just the first and last components
 * of this vector.
 */
47
inline LVector2d LVector3d::get_xz(void) const;

2488 6 get_yz 0 4 3503 17 LVector3d::get_yz 0 1 622 99
/**
 * Returns a 2-component vector that shares just the last two components of
 * this vector.
 */
47
inline LVector2d LVector3d::get_yz(void) const;

2489 10 operator - 0 68 3503 21 LVector3d::operator - 0 1 623 0
51
inline LVector3d LVector3d::operator -(void) const;

2490 10 operator + 0 4 3503 21 LVector3d::operator + 0 2 624 625 0
141
inline LVecBase3d LVector3d::operator +(LVecBase3d const &other) const;
inline LVector3d LVector3d::operator +(LVector3d const &other) const;

2491 10 operator - 0 4 3503 21 LVector3d::operator - 0 2 626 627 0
141
inline LVecBase3d LVector3d::operator -(LVecBase3d const &other) const;
inline LVector3d LVector3d::operator -(LVector3d const &other) const;

2492 5 cross 0 4 3503 16 LVector3d::cross 0 1 628 10
/**
 *
 */
65
inline LVector3d LVector3d::cross(LVecBase3d const &other) const;

2493 10 normalized 0 4 3503 21 LVector3d::normalized 0 1 629 160
/**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */
51
inline LVector3d LVector3d::normalized(void) const;

2494 7 project 0 4 3503 18 LVector3d::project 0 1 630 152
/**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */
66
inline LVector3d LVector3d::project(LVecBase3d const &onto) const;

2495 9 angle_rad 0 4 3503 20 LVector3d::angle_rad 0 1 631 147
/**
 * Returns the unsigned angle between this vector and the other one, expressed
 * in radians.  Both vectors should be initially normalized.
 */
65
inline double LVector3d::angle_rad(LVector3d const &other) const;

2496 9 angle_deg 0 4 3503 20 LVector3d::angle_deg 0 1 632 138
/**
 * Returns the angle between this vector and the other one, expressed in
 * degrees.  Both vectors should be initially normalized.
 */
65
inline double LVector3d::angle_deg(LVector3d const &other) const;

2497 16 signed_angle_rad 0 4 3503 27 LVector3d::signed_angle_rad 0 1 633 259
/**
 * returns the signed angle between two vectors.  The angle is positive if the
 * rotation from this vector to other is clockwise when looking in the
 * direction of the ref vector.
 *
 * Vectors (except the ref vector) should be initially normalized.
 */
94
inline double LVector3d::signed_angle_rad(LVector3d const &other, LVector3d const &ref) const;

2498 16 signed_angle_deg 0 4 3503 27 LVector3d::signed_angle_deg 0 1 634 259
/**
 * Returns the signed angle between two vectors.  The angle is positive if the
 * rotation from this vector to other is clockwise when looking in the
 * direction of the ref vector.
 *
 * Vectors (except the ref vector) should be initially normalized.
 */
94
inline double LVector3d::signed_angle_deg(LVector3d const &other, LVector3d const &ref) const;

2499 18 relative_angle_rad 0 4 3503 29 LVector3d::relative_angle_rad 0 1 635 50
/**
 * This method is deprecated.  Do not use.
 */
74
inline double LVector3d::relative_angle_rad(LVector3d const &other) const;

2500 18 relative_angle_deg 0 4 3503 29 LVector3d::relative_angle_deg 0 1 636 50
/**
 * This method is deprecated.  Do not use.
 */
74
inline double LVector3d::relative_angle_deg(LVector3d const &other) const;

2501 10 operator * 0 4 3503 21 LVector3d::operator * 0 1 637 0
60
inline LVector3d LVector3d::operator *(double scalar) const;

2502 10 operator / 0 4 3503 21 LVector3d::operator / 0 1 638 0
60
inline LVector3d LVector3d::operator /(double scalar) const;

2503 2 up 0 4 3503 13 LVector3d::up 0 1 639 65
/**
 * Returns the up vector for the given coordinate system.
 */
74
static inline LVector3d LVector3d::up(CoordinateSystem cs = ::CS_default);

2504 5 right 0 4 3503 16 LVector3d::right 0 1 640 68
/**
 * Returns the right vector for the given coordinate system.
 */
77
static inline LVector3d LVector3d::right(CoordinateSystem cs = ::CS_default);

2505 7 forward 0 4 3503 18 LVector3d::forward 0 1 641 70
/**
 * Returns the forward vector for the given coordinate system.
 */
79
static inline LVector3d LVector3d::forward(CoordinateSystem cs = ::CS_default);

2506 4 down 0 4 3503 15 LVector3d::down 0 1 642 67
/**
 * Returns the down vector for the given coordinate system.
 */
76
static inline LVector3d LVector3d::down(CoordinateSystem cs = ::CS_default);

2507 4 left 0 4 3503 15 LVector3d::left 0 1 643 67
/**
 * Returns the left vector for the given coordinate system.
 */
76
static inline LVector3d LVector3d::left(CoordinateSystem cs = ::CS_default);

2508 4 back 0 4 3503 15 LVector3d::back 0 1 644 67
/**
 * Returns the back vector for the given coordinate system.
 */
76
static inline LVector3d LVector3d::back(CoordinateSystem cs = ::CS_default);

2509 3 rfu 0 4 3503 14 LVector3d::rfu 0 1 645 221
// INLINE_LINMATH static FLOATNAME(LVector3) & rfu(FLOATTYPE right,

/**
 * Returns a vector that is described by its right, forward, and up
 * components, in whatever way the coordinate system represents that vector.
 */
112
static inline LVector3d LVector3d::rfu(double right, double fwd, double up, CoordinateSystem cs = ::CS_default);

2510 8 __repr__ 0 4 3503 19 LVector3d::__repr__ 0 1 646 0
51
inline std::string LVector3d::__repr__(void) const;

2511 14 get_class_type 0 4 3503 25 LVector3d::get_class_type 0 1 647 0
50
static TypeHandle LVector3d::get_class_type(void);

2512 10 ~LVector3d 0 4 3503 21 LVector3d::~LVector3d 0 0 0
28
LVector3d::~LVector3d(void);

2513 9 LVector3i 0 4 3504 20 LVector3i::LVector3i 0 6 648 649 650 651 652 653 46
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */
310
inline LVector3i::LVector3i(void) = default;
inline LVector3i::LVector3i(LVecBase3i const &copy);
inline LVector3i::LVector3i(int fill_value);
inline LVector3i::LVector3i(int x, int y, int z);
inline LVector3i::LVector3i(LVecBase2i const &copy, int z);
inline LVector3i::LVector3i(LVector3i const &) = default;

2514 11 __getattr__ 0 4 3504 22 LVector3i::__getattr__ 0 1 654 0
92
inline PyObject *LVector3i::__getattr__(PyObject *self, std::string const &attr_name) const;

2515 11 __setattr__ 0 4 3504 22 LVector3i::__setattr__ 0 1 655 0
98
inline int LVector3i::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2516 4 zero 0 4 3504 15 LVector3i::zero 0 1 656 40
/**
 * Returns a zero-length vector.
 */
53
static inline LVector3i const &LVector3i::zero(void);

2517 6 unit_x 0 4 3504 17 LVector3i::unit_x 0 1 657 35
/**
 * Returns a unit X vector.
 */
55
static inline LVector3i const &LVector3i::unit_x(void);

2518 6 unit_y 0 4 3504 17 LVector3i::unit_y 0 1 658 35
/**
 * Returns a unit Y vector.
 */
55
static inline LVector3i const &LVector3i::unit_y(void);

2519 6 unit_z 0 4 3504 17 LVector3i::unit_z 0 1 659 35
/**
 * Returns a unit Z vector.
 */
55
static inline LVector3i const &LVector3i::unit_z(void);

2520 6 get_xy 0 4 3504 17 LVector3i::get_xy 0 1 660 100
/**
 * Returns a 2-component vector that shares just the first two components of
 * this vector.
 */
47
inline LVector2i LVector3i::get_xy(void) const;

2521 6 get_xz 0 4 3504 17 LVector3i::get_xz 0 1 661 105
/**
 * Returns a 2-component vector that shares just the first and last components
 * of this vector.
 */
47
inline LVector2i LVector3i::get_xz(void) const;

2522 6 get_yz 0 4 3504 17 LVector3i::get_yz 0 1 662 99
/**
 * Returns a 2-component vector that shares just the last two components of
 * this vector.
 */
47
inline LVector2i LVector3i::get_yz(void) const;

2523 10 operator - 0 68 3504 21 LVector3i::operator - 0 1 663 0
51
inline LVector3i LVector3i::operator -(void) const;

2524 10 operator + 0 4 3504 21 LVector3i::operator + 0 2 664 665 0
141
inline LVecBase3i LVector3i::operator +(LVecBase3i const &other) const;
inline LVector3i LVector3i::operator +(LVector3i const &other) const;

2525 10 operator - 0 4 3504 21 LVector3i::operator - 0 2 666 667 0
141
inline LVecBase3i LVector3i::operator -(LVecBase3i const &other) const;
inline LVector3i LVector3i::operator -(LVector3i const &other) const;

2526 5 cross 0 4 3504 16 LVector3i::cross 0 1 668 10
/**
 *
 */
65
inline LVector3i LVector3i::cross(LVecBase3i const &other) const;

2527 10 operator * 0 4 3504 21 LVector3i::operator * 0 1 669 0
57
inline LVector3i LVector3i::operator *(int scalar) const;

2528 10 operator / 0 4 3504 21 LVector3i::operator / 0 1 670 0
57
inline LVector3i LVector3i::operator /(int scalar) const;

2529 2 up 0 4 3504 13 LVector3i::up 0 1 671 65
/**
 * Returns the up vector for the given coordinate system.
 */
74
static inline LVector3i LVector3i::up(CoordinateSystem cs = ::CS_default);

2530 5 right 0 4 3504 16 LVector3i::right 0 1 672 68
/**
 * Returns the right vector for the given coordinate system.
 */
77
static inline LVector3i LVector3i::right(CoordinateSystem cs = ::CS_default);

2531 7 forward 0 4 3504 18 LVector3i::forward 0 1 673 70
/**
 * Returns the forward vector for the given coordinate system.
 */
79
static inline LVector3i LVector3i::forward(CoordinateSystem cs = ::CS_default);

2532 4 down 0 4 3504 15 LVector3i::down 0 1 674 67
/**
 * Returns the down vector for the given coordinate system.
 */
76
static inline LVector3i LVector3i::down(CoordinateSystem cs = ::CS_default);

2533 4 left 0 4 3504 15 LVector3i::left 0 1 675 67
/**
 * Returns the left vector for the given coordinate system.
 */
76
static inline LVector3i LVector3i::left(CoordinateSystem cs = ::CS_default);

2534 4 back 0 4 3504 15 LVector3i::back 0 1 676 67
/**
 * Returns the back vector for the given coordinate system.
 */
76
static inline LVector3i LVector3i::back(CoordinateSystem cs = ::CS_default);

2535 3 rfu 0 4 3504 14 LVector3i::rfu 0 1 677 221
// INLINE_LINMATH static FLOATNAME(LVector3) & rfu(FLOATTYPE right,

/**
 * Returns a vector that is described by its right, forward, and up
 * components, in whatever way the coordinate system represents that vector.
 */
103
static inline LVector3i LVector3i::rfu(int right, int fwd, int up, CoordinateSystem cs = ::CS_default);

2536 8 __repr__ 0 4 3504 19 LVector3i::__repr__ 0 1 678 0
51
inline std::string LVector3i::__repr__(void) const;

2537 14 get_class_type 0 4 3504 25 LVector3i::get_class_type 0 1 679 0
50
static TypeHandle LVector3i::get_class_type(void);

2538 10 ~LVector3i 0 4 3504 21 LVector3i::~LVector3i 0 0 0
28
LVector3i::~LVector3i(void);

2539 8 LPoint3f 0 4 3505 18 LPoint3f::LPoint3f 0 6 680 681 682 683 684 685 46
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */
307
inline LPoint3f::LPoint3f(void) = default;
inline LPoint3f::LPoint3f(LVecBase3f const &copy);
inline LPoint3f::LPoint3f(float fill_value);
inline LPoint3f::LPoint3f(float x, float y, float z);
inline LPoint3f::LPoint3f(LVecBase2f const &copy, float z);
inline LPoint3f::LPoint3f(LPoint3f const &) = default;

2540 11 __getattr__ 0 4 3505 21 LPoint3f::__getattr__ 0 1 686 0
91
inline PyObject *LPoint3f::__getattr__(PyObject *self, std::string const &attr_name) const;

2541 11 __setattr__ 0 4 3505 21 LPoint3f::__setattr__ 0 1 687 0
97
inline int LPoint3f::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2542 4 zero 0 4 3505 14 LPoint3f::zero 0 1 688 39
/**
 * Returns a zero-length point.
 */
51
static inline LPoint3f const &LPoint3f::zero(void);

2543 6 unit_x 0 4 3505 16 LPoint3f::unit_x 0 1 689 34
/**
 * Returns a unit X point.
 */
53
static inline LPoint3f const &LPoint3f::unit_x(void);

2544 6 unit_y 0 4 3505 16 LPoint3f::unit_y 0 1 690 34
/**
 * Returns a unit Y point.
 */
53
static inline LPoint3f const &LPoint3f::unit_y(void);

2545 6 unit_z 0 4 3505 16 LPoint3f::unit_z 0 1 691 34
/**
 * Returns a unit Z point.
 */
53
static inline LPoint3f const &LPoint3f::unit_z(void);

2546 6 get_xy 0 4 3505 16 LPoint3f::get_xy 0 1 692 100
/**
 * Returns a 2-component vector that shares just the first two components of
 * this vector.
 */
45
inline LPoint2f LPoint3f::get_xy(void) const;

2547 6 get_xz 0 4 3505 16 LPoint3f::get_xz 0 1 693 105
/**
 * Returns a 2-component vector that shares just the first and last components
 * of this vector.
 */
45
inline LPoint2f LPoint3f::get_xz(void) const;

2548 6 get_yz 0 4 3505 16 LPoint3f::get_yz 0 1 694 99
/**
 * Returns a 2-component vector that shares just the last two components of
 * this vector.
 */
45
inline LPoint2f LPoint3f::get_yz(void) const;

2549 10 operator - 0 68 3505 20 LPoint3f::operator - 0 1 695 0
49
inline LPoint3f LPoint3f::operator -(void) const;

2550 10 operator + 0 4 3505 20 LPoint3f::operator + 0 2 696 697 0
138
inline LVecBase3f LPoint3f::operator +(LVecBase3f const &other) const;
inline LPoint3f LPoint3f::operator +(LVector3f const &other) const;

2551 10 operator - 0 4 3505 20 LPoint3f::operator - 0 3 698 699 700 0
206
inline LVecBase3f LPoint3f::operator -(LVecBase3f const &other) const;
inline LVector3f LPoint3f::operator -(LPoint3f const &other) const;
inline LPoint3f LPoint3f::operator -(LVector3f const &other) const;

2552 5 cross 0 4 3505 15 LPoint3f::cross 0 1 701 10
/**
 *
 */
63
inline LPoint3f LPoint3f::cross(LVecBase3f const &other) const;

2553 10 normalized 0 4 3505 20 LPoint3f::normalized 0 1 702 160
/**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */
49
inline LPoint3f LPoint3f::normalized(void) const;

2554 7 project 0 4 3505 17 LPoint3f::project 0 1 703 152
/**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */
64
inline LPoint3f LPoint3f::project(LVecBase3f const &onto) const;

2555 10 operator * 0 4 3505 20 LPoint3f::operator * 0 1 704 0
57
inline LPoint3f LPoint3f::operator *(float scalar) const;

2556 10 operator / 0 4 3505 20 LPoint3f::operator / 0 1 705 0
57
inline LPoint3f LPoint3f::operator /(float scalar) const;

2557 6 origin 0 4 3505 16 LPoint3f::origin 0 1 706 186
/**
 * Returns the origin of the indicated coordinate system.  This is always 0,
 * 0, 0 with all of our existing coordinate systems; it's hard to imagine it
 * ever being different.
 */
83
static inline LPoint3f const &LPoint3f::origin(CoordinateSystem cs = ::CS_default);

2558 3 rfu 0 4 3505 13 LPoint3f::rfu 0 1 707 146
/**
 * Returns a point described by right, forward, up displacements from the
 * origin, wherever that maps to in the given coordinate system.
 */
107
static inline LPoint3f LPoint3f::rfu(float right, float fwd, float up, CoordinateSystem cs = ::CS_default);

2559 8 __repr__ 0 4 3505 18 LPoint3f::__repr__ 0 1 708 0
50
inline std::string LPoint3f::__repr__(void) const;

2560 14 get_class_type 0 4 3505 24 LPoint3f::get_class_type 0 1 709 0
49
static TypeHandle LPoint3f::get_class_type(void);

2561 9 ~LPoint3f 0 4 3505 19 LPoint3f::~LPoint3f 0 0 0
26
LPoint3f::~LPoint3f(void);

2562 8 LPoint3d 0 4 3506 18 LPoint3d::LPoint3d 0 6 710 711 712 713 714 715 46
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */
312
inline LPoint3d::LPoint3d(void) = default;
inline LPoint3d::LPoint3d(LVecBase3d const &copy);
inline LPoint3d::LPoint3d(double fill_value);
inline LPoint3d::LPoint3d(double x, double y, double z);
inline LPoint3d::LPoint3d(LVecBase2d const &copy, double z);
inline LPoint3d::LPoint3d(LPoint3d const &) = default;

2563 11 __getattr__ 0 4 3506 21 LPoint3d::__getattr__ 0 1 716 0
91
inline PyObject *LPoint3d::__getattr__(PyObject *self, std::string const &attr_name) const;

2564 11 __setattr__ 0 4 3506 21 LPoint3d::__setattr__ 0 1 717 0
97
inline int LPoint3d::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2565 4 zero 0 4 3506 14 LPoint3d::zero 0 1 718 39
/**
 * Returns a zero-length point.
 */
51
static inline LPoint3d const &LPoint3d::zero(void);

2566 6 unit_x 0 4 3506 16 LPoint3d::unit_x 0 1 719 34
/**
 * Returns a unit X point.
 */
53
static inline LPoint3d const &LPoint3d::unit_x(void);

2567 6 unit_y 0 4 3506 16 LPoint3d::unit_y 0 1 720 34
/**
 * Returns a unit Y point.
 */
53
static inline LPoint3d const &LPoint3d::unit_y(void);

2568 6 unit_z 0 4 3506 16 LPoint3d::unit_z 0 1 721 34
/**
 * Returns a unit Z point.
 */
53
static inline LPoint3d const &LPoint3d::unit_z(void);

2569 6 get_xy 0 4 3506 16 LPoint3d::get_xy 0 1 722 100
/**
 * Returns a 2-component vector that shares just the first two components of
 * this vector.
 */
45
inline LPoint2d LPoint3d::get_xy(void) const;

2570 6 get_xz 0 4 3506 16 LPoint3d::get_xz 0 1 723 105
/**
 * Returns a 2-component vector that shares just the first and last components
 * of this vector.
 */
45
inline LPoint2d LPoint3d::get_xz(void) const;

2571 6 get_yz 0 4 3506 16 LPoint3d::get_yz 0 1 724 99
/**
 * Returns a 2-component vector that shares just the last two components of
 * this vector.
 */
45
inline LPoint2d LPoint3d::get_yz(void) const;

2572 10 operator - 0 68 3506 20 LPoint3d::operator - 0 1 725 0
49
inline LPoint3d LPoint3d::operator -(void) const;

2573 10 operator + 0 4 3506 20 LPoint3d::operator + 0 2 726 727 0
138
inline LVecBase3d LPoint3d::operator +(LVecBase3d const &other) const;
inline LPoint3d LPoint3d::operator +(LVector3d const &other) const;

2574 10 operator - 0 4 3506 20 LPoint3d::operator - 0 3 728 729 730 0
206
inline LVecBase3d LPoint3d::operator -(LVecBase3d const &other) const;
inline LVector3d LPoint3d::operator -(LPoint3d const &other) const;
inline LPoint3d LPoint3d::operator -(LVector3d const &other) const;

2575 5 cross 0 4 3506 15 LPoint3d::cross 0 1 731 10
/**
 *
 */
63
inline LPoint3d LPoint3d::cross(LVecBase3d const &other) const;

2576 10 normalized 0 4 3506 20 LPoint3d::normalized 0 1 732 160
/**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */
49
inline LPoint3d LPoint3d::normalized(void) const;

2577 7 project 0 4 3506 17 LPoint3d::project 0 1 733 152
/**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */
64
inline LPoint3d LPoint3d::project(LVecBase3d const &onto) const;

2578 10 operator * 0 4 3506 20 LPoint3d::operator * 0 1 734 0
58
inline LPoint3d LPoint3d::operator *(double scalar) const;

2579 10 operator / 0 4 3506 20 LPoint3d::operator / 0 1 735 0
58
inline LPoint3d LPoint3d::operator /(double scalar) const;

2580 6 origin 0 4 3506 16 LPoint3d::origin 0 1 736 186
/**
 * Returns the origin of the indicated coordinate system.  This is always 0,
 * 0, 0 with all of our existing coordinate systems; it's hard to imagine it
 * ever being different.
 */
83
static inline LPoint3d const &LPoint3d::origin(CoordinateSystem cs = ::CS_default);

2581 3 rfu 0 4 3506 13 LPoint3d::rfu 0 1 737 146
/**
 * Returns a point described by right, forward, up displacements from the
 * origin, wherever that maps to in the given coordinate system.
 */
110
static inline LPoint3d LPoint3d::rfu(double right, double fwd, double up, CoordinateSystem cs = ::CS_default);

2582 8 __repr__ 0 4 3506 18 LPoint3d::__repr__ 0 1 738 0
50
inline std::string LPoint3d::__repr__(void) const;

2583 14 get_class_type 0 4 3506 24 LPoint3d::get_class_type 0 1 739 0
49
static TypeHandle LPoint3d::get_class_type(void);

2584 9 ~LPoint3d 0 4 3506 19 LPoint3d::~LPoint3d 0 0 0
26
LPoint3d::~LPoint3d(void);

2585 8 LPoint3i 0 4 3507 18 LPoint3i::LPoint3i 0 6 740 741 742 743 744 745 46
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */
297
inline LPoint3i::LPoint3i(void) = default;
inline LPoint3i::LPoint3i(LVecBase3i const &copy);
inline LPoint3i::LPoint3i(int fill_value);
inline LPoint3i::LPoint3i(int x, int y, int z);
inline LPoint3i::LPoint3i(LVecBase2i const &copy, int z);
inline LPoint3i::LPoint3i(LPoint3i const &) = default;

2586 11 __getattr__ 0 4 3507 21 LPoint3i::__getattr__ 0 1 746 0
91
inline PyObject *LPoint3i::__getattr__(PyObject *self, std::string const &attr_name) const;

2587 11 __setattr__ 0 4 3507 21 LPoint3i::__setattr__ 0 1 747 0
97
inline int LPoint3i::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2588 4 zero 0 4 3507 14 LPoint3i::zero 0 1 748 39
/**
 * Returns a zero-length point.
 */
51
static inline LPoint3i const &LPoint3i::zero(void);

2589 6 unit_x 0 4 3507 16 LPoint3i::unit_x 0 1 749 34
/**
 * Returns a unit X point.
 */
53
static inline LPoint3i const &LPoint3i::unit_x(void);

2590 6 unit_y 0 4 3507 16 LPoint3i::unit_y 0 1 750 34
/**
 * Returns a unit Y point.
 */
53
static inline LPoint3i const &LPoint3i::unit_y(void);

2591 6 unit_z 0 4 3507 16 LPoint3i::unit_z 0 1 751 34
/**
 * Returns a unit Z point.
 */
53
static inline LPoint3i const &LPoint3i::unit_z(void);

2592 6 get_xy 0 4 3507 16 LPoint3i::get_xy 0 1 752 100
/**
 * Returns a 2-component vector that shares just the first two components of
 * this vector.
 */
45
inline LPoint2i LPoint3i::get_xy(void) const;

2593 6 get_xz 0 4 3507 16 LPoint3i::get_xz 0 1 753 105
/**
 * Returns a 2-component vector that shares just the first and last components
 * of this vector.
 */
45
inline LPoint2i LPoint3i::get_xz(void) const;

2594 6 get_yz 0 4 3507 16 LPoint3i::get_yz 0 1 754 99
/**
 * Returns a 2-component vector that shares just the last two components of
 * this vector.
 */
45
inline LPoint2i LPoint3i::get_yz(void) const;

2595 10 operator - 0 68 3507 20 LPoint3i::operator - 0 1 755 0
49
inline LPoint3i LPoint3i::operator -(void) const;

2596 10 operator + 0 4 3507 20 LPoint3i::operator + 0 2 756 757 0
138
inline LVecBase3i LPoint3i::operator +(LVecBase3i const &other) const;
inline LPoint3i LPoint3i::operator +(LVector3i const &other) const;

2597 10 operator - 0 4 3507 20 LPoint3i::operator - 0 3 758 759 760 0
206
inline LVecBase3i LPoint3i::operator -(LVecBase3i const &other) const;
inline LVector3i LPoint3i::operator -(LPoint3i const &other) const;
inline LPoint3i LPoint3i::operator -(LVector3i const &other) const;

2598 5 cross 0 4 3507 15 LPoint3i::cross 0 1 761 10
/**
 *
 */
63
inline LPoint3i LPoint3i::cross(LVecBase3i const &other) const;

2599 10 operator * 0 4 3507 20 LPoint3i::operator * 0 1 762 0
55
inline LPoint3i LPoint3i::operator *(int scalar) const;

2600 10 operator / 0 4 3507 20 LPoint3i::operator / 0 1 763 0
55
inline LPoint3i LPoint3i::operator /(int scalar) const;

2601 6 origin 0 4 3507 16 LPoint3i::origin 0 1 764 186
/**
 * Returns the origin of the indicated coordinate system.  This is always 0,
 * 0, 0 with all of our existing coordinate systems; it's hard to imagine it
 * ever being different.
 */
83
static inline LPoint3i const &LPoint3i::origin(CoordinateSystem cs = ::CS_default);

2602 3 rfu 0 4 3507 13 LPoint3i::rfu 0 1 765 146
/**
 * Returns a point described by right, forward, up displacements from the
 * origin, wherever that maps to in the given coordinate system.
 */
101
static inline LPoint3i LPoint3i::rfu(int right, int fwd, int up, CoordinateSystem cs = ::CS_default);

2603 8 __repr__ 0 4 3507 18 LPoint3i::__repr__ 0 1 766 0
50
inline std::string LPoint3i::__repr__(void) const;

2604 14 get_class_type 0 4 3507 24 LPoint3i::get_class_type 0 1 767 0
49
static TypeHandle LPoint3i::get_class_type(void);

2605 9 ~LPoint3i 0 4 3507 19 LPoint3i::~LPoint3i 0 0 0
26
LPoint3i::~LPoint3i(void);

2606 10 LVecBase4f 0 4 3508 22 LVecBase4f::LVecBase4f 0 8 768 769 770 771 772 773 774 775 219
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 * Constructs an LVecBase4 from an LPoint3.  The w coordinate is set to 1.0.
 */

/**
 * Constructs an LVecBase4 from an LVector3.  The w coordinate is set to 0.0.
 */
461
inline LVecBase4f::LVecBase4f(void) = default;
inline LVecBase4f::LVecBase4f(float fill_value);
inline LVecBase4f::LVecBase4f(float x, float y, float z, float w);
inline LVecBase4f::LVecBase4f(UnalignedLVecBase4f const &copy);
inline LVecBase4f::LVecBase4f(LVecBase3f const &copy, float w);
inline LVecBase4f::LVecBase4f(LPoint3f const &point);
inline LVecBase4f::LVecBase4f(LVector3f const &vector);
inline LVecBase4f::LVecBase4f(LVecBase4f const &) = default;

2607 12 operator new 0 4 3508 24 LVecBase4f::operator new 0 1 776 0
124
inline void *LVecBase4f::operator new(std::size_t size);
inline void *LVecBase4f::operator new(std::size_t size, void *ptr);

2608 15 operator delete 0 4 3508 27 LVecBase4f::operator delete 0 0 0
108
inline void LVecBase4f::operator delete(void *ptr);
inline void LVecBase4f::operator delete(void *, void *);

2609 12 validate_ptr 0 4 3508 24 LVecBase4f::validate_ptr 0 0 0
61
static inline bool LVecBase4f::validate_ptr(void const *ptr);

2610 10 operator = 0 4 3508 22 LVecBase4f::operator = 0 2 777 778 0
133
LVecBase4f &LVecBase4f::operator =(LVecBase4f const &copy) = default;
LVecBase4f &LVecBase4f::operator =(float fill_value) = default;

2611 4 zero 0 4 3508 16 LVecBase4f::zero 0 1 779 40
/**
 * Returns a zero-length vector.
 */
55
static inline LVecBase4f const &LVecBase4f::zero(void);

2612 6 unit_x 0 4 3508 18 LVecBase4f::unit_x 0 1 780 35
/**
 * Returns a unit X vector.
 */
57
static inline LVecBase4f const &LVecBase4f::unit_x(void);

2613 6 unit_y 0 4 3508 18 LVecBase4f::unit_y 0 1 781 35
/**
 * Returns a unit Y vector.
 */
57
static inline LVecBase4f const &LVecBase4f::unit_y(void);

2614 6 unit_z 0 4 3508 18 LVecBase4f::unit_z 0 1 782 35
/**
 * Returns a unit Z vector.
 */
57
static inline LVecBase4f const &LVecBase4f::unit_z(void);

2615 6 unit_w 0 4 3508 18 LVecBase4f::unit_w 0 1 783 35
/**
 * Returns a unit W vector.
 */
57
static inline LVecBase4f const &LVecBase4f::unit_w(void);

2616 10 __reduce__ 0 4 3508 22 LVecBase4f::__reduce__ 0 1 784 0
62
inline PyObject *LVecBase4f::__reduce__(PyObject *self) const;

2617 11 __getattr__ 0 4 3508 23 LVecBase4f::__getattr__ 0 1 785 0
93
inline PyObject *LVecBase4f::__getattr__(PyObject *self, std::string const &attr_name) const;

2618 11 __setattr__ 0 4 3508 23 LVecBase4f::__setattr__ 0 1 786 0
99
inline int LVecBase4f::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2619 11 operator [] 0 4 3508 23 LVecBase4f::operator [] 0 2 787 788 10
/**
 *
 */
96
inline float LVecBase4f::operator [](int i) const;
inline float &LVecBase4f::operator [](int i);

2620 4 size 0 4 3508 16 LVecBase4f::size 0 1 789 0
44
static constexpr int LVecBase4f::size(void);

2621 6 is_nan 0 4 3508 18 LVecBase4f::is_nan 0 1 790 91
/**
 * Returns true if any component of the vector is not-a-number, false
 * otherwise.
 */
43
inline bool LVecBase4f::is_nan(void) const;

2622 8 get_cell 0 4 3508 20 LVecBase4f::get_cell 0 1 791 10
/**
 *
 */
47
inline float LVecBase4f::get_cell(int i) const;

2623 8 set_cell 0 4 3508 20 LVecBase4f::set_cell 0 1 792 10
/**
 *
 */
53
inline void LVecBase4f::set_cell(int i, float value);

2624 5 get_x 0 4 3508 17 LVecBase4f::get_x 0 1 793 10
/**
 *
 */
43
inline float LVecBase4f::get_x(void) const;

2625 5 get_y 0 4 3508 17 LVecBase4f::get_y 0 1 794 10
/**
 *
 */
43
inline float LVecBase4f::get_y(void) const;

2626 5 get_z 0 4 3508 17 LVecBase4f::get_z 0 1 795 10
/**
 *
 */
43
inline float LVecBase4f::get_z(void) const;

2627 5 get_w 0 4 3508 17 LVecBase4f::get_w 0 1 796 10
/**
 *
 */
43
inline float LVecBase4f::get_w(void) const;

2628 7 get_xyz 0 4 3508 19 LVecBase4f::get_xyz 0 1 797 58
/**
 * Returns the x, y and z component of this vector
 */
50
inline LVecBase3f LVecBase4f::get_xyz(void) const;

2629 6 get_xy 0 4 3508 18 LVecBase4f::get_xy 0 1 798 55
/**
 * Returns the x and y component of this vector
 */
49
inline LVecBase2f LVecBase4f::get_xy(void) const;

2630 5 set_x 0 4 3508 17 LVecBase4f::set_x 0 1 799 10
/**
 *
 */
43
inline void LVecBase4f::set_x(float value);

2631 5 set_y 0 4 3508 17 LVecBase4f::set_y 0 1 800 10
/**
 *
 */
43
inline void LVecBase4f::set_y(float value);

2632 5 set_z 0 4 3508 17 LVecBase4f::set_z 0 1 801 10
/**
 *
 */
43
inline void LVecBase4f::set_z(float value);

2633 5 set_w 0 4 3508 17 LVecBase4f::set_w 0 1 802 10
/**
 *
 */
43
inline void LVecBase4f::set_w(float value);

2634 11 add_to_cell 0 4 3508 23 LVecBase4f::add_to_cell 0 1 803 164
// These next functions add to an existing value.  i.e.
// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
// scripting languages:

/**
 *
 */
56
inline void LVecBase4f::add_to_cell(int i, float value);

2635 5 add_x 0 4 3508 17 LVecBase4f::add_x 0 1 804 10
/**
 *
 */
43
inline void LVecBase4f::add_x(float value);

2636 5 add_y 0 4 3508 17 LVecBase4f::add_y 0 1 805 10
/**
 *
 */
43
inline void LVecBase4f::add_y(float value);

2637 5 add_z 0 4 3508 17 LVecBase4f::add_z 0 1 806 10
/**
 *
 */
43
inline void LVecBase4f::add_z(float value);

2638 5 add_w 0 4 3508 17 LVecBase4f::add_w 0 1 807 10
/**
 *
 */
43
inline void LVecBase4f::add_w(float value);

2639 8 get_data 0 4 3508 20 LVecBase4f::get_data 0 1 808 161
/**
 * Returns the address of the first of the four data elements in the vector.
 * The remaining elements occupy the next positions consecutively in memory.
 */
53
inline float const *LVecBase4f::get_data(void) const;

2640 18 get_num_components 0 4 3508 30 LVecBase4f::get_num_components 0 1 809 0
58
static constexpr int LVecBase4f::get_num_components(void);

2641 12 extract_data 0 4 3508 24 LVecBase4f::extract_data 0 0 0
46
inline void LVecBase4f::extract_data(float *);

2642 4 fill 0 4 3508 16 LVecBase4f::fill 0 1 810 129
/**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */
47
inline void LVecBase4f::fill(float fill_value);

2643 3 set 0 4 3508 15 LVecBase4f::set 0 1 811 10
/**
 *
 */
64
inline void LVecBase4f::set(float x, float y, float z, float w);

2644 3 dot 0 4 3508 15 LVecBase4f::dot 0 1 812 10
/**
 *
 */
60
inline float LVecBase4f::dot(LVecBase4f const &other) const;

2645 14 length_squared 0 4 3508 26 LVecBase4f::length_squared 0 1 813 69
/**
 * Returns the square of the vector's length, cheap and easy.
 */
52
inline float LVecBase4f::length_squared(void) const;

2646 6 length 0 4 3508 18 LVecBase4f::length 0 1 814 72
/**
 * Returns the length of the vector, by the Pythagorean theorem.
 */
44
inline float LVecBase4f::length(void) const;

2647 9 normalize 0 4 3508 21 LVecBase4f::normalize 0 1 815 127
/**
 * Normalizes the vector in place.  Returns true if the vector was normalized,
 * false if it was a zero-length vector.
 */
40
inline bool LVecBase4f::normalize(void);

2648 10 normalized 0 4 3508 22 LVecBase4f::normalized 0 1 816 160
/**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */
53
inline LVecBase4f LVecBase4f::normalized(void) const;

2649 7 project 0 4 3508 19 LVecBase4f::project 0 1 817 152
/**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */
68
inline LVecBase4f LVecBase4f::project(LVecBase4f const &onto) const;

2650 10 operator < 0 4 3508 22 LVecBase4f::operator < 0 1 818 0
66
inline bool LVecBase4f::operator <(LVecBase4f const &other) const;

2651 11 operator == 0 4 3508 23 LVecBase4f::operator == 0 1 819 0
67
inline bool LVecBase4f::operator ==(LVecBase4f const &other) const;

2652 11 operator != 0 4 3508 23 LVecBase4f::operator != 0 1 820 0
67
inline bool LVecBase4f::operator !=(LVecBase4f const &other) const;

2653 10 compare_to 0 4 3508 22 LVecBase4f::compare_to 0 2 821 822 332
/**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */

/**
 * Sorts vectors lexicographically, componentwise.  Returns a number less than
 * 0 if this vector sorts before the other one, greater than zero if it sorts
 * after, 0 if they are equivalent (within the indicated tolerance).
 */
148
inline int LVecBase4f::compare_to(LVecBase4f const &other) const;
inline int LVecBase4f::compare_to(LVecBase4f const &other, float threshold) const;

2654 8 get_hash 0 4 3508 20 LVecBase4f::get_hash 0 2 823 824 100
/**
 * Returns a suitable hash for phash_map.
 */

/**
 * Returns a suitable hash for phash_map.
 */
116
inline std::size_t LVecBase4f::get_hash(void) const;
inline std::size_t LVecBase4f::get_hash(float threshold) const;

2655 8 add_hash 0 4 3508 20 LVecBase4f::add_hash 0 2 825 826 100
/**
 * Adds the vector into the running hash.
 */

/**
 * Adds the vector into the running hash.
 */
146
inline std::size_t LVecBase4f::add_hash(std::size_t hash) const;
inline std::size_t LVecBase4f::add_hash(std::size_t hash, float threshold) const;

2656 13 generate_hash 0 4 3508 25 LVecBase4f::generate_hash 0 2 827 828 120
/**
 * Adds the vector to the indicated hash generator.
 */

/**
 * Adds the vector to the indicated hash generator.
 */
170
inline void LVecBase4f::generate_hash(ChecksumHashGenerator &hashgen) const;
inline void LVecBase4f::generate_hash(ChecksumHashGenerator &hashgen, float threshold) const;

2657 10 operator - 0 68 3508 22 LVecBase4f::operator - 0 1 829 0
53
inline LVecBase4f LVecBase4f::operator -(void) const;

2658 10 operator + 0 4 3508 22 LVecBase4f::operator + 0 1 830 0
72
inline LVecBase4f LVecBase4f::operator +(LVecBase4f const &other) const;

2659 10 operator - 0 4 3508 22 LVecBase4f::operator - 0 1 831 0
72
inline LVecBase4f LVecBase4f::operator -(LVecBase4f const &other) const;

2660 10 operator * 0 4 3508 22 LVecBase4f::operator * 0 1 832 0
61
inline LVecBase4f LVecBase4f::operator *(float scalar) const;

2661 10 operator / 0 4 3508 22 LVecBase4f::operator / 0 1 833 0
61
inline LVecBase4f LVecBase4f::operator /(float scalar) const;

2662 11 operator += 0 4 3508 23 LVecBase4f::operator += 0 1 834 0
61
inline void LVecBase4f::operator +=(LVecBase4f const &other);

2663 11 operator -= 0 4 3508 23 LVecBase4f::operator -= 0 1 835 0
61
inline void LVecBase4f::operator -=(LVecBase4f const &other);

2664 11 operator *= 0 4 3508 23 LVecBase4f::operator *= 0 1 836 0
50
inline void LVecBase4f::operator *=(float scalar);

2665 11 operator /= 0 4 3508 23 LVecBase4f::operator /= 0 1 837 0
50
inline void LVecBase4f::operator /=(float scalar);

2666 18 componentwise_mult 0 4 3508 30 LVecBase4f::componentwise_mult 0 1 838 10
/**
 *
 */
68
inline void LVecBase4f::componentwise_mult(LVecBase4f const &other);

2667 7 __pow__ 0 4 3508 19 LVecBase4f::__pow__ 0 1 839 0
60
inline LVecBase4f LVecBase4f::__pow__(float exponent) const;

2668 8 __ipow__ 0 4 3508 20 LVecBase4f::__ipow__ 0 1 840 0
70
inline PyObject *LVecBase4f::__ipow__(PyObject *self, float exponent);

2669 4 fmax 0 4 3508 16 LVecBase4f::fmax 0 1 841 10
/**
 *
 */
66
inline LVecBase4f LVecBase4f::fmax(LVecBase4f const &other) const;

2670 4 fmin 0 4 3508 16 LVecBase4f::fmin 0 1 842 10
/**
 *
 */
66
inline LVecBase4f LVecBase4f::fmin(LVecBase4f const &other) const;

2671 12 almost_equal 0 4 3508 24 LVecBase4f::almost_equal 0 2 843 844 210
/**
 * Returns true if two vectors are memberwise equal within a specified
 * tolerance.
 */

/**
 * Returns true if two vectors are memberwise equal within a default tolerance
 * based on the numeric type.
 */
154
inline bool LVecBase4f::almost_equal(LVecBase4f const &other, float threshold) const;
inline bool LVecBase4f::almost_equal(LVecBase4f const &other) const;

2672 6 output 0 4 3508 18 LVecBase4f::output 0 1 845 10
/**
 *
 */
51
inline void LVecBase4f::output(ostream &out) const;

2673 8 __repr__ 0 4 3508 20 LVecBase4f::__repr__ 0 1 846 0
52
inline std::string LVecBase4f::__repr__(void) const;

2674 20 write_datagram_fixed 0 4 3508 32 LVecBase4f::write_datagram_fixed 0 1 847 332
/**
 * Writes the vector to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the vector, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */
74
inline void LVecBase4f::write_datagram_fixed(Datagram &destination) const;

2675 19 read_datagram_fixed 0 4 3508 31 LVecBase4f::read_datagram_fixed 0 1 848 114
/**
 * Reads the vector from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */
70
inline void LVecBase4f::read_datagram_fixed(DatagramIterator &source);

2676 14 write_datagram 0 4 3508 26 LVecBase4f::write_datagram 0 1 849 205
/**
 * Writes the vector to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the vector using the standard width
 * setting, especially when you are writing a bam file.
 */
68
inline void LVecBase4f::write_datagram(Datagram &destination) const;

2677 13 read_datagram 0 4 3508 25 LVecBase4f::read_datagram 0 1 850 67
/**
 * Reads the vector from the Datagram using get_stdfloat().
 */
64
inline void LVecBase4f::read_datagram(DatagramIterator &source);

2678 14 get_class_type 0 4 3508 26 LVecBase4f::get_class_type 0 1 851 0
51
static TypeHandle LVecBase4f::get_class_type(void);

2679 11 ~LVecBase4f 0 4 3508 23 LVecBase4f::~LVecBase4f 0 0 0
30
LVecBase4f::~LVecBase4f(void);

2680 19 UnalignedLVecBase4f 0 4 3510 40 UnalignedLVecBase4f::UnalignedLVecBase4f 0 5 852 853 854 855 856 34
/**
 *
 */

/**
 *
 */

/**
 *
 */
377
inline UnalignedLVecBase4f::UnalignedLVecBase4f(void) = default;
inline UnalignedLVecBase4f::UnalignedLVecBase4f(LVecBase4f const &copy);
inline UnalignedLVecBase4f::UnalignedLVecBase4f(float fill_value);
inline UnalignedLVecBase4f::UnalignedLVecBase4f(float x, float y, float z, float w);
inline UnalignedLVecBase4f::UnalignedLVecBase4f(UnalignedLVecBase4f const &) = default;

2681 4 fill 0 4 3510 25 UnalignedLVecBase4f::fill 0 1 857 129
/**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */
56
inline void UnalignedLVecBase4f::fill(float fill_value);

2682 3 set 0 4 3510 24 UnalignedLVecBase4f::set 0 1 858 10
/**
 *
 */
73
inline void UnalignedLVecBase4f::set(float x, float y, float z, float w);

2683 11 operator [] 0 4 3510 32 UnalignedLVecBase4f::operator [] 0 2 859 860 10
/**
 *
 */
114
inline float UnalignedLVecBase4f::operator [](int i) const;
inline float &UnalignedLVecBase4f::operator [](int i);

2684 4 size 0 4 3510 25 UnalignedLVecBase4f::size 0 1 861 0
53
static constexpr int UnalignedLVecBase4f::size(void);

2685 8 get_data 0 4 3510 29 UnalignedLVecBase4f::get_data 0 1 862 162
/**
 * Returns the address of the first of the three data elements in the vector.
 * The remaining elements occupy the next positions consecutively in memory.
 */
62
inline float const *UnalignedLVecBase4f::get_data(void) const;

2686 18 get_num_components 0 4 3510 39 UnalignedLVecBase4f::get_num_components 0 1 863 0
67
static constexpr int UnalignedLVecBase4f::get_num_components(void);

2687 14 get_class_type 0 4 3510 35 UnalignedLVecBase4f::get_class_type 0 1 864 0
60
static TypeHandle UnalignedLVecBase4f::get_class_type(void);

2688 20 ~UnalignedLVecBase4f 0 4 3510 41 UnalignedLVecBase4f::~UnalignedLVecBase4f 0 0 0
48
UnalignedLVecBase4f::~UnalignedLVecBase4f(void);

2689 10 LVecBase4d 0 4 3512 22 LVecBase4d::LVecBase4d 0 8 865 866 867 868 869 870 871 872 219
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 * Constructs an LVecBase4 from an LPoint3.  The w coordinate is set to 1.0.
 */

/**
 * Constructs an LVecBase4 from an LVector3.  The w coordinate is set to 0.0.
 */
467
inline LVecBase4d::LVecBase4d(void) = default;
inline LVecBase4d::LVecBase4d(double fill_value);
inline LVecBase4d::LVecBase4d(double x, double y, double z, double w);
inline LVecBase4d::LVecBase4d(UnalignedLVecBase4d const &copy);
inline LVecBase4d::LVecBase4d(LVecBase3d const &copy, double w);
inline LVecBase4d::LVecBase4d(LPoint3d const &point);
inline LVecBase4d::LVecBase4d(LVector3d const &vector);
inline LVecBase4d::LVecBase4d(LVecBase4d const &) = default;

2690 12 operator new 0 4 3512 24 LVecBase4d::operator new 0 1 873 0
124
inline void *LVecBase4d::operator new(std::size_t size);
inline void *LVecBase4d::operator new(std::size_t size, void *ptr);

2691 15 operator delete 0 4 3512 27 LVecBase4d::operator delete 0 0 0
108
inline void LVecBase4d::operator delete(void *ptr);
inline void LVecBase4d::operator delete(void *, void *);

2692 12 validate_ptr 0 4 3512 24 LVecBase4d::validate_ptr 0 0 0
61
static inline bool LVecBase4d::validate_ptr(void const *ptr);

2693 10 operator = 0 4 3512 22 LVecBase4d::operator = 0 2 874 875 0
134
LVecBase4d &LVecBase4d::operator =(LVecBase4d const &copy) = default;
LVecBase4d &LVecBase4d::operator =(double fill_value) = default;

2694 4 zero 0 4 3512 16 LVecBase4d::zero 0 1 876 40
/**
 * Returns a zero-length vector.
 */
55
static inline LVecBase4d const &LVecBase4d::zero(void);

2695 6 unit_x 0 4 3512 18 LVecBase4d::unit_x 0 1 877 35
/**
 * Returns a unit X vector.
 */
57
static inline LVecBase4d const &LVecBase4d::unit_x(void);

2696 6 unit_y 0 4 3512 18 LVecBase4d::unit_y 0 1 878 35
/**
 * Returns a unit Y vector.
 */
57
static inline LVecBase4d const &LVecBase4d::unit_y(void);

2697 6 unit_z 0 4 3512 18 LVecBase4d::unit_z 0 1 879 35
/**
 * Returns a unit Z vector.
 */
57
static inline LVecBase4d const &LVecBase4d::unit_z(void);

2698 6 unit_w 0 4 3512 18 LVecBase4d::unit_w 0 1 880 35
/**
 * Returns a unit W vector.
 */
57
static inline LVecBase4d const &LVecBase4d::unit_w(void);

2699 10 __reduce__ 0 4 3512 22 LVecBase4d::__reduce__ 0 1 881 0
62
inline PyObject *LVecBase4d::__reduce__(PyObject *self) const;

2700 11 __getattr__ 0 4 3512 23 LVecBase4d::__getattr__ 0 1 882 0
93
inline PyObject *LVecBase4d::__getattr__(PyObject *self, std::string const &attr_name) const;

2701 11 __setattr__ 0 4 3512 23 LVecBase4d::__setattr__ 0 1 883 0
99
inline int LVecBase4d::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2702 11 operator [] 0 4 3512 23 LVecBase4d::operator [] 0 2 884 885 10
/**
 *
 */
98
inline double LVecBase4d::operator [](int i) const;
inline double &LVecBase4d::operator [](int i);

2703 4 size 0 4 3512 16 LVecBase4d::size 0 1 886 0
44
static constexpr int LVecBase4d::size(void);

2704 6 is_nan 0 4 3512 18 LVecBase4d::is_nan 0 1 887 91
/**
 * Returns true if any component of the vector is not-a-number, false
 * otherwise.
 */
43
inline bool LVecBase4d::is_nan(void) const;

2705 8 get_cell 0 4 3512 20 LVecBase4d::get_cell 0 1 888 10
/**
 *
 */
48
inline double LVecBase4d::get_cell(int i) const;

2706 8 set_cell 0 4 3512 20 LVecBase4d::set_cell 0 1 889 10
/**
 *
 */
54
inline void LVecBase4d::set_cell(int i, double value);

2707 5 get_x 0 4 3512 17 LVecBase4d::get_x 0 1 890 10
/**
 *
 */
44
inline double LVecBase4d::get_x(void) const;

2708 5 get_y 0 4 3512 17 LVecBase4d::get_y 0 1 891 10
/**
 *
 */
44
inline double LVecBase4d::get_y(void) const;

2709 5 get_z 0 4 3512 17 LVecBase4d::get_z 0 1 892 10
/**
 *
 */
44
inline double LVecBase4d::get_z(void) const;

2710 5 get_w 0 4 3512 17 LVecBase4d::get_w 0 1 893 10
/**
 *
 */
44
inline double LVecBase4d::get_w(void) const;

2711 7 get_xyz 0 4 3512 19 LVecBase4d::get_xyz 0 1 894 58
/**
 * Returns the x, y and z component of this vector
 */
50
inline LVecBase3d LVecBase4d::get_xyz(void) const;

2712 6 get_xy 0 4 3512 18 LVecBase4d::get_xy 0 1 895 55
/**
 * Returns the x and y component of this vector
 */
49
inline LVecBase2d LVecBase4d::get_xy(void) const;

2713 5 set_x 0 4 3512 17 LVecBase4d::set_x 0 1 896 10
/**
 *
 */
44
inline void LVecBase4d::set_x(double value);

2714 5 set_y 0 4 3512 17 LVecBase4d::set_y 0 1 897 10
/**
 *
 */
44
inline void LVecBase4d::set_y(double value);

2715 5 set_z 0 4 3512 17 LVecBase4d::set_z 0 1 898 10
/**
 *
 */
44
inline void LVecBase4d::set_z(double value);

2716 5 set_w 0 4 3512 17 LVecBase4d::set_w 0 1 899 10
/**
 *
 */
44
inline void LVecBase4d::set_w(double value);

2717 11 add_to_cell 0 4 3512 23 LVecBase4d::add_to_cell 0 1 900 164
// These next functions add to an existing value.  i.e.
// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
// scripting languages:

/**
 *
 */
57
inline void LVecBase4d::add_to_cell(int i, double value);

2718 5 add_x 0 4 3512 17 LVecBase4d::add_x 0 1 901 10
/**
 *
 */
44
inline void LVecBase4d::add_x(double value);

2719 5 add_y 0 4 3512 17 LVecBase4d::add_y 0 1 902 10
/**
 *
 */
44
inline void LVecBase4d::add_y(double value);

2720 5 add_z 0 4 3512 17 LVecBase4d::add_z 0 1 903 10
/**
 *
 */
44
inline void LVecBase4d::add_z(double value);

2721 5 add_w 0 4 3512 17 LVecBase4d::add_w 0 1 904 10
/**
 *
 */
44
inline void LVecBase4d::add_w(double value);

2722 8 get_data 0 4 3512 20 LVecBase4d::get_data 0 1 905 161
/**
 * Returns the address of the first of the four data elements in the vector.
 * The remaining elements occupy the next positions consecutively in memory.
 */
54
inline double const *LVecBase4d::get_data(void) const;

2723 18 get_num_components 0 4 3512 30 LVecBase4d::get_num_components 0 1 906 0
58
static constexpr int LVecBase4d::get_num_components(void);

2724 12 extract_data 0 4 3512 24 LVecBase4d::extract_data 0 0 0
46
inline void LVecBase4d::extract_data(float *);

2725 4 fill 0 4 3512 16 LVecBase4d::fill 0 1 907 129
/**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */
48
inline void LVecBase4d::fill(double fill_value);

2726 3 set 0 4 3512 15 LVecBase4d::set 0 1 908 10
/**
 *
 */
68
inline void LVecBase4d::set(double x, double y, double z, double w);

2727 3 dot 0 4 3512 15 LVecBase4d::dot 0 1 909 10
/**
 *
 */
61
inline double LVecBase4d::dot(LVecBase4d const &other) const;

2728 14 length_squared 0 4 3512 26 LVecBase4d::length_squared 0 1 910 69
/**
 * Returns the square of the vector's length, cheap and easy.
 */
53
inline double LVecBase4d::length_squared(void) const;

2729 6 length 0 4 3512 18 LVecBase4d::length 0 1 911 72
/**
 * Returns the length of the vector, by the Pythagorean theorem.
 */
45
inline double LVecBase4d::length(void) const;

2730 9 normalize 0 4 3512 21 LVecBase4d::normalize 0 1 912 127
/**
 * Normalizes the vector in place.  Returns true if the vector was normalized,
 * false if it was a zero-length vector.
 */
40
inline bool LVecBase4d::normalize(void);

2731 10 normalized 0 4 3512 22 LVecBase4d::normalized 0 1 913 160
/**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */
53
inline LVecBase4d LVecBase4d::normalized(void) const;

2732 7 project 0 4 3512 19 LVecBase4d::project 0 1 914 152
/**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */
68
inline LVecBase4d LVecBase4d::project(LVecBase4d const &onto) const;

2733 10 operator < 0 4 3512 22 LVecBase4d::operator < 0 1 915 0
66
inline bool LVecBase4d::operator <(LVecBase4d const &other) const;

2734 11 operator == 0 4 3512 23 LVecBase4d::operator == 0 1 916 0
67
inline bool LVecBase4d::operator ==(LVecBase4d const &other) const;

2735 11 operator != 0 4 3512 23 LVecBase4d::operator != 0 1 917 0
67
inline bool LVecBase4d::operator !=(LVecBase4d const &other) const;

2736 10 compare_to 0 4 3512 22 LVecBase4d::compare_to 0 2 918 919 332
/**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */

/**
 * Sorts vectors lexicographically, componentwise.  Returns a number less than
 * 0 if this vector sorts before the other one, greater than zero if it sorts
 * after, 0 if they are equivalent (within the indicated tolerance).
 */
149
inline int LVecBase4d::compare_to(LVecBase4d const &other) const;
inline int LVecBase4d::compare_to(LVecBase4d const &other, double threshold) const;

2737 8 get_hash 0 4 3512 20 LVecBase4d::get_hash 0 2 920 921 100
/**
 * Returns a suitable hash for phash_map.
 */

/**
 * Returns a suitable hash for phash_map.
 */
117
inline std::size_t LVecBase4d::get_hash(void) const;
inline std::size_t LVecBase4d::get_hash(double threshold) const;

2738 8 add_hash 0 4 3512 20 LVecBase4d::add_hash 0 2 922 923 100
/**
 * Adds the vector into the running hash.
 */

/**
 * Adds the vector into the running hash.
 */
147
inline std::size_t LVecBase4d::add_hash(std::size_t hash) const;
inline std::size_t LVecBase4d::add_hash(std::size_t hash, double threshold) const;

2739 13 generate_hash 0 4 3512 25 LVecBase4d::generate_hash 0 2 924 925 120
/**
 * Adds the vector to the indicated hash generator.
 */

/**
 * Adds the vector to the indicated hash generator.
 */
171
inline void LVecBase4d::generate_hash(ChecksumHashGenerator &hashgen) const;
inline void LVecBase4d::generate_hash(ChecksumHashGenerator &hashgen, double threshold) const;

2740 10 operator - 0 68 3512 22 LVecBase4d::operator - 0 1 926 0
53
inline LVecBase4d LVecBase4d::operator -(void) const;

2741 10 operator + 0 4 3512 22 LVecBase4d::operator + 0 1 927 0
72
inline LVecBase4d LVecBase4d::operator +(LVecBase4d const &other) const;

2742 10 operator - 0 4 3512 22 LVecBase4d::operator - 0 1 928 0
72
inline LVecBase4d LVecBase4d::operator -(LVecBase4d const &other) const;

2743 10 operator * 0 4 3512 22 LVecBase4d::operator * 0 1 929 0
62
inline LVecBase4d LVecBase4d::operator *(double scalar) const;

2744 10 operator / 0 4 3512 22 LVecBase4d::operator / 0 1 930 0
62
inline LVecBase4d LVecBase4d::operator /(double scalar) const;

2745 11 operator += 0 4 3512 23 LVecBase4d::operator += 0 1 931 0
61
inline void LVecBase4d::operator +=(LVecBase4d const &other);

2746 11 operator -= 0 4 3512 23 LVecBase4d::operator -= 0 1 932 0
61
inline void LVecBase4d::operator -=(LVecBase4d const &other);

2747 11 operator *= 0 4 3512 23 LVecBase4d::operator *= 0 1 933 0
51
inline void LVecBase4d::operator *=(double scalar);

2748 11 operator /= 0 4 3512 23 LVecBase4d::operator /= 0 1 934 0
51
inline void LVecBase4d::operator /=(double scalar);

2749 18 componentwise_mult 0 4 3512 30 LVecBase4d::componentwise_mult 0 1 935 10
/**
 *
 */
68
inline void LVecBase4d::componentwise_mult(LVecBase4d const &other);

2750 7 __pow__ 0 4 3512 19 LVecBase4d::__pow__ 0 1 936 0
61
inline LVecBase4d LVecBase4d::__pow__(double exponent) const;

2751 8 __ipow__ 0 4 3512 20 LVecBase4d::__ipow__ 0 1 937 0
71
inline PyObject *LVecBase4d::__ipow__(PyObject *self, double exponent);

2752 4 fmax 0 4 3512 16 LVecBase4d::fmax 0 1 938 10
/**
 *
 */
66
inline LVecBase4d LVecBase4d::fmax(LVecBase4d const &other) const;

2753 4 fmin 0 4 3512 16 LVecBase4d::fmin 0 1 939 10
/**
 *
 */
66
inline LVecBase4d LVecBase4d::fmin(LVecBase4d const &other) const;

2754 12 almost_equal 0 4 3512 24 LVecBase4d::almost_equal 0 2 940 941 210
/**
 * Returns true if two vectors are memberwise equal within a specified
 * tolerance.
 */

/**
 * Returns true if two vectors are memberwise equal within a default tolerance
 * based on the numeric type.
 */
155
inline bool LVecBase4d::almost_equal(LVecBase4d const &other, double threshold) const;
inline bool LVecBase4d::almost_equal(LVecBase4d const &other) const;

2755 6 output 0 4 3512 18 LVecBase4d::output 0 1 942 10
/**
 *
 */
51
inline void LVecBase4d::output(ostream &out) const;

2756 8 __repr__ 0 4 3512 20 LVecBase4d::__repr__ 0 1 943 0
52
inline std::string LVecBase4d::__repr__(void) const;

2757 20 write_datagram_fixed 0 4 3512 32 LVecBase4d::write_datagram_fixed 0 1 944 332
/**
 * Writes the vector to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the vector, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */
74
inline void LVecBase4d::write_datagram_fixed(Datagram &destination) const;

2758 19 read_datagram_fixed 0 4 3512 31 LVecBase4d::read_datagram_fixed 0 1 945 114
/**
 * Reads the vector from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */
70
inline void LVecBase4d::read_datagram_fixed(DatagramIterator &source);

2759 14 write_datagram 0 4 3512 26 LVecBase4d::write_datagram 0 1 946 205
/**
 * Writes the vector to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the vector using the standard width
 * setting, especially when you are writing a bam file.
 */
68
inline void LVecBase4d::write_datagram(Datagram &destination) const;

2760 13 read_datagram 0 4 3512 25 LVecBase4d::read_datagram 0 1 947 67
/**
 * Reads the vector from the Datagram using get_stdfloat().
 */
64
inline void LVecBase4d::read_datagram(DatagramIterator &source);

2761 14 get_class_type 0 4 3512 26 LVecBase4d::get_class_type 0 1 948 0
51
static TypeHandle LVecBase4d::get_class_type(void);

2762 11 ~LVecBase4d 0 4 3512 23 LVecBase4d::~LVecBase4d 0 0 0
30
LVecBase4d::~LVecBase4d(void);

2763 19 UnalignedLVecBase4d 0 4 3514 40 UnalignedLVecBase4d::UnalignedLVecBase4d 0 5 949 950 951 952 953 34
/**
 *
 */

/**
 *
 */

/**
 *
 */
382
inline UnalignedLVecBase4d::UnalignedLVecBase4d(void) = default;
inline UnalignedLVecBase4d::UnalignedLVecBase4d(LVecBase4d const &copy);
inline UnalignedLVecBase4d::UnalignedLVecBase4d(double fill_value);
inline UnalignedLVecBase4d::UnalignedLVecBase4d(double x, double y, double z, double w);
inline UnalignedLVecBase4d::UnalignedLVecBase4d(UnalignedLVecBase4d const &) = default;

2764 4 fill 0 4 3514 25 UnalignedLVecBase4d::fill 0 1 954 129
/**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */
57
inline void UnalignedLVecBase4d::fill(double fill_value);

2765 3 set 0 4 3514 24 UnalignedLVecBase4d::set 0 1 955 10
/**
 *
 */
77
inline void UnalignedLVecBase4d::set(double x, double y, double z, double w);

2766 11 operator [] 0 4 3514 32 UnalignedLVecBase4d::operator [] 0 2 956 957 10
/**
 *
 */
116
inline double UnalignedLVecBase4d::operator [](int i) const;
inline double &UnalignedLVecBase4d::operator [](int i);

2767 4 size 0 4 3514 25 UnalignedLVecBase4d::size 0 1 958 0
53
static constexpr int UnalignedLVecBase4d::size(void);

2768 8 get_data 0 4 3514 29 UnalignedLVecBase4d::get_data 0 1 959 162
/**
 * Returns the address of the first of the three data elements in the vector.
 * The remaining elements occupy the next positions consecutively in memory.
 */
63
inline double const *UnalignedLVecBase4d::get_data(void) const;

2769 18 get_num_components 0 4 3514 39 UnalignedLVecBase4d::get_num_components 0 1 960 0
67
static constexpr int UnalignedLVecBase4d::get_num_components(void);

2770 14 get_class_type 0 4 3514 35 UnalignedLVecBase4d::get_class_type 0 1 961 0
60
static TypeHandle UnalignedLVecBase4d::get_class_type(void);

2771 20 ~UnalignedLVecBase4d 0 4 3514 41 UnalignedLVecBase4d::~UnalignedLVecBase4d 0 0 0
48
UnalignedLVecBase4d::~UnalignedLVecBase4d(void);

2772 10 LVecBase4i 0 4 3516 22 LVecBase4i::LVecBase4i 0 8 962 963 964 965 966 967 968 969 219
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 * Constructs an LVecBase4 from an LPoint3.  The w coordinate is set to 1.0.
 */

/**
 * Constructs an LVecBase4 from an LVector3.  The w coordinate is set to 0.0.
 */
449
inline LVecBase4i::LVecBase4i(void) = default;
inline LVecBase4i::LVecBase4i(int fill_value);
inline LVecBase4i::LVecBase4i(int x, int y, int z, int w);
inline LVecBase4i::LVecBase4i(UnalignedLVecBase4i const &copy);
inline LVecBase4i::LVecBase4i(LVecBase3i const &copy, int w);
inline LVecBase4i::LVecBase4i(LPoint3i const &point);
inline LVecBase4i::LVecBase4i(LVector3i const &vector);
inline LVecBase4i::LVecBase4i(LVecBase4i const &) = default;

2773 12 operator new 0 4 3516 24 LVecBase4i::operator new 0 1 970 0
124
inline void *LVecBase4i::operator new(std::size_t size);
inline void *LVecBase4i::operator new(std::size_t size, void *ptr);

2774 15 operator delete 0 4 3516 27 LVecBase4i::operator delete 0 0 0
108
inline void LVecBase4i::operator delete(void *ptr);
inline void LVecBase4i::operator delete(void *, void *);

2775 12 validate_ptr 0 4 3516 24 LVecBase4i::validate_ptr 0 0 0
61
static inline bool LVecBase4i::validate_ptr(void const *ptr);

2776 10 operator = 0 4 3516 22 LVecBase4i::operator = 0 2 971 972 0
131
LVecBase4i &LVecBase4i::operator =(LVecBase4i const &copy) = default;
LVecBase4i &LVecBase4i::operator =(int fill_value) = default;

2777 4 zero 0 4 3516 16 LVecBase4i::zero 0 1 973 40
/**
 * Returns a zero-length vector.
 */
55
static inline LVecBase4i const &LVecBase4i::zero(void);

2778 6 unit_x 0 4 3516 18 LVecBase4i::unit_x 0 1 974 35
/**
 * Returns a unit X vector.
 */
57
static inline LVecBase4i const &LVecBase4i::unit_x(void);

2779 6 unit_y 0 4 3516 18 LVecBase4i::unit_y 0 1 975 35
/**
 * Returns a unit Y vector.
 */
57
static inline LVecBase4i const &LVecBase4i::unit_y(void);

2780 6 unit_z 0 4 3516 18 LVecBase4i::unit_z 0 1 976 35
/**
 * Returns a unit Z vector.
 */
57
static inline LVecBase4i const &LVecBase4i::unit_z(void);

2781 6 unit_w 0 4 3516 18 LVecBase4i::unit_w 0 1 977 35
/**
 * Returns a unit W vector.
 */
57
static inline LVecBase4i const &LVecBase4i::unit_w(void);

2782 10 __reduce__ 0 4 3516 22 LVecBase4i::__reduce__ 0 1 978 0
62
inline PyObject *LVecBase4i::__reduce__(PyObject *self) const;

2783 11 __getattr__ 0 4 3516 23 LVecBase4i::__getattr__ 0 1 979 0
93
inline PyObject *LVecBase4i::__getattr__(PyObject *self, std::string const &attr_name) const;

2784 11 __setattr__ 0 4 3516 23 LVecBase4i::__setattr__ 0 1 980 0
99
inline int LVecBase4i::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2785 11 operator [] 0 4 3516 23 LVecBase4i::operator [] 0 2 981 982 10
/**
 *
 */
92
inline int LVecBase4i::operator [](int i) const;
inline int &LVecBase4i::operator [](int i);

2786 4 size 0 4 3516 16 LVecBase4i::size 0 1 983 0
44
static constexpr int LVecBase4i::size(void);

2787 6 is_nan 0 4 3516 18 LVecBase4i::is_nan 0 1 984 91
/**
 * Returns true if any component of the vector is not-a-number, false
 * otherwise.
 */
43
inline bool LVecBase4i::is_nan(void) const;

2788 8 get_cell 0 4 3516 20 LVecBase4i::get_cell 0 1 985 10
/**
 *
 */
45
inline int LVecBase4i::get_cell(int i) const;

2789 8 set_cell 0 4 3516 20 LVecBase4i::set_cell 0 1 986 10
/**
 *
 */
51
inline void LVecBase4i::set_cell(int i, int value);

2790 5 get_x 0 4 3516 17 LVecBase4i::get_x 0 1 987 10
/**
 *
 */
41
inline int LVecBase4i::get_x(void) const;

2791 5 get_y 0 4 3516 17 LVecBase4i::get_y 0 1 988 10
/**
 *
 */
41
inline int LVecBase4i::get_y(void) const;

2792 5 get_z 0 4 3516 17 LVecBase4i::get_z 0 1 989 10
/**
 *
 */
41
inline int LVecBase4i::get_z(void) const;

2793 5 get_w 0 4 3516 17 LVecBase4i::get_w 0 1 990 10
/**
 *
 */
41
inline int LVecBase4i::get_w(void) const;

2794 7 get_xyz 0 4 3516 19 LVecBase4i::get_xyz 0 1 991 58
/**
 * Returns the x, y and z component of this vector
 */
50
inline LVecBase3i LVecBase4i::get_xyz(void) const;

2795 6 get_xy 0 4 3516 18 LVecBase4i::get_xy 0 1 992 55
/**
 * Returns the x and y component of this vector
 */
49
inline LVecBase2i LVecBase4i::get_xy(void) const;

2796 5 set_x 0 4 3516 17 LVecBase4i::set_x 0 1 993 10
/**
 *
 */
41
inline void LVecBase4i::set_x(int value);

2797 5 set_y 0 4 3516 17 LVecBase4i::set_y 0 1 994 10
/**
 *
 */
41
inline void LVecBase4i::set_y(int value);

2798 5 set_z 0 4 3516 17 LVecBase4i::set_z 0 1 995 10
/**
 *
 */
41
inline void LVecBase4i::set_z(int value);

2799 5 set_w 0 4 3516 17 LVecBase4i::set_w 0 1 996 10
/**
 *
 */
41
inline void LVecBase4i::set_w(int value);

2800 11 add_to_cell 0 4 3516 23 LVecBase4i::add_to_cell 0 1 997 164
// These next functions add to an existing value.  i.e.
// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
// scripting languages:

/**
 *
 */
54
inline void LVecBase4i::add_to_cell(int i, int value);

2801 5 add_x 0 4 3516 17 LVecBase4i::add_x 0 1 998 10
/**
 *
 */
41
inline void LVecBase4i::add_x(int value);

2802 5 add_y 0 4 3516 17 LVecBase4i::add_y 0 1 999 10
/**
 *
 */
41
inline void LVecBase4i::add_y(int value);

2803 5 add_z 0 4 3516 17 LVecBase4i::add_z 0 1 1000 10
/**
 *
 */
41
inline void LVecBase4i::add_z(int value);

2804 5 add_w 0 4 3516 17 LVecBase4i::add_w 0 1 1001 10
/**
 *
 */
41
inline void LVecBase4i::add_w(int value);

2805 8 get_data 0 4 3516 20 LVecBase4i::get_data 0 1 1002 161
/**
 * Returns the address of the first of the four data elements in the vector.
 * The remaining elements occupy the next positions consecutively in memory.
 */
51
inline int const *LVecBase4i::get_data(void) const;

2806 18 get_num_components 0 4 3516 30 LVecBase4i::get_num_components 0 1 1003 0
58
static constexpr int LVecBase4i::get_num_components(void);

2807 12 extract_data 0 4 3516 24 LVecBase4i::extract_data 0 0 0
46
inline void LVecBase4i::extract_data(float *);

2808 4 fill 0 4 3516 16 LVecBase4i::fill 0 1 1004 129
/**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */
45
inline void LVecBase4i::fill(int fill_value);

2809 3 set 0 4 3516 15 LVecBase4i::set 0 1 1005 10
/**
 *
 */
56
inline void LVecBase4i::set(int x, int y, int z, int w);

2810 3 dot 0 4 3516 15 LVecBase4i::dot 0 1 1006 10
/**
 *
 */
58
inline int LVecBase4i::dot(LVecBase4i const &other) const;

2811 14 length_squared 0 4 3516 26 LVecBase4i::length_squared 0 1 1007 69
/**
 * Returns the square of the vector's length, cheap and easy.
 */
50
inline int LVecBase4i::length_squared(void) const;

2812 10 operator < 0 4 3516 22 LVecBase4i::operator < 0 1 1008 0
66
inline bool LVecBase4i::operator <(LVecBase4i const &other) const;

2813 11 operator == 0 4 3516 23 LVecBase4i::operator == 0 1 1009 0
67
inline bool LVecBase4i::operator ==(LVecBase4i const &other) const;

2814 11 operator != 0 4 3516 23 LVecBase4i::operator != 0 1 1010 0
67
inline bool LVecBase4i::operator !=(LVecBase4i const &other) const;

2815 10 compare_to 0 4 3516 22 LVecBase4i::compare_to 0 1 1011 97
/**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */
65
inline int LVecBase4i::compare_to(LVecBase4i const &other) const;

2816 8 get_hash 0 4 3516 20 LVecBase4i::get_hash 0 1 1012 49
/**
 * Returns a suitable hash for phash_map.
 */
52
inline std::size_t LVecBase4i::get_hash(void) const;

2817 8 add_hash 0 4 3516 20 LVecBase4i::add_hash 0 1 1013 49
/**
 * Adds the vector into the running hash.
 */
64
inline std::size_t LVecBase4i::add_hash(std::size_t hash) const;

2818 13 generate_hash 0 4 3516 25 LVecBase4i::generate_hash 0 1 1014 59
/**
 * Adds the vector to the indicated hash generator.
 */
76
inline void LVecBase4i::generate_hash(ChecksumHashGenerator &hashgen) const;

2819 10 operator - 0 68 3516 22 LVecBase4i::operator - 0 1 1015 0
53
inline LVecBase4i LVecBase4i::operator -(void) const;

2820 10 operator + 0 4 3516 22 LVecBase4i::operator + 0 1 1016 0
72
inline LVecBase4i LVecBase4i::operator +(LVecBase4i const &other) const;

2821 10 operator - 0 4 3516 22 LVecBase4i::operator - 0 1 1017 0
72
inline LVecBase4i LVecBase4i::operator -(LVecBase4i const &other) const;

2822 10 operator * 0 4 3516 22 LVecBase4i::operator * 0 1 1018 0
59
inline LVecBase4i LVecBase4i::operator *(int scalar) const;

2823 10 operator / 0 4 3516 22 LVecBase4i::operator / 0 1 1019 0
59
inline LVecBase4i LVecBase4i::operator /(int scalar) const;

2824 11 operator += 0 4 3516 23 LVecBase4i::operator += 0 1 1020 0
61
inline void LVecBase4i::operator +=(LVecBase4i const &other);

2825 11 operator -= 0 4 3516 23 LVecBase4i::operator -= 0 1 1021 0
61
inline void LVecBase4i::operator -=(LVecBase4i const &other);

2826 11 operator *= 0 4 3516 23 LVecBase4i::operator *= 0 1 1022 0
48
inline void LVecBase4i::operator *=(int scalar);

2827 11 operator /= 0 4 3516 23 LVecBase4i::operator /= 0 1 1023 0
48
inline void LVecBase4i::operator /=(int scalar);

2828 18 componentwise_mult 0 4 3516 30 LVecBase4i::componentwise_mult 0 1 1024 10
/**
 *
 */
68
inline void LVecBase4i::componentwise_mult(LVecBase4i const &other);

2829 7 __pow__ 0 4 3516 19 LVecBase4i::__pow__ 0 1 1025 0
58
inline LVecBase4i LVecBase4i::__pow__(int exponent) const;

2830 8 __ipow__ 0 4 3516 20 LVecBase4i::__ipow__ 0 1 1026 0
68
inline PyObject *LVecBase4i::__ipow__(PyObject *self, int exponent);

2831 4 fmax 0 4 3516 16 LVecBase4i::fmax 0 1 1027 10
/**
 *
 */
66
inline LVecBase4i LVecBase4i::fmax(LVecBase4i const &other) const;

2832 4 fmin 0 4 3516 16 LVecBase4i::fmin 0 1 1028 10
/**
 *
 */
66
inline LVecBase4i LVecBase4i::fmin(LVecBase4i const &other) const;

2833 12 almost_equal 0 4 3516 24 LVecBase4i::almost_equal 0 2 1029 1030 210
/**
 * Returns true if two vectors are memberwise equal within a specified
 * tolerance.
 */

/**
 * Returns true if two vectors are memberwise equal within a default tolerance
 * based on the numeric type.
 */
152
inline bool LVecBase4i::almost_equal(LVecBase4i const &other, int threshold) const;
inline bool LVecBase4i::almost_equal(LVecBase4i const &other) const;

2834 6 output 0 4 3516 18 LVecBase4i::output 0 1 1031 10
/**
 *
 */
51
inline void LVecBase4i::output(ostream &out) const;

2835 8 __repr__ 0 4 3516 20 LVecBase4i::__repr__ 0 1 1032 0
52
inline std::string LVecBase4i::__repr__(void) const;

2836 20 write_datagram_fixed 0 4 3516 32 LVecBase4i::write_datagram_fixed 0 1 1033 332
/**
 * Writes the vector to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the vector, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */
74
inline void LVecBase4i::write_datagram_fixed(Datagram &destination) const;

2837 19 read_datagram_fixed 0 4 3516 31 LVecBase4i::read_datagram_fixed 0 1 1034 114
/**
 * Reads the vector from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */
70
inline void LVecBase4i::read_datagram_fixed(DatagramIterator &source);

2838 14 write_datagram 0 4 3516 26 LVecBase4i::write_datagram 0 1 1035 205
/**
 * Writes the vector to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the vector using the standard width
 * setting, especially when you are writing a bam file.
 */
68
inline void LVecBase4i::write_datagram(Datagram &destination) const;

2839 13 read_datagram 0 4 3516 25 LVecBase4i::read_datagram 0 1 1036 67
/**
 * Reads the vector from the Datagram using get_stdfloat().
 */
64
inline void LVecBase4i::read_datagram(DatagramIterator &source);

2840 14 get_class_type 0 4 3516 26 LVecBase4i::get_class_type 0 1 1037 0
51
static TypeHandle LVecBase4i::get_class_type(void);

2841 11 ~LVecBase4i 0 4 3516 23 LVecBase4i::~LVecBase4i 0 0 0
30
LVecBase4i::~LVecBase4i(void);

2842 19 UnalignedLVecBase4i 0 4 3518 40 UnalignedLVecBase4i::UnalignedLVecBase4i 0 5 1038 1039 1040 1041 1042 34
/**
 *
 */

/**
 *
 */

/**
 *
 */
367
inline UnalignedLVecBase4i::UnalignedLVecBase4i(void) = default;
inline UnalignedLVecBase4i::UnalignedLVecBase4i(LVecBase4i const &copy);
inline UnalignedLVecBase4i::UnalignedLVecBase4i(int fill_value);
inline UnalignedLVecBase4i::UnalignedLVecBase4i(int x, int y, int z, int w);
inline UnalignedLVecBase4i::UnalignedLVecBase4i(UnalignedLVecBase4i const &) = default;

2843 4 fill 0 4 3518 25 UnalignedLVecBase4i::fill 0 1 1043 129
/**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */
54
inline void UnalignedLVecBase4i::fill(int fill_value);

2844 3 set 0 4 3518 24 UnalignedLVecBase4i::set 0 1 1044 10
/**
 *
 */
65
inline void UnalignedLVecBase4i::set(int x, int y, int z, int w);

2845 11 operator [] 0 4 3518 32 UnalignedLVecBase4i::operator [] 0 2 1045 1046 10
/**
 *
 */
110
inline int UnalignedLVecBase4i::operator [](int i) const;
inline int &UnalignedLVecBase4i::operator [](int i);

2846 4 size 0 4 3518 25 UnalignedLVecBase4i::size 0 1 1047 0
53
static constexpr int UnalignedLVecBase4i::size(void);

2847 8 get_data 0 4 3518 29 UnalignedLVecBase4i::get_data 0 1 1048 162
/**
 * Returns the address of the first of the three data elements in the vector.
 * The remaining elements occupy the next positions consecutively in memory.
 */
60
inline int const *UnalignedLVecBase4i::get_data(void) const;

2848 18 get_num_components 0 4 3518 39 UnalignedLVecBase4i::get_num_components 0 1 1049 0
67
static constexpr int UnalignedLVecBase4i::get_num_components(void);

2849 14 get_class_type 0 4 3518 35 UnalignedLVecBase4i::get_class_type 0 1 1050 0
60
static TypeHandle UnalignedLVecBase4i::get_class_type(void);

2850 20 ~UnalignedLVecBase4i 0 4 3518 41 UnalignedLVecBase4i::~UnalignedLVecBase4i 0 0 0
48
UnalignedLVecBase4i::~UnalignedLVecBase4i(void);

2851 9 LVector4f 0 4 3520 20 LVector4f::LVector4f 0 6 1051 1052 1053 1054 1055 1056 46
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */
329
inline LVector4f::LVector4f(void) = default;
inline LVector4f::LVector4f(LVecBase4f const &copy);
inline LVector4f::LVector4f(float fill_value);
inline LVector4f::LVector4f(float x, float y, float z, float w);
inline LVector4f::LVector4f(LVecBase3f const &copy, float w);
inline LVector4f::LVector4f(LVector4f const &) = default;

2852 11 __getattr__ 0 4 3520 22 LVector4f::__getattr__ 0 1 1057 0
92
inline PyObject *LVector4f::__getattr__(PyObject *self, std::string const &attr_name) const;

2853 11 __setattr__ 0 4 3520 22 LVector4f::__setattr__ 0 1 1058 0
98
inline int LVector4f::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2854 4 zero 0 4 3520 15 LVector4f::zero 0 1 1059 40
/**
 * Returns a zero-length vector.
 */
53
static inline LVector4f const &LVector4f::zero(void);

2855 6 unit_x 0 4 3520 17 LVector4f::unit_x 0 1 1060 35
/**
 * Returns a unit X vector.
 */
55
static inline LVector4f const &LVector4f::unit_x(void);

2856 6 unit_y 0 4 3520 17 LVector4f::unit_y 0 1 1061 35
/**
 * Returns a unit Y vector.
 */
55
static inline LVector4f const &LVector4f::unit_y(void);

2857 6 unit_z 0 4 3520 17 LVector4f::unit_z 0 1 1062 35
/**
 * Returns a unit Z vector.
 */
55
static inline LVector4f const &LVector4f::unit_z(void);

2858 6 unit_w 0 4 3520 17 LVector4f::unit_w 0 1 1063 35
/**
 * Returns a unit W vector.
 */
55
static inline LVector4f const &LVector4f::unit_w(void);

2859 7 get_xyz 0 4 3520 18 LVector4f::get_xyz 0 1 1064 58
/**
 * Returns the x, y and z component of this vector
 */
48
inline LVector3f LVector4f::get_xyz(void) const;

2860 6 get_xy 0 4 3520 17 LVector4f::get_xy 0 1 1065 55
/**
 * Returns the x and y component of this vector
 */
47
inline LVector2f LVector4f::get_xy(void) const;

2861 10 operator - 0 68 3520 21 LVector4f::operator - 0 1 1066 0
51
inline LVector4f LVector4f::operator -(void) const;

2862 10 operator + 0 4 3520 21 LVector4f::operator + 0 2 1067 1068 0
141
inline LVecBase4f LVector4f::operator +(LVecBase4f const &other) const;
inline LVector4f LVector4f::operator +(LVector4f const &other) const;

2863 10 operator - 0 4 3520 21 LVector4f::operator - 0 2 1069 1070 0
141
inline LVecBase4f LVector4f::operator -(LVecBase4f const &other) const;
inline LVector4f LVector4f::operator -(LVector4f const &other) const;

2864 10 operator * 0 4 3520 21 LVector4f::operator * 0 1 1071 0
59
inline LVector4f LVector4f::operator *(float scalar) const;

2865 10 operator / 0 4 3520 21 LVector4f::operator / 0 1 1072 0
59
inline LVector4f LVector4f::operator /(float scalar) const;

2866 10 normalized 0 4 3520 21 LVector4f::normalized 0 1 1073 160
/**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */
51
inline LVector4f LVector4f::normalized(void) const;

2867 7 project 0 4 3520 18 LVector4f::project 0 1 1074 152
/**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */
66
inline LVector4f LVector4f::project(LVecBase4f const &onto) const;

2868 8 __repr__ 0 4 3520 19 LVector4f::__repr__ 0 1 1075 0
51
inline std::string LVector4f::__repr__(void) const;

2869 14 get_class_type 0 4 3520 25 LVector4f::get_class_type 0 1 1076 0
50
static TypeHandle LVector4f::get_class_type(void);

2870 10 ~LVector4f 0 4 3520 21 LVector4f::~LVector4f 0 0 0
28
LVector4f::~LVector4f(void);

2871 9 LVector4d 0 4 3521 20 LVector4d::LVector4d 0 6 1077 1078 1079 1080 1081 1082 46
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */
335
inline LVector4d::LVector4d(void) = default;
inline LVector4d::LVector4d(LVecBase4d const &copy);
inline LVector4d::LVector4d(double fill_value);
inline LVector4d::LVector4d(double x, double y, double z, double w);
inline LVector4d::LVector4d(LVecBase3d const &copy, double w);
inline LVector4d::LVector4d(LVector4d const &) = default;

2872 11 __getattr__ 0 4 3521 22 LVector4d::__getattr__ 0 1 1083 0
92
inline PyObject *LVector4d::__getattr__(PyObject *self, std::string const &attr_name) const;

2873 11 __setattr__ 0 4 3521 22 LVector4d::__setattr__ 0 1 1084 0
98
inline int LVector4d::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2874 4 zero 0 4 3521 15 LVector4d::zero 0 1 1085 40
/**
 * Returns a zero-length vector.
 */
53
static inline LVector4d const &LVector4d::zero(void);

2875 6 unit_x 0 4 3521 17 LVector4d::unit_x 0 1 1086 35
/**
 * Returns a unit X vector.
 */
55
static inline LVector4d const &LVector4d::unit_x(void);

2876 6 unit_y 0 4 3521 17 LVector4d::unit_y 0 1 1087 35
/**
 * Returns a unit Y vector.
 */
55
static inline LVector4d const &LVector4d::unit_y(void);

2877 6 unit_z 0 4 3521 17 LVector4d::unit_z 0 1 1088 35
/**
 * Returns a unit Z vector.
 */
55
static inline LVector4d const &LVector4d::unit_z(void);

2878 6 unit_w 0 4 3521 17 LVector4d::unit_w 0 1 1089 35
/**
 * Returns a unit W vector.
 */
55
static inline LVector4d const &LVector4d::unit_w(void);

2879 7 get_xyz 0 4 3521 18 LVector4d::get_xyz 0 1 1090 58
/**
 * Returns the x, y and z component of this vector
 */
48
inline LVector3d LVector4d::get_xyz(void) const;

2880 6 get_xy 0 4 3521 17 LVector4d::get_xy 0 1 1091 55
/**
 * Returns the x and y component of this vector
 */
47
inline LVector2d LVector4d::get_xy(void) const;

2881 10 operator - 0 68 3521 21 LVector4d::operator - 0 1 1092 0
51
inline LVector4d LVector4d::operator -(void) const;

2882 10 operator + 0 4 3521 21 LVector4d::operator + 0 2 1093 1094 0
141
inline LVecBase4d LVector4d::operator +(LVecBase4d const &other) const;
inline LVector4d LVector4d::operator +(LVector4d const &other) const;

2883 10 operator - 0 4 3521 21 LVector4d::operator - 0 2 1095 1096 0
141
inline LVecBase4d LVector4d::operator -(LVecBase4d const &other) const;
inline LVector4d LVector4d::operator -(LVector4d const &other) const;

2884 10 operator * 0 4 3521 21 LVector4d::operator * 0 1 1097 0
60
inline LVector4d LVector4d::operator *(double scalar) const;

2885 10 operator / 0 4 3521 21 LVector4d::operator / 0 1 1098 0
60
inline LVector4d LVector4d::operator /(double scalar) const;

2886 10 normalized 0 4 3521 21 LVector4d::normalized 0 1 1099 160
/**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */
51
inline LVector4d LVector4d::normalized(void) const;

2887 7 project 0 4 3521 18 LVector4d::project 0 1 1100 152
/**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */
66
inline LVector4d LVector4d::project(LVecBase4d const &onto) const;

2888 8 __repr__ 0 4 3521 19 LVector4d::__repr__ 0 1 1101 0
51
inline std::string LVector4d::__repr__(void) const;

2889 14 get_class_type 0 4 3521 25 LVector4d::get_class_type 0 1 1102 0
50
static TypeHandle LVector4d::get_class_type(void);

2890 10 ~LVector4d 0 4 3521 21 LVector4d::~LVector4d 0 0 0
28
LVector4d::~LVector4d(void);

2891 9 LVector4i 0 4 3522 20 LVector4i::LVector4i 0 6 1103 1104 1105 1106 1107 1108 46
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */
317
inline LVector4i::LVector4i(void) = default;
inline LVector4i::LVector4i(LVecBase4i const &copy);
inline LVector4i::LVector4i(int fill_value);
inline LVector4i::LVector4i(int x, int y, int z, int w);
inline LVector4i::LVector4i(LVecBase3i const &copy, int w);
inline LVector4i::LVector4i(LVector4i const &) = default;

2892 11 __getattr__ 0 4 3522 22 LVector4i::__getattr__ 0 1 1109 0
92
inline PyObject *LVector4i::__getattr__(PyObject *self, std::string const &attr_name) const;

2893 11 __setattr__ 0 4 3522 22 LVector4i::__setattr__ 0 1 1110 0
98
inline int LVector4i::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2894 4 zero 0 4 3522 15 LVector4i::zero 0 1 1111 40
/**
 * Returns a zero-length vector.
 */
53
static inline LVector4i const &LVector4i::zero(void);

2895 6 unit_x 0 4 3522 17 LVector4i::unit_x 0 1 1112 35
/**
 * Returns a unit X vector.
 */
55
static inline LVector4i const &LVector4i::unit_x(void);

2896 6 unit_y 0 4 3522 17 LVector4i::unit_y 0 1 1113 35
/**
 * Returns a unit Y vector.
 */
55
static inline LVector4i const &LVector4i::unit_y(void);

2897 6 unit_z 0 4 3522 17 LVector4i::unit_z 0 1 1114 35
/**
 * Returns a unit Z vector.
 */
55
static inline LVector4i const &LVector4i::unit_z(void);

2898 6 unit_w 0 4 3522 17 LVector4i::unit_w 0 1 1115 35
/**
 * Returns a unit W vector.
 */
55
static inline LVector4i const &LVector4i::unit_w(void);

2899 7 get_xyz 0 4 3522 18 LVector4i::get_xyz 0 1 1116 58
/**
 * Returns the x, y and z component of this vector
 */
48
inline LVector3i LVector4i::get_xyz(void) const;

2900 6 get_xy 0 4 3522 17 LVector4i::get_xy 0 1 1117 55
/**
 * Returns the x and y component of this vector
 */
47
inline LVector2i LVector4i::get_xy(void) const;

2901 10 operator - 0 68 3522 21 LVector4i::operator - 0 1 1118 0
51
inline LVector4i LVector4i::operator -(void) const;

2902 10 operator + 0 4 3522 21 LVector4i::operator + 0 2 1119 1120 0
141
inline LVecBase4i LVector4i::operator +(LVecBase4i const &other) const;
inline LVector4i LVector4i::operator +(LVector4i const &other) const;

2903 10 operator - 0 4 3522 21 LVector4i::operator - 0 2 1121 1122 0
141
inline LVecBase4i LVector4i::operator -(LVecBase4i const &other) const;
inline LVector4i LVector4i::operator -(LVector4i const &other) const;

2904 10 operator * 0 4 3522 21 LVector4i::operator * 0 1 1123 0
57
inline LVector4i LVector4i::operator *(int scalar) const;

2905 10 operator / 0 4 3522 21 LVector4i::operator / 0 1 1124 0
57
inline LVector4i LVector4i::operator /(int scalar) const;

2906 8 __repr__ 0 4 3522 19 LVector4i::__repr__ 0 1 1125 0
51
inline std::string LVector4i::__repr__(void) const;

2907 14 get_class_type 0 4 3522 25 LVector4i::get_class_type 0 1 1126 0
50
static TypeHandle LVector4i::get_class_type(void);

2908 10 ~LVector4i 0 4 3522 21 LVector4i::~LVector4i 0 0 0
28
LVector4i::~LVector4i(void);

2909 8 LPoint4f 0 4 3523 18 LPoint4f::LPoint4f 0 6 1127 1128 1129 1130 1131 1132 46
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */
316
inline LPoint4f::LPoint4f(void) = default;
inline LPoint4f::LPoint4f(LVecBase4f const &copy);
inline LPoint4f::LPoint4f(float fill_value);
inline LPoint4f::LPoint4f(float x, float y, float z, float w);
inline LPoint4f::LPoint4f(LVecBase3f const &copy, float w);
inline LPoint4f::LPoint4f(LPoint4f const &) = default;

2910 11 __getattr__ 0 4 3523 21 LPoint4f::__getattr__ 0 1 1133 0
91
inline PyObject *LPoint4f::__getattr__(PyObject *self, std::string const &attr_name) const;

2911 11 __setattr__ 0 4 3523 21 LPoint4f::__setattr__ 0 1 1134 0
97
inline int LPoint4f::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2912 4 zero 0 4 3523 14 LPoint4f::zero 0 1 1135 39
/**
 * Returns a zero-length point.
 */
51
static inline LPoint4f const &LPoint4f::zero(void);

2913 6 unit_x 0 4 3523 16 LPoint4f::unit_x 0 1 1136 34
/**
 * Returns a unit X point.
 */
53
static inline LPoint4f const &LPoint4f::unit_x(void);

2914 6 unit_y 0 4 3523 16 LPoint4f::unit_y 0 1 1137 34
/**
 * Returns a unit Y point.
 */
53
static inline LPoint4f const &LPoint4f::unit_y(void);

2915 6 unit_z 0 4 3523 16 LPoint4f::unit_z 0 1 1138 34
/**
 * Returns a unit Z point.
 */
53
static inline LPoint4f const &LPoint4f::unit_z(void);

2916 6 unit_w 0 4 3523 16 LPoint4f::unit_w 0 1 1139 34
/**
 * Returns a unit W point.
 */
53
static inline LPoint4f const &LPoint4f::unit_w(void);

2917 7 get_xyz 0 4 3523 17 LPoint4f::get_xyz 0 1 1140 58
/**
 * Returns the x, y and z component of this vector
 */
46
inline LPoint3f LPoint4f::get_xyz(void) const;

2918 6 get_xy 0 4 3523 16 LPoint4f::get_xy 0 1 1141 55
/**
 * Returns the x and y component of this vector
 */
45
inline LPoint2f LPoint4f::get_xy(void) const;

2919 10 operator - 0 68 3523 20 LPoint4f::operator - 0 1 1142 0
49
inline LPoint4f LPoint4f::operator -(void) const;

2920 10 operator + 0 4 3523 20 LPoint4f::operator + 0 2 1143 1144 0
138
inline LVecBase4f LPoint4f::operator +(LVecBase4f const &other) const;
inline LPoint4f LPoint4f::operator +(LVector4f const &other) const;

2921 10 operator - 0 4 3523 20 LPoint4f::operator - 0 3 1145 1146 1147 0
206
inline LVecBase4f LPoint4f::operator -(LVecBase4f const &other) const;
inline LVector4f LPoint4f::operator -(LPoint4f const &other) const;
inline LPoint4f LPoint4f::operator -(LVector4f const &other) const;

2922 10 operator * 0 4 3523 20 LPoint4f::operator * 0 1 1148 0
57
inline LPoint4f LPoint4f::operator *(float scalar) const;

2923 10 operator / 0 4 3523 20 LPoint4f::operator / 0 1 1149 0
57
inline LPoint4f LPoint4f::operator /(float scalar) const;

2924 10 normalized 0 4 3523 20 LPoint4f::normalized 0 1 1150 160
/**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */
49
inline LPoint4f LPoint4f::normalized(void) const;

2925 7 project 0 4 3523 17 LPoint4f::project 0 1 1151 152
/**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */
64
inline LPoint4f LPoint4f::project(LVecBase4f const &onto) const;

2926 8 __repr__ 0 4 3523 18 LPoint4f::__repr__ 0 1 1152 0
50
inline std::string LPoint4f::__repr__(void) const;

2927 14 get_class_type 0 4 3523 24 LPoint4f::get_class_type 0 1 1153 0
49
static TypeHandle LPoint4f::get_class_type(void);

2928 9 ~LPoint4f 0 4 3523 19 LPoint4f::~LPoint4f 0 0 0
26
LPoint4f::~LPoint4f(void);

2929 8 LPoint4d 0 4 3524 18 LPoint4d::LPoint4d 0 6 1154 1155 1156 1157 1158 1159 46
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */
322
inline LPoint4d::LPoint4d(void) = default;
inline LPoint4d::LPoint4d(LVecBase4d const &copy);
inline LPoint4d::LPoint4d(double fill_value);
inline LPoint4d::LPoint4d(double x, double y, double z, double w);
inline LPoint4d::LPoint4d(LVecBase3d const &copy, double w);
inline LPoint4d::LPoint4d(LPoint4d const &) = default;

2930 11 __getattr__ 0 4 3524 21 LPoint4d::__getattr__ 0 1 1160 0
91
inline PyObject *LPoint4d::__getattr__(PyObject *self, std::string const &attr_name) const;

2931 11 __setattr__ 0 4 3524 21 LPoint4d::__setattr__ 0 1 1161 0
97
inline int LPoint4d::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2932 4 zero 0 4 3524 14 LPoint4d::zero 0 1 1162 39
/**
 * Returns a zero-length point.
 */
51
static inline LPoint4d const &LPoint4d::zero(void);

2933 6 unit_x 0 4 3524 16 LPoint4d::unit_x 0 1 1163 34
/**
 * Returns a unit X point.
 */
53
static inline LPoint4d const &LPoint4d::unit_x(void);

2934 6 unit_y 0 4 3524 16 LPoint4d::unit_y 0 1 1164 34
/**
 * Returns a unit Y point.
 */
53
static inline LPoint4d const &LPoint4d::unit_y(void);

2935 6 unit_z 0 4 3524 16 LPoint4d::unit_z 0 1 1165 34
/**
 * Returns a unit Z point.
 */
53
static inline LPoint4d const &LPoint4d::unit_z(void);

2936 6 unit_w 0 4 3524 16 LPoint4d::unit_w 0 1 1166 34
/**
 * Returns a unit W point.
 */
53
static inline LPoint4d const &LPoint4d::unit_w(void);

2937 7 get_xyz 0 4 3524 17 LPoint4d::get_xyz 0 1 1167 58
/**
 * Returns the x, y and z component of this vector
 */
46
inline LPoint3d LPoint4d::get_xyz(void) const;

2938 6 get_xy 0 4 3524 16 LPoint4d::get_xy 0 1 1168 55
/**
 * Returns the x and y component of this vector
 */
45
inline LPoint2d LPoint4d::get_xy(void) const;

2939 10 operator - 0 68 3524 20 LPoint4d::operator - 0 1 1169 0
49
inline LPoint4d LPoint4d::operator -(void) const;

2940 10 operator + 0 4 3524 20 LPoint4d::operator + 0 2 1170 1171 0
138
inline LVecBase4d LPoint4d::operator +(LVecBase4d const &other) const;
inline LPoint4d LPoint4d::operator +(LVector4d const &other) const;

2941 10 operator - 0 4 3524 20 LPoint4d::operator - 0 3 1172 1173 1174 0
206
inline LVecBase4d LPoint4d::operator -(LVecBase4d const &other) const;
inline LVector4d LPoint4d::operator -(LPoint4d const &other) const;
inline LPoint4d LPoint4d::operator -(LVector4d const &other) const;

2942 10 operator * 0 4 3524 20 LPoint4d::operator * 0 1 1175 0
58
inline LPoint4d LPoint4d::operator *(double scalar) const;

2943 10 operator / 0 4 3524 20 LPoint4d::operator / 0 1 1176 0
58
inline LPoint4d LPoint4d::operator /(double scalar) const;

2944 10 normalized 0 4 3524 20 LPoint4d::normalized 0 1 1177 160
/**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */
49
inline LPoint4d LPoint4d::normalized(void) const;

2945 7 project 0 4 3524 17 LPoint4d::project 0 1 1178 152
/**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */
64
inline LPoint4d LPoint4d::project(LVecBase4d const &onto) const;

2946 8 __repr__ 0 4 3524 18 LPoint4d::__repr__ 0 1 1179 0
50
inline std::string LPoint4d::__repr__(void) const;

2947 14 get_class_type 0 4 3524 24 LPoint4d::get_class_type 0 1 1180 0
49
static TypeHandle LPoint4d::get_class_type(void);

2948 9 ~LPoint4d 0 4 3524 19 LPoint4d::~LPoint4d 0 0 0
26
LPoint4d::~LPoint4d(void);

2949 8 LPoint4i 0 4 3525 18 LPoint4i::LPoint4i 0 6 1181 1182 1183 1184 1185 1186 46
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */
304
inline LPoint4i::LPoint4i(void) = default;
inline LPoint4i::LPoint4i(LVecBase4i const &copy);
inline LPoint4i::LPoint4i(int fill_value);
inline LPoint4i::LPoint4i(int x, int y, int z, int w);
inline LPoint4i::LPoint4i(LVecBase3i const &copy, int w);
inline LPoint4i::LPoint4i(LPoint4i const &) = default;

2950 11 __getattr__ 0 4 3525 21 LPoint4i::__getattr__ 0 1 1187 0
91
inline PyObject *LPoint4i::__getattr__(PyObject *self, std::string const &attr_name) const;

2951 11 __setattr__ 0 4 3525 21 LPoint4i::__setattr__ 0 1 1188 0
97
inline int LPoint4i::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2952 4 zero 0 4 3525 14 LPoint4i::zero 0 1 1189 39
/**
 * Returns a zero-length point.
 */
51
static inline LPoint4i const &LPoint4i::zero(void);

2953 6 unit_x 0 4 3525 16 LPoint4i::unit_x 0 1 1190 34
/**
 * Returns a unit X point.
 */
53
static inline LPoint4i const &LPoint4i::unit_x(void);

2954 6 unit_y 0 4 3525 16 LPoint4i::unit_y 0 1 1191 34
/**
 * Returns a unit Y point.
 */
53
static inline LPoint4i const &LPoint4i::unit_y(void);

2955 6 unit_z 0 4 3525 16 LPoint4i::unit_z 0 1 1192 34
/**
 * Returns a unit Z point.
 */
53
static inline LPoint4i const &LPoint4i::unit_z(void);

2956 6 unit_w 0 4 3525 16 LPoint4i::unit_w 0 1 1193 34
/**
 * Returns a unit W point.
 */
53
static inline LPoint4i const &LPoint4i::unit_w(void);

2957 7 get_xyz 0 4 3525 17 LPoint4i::get_xyz 0 1 1194 58
/**
 * Returns the x, y and z component of this vector
 */
46
inline LPoint3i LPoint4i::get_xyz(void) const;

2958 6 get_xy 0 4 3525 16 LPoint4i::get_xy 0 1 1195 55
/**
 * Returns the x and y component of this vector
 */
45
inline LPoint2i LPoint4i::get_xy(void) const;

2959 10 operator - 0 68 3525 20 LPoint4i::operator - 0 1 1196 0
49
inline LPoint4i LPoint4i::operator -(void) const;

2960 10 operator + 0 4 3525 20 LPoint4i::operator + 0 2 1197 1198 0
138
inline LVecBase4i LPoint4i::operator +(LVecBase4i const &other) const;
inline LPoint4i LPoint4i::operator +(LVector4i const &other) const;

2961 10 operator - 0 4 3525 20 LPoint4i::operator - 0 3 1199 1200 1201 0
206
inline LVecBase4i LPoint4i::operator -(LVecBase4i const &other) const;
inline LVector4i LPoint4i::operator -(LPoint4i const &other) const;
inline LPoint4i LPoint4i::operator -(LVector4i const &other) const;

2962 10 operator * 0 4 3525 20 LPoint4i::operator * 0 1 1202 0
55
inline LPoint4i LPoint4i::operator *(int scalar) const;

2963 10 operator / 0 4 3525 20 LPoint4i::operator / 0 1 1203 0
55
inline LPoint4i LPoint4i::operator /(int scalar) const;

2964 8 __repr__ 0 4 3525 18 LPoint4i::__repr__ 0 1 1204 0
50
inline std::string LPoint4i::__repr__(void) const;

2965 14 get_class_type 0 4 3525 24 LPoint4i::get_class_type 0 1 1205 0
49
static TypeHandle LPoint4i::get_class_type(void);

2966 9 ~LPoint4i 0 4 3525 19 LPoint4i::~LPoint4i 0 0 0
26
LPoint4i::~LPoint4i(void);

2967 11 operator [] 0 4 3528 27 LMatrix3f::Row::operator [] 0 2 1307 1308 10
/**
 *
 */
104
inline float LMatrix3f::Row::operator [](int i) const;
inline float &LMatrix3f::Row::operator [](int i);

2968 4 size 0 4 3528 20 LMatrix3f::Row::size 0 1 1309 58
/**
 * Returns 3: the number of columns of a LMatrix3.
 */
45
static inline int LMatrix3f::Row::size(void);

2969 3 Row 0 4 3528 19 LMatrix3f::Row::Row 0 1 1306 60
/**
 * Defines a row-level index accessor to the matrix.
 */
61
inline LMatrix3f::Row::Row(LMatrix3f::Row const &) = default;

2970 4 ~Row 0 4 3528 20 LMatrix3f::Row::~Row 0 0 0
27
LMatrix3f::Row::~Row(void);

2971 11 operator [] 0 4 3529 28 LMatrix3f::CRow::operator [] 0 1 1311 0
55
inline float LMatrix3f::CRow::operator [](int i) const;

2972 4 size 0 4 3529 21 LMatrix3f::CRow::size 0 1 1312 58
/**
 * Returns 3: the number of columns of a LMatrix3.
 */
46
static inline int LMatrix3f::CRow::size(void);

2973 4 CRow 0 4 3529 21 LMatrix3f::CRow::CRow 0 1 1310 63
/**
 * Defines a row-level constant accessor to the matrix.
 */
64
inline LMatrix3f::CRow::CRow(LMatrix3f::CRow const &) = default;

2974 5 ~CRow 0 4 3529 22 LMatrix3f::CRow::~CRow 0 0 0
29
LMatrix3f::CRow::~CRow(void);

2975 9 LMatrix3f 0 4 3526 20 LMatrix3f::LMatrix3f 0 3 1206 1207 1208 34
/**
 *
 */

/**
 *
 */

/**
 *
 */
215
inline LMatrix3f::LMatrix3f(void);
inline LMatrix3f::LMatrix3f(LMatrix3f const &other);
inline LMatrix3f::LMatrix3f(float e00, float e01, float e02, float e10, float e11, float e12, float e20, float e21, float e22);

2976 10 operator = 0 4 3526 21 LMatrix3f::operator = 0 2 1209 1210 22
/**
 *
 */

/**
 *
 */
123
inline LMatrix3f &LMatrix3f::operator =(LMatrix3f const &other);
inline LMatrix3f &LMatrix3f::operator =(float fill_value);

2977 12 operator new 0 4 3526 23 LMatrix3f::operator new 0 1 1211 0
122
inline void *LMatrix3f::operator new(std::size_t size);
inline void *LMatrix3f::operator new(std::size_t size, void *ptr);

2978 15 operator delete 0 4 3526 26 LMatrix3f::operator delete 0 0 0
106
inline void LMatrix3f::operator delete(void *ptr);
inline void LMatrix3f::operator delete(void *, void *);

2979 12 validate_ptr 0 4 3526 23 LMatrix3f::validate_ptr 0 0 0
60
static inline bool LMatrix3f::validate_ptr(void const *ptr);

2980 10 __reduce__ 0 4 3526 21 LMatrix3f::__reduce__ 0 1 1212 0
61
inline PyObject *LMatrix3f::__reduce__(PyObject *self) const;

2981 4 fill 0 4 3526 15 LMatrix3f::fill 0 1 1213 157
/**
 * Sets each element of the matrix to the indicated fill_value.  This is of
 * questionable value, but is sometimes useful when initializing to zero.
 */
39
void LMatrix3f::fill(float fill_value);

2982 3 set 0 4 3526 14 LMatrix3f::set 0 1 1214 10
/**
 *
 */
126
inline void LMatrix3f::set(float e00, float e01, float e02, float e10, float e11, float e12, float e20, float e21, float e22);

2983 11 operator [] 0 4 3526 22 LMatrix3f::operator [] 0 2 1215 1216 0
112
inline LMatrix3f::CRow LMatrix3f::operator [](int i) const;
inline LMatrix3f::Row LMatrix3f::operator [](int i);

2984 4 size 0 4 3526 15 LMatrix3f::size 0 1 1217 55
/**
 * Returns 3: the number of rows of a LMatrix3.
 */
40
static inline int LMatrix3f::size(void);

2985 7 set_row 0 4 3526 18 LMatrix3f::set_row 0 2 1218 1219 193
/**
 * Replaces the indicated row of the matrix from a three-component vector.
 */

/**
 * Replaces the indicated row of the matrix from a two-component vector,
 * ignoring the last column.
 */
123
inline void LMatrix3f::set_row(int row, LVecBase3f const &v);
inline void LMatrix3f::set_row(int row, LVecBase2f const &v);

2986 7 set_col 0 4 3526 18 LMatrix3f::set_col 0 2 1220 1221 196
/**
 * Replaces the indicated column of the matrix from a three-component vector.
 */

/**
 * Replaces the indicated column of the matrix from a two-component vector,
 * ignoring the last row.
 */
123
inline void LMatrix3f::set_col(int col, LVecBase3f const &v);
inline void LMatrix3f::set_col(int col, LVecBase2f const &v);

2987 7 get_row 0 4 3526 18 LMatrix3f::get_row 0 2 1222 1223 192
// these versions inline better

/**
 * Returns the indicated row of the matrix as a three-component vector.
 */

/**
 * Stores the indicated row of the matrix as a three-component vector.
 */
123
inline LVecBase3f LMatrix3f::get_row(int row) const;
inline void LMatrix3f::get_row(LVecBase3f &result_vec, int row) const;

2988 7 get_col 0 4 3526 18 LMatrix3f::get_col 0 1 1224 82
/**
 * Returns the indicated column of the matrix as a three-component vector.
 */
52
inline LVecBase3f LMatrix3f::get_col(int col) const;

2989 0 0 0 0 0 0 0 0
0

2990 0 0 0 0 0 0 0 0
0

2991 8 get_row2 0 4 3526 19 LMatrix3f::get_row2 0 1 1225 106
/**
 * Returns the indicated row of the matrix as a two-component vector, ignoring
 * the last column.
 */
53
inline LVecBase2f LMatrix3f::get_row2(int row) const;

2992 8 get_col2 0 4 3526 19 LMatrix3f::get_col2 0 1 1226 106
/**
 * Returns the indicated column of the matrix as a two-component vector,
 * ignoring the last row.
 */
53
inline LVecBase2f LMatrix3f::get_col2(int col) const;

2993 11 operator () 0 4 3526 22 LMatrix3f::operator () 0 2 1227 1228 10
/**
 *
 */
116
inline float &LMatrix3f::operator ()(int row, int col);
inline float LMatrix3f::operator ()(int row, int col) const;

2994 6 is_nan 0 4 3526 17 LMatrix3f::is_nan 0 1 1229 91
/**
 * Returns true if any component of the matrix is not-a-number, false
 * otherwise.
 */
42
inline bool LMatrix3f::is_nan(void) const;

2995 11 is_identity 0 4 3526 22 LMatrix3f::is_identity 0 1 1230 93
/**
 * Returns true if this is (close enough to) the identity matrix, false
 * otherwise.
 */
47
inline bool LMatrix3f::is_identity(void) const;

2996 8 get_cell 0 4 3526 19 LMatrix3f::get_cell 0 1 1231 54
/**
 * Returns a particular element of the matrix.
 */
57
inline float LMatrix3f::get_cell(int row, int col) const;

2997 8 set_cell 0 4 3526 19 LMatrix3f::set_cell 0 1 1232 54
/**
 * Changes a particular element of the matrix.
 */
63
inline void LMatrix3f::set_cell(int row, int col, float value);

2998 8 get_data 0 4 3526 19 LMatrix3f::get_data 0 1 1233 162
/**
 * Returns the address of the first of the nine data elements in the matrix.
 * The remaining elements occupy the next eight positions in row-major order.
 */
52
inline float const *LMatrix3f::get_data(void) const;

2999 18 get_num_components 0 4 3526 29 LMatrix3f::get_num_components 0 1 1234 62
/**
 * Returns the number of elements in the matrix, nine.
 */
53
inline int LMatrix3f::get_num_components(void) const;

3000 10 operator < 0 4 3526 21 LMatrix3f::operator < 0 1 1235 0
64
inline bool LMatrix3f::operator <(LMatrix3f const &other) const;

3001 11 operator == 0 4 3526 22 LMatrix3f::operator == 0 1 1236 0
65
inline bool LMatrix3f::operator ==(LMatrix3f const &other) const;

3002 11 operator != 0 4 3526 22 LMatrix3f::operator != 0 1 1237 0
65
inline bool LMatrix3f::operator !=(LMatrix3f const &other) const;

3003 10 compare_to 0 4 3526 21 LMatrix3f::compare_to 0 2 1238 1239 333
/**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */

/**
 * Sorts matrices lexicographically, componentwise.  Returns a number less
 * than 0 if this matrix sorts before the other one, greater than zero if it
 * sorts after, 0 if they are equivalent (within the indicated tolerance).
 */
137
inline int LMatrix3f::compare_to(LMatrix3f const &other) const;
int LMatrix3f::compare_to(LMatrix3f const &other, float threshold) const;

3004 8 get_hash 0 4 3526 19 LMatrix3f::get_hash 0 2 1240 1241 100
/**
 * Returns a suitable hash for phash_map.
 */

/**
 * Returns a suitable hash for phash_map.
 */
114
inline std::size_t LMatrix3f::get_hash(void) const;
inline std::size_t LMatrix3f::get_hash(float threshold) const;

3005 8 add_hash 0 4 3526 19 LMatrix3f::add_hash 0 2 1242 1243 100
/**
 * Adds the vector into the running hash.
 */

/**
 * Adds the vector into the running hash.
 */
144
inline std::size_t LMatrix3f::add_hash(std::size_t hash) const;
inline std::size_t LMatrix3f::add_hash(std::size_t hash, float threshold) const;

3006 5 xform 0 4 3526 16 LMatrix3f::xform 0 1 1244 52
/**
 * 3-component vector or point times matrix.
 */
62
inline LVecBase3f LMatrix3f::xform(LVecBase3f const &v) const;

3007 11 xform_point 0 4 3526 22 LMatrix3f::xform_point 0 1 1245 162
/**
 * The matrix transforms a 2-component point (including translation component)
 * and returns the result.  This assumes the matrix is an affine transform.
 */
68
inline LVecBase2f LMatrix3f::xform_point(LVecBase2f const &v) const;

3008 9 xform_vec 0 4 3526 20 LMatrix3f::xform_vec 0 2 1246 1247 357
/**
 * The matrix transforms a 2-component vector (without translation component)
 * and returns the result.  This assumes the matrix is an affine transform.
 */

/**
 * The matrix transforms a 3-component vector and returns the result.  This
 * assumes the matrix is an orthonormal transform.
 *
 * In practice, this is the same computation as xform().
 */
133
inline LVecBase2f LMatrix3f::xform_vec(LVecBase2f const &v) const;
inline LVecBase3f LMatrix3f::xform_vec(LVecBase3f const &v) const;

3009 17 xform_vec_general 0 4 3526 28 LMatrix3f::xform_vec_general 0 1 1248 142
/**
 * The matrix transforms a 3-component vector (without translation component)
 * and returns the result, as a fully general operation.
 */
74
inline LVecBase3f LMatrix3f::xform_vec_general(LVecBase3f const &v) const;

3010 14 xform_in_place 0 4 3526 25 LMatrix3f::xform_in_place 0 1 1249 52
/**
 * 3-component vector or point times matrix.
 */
59
inline void LMatrix3f::xform_in_place(LVecBase3f &v) const;

3011 20 xform_point_in_place 0 4 3526 31 LMatrix3f::xform_point_in_place 0 1 1250 139
/**
 * The matrix transforms a 2-component point (including translation
 * component).  This assumes the matrix is an affine transform.
 */
65
inline void LMatrix3f::xform_point_in_place(LVecBase2f &v) const;

3012 18 xform_vec_in_place 0 4 3526 29 LMatrix3f::xform_vec_in_place 0 2 1251 1252 310
/**
 * The matrix transforms a 2-component vector (without translation component).
 * This assumes the matrix is an affine transform.
 */

/**
 * The matrix transforms a 3-component vector.  This assumes the matrix is an
 * orthonormal transform.
 *
 * In practice, this is the same computation as xform().
 */
127
inline void LMatrix3f::xform_vec_in_place(LVecBase2f &v) const;
inline void LMatrix3f::xform_vec_in_place(LVecBase3f &v) const;

3013 26 xform_vec_general_in_place 0 4 3526 37 LMatrix3f::xform_vec_general_in_place 0 1 1253 119
/**
 * The matrix transforms a 3-component vector (without translation component),
 * as a fully general operation.
 */
71
inline void LMatrix3f::xform_vec_general_in_place(LVecBase3f &v) const;

3014 8 multiply 0 4 3526 19 LMatrix3f::multiply 0 1 1254 52
// this = other1 * other2

// this = other1 * other2
82
inline void LMatrix3f::multiply(LMatrix3f const &other1, LMatrix3f const &other2);

3015 10 operator * 0 4 3526 21 LMatrix3f::operator * 0 2 1255 1256 0
129
inline LMatrix3f LMatrix3f::operator *(LMatrix3f const &other) const;
inline LMatrix3f LMatrix3f::operator *(float scalar) const;

3016 10 operator / 0 4 3526 21 LMatrix3f::operator / 0 1 1257 0
59
inline LMatrix3f LMatrix3f::operator /(float scalar) const;

3017 11 operator += 0 4 3526 22 LMatrix3f::operator += 0 1 1258 63
/**
 * Performs a memberwise addition between two matrices.
 */
65
inline LMatrix3f &LMatrix3f::operator +=(LMatrix3f const &other);

3018 11 operator -= 0 4 3526 22 LMatrix3f::operator -= 0 1 1259 66
/**
 * Performs a memberwise subtraction between two matrices.
 */
65
inline LMatrix3f &LMatrix3f::operator -=(LMatrix3f const &other);

3019 11 operator *= 0 4 3526 22 LMatrix3f::operator *= 0 2 1260 1261 51
/**
 *
 */

/**
 * Performs a memberwise scale.
 */
121
inline LMatrix3f &LMatrix3f::operator *=(LMatrix3f const &other);
inline LMatrix3f &LMatrix3f::operator *=(float scalar);

3020 11 operator /= 0 4 3526 22 LMatrix3f::operator /= 0 1 1262 39
/**
 * Performs a memberwise scale.
 */
55
inline LMatrix3f &LMatrix3f::operator /=(float scalar);

3021 18 componentwise_mult 0 4 3526 29 LMatrix3f::componentwise_mult 0 1 1263 10
/**
 *
 */
66
inline void LMatrix3f::componentwise_mult(LMatrix3f const &other);

3022 11 determinant 0 4 3526 22 LMatrix3f::determinant 0 1 1264 49
/**
 * Returns the determinant of the matrix.
 */
48
inline float LMatrix3f::determinant(void) const;

3023 14 transpose_from 0 4 3526 25 LMatrix3f::transpose_from 0 1 1265 10
/**
 *
 */
62
inline void LMatrix3f::transpose_from(LMatrix3f const &other);

3024 18 transpose_in_place 0 4 3526 29 LMatrix3f::transpose_in_place 0 1 1266 10
/**
 *
 */
48
inline void LMatrix3f::transpose_in_place(void);

3025 11 invert_from 0 4 3526 22 LMatrix3f::invert_from 0 1 1267 463
/**
 * Computes the inverse of the other matrix, and stores the result in this
 * matrix.  This is a fully general operation and makes no assumptions about
 * the type of transform represented by the matrix.
 *
 * The other matrix must be a different object than this matrix.  However, if
 * you need to invert a matrix in place, see invert_in_place.
 *
 * The return value is true if the matrix was successfully inverted, false if
 * there was a singularity.
 */
59
inline bool LMatrix3f::invert_from(LMatrix3f const &other);

3026 15 invert_in_place 0 4 3526 26 LMatrix3f::invert_in_place 0 1 1268 119
/**
 * Inverts the current matrix.  Returns true if the inverse is successful,
 * false if the matrix was singular.
 */
45
inline bool LMatrix3f::invert_in_place(void);

3027 21 invert_transpose_from 0 4 3526 32 LMatrix3f::invert_transpose_from 0 2 1269 1270 230
/**
 * Simultaneously computes the inverse of the indicated matrix, and then the
 * transpose of that inverse.
 */

/**
 * Simultaneously computes the inverse of the indicated matrix, and then the
 * transpose of that inverse.
 */
139
inline bool LMatrix3f::invert_transpose_from(LMatrix3f const &other);
inline bool LMatrix3f::invert_transpose_from(LMatrix4f const &other);

3028 9 ident_mat 0 4 3526 20 LMatrix3f::ident_mat 0 1 1271 147
/**
 * Returns an identity matrix.
 *
 * This function definition must appear first, since some inline functions
 * below take advantage of it.
 */
58
static inline LMatrix3f const &LMatrix3f::ident_mat(void);

3029 17 set_translate_mat 0 4 3526 28 LMatrix3f::set_translate_mat 0 1 1272 74
/**
 * Fills mat with a matrix that applies the indicated translation.
 */
66
inline void LMatrix3f::set_translate_mat(LVecBase2f const &trans);

3030 14 set_rotate_mat 0 4 3526 25 LMatrix3f::set_rotate_mat 0 2 1273 1274 225
/**
 * Fills mat with a matrix that rotates by the given angle in degrees
 * counterclockwise.
 */

/**
 * Fills mat with a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.
 */
156
inline void LMatrix3f::set_rotate_mat(float angle);
void LMatrix3f::set_rotate_mat(float angle, LVecBase3f const &axis, CoordinateSystem cs = ::CS_default);

3031 13 set_scale_mat 0 4 3526 24 LMatrix3f::set_scale_mat 0 2 1275 1276 194
/**
 * Fills mat with a matrix that applies the indicated scale in each of the two
 * axes.
 */

/**
 * Fills mat with a matrix that applies the indicated scale in each of the
 * three axes.
 */
125
inline void LMatrix3f::set_scale_mat(LVecBase2f const &scale);
inline void LMatrix3f::set_scale_mat(LVecBase3f const &scale);

3032 13 translate_mat 0 4 3526 24 LMatrix3f::translate_mat 0 2 1277 1278 136
/**
 * Returns a matrix that applies the indicated translation.
 */

/**
 * Returns a matrix that applies the indicated translation.
 */
144
static inline LMatrix3f LMatrix3f::translate_mat(LVecBase2f const &trans);
static inline LMatrix3f LMatrix3f::translate_mat(float tx, float ty);

3033 10 rotate_mat 0 4 3526 21 LMatrix3f::rotate_mat 0 2 1279 1280 211
/**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise.
 */

/**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.
 */
179
static inline LMatrix3f LMatrix3f::rotate_mat(float angle);
static inline LMatrix3f LMatrix3f::rotate_mat(float angle, LVecBase3f const &axis, CoordinateSystem cs = ::CS_default);

3034 9 scale_mat 0 4 3526 20 LMatrix3f::scale_mat 0 4 1281 1282 1283 1284 356
/**
 * Returns a matrix that applies the indicated scale in each of the two axes.
 */

/**
 * Returns a matrix that applies the indicated scale in each of the two axes.
 */

/**
 * Returns a matrix that applies the indicated scale in each of the three
 * axes.
 */

/**
 * Returns a matrix that applies the indicated scale in each of the three
 * axes.
 */
283
static inline LMatrix3f LMatrix3f::scale_mat(LVecBase2f const &scale);
static inline LMatrix3f LMatrix3f::scale_mat(float sx, float sy);
static inline LMatrix3f LMatrix3f::scale_mat(LVecBase3f const &scale);
static inline LMatrix3f LMatrix3f::scale_mat(float sx, float sy, float sz);

3035 23 set_rotate_mat_normaxis 0 4 3526 34 LMatrix3f::set_rotate_mat_normaxis 0 1 1285 163
/**
 * Fills mat with a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.  Assumes axis has been
 * normalized.
 */
113
void LMatrix3f::set_rotate_mat_normaxis(float angle, LVecBase3f const &axis, CoordinateSystem cs = ::CS_default);

3036 19 rotate_mat_normaxis 0 4 3526 30 LMatrix3f::rotate_mat_normaxis 0 1 1286 156
/**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.  Assumes axis has been
 * normalized.
 */
128
static inline LMatrix3f LMatrix3f::rotate_mat_normaxis(float angle, LVecBase3f const &axis, CoordinateSystem cs = ::CS_default);

3037 13 set_shear_mat 0 4 3526 24 LMatrix3f::set_shear_mat 0 1 1287 99
/**
 * Fills mat with a matrix that applies the indicated shear in each of the
 * three planes.
 */
98
inline void LMatrix3f::set_shear_mat(LVecBase3f const &shear, CoordinateSystem cs = ::CS_default);

3038 9 shear_mat 0 4 3526 20 LMatrix3f::shear_mat 0 2 1288 1289 186
/**
 * Returns a matrix that applies the indicated shear in each of the three
 * planes.
 */

/**
 * Returns a matrix that applies the indicated shear in each of the three
 * planes.
 */
224
static inline LMatrix3f LMatrix3f::shear_mat(LVecBase3f const &shear, CoordinateSystem cs = ::CS_default);
static inline LMatrix3f LMatrix3f::shear_mat(float shxy, float shxz, float shyz, CoordinateSystem cs = ::CS_default);

3039 19 set_scale_shear_mat 0 4 3526 30 LMatrix3f::set_scale_shear_mat 0 1 1290 78
/**
 * Fills mat with a matrix that applies the indicated scale and shear.
 */
122
void LMatrix3f::set_scale_shear_mat(LVecBase3f const &scale, LVecBase3f const &shear, CoordinateSystem cs = ::CS_default);

3040 15 scale_shear_mat 0 4 3526 26 LMatrix3f::scale_shear_mat 0 2 1291 1292 144
/**
 * Returns a matrix that applies the indicated scale and shear.
 */

/**
 * Returns a matrix that applies the indicated scale and shear.
 */
291
static inline LMatrix3f LMatrix3f::scale_shear_mat(LVecBase3f const &scale, LVecBase3f const &shear, CoordinateSystem cs = ::CS_default);
static inline LMatrix3f LMatrix3f::scale_shear_mat(float sx, float sy, float sz, float shxy, float shxz, float shyz, CoordinateSystem cs = ::CS_default);

3041 11 convert_mat 0 4 3526 22 LMatrix3f::convert_mat 0 1 1293 119
/**
 * Returns a matrix that transforms from the indicated coordinate system to
 * the indicated coordinate system.
 */
91
static LMatrix3f const &LMatrix3f::convert_mat(CoordinateSystem from, CoordinateSystem to);

3042 12 almost_equal 0 4 3526 23 LMatrix3f::almost_equal 0 2 1294 1295 212
/**
 * Returns true if two matrices are memberwise equal within a default
 * tolerance based on the numeric type.
 */

/**
 * Returns true if two matrices are memberwise equal within a specified
 * tolerance.
 */
143
bool LMatrix3f::almost_equal(LMatrix3f const &other, float threshold) const;
inline bool LMatrix3f::almost_equal(LMatrix3f const &other) const;

3043 6 output 0 4 3526 17 LMatrix3f::output 0 1 1296 10
/**
 *
 */
43
void LMatrix3f::output(ostream &out) const;

3044 5 write 0 4 3526 16 LMatrix3f::write 0 1 1297 10
/**
 *
 */
64
void LMatrix3f::write(ostream &out, int indent_level = 0) const;

3045 8 __repr__ 0 4 3526 19 LMatrix3f::__repr__ 0 1 1298 0
51
inline std::string LMatrix3f::__repr__(void) const;

3046 13 generate_hash 0 4 3526 24 LMatrix3f::generate_hash 0 2 1299 1300 120
/**
 * Adds the vector to the indicated hash generator.
 */

/**
 * Adds the vector to the indicated hash generator.
 */
161
inline void LMatrix3f::generate_hash(ChecksumHashGenerator &hashgen) const;
void LMatrix3f::generate_hash(ChecksumHashGenerator &hashgen, float threshold) const;

3047 20 write_datagram_fixed 0 4 3526 31 LMatrix3f::write_datagram_fixed 0 1 1301 332
/**
 * Writes the matrix to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the matrix, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */
66
void LMatrix3f::write_datagram_fixed(Datagram &destination) const;

3048 19 read_datagram_fixed 0 4 3526 30 LMatrix3f::read_datagram_fixed 0 1 1302 114
/**
 * Reads the matrix from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */
60
void LMatrix3f::read_datagram_fixed(DatagramIterator &scan);

3049 14 write_datagram 0 4 3526 25 LMatrix3f::write_datagram 0 1 1303 205
/**
 * Writes the matrix to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the matrix using the standard width
 * setting, especially when you are writing a bam file.
 */
60
void LMatrix3f::write_datagram(Datagram &destination) const;

3050 13 read_datagram 0 4 3526 24 LMatrix3f::read_datagram 0 1 1304 67
/**
 * Reads the matrix from the Datagram using get_stdfloat().
 */
56
void LMatrix3f::read_datagram(DatagramIterator &source);

3051 14 get_class_type 0 4 3526 25 LMatrix3f::get_class_type 0 1 1305 0
50
static TypeHandle LMatrix3f::get_class_type(void);

3052 10 ~LMatrix3f 0 4 3526 21 LMatrix3f::~LMatrix3f 0 0 0
28
LMatrix3f::~LMatrix3f(void);

3053 9 transpose 0 1 0 9 transpose 0 4 1860 1861 1862 1863 0
191
inline LMatrix3f transpose(LMatrix3f const &a);
inline LMatrix4f transpose(LMatrix4f const &a);
inline LMatrix3d transpose(LMatrix3d const &a);
inline LMatrix4d transpose(LMatrix4d const &a);

3054 6 invert 0 1 0 6 invert 0 6 1864 1865 1866 1867 1868 1869 0
281
inline LMatrix3f invert(LMatrix3f const &a);
inline LMatrix4f invert(LMatrix4f const &a);
inline LMatrix3d invert(LMatrix3d const &a);
inline LMatrix4d invert(LMatrix4d const &a);
inline LQuaternionf invert(LQuaternionf const &a);
inline LQuaterniond invert(LQuaterniond const &a);

3055 11 operator [] 0 4 3532 27 LMatrix4f::Row::operator [] 0 2 1424 1425 10
/**
 *
 */
104
inline float LMatrix4f::Row::operator [](int i) const;
inline float &LMatrix4f::Row::operator [](int i);

3056 4 size 0 4 3532 20 LMatrix4f::Row::size 0 1 1426 58
/**
 * Returns 4: the number of columns of a LMatrix4.
 */
45
static inline int LMatrix4f::Row::size(void);

3057 3 Row 0 4 3532 19 LMatrix4f::Row::Row 0 1 1423 60
/**
 * Defines a row-level index accessor to the matrix.
 */
61
inline LMatrix4f::Row::Row(LMatrix4f::Row const &) = default;

3058 4 ~Row 0 4 3532 20 LMatrix4f::Row::~Row 0 0 0
27
LMatrix4f::Row::~Row(void);

3059 11 operator [] 0 4 3533 28 LMatrix4f::CRow::operator [] 0 1 1428 0
55
inline float LMatrix4f::CRow::operator [](int i) const;

3060 4 size 0 4 3533 21 LMatrix4f::CRow::size 0 1 1429 58
/**
 * Returns 4: the number of columns of a LMatrix4.
 */
46
static inline int LMatrix4f::CRow::size(void);

3061 4 CRow 0 4 3533 21 LMatrix4f::CRow::CRow 0 1 1427 63
/**
 * Defines a row-level constant accessor to the matrix.
 */
64
inline LMatrix4f::CRow::CRow(LMatrix4f::CRow const &) = default;

3062 5 ~CRow 0 4 3533 22 LMatrix4f::CRow::~CRow 0 0 0
29
LMatrix4f::CRow::~CRow(void);

3063 9 LMatrix4f 0 4 3530 20 LMatrix4f::LMatrix4f 0 6 1313 1314 1315 1316 1317 1318 167
// Construct a 4x4 matrix given a 3x3 rotation matrix and an optional
// translation component.

/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */
487
inline LMatrix4f::LMatrix4f(void);
inline LMatrix4f::LMatrix4f(LMatrix4f const &other);
inline LMatrix4f::LMatrix4f(UnalignedLMatrix4f const &other);
inline LMatrix4f::LMatrix4f(float e00, float e01, float e02, float e03, float e10, float e11, float e12, float e13, float e20, float e21, float e22, float e23, float e30, float e31, float e32, float e33);
inline LMatrix4f::LMatrix4f(LMatrix3f const &upper3);
inline LMatrix4f::LMatrix4f(LMatrix3f const &upper3, LVecBase3f const &trans);

3064 10 operator = 0 4 3530 21 LMatrix4f::operator = 0 3 1319 1320 1321 34
/**
 *
 */

/**
 *
 */

/**
 *
 */
197
inline LMatrix4f &LMatrix4f::operator =(LMatrix4f const &other);
inline LMatrix4f &LMatrix4f::operator =(UnalignedLMatrix4f const &other);
inline LMatrix4f &LMatrix4f::operator =(float fill_value);

3065 12 operator new 0 4 3530 23 LMatrix4f::operator new 0 1 1322 0
122
inline void *LMatrix4f::operator new(std::size_t size);
inline void *LMatrix4f::operator new(std::size_t size, void *ptr);

3066 15 operator delete 0 4 3530 26 LMatrix4f::operator delete 0 0 0
106
inline void LMatrix4f::operator delete(void *ptr);
inline void LMatrix4f::operator delete(void *, void *);

3067 12 validate_ptr 0 4 3530 23 LMatrix4f::validate_ptr 0 0 0
60
static inline bool LMatrix4f::validate_ptr(void const *ptr);

3068 10 __reduce__ 0 4 3530 21 LMatrix4f::__reduce__ 0 1 1323 0
61
inline PyObject *LMatrix4f::__reduce__(PyObject *self) const;

3069 4 fill 0 4 3530 15 LMatrix4f::fill 0 1 1324 157
/**
 * Sets each element of the matrix to the indicated fill_value.  This is of
 * questionable value, but is sometimes useful when initializing to zero.
 */
46
inline void LMatrix4f::fill(float fill_value);

3070 3 set 0 4 3530 14 LMatrix4f::set 0 1 1325 10
/**
 *
 */
203
inline void LMatrix4f::set(float e00, float e01, float e02, float e03, float e10, float e11, float e12, float e13, float e20, float e21, float e22, float e23, float e30, float e31, float e32, float e33);

3071 11 set_upper_3 0 4 3530 22 LMatrix4f::set_upper_3 0 1 1326 87
// Get and set the upper 3x3 rotation matrix.

/**
 * Sets the upper 3x3 submatrix.
 */
60
inline void LMatrix4f::set_upper_3(LMatrix3f const &upper3);

3072 11 get_upper_3 0 4 3530 22 LMatrix4f::get_upper_3 0 1 1327 45
/**
 * Retrieves the upper 3x3 submatrix.
 */
52
inline LMatrix3f LMatrix4f::get_upper_3(void) const;

3073 11 operator [] 0 4 3530 22 LMatrix4f::operator [] 0 2 1328 1329 0
112
inline LMatrix4f::CRow LMatrix4f::operator [](int i) const;
inline LMatrix4f::Row LMatrix4f::operator [](int i);

3074 4 size 0 4 3530 15 LMatrix4f::size 0 1 1330 55
/**
 * Returns 4: the number of rows of a LMatrix4.
 */
40
static inline int LMatrix4f::size(void);

3075 7 set_row 0 4 3530 18 LMatrix4f::set_row 0 2 1331 1332 173
/**
 * Replaces the indicated row of the matrix.
 */

/**
 * Replaces the indicated row of the matrix with the indicated 3-component
 * vector, ignoring the last column.
 */
123
inline void LMatrix4f::set_row(int row, LVecBase4f const &v);
inline void LMatrix4f::set_row(int row, LVecBase3f const &v);

3076 7 set_col 0 4 3530 18 LMatrix4f::set_col 0 2 1333 1334 176
/**
 * Replaces the indicated column of the matrix.
 */

/**
 * Replaces the indicated column of the matrix with the indicated 3-component
 * vector, ignoring the last row.
 */
123
inline void LMatrix4f::set_col(int col, LVecBase4f const &v);
inline void LMatrix4f::set_col(int col, LVecBase3f const &v);

3077 7 get_row 0 4 3530 18 LMatrix4f::get_row 0 2 1335 1336 186
// these versions inline better

/**
 * Retrieves the indicated row of the matrix as a 4-component vector.
 */

/**
 * Stores the indicated row of the matrix as a 4-component vector.
 */
123
inline LVecBase4f LMatrix4f::get_row(int row) const;
inline void LMatrix4f::get_row(LVecBase4f &result_vec, int row) const;

3078 7 get_col 0 4 3530 18 LMatrix4f::get_col 0 1 1337 80
/**
 * Retrieves the indicated column of the matrix as a 4-component vector.
 */
52
inline LVecBase4f LMatrix4f::get_col(int col) const;

3079 8 get_row3 0 4 3530 19 LMatrix4f::get_row3 0 2 1338 1339 205
/**
 * Retrieves the row column of the matrix as a 3-component vector, ignoring
 * the last column.
 */

/**
 * Stores the row column of the matrix as a 3-component vector, ignoring the
 * last column.
 */
125
inline LVecBase3f LMatrix4f::get_row3(int row) const;
inline void LMatrix4f::get_row3(LVecBase3f &result_vec, int row) const;

3080 0 0 0 0 0 0 0 0
0

3081 0 0 0 0 0 0 0 0
0

3082 8 get_col3 0 4 3530 19 LMatrix4f::get_col3 0 1 1340 106
/**
 * Retrieves the indicated column of the matrix as a 3-component vector,
 * ignoring the last row.
 */
53
inline LVecBase3f LMatrix4f::get_col3(int col) const;

3083 11 operator () 0 4 3530 22 LMatrix4f::operator () 0 2 1341 1342 10
/**
 *
 */
116
inline float &LMatrix4f::operator ()(int row, int col);
inline float LMatrix4f::operator ()(int row, int col) const;

3084 6 is_nan 0 4 3530 17 LMatrix4f::is_nan 0 1 1343 91
/**
 * Returns true if any component of the matrix is not-a-number, false
 * otherwise.
 */
42
inline bool LMatrix4f::is_nan(void) const;

3085 11 is_identity 0 4 3530 22 LMatrix4f::is_identity 0 1 1344 93
/**
 * Returns true if this is (close enough to) the identity matrix, false
 * otherwise.
 */
47
inline bool LMatrix4f::is_identity(void) const;

3086 8 get_cell 0 4 3530 19 LMatrix4f::get_cell 0 1 1345 54
/**
 * Returns a particular element of the matrix.
 */
57
inline float LMatrix4f::get_cell(int row, int col) const;

3087 8 set_cell 0 4 3530 19 LMatrix4f::set_cell 0 1 1346 54
/**
 * Changes a particular element of the matrix.
 */
63
inline void LMatrix4f::set_cell(int row, int col, float value);

3088 8 get_data 0 4 3530 19 LMatrix4f::get_data 0 1 1347 162
/**
 * Returns the address of the first of the nine data elements in the matrix.
 * The remaining elements occupy the next eight positions in row-major order.
 */
52
inline float const *LMatrix4f::get_data(void) const;

3089 18 get_num_components 0 4 3530 29 LMatrix4f::get_num_components 0 1 1348 60
/**
 * Returns the number of elements in the matrix, 16.
 */
53
inline int LMatrix4f::get_num_components(void) const;

3090 5 begin 0 4 3530 16 LMatrix4f::begin 0 2 1349 1350 204
/**
 * Returns an iterator that may be used to traverse the elements of the
 * matrix, STL-style.
 */

/**
 * Returns an iterator that may be used to traverse the elements of the
 * matrix, STL-style.
 */
113
inline LMatrix4f::iterator LMatrix4f::begin(void);
inline LMatrix4f::const_iterator LMatrix4f::begin(void) const;

3091 3 end 0 4 3530 14 LMatrix4f::end 0 2 1351 1352 204
/**
 * Returns an iterator that may be used to traverse the elements of the
 * matrix, STL-style.
 */

/**
 * Returns an iterator that may be used to traverse the elements of the
 * matrix, STL-style.
 */
109
inline LMatrix4f::iterator LMatrix4f::end(void);
inline LMatrix4f::const_iterator LMatrix4f::end(void) const;

3092 10 operator < 0 4 3530 21 LMatrix4f::operator < 0 1 1353 0
64
inline bool LMatrix4f::operator <(LMatrix4f const &other) const;

3093 11 operator == 0 4 3530 22 LMatrix4f::operator == 0 1 1354 0
65
inline bool LMatrix4f::operator ==(LMatrix4f const &other) const;

3094 11 operator != 0 4 3530 22 LMatrix4f::operator != 0 1 1355 0
65
inline bool LMatrix4f::operator !=(LMatrix4f const &other) const;

3095 10 compare_to 0 4 3530 21 LMatrix4f::compare_to 0 2 1356 1357 333
/**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */

/**
 * Sorts matrices lexicographically, componentwise.  Returns a number less
 * than 0 if this matrix sorts before the other one, greater than zero if it
 * sorts after, 0 if they are equivalent (within the indicated tolerance).
 */
137
inline int LMatrix4f::compare_to(LMatrix4f const &other) const;
int LMatrix4f::compare_to(LMatrix4f const &other, float threshold) const;

3096 8 get_hash 0 4 3530 19 LMatrix4f::get_hash 0 2 1358 1359 100
/**
 * Returns a suitable hash for phash_map.
 */

/**
 * Returns a suitable hash for phash_map.
 */
114
inline std::size_t LMatrix4f::get_hash(void) const;
inline std::size_t LMatrix4f::get_hash(float threshold) const;

3097 8 add_hash 0 4 3530 19 LMatrix4f::add_hash 0 2 1360 1361 100
/**
 * Adds the vector into the running hash.
 */

/**
 * Adds the vector into the running hash.
 */
144
inline std::size_t LMatrix4f::add_hash(std::size_t hash) const;
inline std::size_t LMatrix4f::add_hash(std::size_t hash, float threshold) const;

3098 5 xform 0 4 3530 16 LMatrix4f::xform 0 1 1362 91
/**
 * 4-component vector or point times matrix.  This is a fully general
 * operation.
 */
62
inline LVecBase4f LMatrix4f::xform(LVecBase4f const &v) const;

3099 11 xform_point 0 4 3530 22 LMatrix4f::xform_point 0 1 1363 162
/**
 * The matrix transforms a 3-component point (including translation component)
 * and returns the result.  This assumes the matrix is an affine transform.
 */
68
inline LVecBase3f LMatrix4f::xform_point(LVecBase3f const &v) const;

3100 19 xform_point_general 0 4 3530 30 LMatrix4f::xform_point_general 0 1 1364 143
/**
 * The matrix transforms a 3-component point (including translation component)
 * and returns the result, as a fully general operation.
 */
76
inline LVecBase3f LMatrix4f::xform_point_general(LVecBase3f const &v) const;

3101 9 xform_vec 0 4 3530 20 LMatrix4f::xform_vec 0 1 1365 169
/**
 * The matrix transforms a 3-component vector (without translation component)
 * and returns the result.  This assumes the matrix is an orthonormal
 * transform.
 */
66
inline LVecBase3f LMatrix4f::xform_vec(LVecBase3f const &v) const;

3102 17 xform_vec_general 0 4 3530 28 LMatrix4f::xform_vec_general 0 1 1366 142
/**
 * The matrix transforms a 3-component vector (without translation component)
 * and returns the result, as a fully general operation.
 */
74
inline LVecBase3f LMatrix4f::xform_vec_general(LVecBase3f const &v) const;

3103 14 xform_in_place 0 4 3530 25 LMatrix4f::xform_in_place 0 1 1367 91
/**
 * 4-component vector or point times matrix.  This is a fully general
 * operation.
 */
59
inline void LMatrix4f::xform_in_place(LVecBase4f &v) const;

3104 20 xform_point_in_place 0 4 3530 31 LMatrix4f::xform_point_in_place 0 1 1368 139
/**
 * The matrix transforms a 3-component point (including translation
 * component).  This assumes the matrix is an affine transform.
 */
65
inline void LMatrix4f::xform_point_in_place(LVecBase3f &v) const;

3105 28 xform_point_general_in_place 0 4 3530 39 LMatrix4f::xform_point_general_in_place 0 1 1369 120
/**
 * The matrix transforms a 3-component point (including translation
 * component), as a fully general operation.
 */
73
inline void LMatrix4f::xform_point_general_in_place(LVecBase3f &v) const;

3106 18 xform_vec_in_place 0 4 3530 29 LMatrix4f::xform_vec_in_place 0 1 1370 142
/**
 * The matrix transforms a 3-component vector (without translation component).
 * This assumes the matrix is an orthonormal transform.
 */
63
inline void LMatrix4f::xform_vec_in_place(LVecBase3f &v) const;

3107 26 xform_vec_general_in_place 0 4 3530 37 LMatrix4f::xform_vec_general_in_place 0 1 1371 119
/**
 * The matrix transforms a 3-component vector (without translation component),
 * as a fully general operation.
 */
71
inline void LMatrix4f::xform_vec_general_in_place(LVecBase3f &v) const;

3108 8 multiply 0 4 3530 19 LMatrix4f::multiply 0 1 1372 52
// this = other1 * other2

// this = other1 * other2
82
inline void LMatrix4f::multiply(LMatrix4f const &other1, LMatrix4f const &other2);

3109 10 operator * 0 4 3530 21 LMatrix4f::operator * 0 2 1373 1374 0
129
inline LMatrix4f LMatrix4f::operator *(LMatrix4f const &other) const;
inline LMatrix4f LMatrix4f::operator *(float scalar) const;

3110 10 operator / 0 4 3530 21 LMatrix4f::operator / 0 1 1375 0
59
inline LMatrix4f LMatrix4f::operator /(float scalar) const;

3111 11 operator += 0 4 3530 22 LMatrix4f::operator += 0 1 1376 63
/**
 * Performs a memberwise addition between two matrices.
 */
65
inline LMatrix4f &LMatrix4f::operator +=(LMatrix4f const &other);

3112 11 operator -= 0 4 3530 22 LMatrix4f::operator -= 0 1 1377 63
/**
 * Performs a memberwise addition between two matrices.
 */
65
inline LMatrix4f &LMatrix4f::operator -=(LMatrix4f const &other);

3113 11 operator *= 0 4 3530 22 LMatrix4f::operator *= 0 2 1378 1379 22
/**
 *
 */

/**
 *
 */
121
inline LMatrix4f &LMatrix4f::operator *=(LMatrix4f const &other);
inline LMatrix4f &LMatrix4f::operator *=(float scalar);

3114 11 operator /= 0 4 3530 22 LMatrix4f::operator /= 0 1 1380 10
/**
 *
 */
55
inline LMatrix4f &LMatrix4f::operator /=(float scalar);

3115 18 componentwise_mult 0 4 3530 29 LMatrix4f::componentwise_mult 0 1 1381 10
/**
 *
 */
66
inline void LMatrix4f::componentwise_mult(LMatrix4f const &other);

3116 14 transpose_from 0 4 3530 25 LMatrix4f::transpose_from 0 1 1382 10
/**
 *
 */
62
inline void LMatrix4f::transpose_from(LMatrix4f const &other);

3117 18 transpose_in_place 0 4 3530 29 LMatrix4f::transpose_in_place 0 1 1383 10
/**
 *
 */
48
inline void LMatrix4f::transpose_in_place(void);

3118 11 invert_from 0 4 3530 22 LMatrix4f::invert_from 0 1 1384 461
/**
 * Computes the inverse of the other matrix, and stores the result in this
 * matrix.  This is a fully general operation and makes no assumptions about
 * the type of transform represented by the matrix.
 *
 * The other matrix must be a different object than this matrix.  However, if
 * you need to invert a matrix in place, see invert_in_place.
 *
 * The return value is true if the matrix was successfully inverted, false if
 * the was a singularity.
 */
59
inline bool LMatrix4f::invert_from(LMatrix4f const &other);

3119 18 invert_affine_from 0 4 3530 29 LMatrix4f::invert_affine_from 0 1 1385 139
// bugbug: we could optimize this for rotationscaletranslation matrices
// (transpose upper 3x3 and take negative of translation component)
66
inline bool LMatrix4f::invert_affine_from(LMatrix4f const &other);

3120 15 invert_in_place 0 4 3530 26 LMatrix4f::invert_in_place 0 1 1386 119
/**
 * Inverts the current matrix.  Returns true if the inverse is successful,
 * false if the matrix was singular.
 */
45
inline bool LMatrix4f::invert_in_place(void);

3121 10 accumulate 0 4 3530 21 LMatrix4f::accumulate 0 1 1387 46
/**
 * Computes (*this) += other * weight.
 */
72
inline void LMatrix4f::accumulate(LMatrix4f const &other, float weight);

3122 9 ident_mat 0 4 3530 20 LMatrix4f::ident_mat 0 1 1388 147
/**
 * Returns an identity matrix.
 *
 * This function definition must appear first, since some inline functions
 * below take advantage of it.
 */
58
static inline LMatrix4f const &LMatrix4f::ident_mat(void);

3123 8 ones_mat 0 4 3530 19 LMatrix4f::ones_mat 0 1 1389 46
/**
 * Returns an matrix filled with ones.
 */
57
static inline LMatrix4f const &LMatrix4f::ones_mat(void);

3124 9 zeros_mat 0 4 3530 20 LMatrix4f::zeros_mat 0 1 1390 47
/**
 * Returns an matrix filled with zeros.
 */
58
static inline LMatrix4f const &LMatrix4f::zeros_mat(void);

3125 17 set_translate_mat 0 4 3530 28 LMatrix4f::set_translate_mat 0 1 1391 74
/**
 * Fills mat with a matrix that applies the indicated translation.
 */
66
inline void LMatrix4f::set_translate_mat(LVecBase3f const &trans);

3126 14 set_rotate_mat 0 4 3530 25 LMatrix4f::set_rotate_mat 0 1 1392 122
/**
 * Sets mat to a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.
 */
104
void LMatrix4f::set_rotate_mat(float angle, LVecBase3f const &axis, CoordinateSystem cs = ::CS_default);

3127 23 set_rotate_mat_normaxis 0 4 3530 34 LMatrix4f::set_rotate_mat_normaxis 0 1 1393 166
/**
 * Fills mat with a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.  Assumes axis has been
 * prenormalized.
 */
113
void LMatrix4f::set_rotate_mat_normaxis(float angle, LVecBase3f const &axis, CoordinateSystem cs = ::CS_default);

3128 13 set_scale_mat 0 4 3530 24 LMatrix4f::set_scale_mat 0 1 1394 97
/**
 * Fills mat with a matrix that applies the indicated scale in each of the
 * three axes.
 */
62
inline void LMatrix4f::set_scale_mat(LVecBase3f const &scale);

3129 13 set_shear_mat 0 4 3530 24 LMatrix4f::set_shear_mat 0 1 1395 99
/**
 * Fills mat with a matrix that applies the indicated shear in each of the
 * three planes.
 */
98
inline void LMatrix4f::set_shear_mat(LVecBase3f const &shear, CoordinateSystem cs = ::CS_default);

3130 19 set_scale_shear_mat 0 4 3530 30 LMatrix4f::set_scale_shear_mat 0 1 1396 78
/**
 * Fills mat with a matrix that applies the indicated scale and shear.
 */
129
inline void LMatrix4f::set_scale_shear_mat(LVecBase3f const &scale, LVecBase3f const &shear, CoordinateSystem cs = ::CS_default);

3131 13 translate_mat 0 4 3530 24 LMatrix4f::translate_mat 0 2 1397 1398 136
/**
 * Returns a matrix that applies the indicated translation.
 */

/**
 * Returns a matrix that applies the indicated translation.
 */
154
static inline LMatrix4f LMatrix4f::translate_mat(LVecBase3f const &trans);
static inline LMatrix4f LMatrix4f::translate_mat(float tx, float ty, float tz);

3132 10 rotate_mat 0 4 3530 21 LMatrix4f::rotate_mat 0 1 1399 118
/**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.
 */
119
static inline LMatrix4f LMatrix4f::rotate_mat(float angle, LVecBase3f const &axis, CoordinateSystem cs = ::CS_default);

3133 19 rotate_mat_normaxis 0 4 3530 30 LMatrix4f::rotate_mat_normaxis 0 1 1400 159
/**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.  Assumes axis has been
 * prenormalized.
 */
128
static inline LMatrix4f LMatrix4f::rotate_mat_normaxis(float angle, LVecBase3f const &axis, CoordinateSystem cs = ::CS_default);

3134 9 scale_mat 0 4 3530 20 LMatrix4f::scale_mat 0 3 1401 1402 1403 253
/**
 * Returns a matrix that applies the indicated scale in each of the three
 * axes.
 */

/**
 * Returns a matrix that applies the indicated scale in each of the three
 * axes.
 */

/**
 * Returns a matrix that applies the indicated uniform scale.
 */
205
static inline LMatrix4f LMatrix4f::scale_mat(LVecBase3f const &scale);
static inline LMatrix4f LMatrix4f::scale_mat(float sx, float sy, float sz);
static inline LMatrix4f LMatrix4f::scale_mat(float scale);

3135 9 shear_mat 0 4 3530 20 LMatrix4f::shear_mat 0 2 1404 1405 186
/**
 * Returns a matrix that applies the indicated shear in each of the three
 * planes.
 */

/**
 * Returns a matrix that applies the indicated shear in each of the three
 * planes.
 */
224
static inline LMatrix4f LMatrix4f::shear_mat(LVecBase3f const &shear, CoordinateSystem cs = ::CS_default);
static inline LMatrix4f LMatrix4f::shear_mat(float shxy, float shxz, float shyz, CoordinateSystem cs = ::CS_default);

3136 15 scale_shear_mat 0 4 3530 26 LMatrix4f::scale_shear_mat 0 2 1406 1407 144
/**
 * Returns a matrix that applies the indicated scale and shear.
 */

/**
 * Returns a matrix that applies the indicated scale and shear.
 */
291
static inline LMatrix4f LMatrix4f::scale_shear_mat(LVecBase3f const &scale, LVecBase3f const &shear, CoordinateSystem cs = ::CS_default);
static inline LMatrix4f LMatrix4f::scale_shear_mat(float sx, float sy, float sz, float shxy, float shxz, float shyz, CoordinateSystem cs = ::CS_default);

3137 13 y_to_z_up_mat 0 4 3530 24 LMatrix4f::y_to_z_up_mat 0 1 1408 109
/**
 * Returns a matrix that transforms from the Y-up coordinate system to the
 * Z-up coordinate system.
 */
62
static inline LMatrix4f const &LMatrix4f::y_to_z_up_mat(void);

3138 13 z_to_y_up_mat 0 4 3530 24 LMatrix4f::z_to_y_up_mat 0 1 1409 109
/**
 * Returns a matrix that transforms from the Y-up coordinate system to the
 * Z-up coordinate system.
 */
62
static inline LMatrix4f const &LMatrix4f::z_to_y_up_mat(void);

3139 11 convert_mat 0 4 3530 22 LMatrix4f::convert_mat 0 1 1410 119
/**
 * Returns a matrix that transforms from the indicated coordinate system to
 * the indicated coordinate system.
 */
91
static LMatrix4f const &LMatrix4f::convert_mat(CoordinateSystem from, CoordinateSystem to);

3140 12 almost_equal 0 4 3530 23 LMatrix4f::almost_equal 0 2 1411 1412 318
/**
 * Returns true if two matrices are memberwise equal within a default
 * tolerance based on the numeric type.
 */

/**
 * Returns true if two matrices are memberwise equal within a specified
 * tolerance.  This is faster than the equivalence operator as this doesn't
 * have to guarantee that it is transitive.
 */
143
bool LMatrix4f::almost_equal(LMatrix4f const &other, float threshold) const;
inline bool LMatrix4f::almost_equal(LMatrix4f const &other) const;

3141 6 output 0 4 3530 17 LMatrix4f::output 0 1 1413 10
/**
 *
 */
43
void LMatrix4f::output(ostream &out) const;

3142 5 write 0 4 3530 16 LMatrix4f::write 0 1 1414 10
/**
 *
 */
64
void LMatrix4f::write(ostream &out, int indent_level = 0) const;

3143 8 __repr__ 0 4 3530 19 LMatrix4f::__repr__ 0 1 1415 0
51
inline std::string LMatrix4f::__repr__(void) const;

3144 13 generate_hash 0 4 3530 24 LMatrix4f::generate_hash 0 2 1416 1417 120
/**
 * Adds the vector to the indicated hash generator.
 */

/**
 * Adds the vector to the indicated hash generator.
 */
157
inline void LMatrix4f::generate_hash(ChecksumHashGenerator &hashgen) const;
void LMatrix4f::generate_hash(ChecksumHashGenerator &hashgen, float scale) const;

3145 20 write_datagram_fixed 0 4 3530 31 LMatrix4f::write_datagram_fixed 0 1 1418 332
/**
 * Writes the matrix to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the matrix, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */
66
void LMatrix4f::write_datagram_fixed(Datagram &destination) const;

3146 19 read_datagram_fixed 0 4 3530 30 LMatrix4f::read_datagram_fixed 0 1 1419 114
/**
 * Reads the matrix from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */
60
void LMatrix4f::read_datagram_fixed(DatagramIterator &scan);

3147 14 write_datagram 0 4 3530 25 LMatrix4f::write_datagram 0 1 1420 205
/**
 * Writes the matrix to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the matrix using the standard width
 * setting, especially when you are writing a bam file.
 */
60
void LMatrix4f::write_datagram(Datagram &destination) const;

3148 13 read_datagram 0 4 3530 24 LMatrix4f::read_datagram 0 1 1421 67
/**
 * Reads the matrix from the Datagram using get_stdfloat().
 */
56
void LMatrix4f::read_datagram(DatagramIterator &source);

3149 14 get_class_type 0 4 3530 25 LMatrix4f::get_class_type 0 1 1422 0
50
static TypeHandle LMatrix4f::get_class_type(void);

3150 10 ~LMatrix4f 0 4 3530 21 LMatrix4f::~LMatrix4f 0 0 0
28
LMatrix4f::~LMatrix4f(void);

3151 18 UnalignedLMatrix4f 0 4 3534 38 UnalignedLMatrix4f::UnalignedLMatrix4f 0 4 1430 1431 1432 1433 46
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */
424
inline UnalignedLMatrix4f::UnalignedLMatrix4f(void);
inline UnalignedLMatrix4f::UnalignedLMatrix4f(LMatrix4f const &copy);
inline UnalignedLMatrix4f::UnalignedLMatrix4f(UnalignedLMatrix4f const &copy);
inline UnalignedLMatrix4f::UnalignedLMatrix4f(float e00, float e01, float e02, float e03, float e10, float e11, float e12, float e13, float e20, float e21, float e22, float e23, float e30, float e31, float e32, float e33);

3152 10 operator = 0 4 3534 30 UnalignedLMatrix4f::operator = 0 2 1434 1435 22
/**
 *
 */

/**
 *
 */
172
inline UnalignedLMatrix4f &UnalignedLMatrix4f::operator =(LMatrix4f const &copy);
inline UnalignedLMatrix4f &UnalignedLMatrix4f::operator =(UnalignedLMatrix4f const &copy);

3153 3 set 0 4 3534 23 UnalignedLMatrix4f::set 0 1 1436 10
/**
 *
 */
212
inline void UnalignedLMatrix4f::set(float e00, float e01, float e02, float e03, float e10, float e11, float e12, float e13, float e20, float e21, float e22, float e23, float e30, float e31, float e32, float e33);

3154 11 operator () 0 4 3534 31 UnalignedLMatrix4f::operator () 0 2 1437 1438 10
/**
 *
 */
134
inline float &UnalignedLMatrix4f::operator ()(int row, int col);
inline float UnalignedLMatrix4f::operator ()(int row, int col) const;

3155 8 get_data 0 4 3534 28 UnalignedLMatrix4f::get_data 0 1 1439 162
/**
 * Returns the address of the first of the nine data elements in the matrix.
 * The remaining elements occupy the next eight positions in row-major order.
 */
61
inline float const *UnalignedLMatrix4f::get_data(void) const;

3156 18 get_num_components 0 4 3534 38 UnalignedLMatrix4f::get_num_components 0 1 1440 65
/**
 * Returns the number of elements in the matrix, sixteen.
 */
62
inline int UnalignedLMatrix4f::get_num_components(void) const;

3157 14 get_class_type 0 4 3534 34 UnalignedLMatrix4f::get_class_type 0 1 1441 0
59
static TypeHandle UnalignedLMatrix4f::get_class_type(void);

3158 19 ~UnalignedLMatrix4f 0 4 3534 39 UnalignedLMatrix4f::~UnalignedLMatrix4f 0 0 0
46
UnalignedLMatrix4f::~UnalignedLMatrix4f(void);

3159 11 operator [] 0 4 3538 27 LMatrix3d::Row::operator [] 0 2 1543 1544 10
/**
 *
 */
106
inline double LMatrix3d::Row::operator [](int i) const;
inline double &LMatrix3d::Row::operator [](int i);

3160 4 size 0 4 3538 20 LMatrix3d::Row::size 0 1 1545 58
/**
 * Returns 3: the number of columns of a LMatrix3.
 */
45
static inline int LMatrix3d::Row::size(void);

3161 3 Row 0 4 3538 19 LMatrix3d::Row::Row 0 1 1542 60
/**
 * Defines a row-level index accessor to the matrix.
 */
61
inline LMatrix3d::Row::Row(LMatrix3d::Row const &) = default;

3162 4 ~Row 0 4 3538 20 LMatrix3d::Row::~Row 0 0 0
27
LMatrix3d::Row::~Row(void);

3163 11 operator [] 0 4 3539 28 LMatrix3d::CRow::operator [] 0 1 1547 0
56
inline double LMatrix3d::CRow::operator [](int i) const;

3164 4 size 0 4 3539 21 LMatrix3d::CRow::size 0 1 1548 58
/**
 * Returns 3: the number of columns of a LMatrix3.
 */
46
static inline int LMatrix3d::CRow::size(void);

3165 4 CRow 0 4 3539 21 LMatrix3d::CRow::CRow 0 1 1546 63
/**
 * Defines a row-level constant accessor to the matrix.
 */
64
inline LMatrix3d::CRow::CRow(LMatrix3d::CRow const &) = default;

3166 5 ~CRow 0 4 3539 22 LMatrix3d::CRow::~CRow 0 0 0
29
LMatrix3d::CRow::~CRow(void);

3167 9 LMatrix3d 0 4 3536 20 LMatrix3d::LMatrix3d 0 3 1442 1443 1444 34
/**
 *
 */

/**
 *
 */

/**
 *
 */
224
inline LMatrix3d::LMatrix3d(void);
inline LMatrix3d::LMatrix3d(LMatrix3d const &other);
inline LMatrix3d::LMatrix3d(double e00, double e01, double e02, double e10, double e11, double e12, double e20, double e21, double e22);

3168 10 operator = 0 4 3536 21 LMatrix3d::operator = 0 2 1445 1446 22
/**
 *
 */

/**
 *
 */
124
inline LMatrix3d &LMatrix3d::operator =(LMatrix3d const &other);
inline LMatrix3d &LMatrix3d::operator =(double fill_value);

3169 12 operator new 0 4 3536 23 LMatrix3d::operator new 0 1 1447 0
122
inline void *LMatrix3d::operator new(std::size_t size);
inline void *LMatrix3d::operator new(std::size_t size, void *ptr);

3170 15 operator delete 0 4 3536 26 LMatrix3d::operator delete 0 0 0
106
inline void LMatrix3d::operator delete(void *ptr);
inline void LMatrix3d::operator delete(void *, void *);

3171 12 validate_ptr 0 4 3536 23 LMatrix3d::validate_ptr 0 0 0
60
static inline bool LMatrix3d::validate_ptr(void const *ptr);

3172 10 __reduce__ 0 4 3536 21 LMatrix3d::__reduce__ 0 1 1448 0
61
inline PyObject *LMatrix3d::__reduce__(PyObject *self) const;

3173 4 fill 0 4 3536 15 LMatrix3d::fill 0 1 1449 157
/**
 * Sets each element of the matrix to the indicated fill_value.  This is of
 * questionable value, but is sometimes useful when initializing to zero.
 */
40
void LMatrix3d::fill(double fill_value);

3174 3 set 0 4 3536 14 LMatrix3d::set 0 1 1450 10
/**
 *
 */
135
inline void LMatrix3d::set(double e00, double e01, double e02, double e10, double e11, double e12, double e20, double e21, double e22);

3175 11 operator [] 0 4 3536 22 LMatrix3d::operator [] 0 2 1451 1452 0
112
inline LMatrix3d::CRow LMatrix3d::operator [](int i) const;
inline LMatrix3d::Row LMatrix3d::operator [](int i);

3176 4 size 0 4 3536 15 LMatrix3d::size 0 1 1453 55
/**
 * Returns 3: the number of rows of a LMatrix3.
 */
40
static inline int LMatrix3d::size(void);

3177 7 set_row 0 4 3536 18 LMatrix3d::set_row 0 2 1454 1455 193
/**
 * Replaces the indicated row of the matrix from a three-component vector.
 */

/**
 * Replaces the indicated row of the matrix from a two-component vector,
 * ignoring the last column.
 */
123
inline void LMatrix3d::set_row(int row, LVecBase3d const &v);
inline void LMatrix3d::set_row(int row, LVecBase2d const &v);

3178 7 set_col 0 4 3536 18 LMatrix3d::set_col 0 2 1456 1457 196
/**
 * Replaces the indicated column of the matrix from a three-component vector.
 */

/**
 * Replaces the indicated column of the matrix from a two-component vector,
 * ignoring the last row.
 */
123
inline void LMatrix3d::set_col(int col, LVecBase3d const &v);
inline void LMatrix3d::set_col(int col, LVecBase2d const &v);

3179 7 get_row 0 4 3536 18 LMatrix3d::get_row 0 2 1458 1459 192
// these versions inline better

/**
 * Returns the indicated row of the matrix as a three-component vector.
 */

/**
 * Stores the indicated row of the matrix as a three-component vector.
 */
123
inline LVecBase3d LMatrix3d::get_row(int row) const;
inline void LMatrix3d::get_row(LVecBase3d &result_vec, int row) const;

3180 7 get_col 0 4 3536 18 LMatrix3d::get_col 0 1 1460 82
/**
 * Returns the indicated column of the matrix as a three-component vector.
 */
52
inline LVecBase3d LMatrix3d::get_col(int col) const;

3181 0 0 0 0 0 0 0 0
0

3182 0 0 0 0 0 0 0 0
0

3183 8 get_row2 0 4 3536 19 LMatrix3d::get_row2 0 1 1461 106
/**
 * Returns the indicated row of the matrix as a two-component vector, ignoring
 * the last column.
 */
53
inline LVecBase2d LMatrix3d::get_row2(int row) const;

3184 8 get_col2 0 4 3536 19 LMatrix3d::get_col2 0 1 1462 106
/**
 * Returns the indicated column of the matrix as a two-component vector,
 * ignoring the last row.
 */
53
inline LVecBase2d LMatrix3d::get_col2(int col) const;

3185 11 operator () 0 4 3536 22 LMatrix3d::operator () 0 2 1463 1464 10
/**
 *
 */
118
inline double &LMatrix3d::operator ()(int row, int col);
inline double LMatrix3d::operator ()(int row, int col) const;

3186 6 is_nan 0 4 3536 17 LMatrix3d::is_nan 0 1 1465 91
/**
 * Returns true if any component of the matrix is not-a-number, false
 * otherwise.
 */
42
inline bool LMatrix3d::is_nan(void) const;

3187 11 is_identity 0 4 3536 22 LMatrix3d::is_identity 0 1 1466 93
/**
 * Returns true if this is (close enough to) the identity matrix, false
 * otherwise.
 */
47
inline bool LMatrix3d::is_identity(void) const;

3188 8 get_cell 0 4 3536 19 LMatrix3d::get_cell 0 1 1467 54
/**
 * Returns a particular element of the matrix.
 */
58
inline double LMatrix3d::get_cell(int row, int col) const;

3189 8 set_cell 0 4 3536 19 LMatrix3d::set_cell 0 1 1468 54
/**
 * Changes a particular element of the matrix.
 */
64
inline void LMatrix3d::set_cell(int row, int col, double value);

3190 8 get_data 0 4 3536 19 LMatrix3d::get_data 0 1 1469 162
/**
 * Returns the address of the first of the nine data elements in the matrix.
 * The remaining elements occupy the next eight positions in row-major order.
 */
53
inline double const *LMatrix3d::get_data(void) const;

3191 18 get_num_components 0 4 3536 29 LMatrix3d::get_num_components 0 1 1470 62
/**
 * Returns the number of elements in the matrix, nine.
 */
53
inline int LMatrix3d::get_num_components(void) const;

3192 10 operator < 0 4 3536 21 LMatrix3d::operator < 0 1 1471 0
64
inline bool LMatrix3d::operator <(LMatrix3d const &other) const;

3193 11 operator == 0 4 3536 22 LMatrix3d::operator == 0 1 1472 0
65
inline bool LMatrix3d::operator ==(LMatrix3d const &other) const;

3194 11 operator != 0 4 3536 22 LMatrix3d::operator != 0 1 1473 0
65
inline bool LMatrix3d::operator !=(LMatrix3d const &other) const;

3195 10 compare_to 0 4 3536 21 LMatrix3d::compare_to 0 2 1474 1475 333
/**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */

/**
 * Sorts matrices lexicographically, componentwise.  Returns a number less
 * than 0 if this matrix sorts before the other one, greater than zero if it
 * sorts after, 0 if they are equivalent (within the indicated tolerance).
 */
138
inline int LMatrix3d::compare_to(LMatrix3d const &other) const;
int LMatrix3d::compare_to(LMatrix3d const &other, double threshold) const;

3196 8 get_hash 0 4 3536 19 LMatrix3d::get_hash 0 2 1476 1477 100
/**
 * Returns a suitable hash for phash_map.
 */

/**
 * Returns a suitable hash for phash_map.
 */
115
inline std::size_t LMatrix3d::get_hash(void) const;
inline std::size_t LMatrix3d::get_hash(double threshold) const;

3197 8 add_hash 0 4 3536 19 LMatrix3d::add_hash 0 2 1478 1479 100
/**
 * Adds the vector into the running hash.
 */

/**
 * Adds the vector into the running hash.
 */
145
inline std::size_t LMatrix3d::add_hash(std::size_t hash) const;
inline std::size_t LMatrix3d::add_hash(std::size_t hash, double threshold) const;

3198 5 xform 0 4 3536 16 LMatrix3d::xform 0 1 1480 52
/**
 * 3-component vector or point times matrix.
 */
62
inline LVecBase3d LMatrix3d::xform(LVecBase3d const &v) const;

3199 11 xform_point 0 4 3536 22 LMatrix3d::xform_point 0 1 1481 162
/**
 * The matrix transforms a 2-component point (including translation component)
 * and returns the result.  This assumes the matrix is an affine transform.
 */
68
inline LVecBase2d LMatrix3d::xform_point(LVecBase2d const &v) const;

3200 9 xform_vec 0 4 3536 20 LMatrix3d::xform_vec 0 2 1482 1483 357
/**
 * The matrix transforms a 2-component vector (without translation component)
 * and returns the result.  This assumes the matrix is an affine transform.
 */

/**
 * The matrix transforms a 3-component vector and returns the result.  This
 * assumes the matrix is an orthonormal transform.
 *
 * In practice, this is the same computation as xform().
 */
133
inline LVecBase2d LMatrix3d::xform_vec(LVecBase2d const &v) const;
inline LVecBase3d LMatrix3d::xform_vec(LVecBase3d const &v) const;

3201 17 xform_vec_general 0 4 3536 28 LMatrix3d::xform_vec_general 0 1 1484 142
/**
 * The matrix transforms a 3-component vector (without translation component)
 * and returns the result, as a fully general operation.
 */
74
inline LVecBase3d LMatrix3d::xform_vec_general(LVecBase3d const &v) const;

3202 14 xform_in_place 0 4 3536 25 LMatrix3d::xform_in_place 0 1 1485 52
/**
 * 3-component vector or point times matrix.
 */
59
inline void LMatrix3d::xform_in_place(LVecBase3d &v) const;

3203 20 xform_point_in_place 0 4 3536 31 LMatrix3d::xform_point_in_place 0 1 1486 139
/**
 * The matrix transforms a 2-component point (including translation
 * component).  This assumes the matrix is an affine transform.
 */
65
inline void LMatrix3d::xform_point_in_place(LVecBase2d &v) const;

3204 18 xform_vec_in_place 0 4 3536 29 LMatrix3d::xform_vec_in_place 0 2 1487 1488 310
/**
 * The matrix transforms a 2-component vector (without translation component).
 * This assumes the matrix is an affine transform.
 */

/**
 * The matrix transforms a 3-component vector.  This assumes the matrix is an
 * orthonormal transform.
 *
 * In practice, this is the same computation as xform().
 */
127
inline void LMatrix3d::xform_vec_in_place(LVecBase2d &v) const;
inline void LMatrix3d::xform_vec_in_place(LVecBase3d &v) const;

3205 26 xform_vec_general_in_place 0 4 3536 37 LMatrix3d::xform_vec_general_in_place 0 1 1489 119
/**
 * The matrix transforms a 3-component vector (without translation component),
 * as a fully general operation.
 */
71
inline void LMatrix3d::xform_vec_general_in_place(LVecBase3d &v) const;

3206 8 multiply 0 4 3536 19 LMatrix3d::multiply 0 1 1490 52
// this = other1 * other2

// this = other1 * other2
82
inline void LMatrix3d::multiply(LMatrix3d const &other1, LMatrix3d const &other2);

3207 10 operator * 0 4 3536 21 LMatrix3d::operator * 0 2 1491 1492 0
130
inline LMatrix3d LMatrix3d::operator *(LMatrix3d const &other) const;
inline LMatrix3d LMatrix3d::operator *(double scalar) const;

3208 10 operator / 0 4 3536 21 LMatrix3d::operator / 0 1 1493 0
60
inline LMatrix3d LMatrix3d::operator /(double scalar) const;

3209 11 operator += 0 4 3536 22 LMatrix3d::operator += 0 1 1494 63
/**
 * Performs a memberwise addition between two matrices.
 */
65
inline LMatrix3d &LMatrix3d::operator +=(LMatrix3d const &other);

3210 11 operator -= 0 4 3536 22 LMatrix3d::operator -= 0 1 1495 66
/**
 * Performs a memberwise subtraction between two matrices.
 */
65
inline LMatrix3d &LMatrix3d::operator -=(LMatrix3d const &other);

3211 11 operator *= 0 4 3536 22 LMatrix3d::operator *= 0 2 1496 1497 51
/**
 *
 */

/**
 * Performs a memberwise scale.
 */
122
inline LMatrix3d &LMatrix3d::operator *=(LMatrix3d const &other);
inline LMatrix3d &LMatrix3d::operator *=(double scalar);

3212 11 operator /= 0 4 3536 22 LMatrix3d::operator /= 0 1 1498 39
/**
 * Performs a memberwise scale.
 */
56
inline LMatrix3d &LMatrix3d::operator /=(double scalar);

3213 18 componentwise_mult 0 4 3536 29 LMatrix3d::componentwise_mult 0 1 1499 10
/**
 *
 */
66
inline void LMatrix3d::componentwise_mult(LMatrix3d const &other);

3214 11 determinant 0 4 3536 22 LMatrix3d::determinant 0 1 1500 49
/**
 * Returns the determinant of the matrix.
 */
49
inline double LMatrix3d::determinant(void) const;

3215 14 transpose_from 0 4 3536 25 LMatrix3d::transpose_from 0 1 1501 10
/**
 *
 */
62
inline void LMatrix3d::transpose_from(LMatrix3d const &other);

3216 18 transpose_in_place 0 4 3536 29 LMatrix3d::transpose_in_place 0 1 1502 10
/**
 *
 */
48
inline void LMatrix3d::transpose_in_place(void);

3217 11 invert_from 0 4 3536 22 LMatrix3d::invert_from 0 1 1503 463
/**
 * Computes the inverse of the other matrix, and stores the result in this
 * matrix.  This is a fully general operation and makes no assumptions about
 * the type of transform represented by the matrix.
 *
 * The other matrix must be a different object than this matrix.  However, if
 * you need to invert a matrix in place, see invert_in_place.
 *
 * The return value is true if the matrix was successfully inverted, false if
 * there was a singularity.
 */
59
inline bool LMatrix3d::invert_from(LMatrix3d const &other);

3218 15 invert_in_place 0 4 3536 26 LMatrix3d::invert_in_place 0 1 1504 119
/**
 * Inverts the current matrix.  Returns true if the inverse is successful,
 * false if the matrix was singular.
 */
45
inline bool LMatrix3d::invert_in_place(void);

3219 21 invert_transpose_from 0 4 3536 32 LMatrix3d::invert_transpose_from 0 2 1505 1506 230
/**
 * Simultaneously computes the inverse of the indicated matrix, and then the
 * transpose of that inverse.
 */

/**
 * Simultaneously computes the inverse of the indicated matrix, and then the
 * transpose of that inverse.
 */
139
inline bool LMatrix3d::invert_transpose_from(LMatrix3d const &other);
inline bool LMatrix3d::invert_transpose_from(LMatrix4d const &other);

3220 9 ident_mat 0 4 3536 20 LMatrix3d::ident_mat 0 1 1507 147
/**
 * Returns an identity matrix.
 *
 * This function definition must appear first, since some inline functions
 * below take advantage of it.
 */
58
static inline LMatrix3d const &LMatrix3d::ident_mat(void);

3221 17 set_translate_mat 0 4 3536 28 LMatrix3d::set_translate_mat 0 1 1508 74
/**
 * Fills mat with a matrix that applies the indicated translation.
 */
66
inline void LMatrix3d::set_translate_mat(LVecBase2d const &trans);

3222 14 set_rotate_mat 0 4 3536 25 LMatrix3d::set_rotate_mat 0 2 1509 1510 225
/**
 * Fills mat with a matrix that rotates by the given angle in degrees
 * counterclockwise.
 */

/**
 * Fills mat with a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.
 */
158
inline void LMatrix3d::set_rotate_mat(double angle);
void LMatrix3d::set_rotate_mat(double angle, LVecBase3d const &axis, CoordinateSystem cs = ::CS_default);

3223 13 set_scale_mat 0 4 3536 24 LMatrix3d::set_scale_mat 0 2 1511 1512 194
/**
 * Fills mat with a matrix that applies the indicated scale in each of the two
 * axes.
 */

/**
 * Fills mat with a matrix that applies the indicated scale in each of the
 * three axes.
 */
125
inline void LMatrix3d::set_scale_mat(LVecBase2d const &scale);
inline void LMatrix3d::set_scale_mat(LVecBase3d const &scale);

3224 13 translate_mat 0 4 3536 24 LMatrix3d::translate_mat 0 2 1513 1514 136
/**
 * Returns a matrix that applies the indicated translation.
 */

/**
 * Returns a matrix that applies the indicated translation.
 */
146
static inline LMatrix3d LMatrix3d::translate_mat(LVecBase2d const &trans);
static inline LMatrix3d LMatrix3d::translate_mat(double tx, double ty);

3225 10 rotate_mat 0 4 3536 21 LMatrix3d::rotate_mat 0 2 1515 1516 211
/**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise.
 */

/**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.
 */
181
static inline LMatrix3d LMatrix3d::rotate_mat(double angle);
static inline LMatrix3d LMatrix3d::rotate_mat(double angle, LVecBase3d const &axis, CoordinateSystem cs = ::CS_default);

3226 9 scale_mat 0 4 3536 20 LMatrix3d::scale_mat 0 4 1517 1518 1519 1520 356
/**
 * Returns a matrix that applies the indicated scale in each of the two axes.
 */

/**
 * Returns a matrix that applies the indicated scale in each of the two axes.
 */

/**
 * Returns a matrix that applies the indicated scale in each of the three
 * axes.
 */

/**
 * Returns a matrix that applies the indicated scale in each of the three
 * axes.
 */
288
static inline LMatrix3d LMatrix3d::scale_mat(LVecBase2d const &scale);
static inline LMatrix3d LMatrix3d::scale_mat(double sx, double sy);
static inline LMatrix3d LMatrix3d::scale_mat(LVecBase3d const &scale);
static inline LMatrix3d LMatrix3d::scale_mat(double sx, double sy, double sz);

3227 23 set_rotate_mat_normaxis 0 4 3536 34 LMatrix3d::set_rotate_mat_normaxis 0 1 1521 163
/**
 * Fills mat with a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.  Assumes axis has been
 * normalized.
 */
114
void LMatrix3d::set_rotate_mat_normaxis(double angle, LVecBase3d const &axis, CoordinateSystem cs = ::CS_default);

3228 19 rotate_mat_normaxis 0 4 3536 30 LMatrix3d::rotate_mat_normaxis 0 1 1522 156
/**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.  Assumes axis has been
 * normalized.
 */
129
static inline LMatrix3d LMatrix3d::rotate_mat_normaxis(double angle, LVecBase3d const &axis, CoordinateSystem cs = ::CS_default);

3229 13 set_shear_mat 0 4 3536 24 LMatrix3d::set_shear_mat 0 1 1523 99
/**
 * Fills mat with a matrix that applies the indicated shear in each of the
 * three planes.
 */
98
inline void LMatrix3d::set_shear_mat(LVecBase3d const &shear, CoordinateSystem cs = ::CS_default);

3230 9 shear_mat 0 4 3536 20 LMatrix3d::shear_mat 0 2 1524 1525 186
/**
 * Returns a matrix that applies the indicated shear in each of the three
 * planes.
 */

/**
 * Returns a matrix that applies the indicated shear in each of the three
 * planes.
 */
227
static inline LMatrix3d LMatrix3d::shear_mat(LVecBase3d const &shear, CoordinateSystem cs = ::CS_default);
static inline LMatrix3d LMatrix3d::shear_mat(double shxy, double shxz, double shyz, CoordinateSystem cs = ::CS_default);

3231 19 set_scale_shear_mat 0 4 3536 30 LMatrix3d::set_scale_shear_mat 0 1 1526 78
/**
 * Fills mat with a matrix that applies the indicated scale and shear.
 */
122
void LMatrix3d::set_scale_shear_mat(LVecBase3d const &scale, LVecBase3d const &shear, CoordinateSystem cs = ::CS_default);

3232 15 scale_shear_mat 0 4 3536 26 LMatrix3d::scale_shear_mat 0 2 1527 1528 144
/**
 * Returns a matrix that applies the indicated scale and shear.
 */

/**
 * Returns a matrix that applies the indicated scale and shear.
 */
297
static inline LMatrix3d LMatrix3d::scale_shear_mat(LVecBase3d const &scale, LVecBase3d const &shear, CoordinateSystem cs = ::CS_default);
static inline LMatrix3d LMatrix3d::scale_shear_mat(double sx, double sy, double sz, double shxy, double shxz, double shyz, CoordinateSystem cs = ::CS_default);

3233 11 convert_mat 0 4 3536 22 LMatrix3d::convert_mat 0 1 1529 119
/**
 * Returns a matrix that transforms from the indicated coordinate system to
 * the indicated coordinate system.
 */
91
static LMatrix3d const &LMatrix3d::convert_mat(CoordinateSystem from, CoordinateSystem to);

3234 12 almost_equal 0 4 3536 23 LMatrix3d::almost_equal 0 2 1530 1531 212
/**
 * Returns true if two matrices are memberwise equal within a default
 * tolerance based on the numeric type.
 */

/**
 * Returns true if two matrices are memberwise equal within a specified
 * tolerance.
 */
144
bool LMatrix3d::almost_equal(LMatrix3d const &other, double threshold) const;
inline bool LMatrix3d::almost_equal(LMatrix3d const &other) const;

3235 6 output 0 4 3536 17 LMatrix3d::output 0 1 1532 10
/**
 *
 */
43
void LMatrix3d::output(ostream &out) const;

3236 5 write 0 4 3536 16 LMatrix3d::write 0 1 1533 10
/**
 *
 */
64
void LMatrix3d::write(ostream &out, int indent_level = 0) const;

3237 8 __repr__ 0 4 3536 19 LMatrix3d::__repr__ 0 1 1534 0
51
inline std::string LMatrix3d::__repr__(void) const;

3238 13 generate_hash 0 4 3536 24 LMatrix3d::generate_hash 0 2 1535 1536 120
/**
 * Adds the vector to the indicated hash generator.
 */

/**
 * Adds the vector to the indicated hash generator.
 */
162
inline void LMatrix3d::generate_hash(ChecksumHashGenerator &hashgen) const;
void LMatrix3d::generate_hash(ChecksumHashGenerator &hashgen, double threshold) const;

3239 20 write_datagram_fixed 0 4 3536 31 LMatrix3d::write_datagram_fixed 0 1 1537 332
/**
 * Writes the matrix to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the matrix, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */
66
void LMatrix3d::write_datagram_fixed(Datagram &destination) const;

3240 19 read_datagram_fixed 0 4 3536 30 LMatrix3d::read_datagram_fixed 0 1 1538 114
/**
 * Reads the matrix from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */
60
void LMatrix3d::read_datagram_fixed(DatagramIterator &scan);

3241 14 write_datagram 0 4 3536 25 LMatrix3d::write_datagram 0 1 1539 205
/**
 * Writes the matrix to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the matrix using the standard width
 * setting, especially when you are writing a bam file.
 */
60
void LMatrix3d::write_datagram(Datagram &destination) const;

3242 13 read_datagram 0 4 3536 24 LMatrix3d::read_datagram 0 1 1540 67
/**
 * Reads the matrix from the Datagram using get_stdfloat().
 */
56
void LMatrix3d::read_datagram(DatagramIterator &source);

3243 14 get_class_type 0 4 3536 25 LMatrix3d::get_class_type 0 1 1541 0
50
static TypeHandle LMatrix3d::get_class_type(void);

3244 10 ~LMatrix3d 0 4 3536 21 LMatrix3d::~LMatrix3d 0 0 0
28
LMatrix3d::~LMatrix3d(void);

3245 11 operator [] 0 4 3542 27 LMatrix4d::Row::operator [] 0 2 1660 1661 10
/**
 *
 */
106
inline double LMatrix4d::Row::operator [](int i) const;
inline double &LMatrix4d::Row::operator [](int i);

3246 4 size 0 4 3542 20 LMatrix4d::Row::size 0 1 1662 58
/**
 * Returns 4: the number of columns of a LMatrix4.
 */
45
static inline int LMatrix4d::Row::size(void);

3247 3 Row 0 4 3542 19 LMatrix4d::Row::Row 0 1 1659 60
/**
 * Defines a row-level index accessor to the matrix.
 */
61
inline LMatrix4d::Row::Row(LMatrix4d::Row const &) = default;

3248 4 ~Row 0 4 3542 20 LMatrix4d::Row::~Row 0 0 0
27
LMatrix4d::Row::~Row(void);

3249 11 operator [] 0 4 3543 28 LMatrix4d::CRow::operator [] 0 1 1664 0
56
inline double LMatrix4d::CRow::operator [](int i) const;

3250 4 size 0 4 3543 21 LMatrix4d::CRow::size 0 1 1665 58
/**
 * Returns 4: the number of columns of a LMatrix4.
 */
46
static inline int LMatrix4d::CRow::size(void);

3251 4 CRow 0 4 3543 21 LMatrix4d::CRow::CRow 0 1 1663 63
/**
 * Defines a row-level constant accessor to the matrix.
 */
64
inline LMatrix4d::CRow::CRow(LMatrix4d::CRow const &) = default;

3252 5 ~CRow 0 4 3543 22 LMatrix4d::CRow::~CRow 0 0 0
29
LMatrix4d::CRow::~CRow(void);

3253 9 LMatrix4d 0 4 3540 20 LMatrix4d::LMatrix4d 0 6 1549 1550 1551 1552 1553 1554 167
// Construct a 4x4 matrix given a 3x3 rotation matrix and an optional
// translation component.

/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */
503
inline LMatrix4d::LMatrix4d(void);
inline LMatrix4d::LMatrix4d(LMatrix4d const &other);
inline LMatrix4d::LMatrix4d(UnalignedLMatrix4d const &other);
inline LMatrix4d::LMatrix4d(double e00, double e01, double e02, double e03, double e10, double e11, double e12, double e13, double e20, double e21, double e22, double e23, double e30, double e31, double e32, double e33);
inline LMatrix4d::LMatrix4d(LMatrix3d const &upper3);
inline LMatrix4d::LMatrix4d(LMatrix3d const &upper3, LVecBase3d const &trans);

3254 10 operator = 0 4 3540 21 LMatrix4d::operator = 0 3 1555 1556 1557 34
/**
 *
 */

/**
 *
 */

/**
 *
 */
198
inline LMatrix4d &LMatrix4d::operator =(LMatrix4d const &other);
inline LMatrix4d &LMatrix4d::operator =(UnalignedLMatrix4d const &other);
inline LMatrix4d &LMatrix4d::operator =(double fill_value);

3255 12 operator new 0 4 3540 23 LMatrix4d::operator new 0 1 1558 0
122
inline void *LMatrix4d::operator new(std::size_t size);
inline void *LMatrix4d::operator new(std::size_t size, void *ptr);

3256 15 operator delete 0 4 3540 26 LMatrix4d::operator delete 0 0 0
106
inline void LMatrix4d::operator delete(void *ptr);
inline void LMatrix4d::operator delete(void *, void *);

3257 12 validate_ptr 0 4 3540 23 LMatrix4d::validate_ptr 0 0 0
60
static inline bool LMatrix4d::validate_ptr(void const *ptr);

3258 10 __reduce__ 0 4 3540 21 LMatrix4d::__reduce__ 0 1 1559 0
61
inline PyObject *LMatrix4d::__reduce__(PyObject *self) const;

3259 4 fill 0 4 3540 15 LMatrix4d::fill 0 1 1560 157
/**
 * Sets each element of the matrix to the indicated fill_value.  This is of
 * questionable value, but is sometimes useful when initializing to zero.
 */
47
inline void LMatrix4d::fill(double fill_value);

3260 3 set 0 4 3540 14 LMatrix4d::set 0 1 1561 10
/**
 *
 */
219
inline void LMatrix4d::set(double e00, double e01, double e02, double e03, double e10, double e11, double e12, double e13, double e20, double e21, double e22, double e23, double e30, double e31, double e32, double e33);

3261 11 set_upper_3 0 4 3540 22 LMatrix4d::set_upper_3 0 1 1562 87
// Get and set the upper 3x3 rotation matrix.

/**
 * Sets the upper 3x3 submatrix.
 */
60
inline void LMatrix4d::set_upper_3(LMatrix3d const &upper3);

3262 11 get_upper_3 0 4 3540 22 LMatrix4d::get_upper_3 0 1 1563 45
/**
 * Retrieves the upper 3x3 submatrix.
 */
52
inline LMatrix3d LMatrix4d::get_upper_3(void) const;

3263 11 operator [] 0 4 3540 22 LMatrix4d::operator [] 0 2 1564 1565 0
112
inline LMatrix4d::CRow LMatrix4d::operator [](int i) const;
inline LMatrix4d::Row LMatrix4d::operator [](int i);

3264 4 size 0 4 3540 15 LMatrix4d::size 0 1 1566 55
/**
 * Returns 4: the number of rows of a LMatrix4.
 */
40
static inline int LMatrix4d::size(void);

3265 7 set_row 0 4 3540 18 LMatrix4d::set_row 0 2 1567 1568 173
/**
 * Replaces the indicated row of the matrix.
 */

/**
 * Replaces the indicated row of the matrix with the indicated 3-component
 * vector, ignoring the last column.
 */
123
inline void LMatrix4d::set_row(int row, LVecBase4d const &v);
inline void LMatrix4d::set_row(int row, LVecBase3d const &v);

3266 7 set_col 0 4 3540 18 LMatrix4d::set_col 0 2 1569 1570 176
/**
 * Replaces the indicated column of the matrix.
 */

/**
 * Replaces the indicated column of the matrix with the indicated 3-component
 * vector, ignoring the last row.
 */
123
inline void LMatrix4d::set_col(int col, LVecBase4d const &v);
inline void LMatrix4d::set_col(int col, LVecBase3d const &v);

3267 7 get_row 0 4 3540 18 LMatrix4d::get_row 0 2 1571 1572 186
// these versions inline better

/**
 * Retrieves the indicated row of the matrix as a 4-component vector.
 */

/**
 * Stores the indicated row of the matrix as a 4-component vector.
 */
123
inline LVecBase4d LMatrix4d::get_row(int row) const;
inline void LMatrix4d::get_row(LVecBase4d &result_vec, int row) const;

3268 7 get_col 0 4 3540 18 LMatrix4d::get_col 0 1 1573 80
/**
 * Retrieves the indicated column of the matrix as a 4-component vector.
 */
52
inline LVecBase4d LMatrix4d::get_col(int col) const;

3269 8 get_row3 0 4 3540 19 LMatrix4d::get_row3 0 2 1574 1575 205
/**
 * Retrieves the row column of the matrix as a 3-component vector, ignoring
 * the last column.
 */

/**
 * Stores the row column of the matrix as a 3-component vector, ignoring the
 * last column.
 */
125
inline LVecBase3d LMatrix4d::get_row3(int row) const;
inline void LMatrix4d::get_row3(LVecBase3d &result_vec, int row) const;

3270 0 0 0 0 0 0 0 0
0

3271 0 0 0 0 0 0 0 0
0

3272 8 get_col3 0 4 3540 19 LMatrix4d::get_col3 0 1 1576 106
/**
 * Retrieves the indicated column of the matrix as a 3-component vector,
 * ignoring the last row.
 */
53
inline LVecBase3d LMatrix4d::get_col3(int col) const;

3273 11 operator () 0 4 3540 22 LMatrix4d::operator () 0 2 1577 1578 10
/**
 *
 */
118
inline double &LMatrix4d::operator ()(int row, int col);
inline double LMatrix4d::operator ()(int row, int col) const;

3274 6 is_nan 0 4 3540 17 LMatrix4d::is_nan 0 1 1579 91
/**
 * Returns true if any component of the matrix is not-a-number, false
 * otherwise.
 */
42
inline bool LMatrix4d::is_nan(void) const;

3275 11 is_identity 0 4 3540 22 LMatrix4d::is_identity 0 1 1580 93
/**
 * Returns true if this is (close enough to) the identity matrix, false
 * otherwise.
 */
47
inline bool LMatrix4d::is_identity(void) const;

3276 8 get_cell 0 4 3540 19 LMatrix4d::get_cell 0 1 1581 54
/**
 * Returns a particular element of the matrix.
 */
58
inline double LMatrix4d::get_cell(int row, int col) const;

3277 8 set_cell 0 4 3540 19 LMatrix4d::set_cell 0 1 1582 54
/**
 * Changes a particular element of the matrix.
 */
64
inline void LMatrix4d::set_cell(int row, int col, double value);

3278 8 get_data 0 4 3540 19 LMatrix4d::get_data 0 1 1583 162
/**
 * Returns the address of the first of the nine data elements in the matrix.
 * The remaining elements occupy the next eight positions in row-major order.
 */
53
inline double const *LMatrix4d::get_data(void) const;

3279 18 get_num_components 0 4 3540 29 LMatrix4d::get_num_components 0 1 1584 60
/**
 * Returns the number of elements in the matrix, 16.
 */
53
inline int LMatrix4d::get_num_components(void) const;

3280 5 begin 0 4 3540 16 LMatrix4d::begin 0 2 1585 1586 204
/**
 * Returns an iterator that may be used to traverse the elements of the
 * matrix, STL-style.
 */

/**
 * Returns an iterator that may be used to traverse the elements of the
 * matrix, STL-style.
 */
113
inline LMatrix4d::iterator LMatrix4d::begin(void);
inline LMatrix4d::const_iterator LMatrix4d::begin(void) const;

3281 3 end 0 4 3540 14 LMatrix4d::end 0 2 1587 1588 204
/**
 * Returns an iterator that may be used to traverse the elements of the
 * matrix, STL-style.
 */

/**
 * Returns an iterator that may be used to traverse the elements of the
 * matrix, STL-style.
 */
109
inline LMatrix4d::iterator LMatrix4d::end(void);
inline LMatrix4d::const_iterator LMatrix4d::end(void) const;

3282 10 operator < 0 4 3540 21 LMatrix4d::operator < 0 1 1589 0
64
inline bool LMatrix4d::operator <(LMatrix4d const &other) const;

3283 11 operator == 0 4 3540 22 LMatrix4d::operator == 0 1 1590 0
65
inline bool LMatrix4d::operator ==(LMatrix4d const &other) const;

3284 11 operator != 0 4 3540 22 LMatrix4d::operator != 0 1 1591 0
65
inline bool LMatrix4d::operator !=(LMatrix4d const &other) const;

3285 10 compare_to 0 4 3540 21 LMatrix4d::compare_to 0 2 1592 1593 333
/**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */

/**
 * Sorts matrices lexicographically, componentwise.  Returns a number less
 * than 0 if this matrix sorts before the other one, greater than zero if it
 * sorts after, 0 if they are equivalent (within the indicated tolerance).
 */
138
inline int LMatrix4d::compare_to(LMatrix4d const &other) const;
int LMatrix4d::compare_to(LMatrix4d const &other, double threshold) const;

3286 8 get_hash 0 4 3540 19 LMatrix4d::get_hash 0 2 1594 1595 100
/**
 * Returns a suitable hash for phash_map.
 */

/**
 * Returns a suitable hash for phash_map.
 */
115
inline std::size_t LMatrix4d::get_hash(void) const;
inline std::size_t LMatrix4d::get_hash(double threshold) const;

3287 8 add_hash 0 4 3540 19 LMatrix4d::add_hash 0 2 1596 1597 100
/**
 * Adds the vector into the running hash.
 */

/**
 * Adds the vector into the running hash.
 */
145
inline std::size_t LMatrix4d::add_hash(std::size_t hash) const;
inline std::size_t LMatrix4d::add_hash(std::size_t hash, double threshold) const;

3288 5 xform 0 4 3540 16 LMatrix4d::xform 0 1 1598 91
/**
 * 4-component vector or point times matrix.  This is a fully general
 * operation.
 */
62
inline LVecBase4d LMatrix4d::xform(LVecBase4d const &v) const;

3289 11 xform_point 0 4 3540 22 LMatrix4d::xform_point 0 1 1599 162
/**
 * The matrix transforms a 3-component point (including translation component)
 * and returns the result.  This assumes the matrix is an affine transform.
 */
68
inline LVecBase3d LMatrix4d::xform_point(LVecBase3d const &v) const;

3290 19 xform_point_general 0 4 3540 30 LMatrix4d::xform_point_general 0 1 1600 143
/**
 * The matrix transforms a 3-component point (including translation component)
 * and returns the result, as a fully general operation.
 */
76
inline LVecBase3d LMatrix4d::xform_point_general(LVecBase3d const &v) const;

3291 9 xform_vec 0 4 3540 20 LMatrix4d::xform_vec 0 1 1601 169
/**
 * The matrix transforms a 3-component vector (without translation component)
 * and returns the result.  This assumes the matrix is an orthonormal
 * transform.
 */
66
inline LVecBase3d LMatrix4d::xform_vec(LVecBase3d const &v) const;

3292 17 xform_vec_general 0 4 3540 28 LMatrix4d::xform_vec_general 0 1 1602 142
/**
 * The matrix transforms a 3-component vector (without translation component)
 * and returns the result, as a fully general operation.
 */
74
inline LVecBase3d LMatrix4d::xform_vec_general(LVecBase3d const &v) const;

3293 14 xform_in_place 0 4 3540 25 LMatrix4d::xform_in_place 0 1 1603 91
/**
 * 4-component vector or point times matrix.  This is a fully general
 * operation.
 */
59
inline void LMatrix4d::xform_in_place(LVecBase4d &v) const;

3294 20 xform_point_in_place 0 4 3540 31 LMatrix4d::xform_point_in_place 0 1 1604 139
/**
 * The matrix transforms a 3-component point (including translation
 * component).  This assumes the matrix is an affine transform.
 */
65
inline void LMatrix4d::xform_point_in_place(LVecBase3d &v) const;

3295 28 xform_point_general_in_place 0 4 3540 39 LMatrix4d::xform_point_general_in_place 0 1 1605 120
/**
 * The matrix transforms a 3-component point (including translation
 * component), as a fully general operation.
 */
73
inline void LMatrix4d::xform_point_general_in_place(LVecBase3d &v) const;

3296 18 xform_vec_in_place 0 4 3540 29 LMatrix4d::xform_vec_in_place 0 1 1606 142
/**
 * The matrix transforms a 3-component vector (without translation component).
 * This assumes the matrix is an orthonormal transform.
 */
63
inline void LMatrix4d::xform_vec_in_place(LVecBase3d &v) const;

3297 26 xform_vec_general_in_place 0 4 3540 37 LMatrix4d::xform_vec_general_in_place 0 1 1607 119
/**
 * The matrix transforms a 3-component vector (without translation component),
 * as a fully general operation.
 */
71
inline void LMatrix4d::xform_vec_general_in_place(LVecBase3d &v) const;

3298 8 multiply 0 4 3540 19 LMatrix4d::multiply 0 1 1608 52
// this = other1 * other2

// this = other1 * other2
82
inline void LMatrix4d::multiply(LMatrix4d const &other1, LMatrix4d const &other2);

3299 10 operator * 0 4 3540 21 LMatrix4d::operator * 0 2 1609 1610 0
130
inline LMatrix4d LMatrix4d::operator *(LMatrix4d const &other) const;
inline LMatrix4d LMatrix4d::operator *(double scalar) const;

3300 10 operator / 0 4 3540 21 LMatrix4d::operator / 0 1 1611 0
60
inline LMatrix4d LMatrix4d::operator /(double scalar) const;

3301 11 operator += 0 4 3540 22 LMatrix4d::operator += 0 1 1612 63
/**
 * Performs a memberwise addition between two matrices.
 */
65
inline LMatrix4d &LMatrix4d::operator +=(LMatrix4d const &other);

3302 11 operator -= 0 4 3540 22 LMatrix4d::operator -= 0 1 1613 63
/**
 * Performs a memberwise addition between two matrices.
 */
65
inline LMatrix4d &LMatrix4d::operator -=(LMatrix4d const &other);

3303 11 operator *= 0 4 3540 22 LMatrix4d::operator *= 0 2 1614 1615 22
/**
 *
 */

/**
 *
 */
122
inline LMatrix4d &LMatrix4d::operator *=(LMatrix4d const &other);
inline LMatrix4d &LMatrix4d::operator *=(double scalar);

3304 11 operator /= 0 4 3540 22 LMatrix4d::operator /= 0 1 1616 10
/**
 *
 */
56
inline LMatrix4d &LMatrix4d::operator /=(double scalar);

3305 18 componentwise_mult 0 4 3540 29 LMatrix4d::componentwise_mult 0 1 1617 10
/**
 *
 */
66
inline void LMatrix4d::componentwise_mult(LMatrix4d const &other);

3306 14 transpose_from 0 4 3540 25 LMatrix4d::transpose_from 0 1 1618 10
/**
 *
 */
62
inline void LMatrix4d::transpose_from(LMatrix4d const &other);

3307 18 transpose_in_place 0 4 3540 29 LMatrix4d::transpose_in_place 0 1 1619 10
/**
 *
 */
48
inline void LMatrix4d::transpose_in_place(void);

3308 11 invert_from 0 4 3540 22 LMatrix4d::invert_from 0 1 1620 461
/**
 * Computes the inverse of the other matrix, and stores the result in this
 * matrix.  This is a fully general operation and makes no assumptions about
 * the type of transform represented by the matrix.
 *
 * The other matrix must be a different object than this matrix.  However, if
 * you need to invert a matrix in place, see invert_in_place.
 *
 * The return value is true if the matrix was successfully inverted, false if
 * the was a singularity.
 */
59
inline bool LMatrix4d::invert_from(LMatrix4d const &other);

3309 18 invert_affine_from 0 4 3540 29 LMatrix4d::invert_affine_from 0 1 1621 139
// bugbug: we could optimize this for rotationscaletranslation matrices
// (transpose upper 3x3 and take negative of translation component)
66
inline bool LMatrix4d::invert_affine_from(LMatrix4d const &other);

3310 15 invert_in_place 0 4 3540 26 LMatrix4d::invert_in_place 0 1 1622 119
/**
 * Inverts the current matrix.  Returns true if the inverse is successful,
 * false if the matrix was singular.
 */
45
inline bool LMatrix4d::invert_in_place(void);

3311 10 accumulate 0 4 3540 21 LMatrix4d::accumulate 0 1 1623 46
/**
 * Computes (*this) += other * weight.
 */
73
inline void LMatrix4d::accumulate(LMatrix4d const &other, double weight);

3312 9 ident_mat 0 4 3540 20 LMatrix4d::ident_mat 0 1 1624 147
/**
 * Returns an identity matrix.
 *
 * This function definition must appear first, since some inline functions
 * below take advantage of it.
 */
58
static inline LMatrix4d const &LMatrix4d::ident_mat(void);

3313 8 ones_mat 0 4 3540 19 LMatrix4d::ones_mat 0 1 1625 46
/**
 * Returns an matrix filled with ones.
 */
57
static inline LMatrix4d const &LMatrix4d::ones_mat(void);

3314 9 zeros_mat 0 4 3540 20 LMatrix4d::zeros_mat 0 1 1626 47
/**
 * Returns an matrix filled with zeros.
 */
58
static inline LMatrix4d const &LMatrix4d::zeros_mat(void);

3315 17 set_translate_mat 0 4 3540 28 LMatrix4d::set_translate_mat 0 1 1627 74
/**
 * Fills mat with a matrix that applies the indicated translation.
 */
66
inline void LMatrix4d::set_translate_mat(LVecBase3d const &trans);

3316 14 set_rotate_mat 0 4 3540 25 LMatrix4d::set_rotate_mat 0 1 1628 122
/**
 * Sets mat to a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.
 */
105
void LMatrix4d::set_rotate_mat(double angle, LVecBase3d const &axis, CoordinateSystem cs = ::CS_default);

3317 23 set_rotate_mat_normaxis 0 4 3540 34 LMatrix4d::set_rotate_mat_normaxis 0 1 1629 166
/**
 * Fills mat with a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.  Assumes axis has been
 * prenormalized.
 */
114
void LMatrix4d::set_rotate_mat_normaxis(double angle, LVecBase3d const &axis, CoordinateSystem cs = ::CS_default);

3318 13 set_scale_mat 0 4 3540 24 LMatrix4d::set_scale_mat 0 1 1630 97
/**
 * Fills mat with a matrix that applies the indicated scale in each of the
 * three axes.
 */
62
inline void LMatrix4d::set_scale_mat(LVecBase3d const &scale);

3319 13 set_shear_mat 0 4 3540 24 LMatrix4d::set_shear_mat 0 1 1631 99
/**
 * Fills mat with a matrix that applies the indicated shear in each of the
 * three planes.
 */
98
inline void LMatrix4d::set_shear_mat(LVecBase3d const &shear, CoordinateSystem cs = ::CS_default);

3320 19 set_scale_shear_mat 0 4 3540 30 LMatrix4d::set_scale_shear_mat 0 1 1632 78
/**
 * Fills mat with a matrix that applies the indicated scale and shear.
 */
129
inline void LMatrix4d::set_scale_shear_mat(LVecBase3d const &scale, LVecBase3d const &shear, CoordinateSystem cs = ::CS_default);

3321 13 translate_mat 0 4 3540 24 LMatrix4d::translate_mat 0 2 1633 1634 136
/**
 * Returns a matrix that applies the indicated translation.
 */

/**
 * Returns a matrix that applies the indicated translation.
 */
157
static inline LMatrix4d LMatrix4d::translate_mat(LVecBase3d const &trans);
static inline LMatrix4d LMatrix4d::translate_mat(double tx, double ty, double tz);

3322 10 rotate_mat 0 4 3540 21 LMatrix4d::rotate_mat 0 1 1635 118
/**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.
 */
120
static inline LMatrix4d LMatrix4d::rotate_mat(double angle, LVecBase3d const &axis, CoordinateSystem cs = ::CS_default);

3323 19 rotate_mat_normaxis 0 4 3540 30 LMatrix4d::rotate_mat_normaxis 0 1 1636 159
/**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.  Assumes axis has been
 * prenormalized.
 */
129
static inline LMatrix4d LMatrix4d::rotate_mat_normaxis(double angle, LVecBase3d const &axis, CoordinateSystem cs = ::CS_default);

3324 9 scale_mat 0 4 3540 20 LMatrix4d::scale_mat 0 3 1637 1638 1639 253
/**
 * Returns a matrix that applies the indicated scale in each of the three
 * axes.
 */

/**
 * Returns a matrix that applies the indicated scale in each of the three
 * axes.
 */

/**
 * Returns a matrix that applies the indicated uniform scale.
 */
209
static inline LMatrix4d LMatrix4d::scale_mat(LVecBase3d const &scale);
static inline LMatrix4d LMatrix4d::scale_mat(double sx, double sy, double sz);
static inline LMatrix4d LMatrix4d::scale_mat(double scale);

3325 9 shear_mat 0 4 3540 20 LMatrix4d::shear_mat 0 2 1640 1641 186
/**
 * Returns a matrix that applies the indicated shear in each of the three
 * planes.
 */

/**
 * Returns a matrix that applies the indicated shear in each of the three
 * planes.
 */
227
static inline LMatrix4d LMatrix4d::shear_mat(LVecBase3d const &shear, CoordinateSystem cs = ::CS_default);
static inline LMatrix4d LMatrix4d::shear_mat(double shxy, double shxz, double shyz, CoordinateSystem cs = ::CS_default);

3326 15 scale_shear_mat 0 4 3540 26 LMatrix4d::scale_shear_mat 0 2 1642 1643 144
/**
 * Returns a matrix that applies the indicated scale and shear.
 */

/**
 * Returns a matrix that applies the indicated scale and shear.
 */
297
static inline LMatrix4d LMatrix4d::scale_shear_mat(LVecBase3d const &scale, LVecBase3d const &shear, CoordinateSystem cs = ::CS_default);
static inline LMatrix4d LMatrix4d::scale_shear_mat(double sx, double sy, double sz, double shxy, double shxz, double shyz, CoordinateSystem cs = ::CS_default);

3327 13 y_to_z_up_mat 0 4 3540 24 LMatrix4d::y_to_z_up_mat 0 1 1644 109
/**
 * Returns a matrix that transforms from the Y-up coordinate system to the
 * Z-up coordinate system.
 */
62
static inline LMatrix4d const &LMatrix4d::y_to_z_up_mat(void);

3328 13 z_to_y_up_mat 0 4 3540 24 LMatrix4d::z_to_y_up_mat 0 1 1645 109
/**
 * Returns a matrix that transforms from the Y-up coordinate system to the
 * Z-up coordinate system.
 */
62
static inline LMatrix4d const &LMatrix4d::z_to_y_up_mat(void);

3329 11 convert_mat 0 4 3540 22 LMatrix4d::convert_mat 0 1 1646 119
/**
 * Returns a matrix that transforms from the indicated coordinate system to
 * the indicated coordinate system.
 */
91
static LMatrix4d const &LMatrix4d::convert_mat(CoordinateSystem from, CoordinateSystem to);

3330 12 almost_equal 0 4 3540 23 LMatrix4d::almost_equal 0 2 1647 1648 318
/**
 * Returns true if two matrices are memberwise equal within a default
 * tolerance based on the numeric type.
 */

/**
 * Returns true if two matrices are memberwise equal within a specified
 * tolerance.  This is faster than the equivalence operator as this doesn't
 * have to guarantee that it is transitive.
 */
144
bool LMatrix4d::almost_equal(LMatrix4d const &other, double threshold) const;
inline bool LMatrix4d::almost_equal(LMatrix4d const &other) const;

3331 6 output 0 4 3540 17 LMatrix4d::output 0 1 1649 10
/**
 *
 */
43
void LMatrix4d::output(ostream &out) const;

3332 5 write 0 4 3540 16 LMatrix4d::write 0 1 1650 10
/**
 *
 */
64
void LMatrix4d::write(ostream &out, int indent_level = 0) const;

3333 8 __repr__ 0 4 3540 19 LMatrix4d::__repr__ 0 1 1651 0
51
inline std::string LMatrix4d::__repr__(void) const;

3334 13 generate_hash 0 4 3540 24 LMatrix4d::generate_hash 0 2 1652 1653 120
/**
 * Adds the vector to the indicated hash generator.
 */

/**
 * Adds the vector to the indicated hash generator.
 */
158
inline void LMatrix4d::generate_hash(ChecksumHashGenerator &hashgen) const;
void LMatrix4d::generate_hash(ChecksumHashGenerator &hashgen, double scale) const;

3335 20 write_datagram_fixed 0 4 3540 31 LMatrix4d::write_datagram_fixed 0 1 1654 332
/**
 * Writes the matrix to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the matrix, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */
66
void LMatrix4d::write_datagram_fixed(Datagram &destination) const;

3336 19 read_datagram_fixed 0 4 3540 30 LMatrix4d::read_datagram_fixed 0 1 1655 114
/**
 * Reads the matrix from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */
60
void LMatrix4d::read_datagram_fixed(DatagramIterator &scan);

3337 14 write_datagram 0 4 3540 25 LMatrix4d::write_datagram 0 1 1656 205
/**
 * Writes the matrix to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the matrix using the standard width
 * setting, especially when you are writing a bam file.
 */
60
void LMatrix4d::write_datagram(Datagram &destination) const;

3338 13 read_datagram 0 4 3540 24 LMatrix4d::read_datagram 0 1 1657 67
/**
 * Reads the matrix from the Datagram using get_stdfloat().
 */
56
void LMatrix4d::read_datagram(DatagramIterator &source);

3339 14 get_class_type 0 4 3540 25 LMatrix4d::get_class_type 0 1 1658 0
50
static TypeHandle LMatrix4d::get_class_type(void);

3340 10 ~LMatrix4d 0 4 3540 21 LMatrix4d::~LMatrix4d 0 0 0
28
LMatrix4d::~LMatrix4d(void);

3341 18 UnalignedLMatrix4d 0 4 3544 38 UnalignedLMatrix4d::UnalignedLMatrix4d 0 4 1666 1667 1668 1669 46
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */
440
inline UnalignedLMatrix4d::UnalignedLMatrix4d(void);
inline UnalignedLMatrix4d::UnalignedLMatrix4d(LMatrix4d const &copy);
inline UnalignedLMatrix4d::UnalignedLMatrix4d(UnalignedLMatrix4d const &copy);
inline UnalignedLMatrix4d::UnalignedLMatrix4d(double e00, double e01, double e02, double e03, double e10, double e11, double e12, double e13, double e20, double e21, double e22, double e23, double e30, double e31, double e32, double e33);

3342 10 operator = 0 4 3544 30 UnalignedLMatrix4d::operator = 0 2 1670 1671 22
/**
 *
 */

/**
 *
 */
172
inline UnalignedLMatrix4d &UnalignedLMatrix4d::operator =(LMatrix4d const &copy);
inline UnalignedLMatrix4d &UnalignedLMatrix4d::operator =(UnalignedLMatrix4d const &copy);

3343 3 set 0 4 3544 23 UnalignedLMatrix4d::set 0 1 1672 10
/**
 *
 */
228
inline void UnalignedLMatrix4d::set(double e00, double e01, double e02, double e03, double e10, double e11, double e12, double e13, double e20, double e21, double e22, double e23, double e30, double e31, double e32, double e33);

3344 11 operator () 0 4 3544 31 UnalignedLMatrix4d::operator () 0 2 1673 1674 10
/**
 *
 */
136
inline double &UnalignedLMatrix4d::operator ()(int row, int col);
inline double UnalignedLMatrix4d::operator ()(int row, int col) const;

3345 8 get_data 0 4 3544 28 UnalignedLMatrix4d::get_data 0 1 1675 162
/**
 * Returns the address of the first of the nine data elements in the matrix.
 * The remaining elements occupy the next eight positions in row-major order.
 */
62
inline double const *UnalignedLMatrix4d::get_data(void) const;

3346 18 get_num_components 0 4 3544 38 UnalignedLMatrix4d::get_num_components 0 1 1676 65
/**
 * Returns the number of elements in the matrix, sixteen.
 */
62
inline int UnalignedLMatrix4d::get_num_components(void) const;

3347 14 get_class_type 0 4 3544 34 UnalignedLMatrix4d::get_class_type 0 1 1677 0
59
static TypeHandle UnalignedLMatrix4d::get_class_type(void);

3348 19 ~UnalignedLMatrix4d 0 4 3544 39 UnalignedLMatrix4d::~UnalignedLMatrix4d 0 0 0
46
UnalignedLMatrix4d::~UnalignedLMatrix4d(void);

3349 10 operator * 0 1 0 10 operator * 0 24 1870 1871 1872 1873 1874 1875 1876 1877 1878 1879 1880 1881 1882 1883 1884 1885 1886 1887 1888 1889 1890 1891 1892 1893 0
1659
inline LVecBase3f operator *(LVecBase3f const &v, LMatrix3f const &m);
inline LVector3f operator *(LVector3f const &v, LMatrix3f const &m);
inline LPoint3f operator *(LPoint3f const &v, LMatrix3f const &m);
inline LVector2f operator *(LVector2f const &v, LMatrix3f const &m);
inline LPoint2f operator *(LPoint2f const &v, LMatrix3f const &m);
inline LVecBase4f operator *(LVecBase4f const &v, LMatrix4f const &m);
inline LPoint4f operator *(LPoint4f const &v, LMatrix4f const &m);
inline LVector4f operator *(LVector4f const &v, LMatrix4f const &m);
inline LVector3f operator *(LVector3f const &v, LMatrix4f const &m);
inline LPoint3f operator *(LPoint3f const &v, LMatrix4f const &m);
inline LVecBase3d operator *(LVecBase3d const &v, LMatrix3d const &m);
inline LVector3d operator *(LVector3d const &v, LMatrix3d const &m);
inline LPoint3d operator *(LPoint3d const &v, LMatrix3d const &m);
inline LVector2d operator *(LVector2d const &v, LMatrix3d const &m);
inline LPoint2d operator *(LPoint2d const &v, LMatrix3d const &m);
inline LVecBase4d operator *(LVecBase4d const &v, LMatrix4d const &m);
inline LPoint4d operator *(LPoint4d const &v, LMatrix4d const &m);
inline LVector4d operator *(LVector4d const &v, LMatrix4d const &m);
inline LVector3d operator *(LVector3d const &v, LMatrix4d const &m);
inline LPoint3d operator *(LPoint3d const &v, LMatrix4d const &m);
inline LMatrix3f operator *(LMatrix3f const &m, LQuaternionf const &q);
inline LMatrix4f operator *(LMatrix4f const &m, LQuaternionf const &q);
inline LMatrix3d operator *(LMatrix3d const &m, LQuaterniond const &q);
inline LMatrix4d operator *(LMatrix4d const &m, LQuaterniond const &q);

3350 11 operator *= 0 1 0 11 operator *= 0 16 1894 1895 1896 1897 1898 1899 1900 1901 1902 1903 1904 1905 1906 1907 1908 1909 0
941
inline void operator *=(LVecBase3f &v, LMatrix3f const &m);
inline void operator *=(LVector3f &v, LMatrix3f const &m);
inline void operator *=(LPoint3f &v, LMatrix3f const &m);
inline void operator *=(LVector2f &v, LMatrix3f const &m);
inline void operator *=(LPoint2f &v, LMatrix3f const &m);
inline void operator *=(LVecBase4f &v, LMatrix4f const &m);
inline void operator *=(LVector3f &v, LMatrix4f const &m);
inline void operator *=(LPoint3f &v, LMatrix4f const &m);
inline void operator *=(LVecBase3d &v, LMatrix3d const &m);
inline void operator *=(LVector3d &v, LMatrix3d const &m);
inline void operator *=(LPoint3d &v, LMatrix3d const &m);
inline void operator *=(LVector2d &v, LMatrix3d const &m);
inline void operator *=(LPoint2d &v, LMatrix3d const &m);
inline void operator *=(LVecBase4d &v, LMatrix4d const &m);
inline void operator *=(LVector3d &v, LMatrix4d const &m);
inline void operator *=(LPoint3d &v, LMatrix4d const &m);

3351 22 generic_write_datagram 0 1 0 22 generic_write_datagram 0 4 1910 1911 1912 1913 0
303
inline void generic_write_datagram(Datagram &dest, LMatrix3f const &value);
inline void generic_write_datagram(Datagram &dest, LMatrix4f const &value);
inline void generic_write_datagram(Datagram &dest, LMatrix3d const &value);
inline void generic_write_datagram(Datagram &dest, LMatrix4d const &value);

3352 21 generic_read_datagram 0 1 0 21 generic_read_datagram 0 4 1914 1915 1916 1917 0
319
inline void generic_read_datagram(LMatrix3f &result, DatagramIterator &source);
inline void generic_read_datagram(LMatrix4f &result, DatagramIterator &source);
inline void generic_read_datagram(LMatrix3d &result, DatagramIterator &source);
inline void generic_read_datagram(LMatrix4d &result, DatagramIterator &source);

3353 14 compose_matrix 0 1 0 14 compose_matrix 0 10 1918 1919 1920 1921 1922 1923 1924 1925 1926 1927 0
1484
void compose_matrix(LMatrix3f &mat, LVecBase3f const &scale, LVecBase3f const &shear, LVecBase3f const &hpr, CoordinateSystem cs = ::CS_default);
inline void compose_matrix(LMatrix4f &mat, LVecBase3f const &scale, LVecBase3f const &shear, LVecBase3f const &hpr, LVecBase3f const &translate, CoordinateSystem cs = ::CS_default);
inline void compose_matrix(LMatrix4f &mat, float const components[::num_matrix_components], CoordinateSystem cs = ::CS_default);
inline void compose_matrix(LMatrix3f &mat, LVecBase3f const &scale, LVecBase3f const &hpr, CoordinateSystem cs = ::CS_default);
inline void compose_matrix(LMatrix4f &mat, LVecBase3f const &scale, LVecBase3f const &hpr, LVecBase3f const &translate, CoordinateSystem cs = ::CS_default);
void compose_matrix(LMatrix3d &mat, LVecBase3d const &scale, LVecBase3d const &shear, LVecBase3d const &hpr, CoordinateSystem cs = ::CS_default);
inline void compose_matrix(LMatrix4d &mat, LVecBase3d const &scale, LVecBase3d const &shear, LVecBase3d const &hpr, LVecBase3d const &translate, CoordinateSystem cs = ::CS_default);
inline void compose_matrix(LMatrix4d &mat, double const components[::num_matrix_components], CoordinateSystem cs = ::CS_default);
inline void compose_matrix(LMatrix3d &mat, LVecBase3d const &scale, LVecBase3d const &hpr, CoordinateSystem cs = ::CS_default);
inline void compose_matrix(LMatrix4d &mat, LVecBase3d const &scale, LVecBase3d const &hpr, LVecBase3d const &translate, CoordinateSystem cs = ::CS_default);

3354 16 decompose_matrix 0 1 0 16 decompose_matrix 0 10 1928 1929 1930 1931 1932 1933 1934 1935 1936 1937 0
1408
bool decompose_matrix(LMatrix3f const &mat, LVecBase3f &scale, LVecBase3f &shear, LVecBase3f &hpr, CoordinateSystem cs = ::CS_default);
inline bool decompose_matrix(LMatrix4f const &mat, LVecBase3f &scale, LVecBase3f &shear, LVecBase3f &hpr, LVecBase3f &translate, CoordinateSystem cs = ::CS_default);
inline bool decompose_matrix(LMatrix4f const &mat, float components[::num_matrix_components], CoordinateSystem CS = ::CS_default);
inline bool decompose_matrix(LMatrix3f const &mat, LVecBase3f &scale, LVecBase3f &hpr, CoordinateSystem cs = ::CS_default);
inline bool decompose_matrix(LMatrix4f const &mat, LVecBase3f &scale, LVecBase3f &hpr, LVecBase3f &translate, CoordinateSystem cs = ::CS_default);
bool decompose_matrix(LMatrix3d const &mat, LVecBase3d &scale, LVecBase3d &shear, LVecBase3d &hpr, CoordinateSystem cs = ::CS_default);
inline bool decompose_matrix(LMatrix4d const &mat, LVecBase3d &scale, LVecBase3d &shear, LVecBase3d &hpr, LVecBase3d &translate, CoordinateSystem cs = ::CS_default);
inline bool decompose_matrix(LMatrix4d const &mat, double components[::num_matrix_components], CoordinateSystem CS = ::CS_default);
inline bool decompose_matrix(LMatrix3d const &mat, LVecBase3d &scale, LVecBase3d &hpr, CoordinateSystem cs = ::CS_default);
inline bool decompose_matrix(LMatrix4d const &mat, LVecBase3d &scale, LVecBase3d &hpr, LVecBase3d &translate, CoordinateSystem cs = ::CS_default);

3355 24 decompose_matrix_old_hpr 0 1 0 24 decompose_matrix_old_hpr 0 2 1938 1939 0
287
bool decompose_matrix_old_hpr(LMatrix3f const &mat, LVecBase3f &scale, LVecBase3f &shear, LVecBase3f &hpr, CoordinateSystem cs = ::CS_default);
bool decompose_matrix_old_hpr(LMatrix3d const &mat, LVecBase3d &scale, LVecBase3d &shear, LVecBase3d &hpr, CoordinateSystem cs = ::CS_default);

3356 14 old_to_new_hpr 0 1 0 14 old_to_new_hpr 0 2 1940 1941 0
107
LVecBase3f old_to_new_hpr(LVecBase3f const &old_hpr);
LVecBase3d old_to_new_hpr(LVecBase3d const &old_hpr);

3357 12 LQuaternionf 0 4 3546 26 LQuaternionf::LQuaternionf 0 5 1678 1679 1680 1681 1682 46
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */
305
inline LQuaternionf::LQuaternionf(void);
inline LQuaternionf::LQuaternionf(LVecBase4f const &copy);
inline LQuaternionf::LQuaternionf(float r, LVecBase3f const &copy);
inline LQuaternionf::LQuaternionf(float r, float i, float j, float k);
inline LQuaternionf::LQuaternionf(LQuaternionf const &) = default;

3358 14 pure_imaginary 0 4 3546 28 LQuaternionf::pure_imaginary 0 1 1683 10
/**
 *
 */
69
static LQuaternionf LQuaternionf::pure_imaginary(LVector3f const &v);

3359 9 conjugate 0 4 3546 23 LQuaternionf::conjugate 0 1 1684 54
/**
 * Returns the complex conjugate of this quat.
 */
56
inline LQuaternionf LQuaternionf::conjugate(void) const;

3360 5 xform 0 4 3546 19 LQuaternionf::xform 0 2 1685 1686 122
/**
 * Transforms a 3-d vector by the indicated rotation
 */

/**
 * Transforms a 4-d vector by the indicated rotation
 */
131
inline LVecBase3f LQuaternionf::xform(LVecBase3f const &v) const;
inline LVecBase4f LQuaternionf::xform(LVecBase4f const &v) const;

3361 8 multiply 0 4 3546 22 LQuaternionf::multiply 0 1 1687 45
/**
 * actual multiply call (non virtual)
 */
74
inline LQuaternionf LQuaternionf::multiply(LQuaternionf const &rhs) const;

3362 10 operator - 0 68 3546 24 LQuaternionf::operator - 0 1 1688 0
57
inline LQuaternionf LQuaternionf::operator -(void) const;

3363 10 operator + 0 4 3546 24 LQuaternionf::operator + 0 1 1689 0
78
inline LQuaternionf LQuaternionf::operator +(LQuaternionf const &other) const;

3364 10 operator - 0 4 3546 24 LQuaternionf::operator - 0 1 1690 0
78
inline LQuaternionf LQuaternionf::operator -(LQuaternionf const &other) const;

3365 9 angle_rad 0 4 3546 23 LQuaternionf::angle_rad 0 1 1691 127
/**
 * Returns the angle between the orientation represented by this quaternion
 * and the other one, expressed in radians.
 */
70
inline float LQuaternionf::angle_rad(LQuaternionf const &other) const;

3366 9 angle_deg 0 4 3546 23 LQuaternionf::angle_deg 0 1 1692 127
/**
 * Returns the angle between the orientation represented by this quaternion
 * and the other one, expressed in degrees.
 */
70
inline float LQuaternionf::angle_deg(LQuaternionf const &other) const;

3367 10 operator * 0 4 3546 24 LQuaternionf::operator * 0 4 1693 1694 1695 1696 0
263
inline LQuaternionf LQuaternionf::operator *(float scalar) const;
inline LQuaternionf LQuaternionf::operator *(LQuaternionf const &) const;
inline LMatrix3f LQuaternionf::operator *(LMatrix3f const &);
inline LMatrix4f LQuaternionf::operator *(LMatrix4f const &);

3368 10 operator / 0 4 3546 24 LQuaternionf::operator / 0 1 1697 0
65
inline LQuaternionf LQuaternionf::operator /(float scalar) const;

3369 11 operator *= 0 4 3546 25 LQuaternionf::operator *= 0 1 1698 10
/**
 *
 */
69
inline LQuaternionf &LQuaternionf::operator *=(LQuaternionf const &);

3370 12 almost_equal 0 4 3546 26 LQuaternionf::almost_equal 0 2 1699 1700 218
/**
 * Returns true if two quaternions are memberwise equal within a default
 * tolerance based on the numeric type.
 */

/**
 * Returns true if two quaternions are memberwise equal within a specified
 * tolerance.
 */
162
inline bool LQuaternionf::almost_equal(LQuaternionf const &other) const;
inline bool LQuaternionf::almost_equal(LQuaternionf const &other, float threshold) const;

3371 17 is_same_direction 0 4 3546 31 LQuaternionf::is_same_direction 0 1 1701 127
/**
 * Returns true if two quaternions represent the same rotation within a
 * default tolerance based on the numeric type.
 */
77
inline bool LQuaternionf::is_same_direction(LQuaternionf const &other) const;

3372 21 almost_same_direction 0 4 3546 35 LQuaternionf::almost_same_direction 0 1 1702 103
/**
 * Returns true if two quaternions represent the same rotation within a
 * specified tolerance.
 */
98
inline bool LQuaternionf::almost_same_direction(LQuaternionf const &other, float threshold) const;

3373 6 output 0 4 3546 20 LQuaternionf::output 0 1 1703 10
/**
 *
 */
50
inline void LQuaternionf::output(ostream &) const;

3374 17 extract_to_matrix 0 4 3546 31 LQuaternionf::extract_to_matrix 0 2 1704 1705 88
/**
 * Based on the quat lib from VRPN.
 */

/**
 * Based on the quat lib from VRPN.
 */
115
void LQuaternionf::extract_to_matrix(LMatrix3f &m) const;
void LQuaternionf::extract_to_matrix(LMatrix4f &m) const;

3375 15 set_from_matrix 0 4 3546 29 LQuaternionf::set_from_matrix 0 2 1706 1707 238
/**
 *
 */

/**
 * Sets the quaternion according to the rotation represented by the matrix.
 * Originally we tried an algorithm presented by Do-While Jones, but that
 * turned out to be broken.  This is based on the quat lib from UNC.
 */
118
void LQuaternionf::set_from_matrix(LMatrix3f const &m);
inline void LQuaternionf::set_from_matrix(LMatrix4f const &m);

3376 7 set_hpr 0 4 3546 21 LQuaternionf::set_hpr 0 1 1708 132
/**
 * Sets the quaternion as the unit quaternion that is equivalent to these
 * Euler angles.  (from Real-time Rendering, p.49)
 */
86
void LQuaternionf::set_hpr(LVecBase3f const &hpr, CoordinateSystem cs = ::CS_default);

3377 7 get_hpr 0 4 3546 21 LQuaternionf::get_hpr 0 1 1709 73
/**
 * Extracts the equivalent Euler angles from the unit quaternion.
 */
75
LVecBase3f LQuaternionf::get_hpr(CoordinateSystem cs = ::CS_default) const;

3378 8 get_axis 0 4 3546 22 LQuaternionf::get_axis 0 1 1710 180
/**
 * This, along with get_angle(), returns the rotation represented by the
 * quaternion as an angle about an arbitrary axis.  This returns the axis; it
 * is not normalized.
 */
52
inline LVector3f LQuaternionf::get_axis(void) const;

3379 19 get_axis_normalized 0 4 3546 33 LQuaternionf::get_axis_normalized 0 1 1711 169
/**
 * This, along with get_angle(), returns the rotation represented by the
 * quaternion as an angle about an arbitrary axis.  This returns the
 * normalized axis.
 */
63
inline LVector3f LQuaternionf::get_axis_normalized(void) const;

3380 13 get_angle_rad 0 4 3546 27 LQuaternionf::get_angle_rad 0 1 1712 343
/**
 * This, along with get_axis(), returns the rotation represented by the
 * quaternion as an angle about an arbitrary axis.  This returns the angle, in
 * radians counterclockwise about the axis.
 *
 * It is necessary to ensure the quaternion has been normalized (for instance,
 * with a call to normalize()) before calling this method.
 */
53
inline float LQuaternionf::get_angle_rad(void) const;

3381 9 get_angle 0 4 3546 23 LQuaternionf::get_angle 0 1 1713 343
/**
 * This, along with get_axis(), returns the rotation represented by the
 * quaternion as an angle about an arbitrary axis.  This returns the angle, in
 * degrees counterclockwise about the axis.
 *
 * It is necessary to ensure the quaternion has been normalized (for instance,
 * with a call to normalize()) before calling this method.
 */
49
inline float LQuaternionf::get_angle(void) const;

3382 23 set_from_axis_angle_rad 0 4 3546 37 LQuaternionf::set_from_axis_angle_rad 0 1 1714 86
/**
 * angle_rad is the angle about the axis in radians.  axis must be normalized.
 */
90
inline void LQuaternionf::set_from_axis_angle_rad(float angle_rad, LVector3f const &axis);

3383 19 set_from_axis_angle 0 4 3546 33 LQuaternionf::set_from_axis_angle 0 1 1715 86
/**
 * angle_deg is the angle about the axis in degrees.  axis must be normalized.
 */
86
inline void LQuaternionf::set_from_axis_angle(float angle_deg, LVector3f const &axis);

3384 6 get_up 0 4 3546 20 LQuaternionf::get_up 0 1 1716 96
/**
 * Returns the orientation represented by this quaternion, expressed as an up
 * vector.
 */
80
inline LVector3f LQuaternionf::get_up(CoordinateSystem cs = ::CS_default) const;

3385 9 get_right 0 4 3546 23 LQuaternionf::get_right 0 1 1717 98
/**
 * Returns the orientation represented by this quaternion, expressed as a
 * right vector.
 */
83
inline LVector3f LQuaternionf::get_right(CoordinateSystem cs = ::CS_default) const;

3386 11 get_forward 0 4 3546 25 LQuaternionf::get_forward 0 1 1718 100
/**
 * Returns the orientation represented by this quaternion, expressed as a
 * forward vector.
 */
85
inline LVector3f LQuaternionf::get_forward(CoordinateSystem cs = ::CS_default) const;

3387 5 get_r 0 4 3546 19 LQuaternionf::get_r 0 1 1719 10
/**
 *
 */
45
inline float LQuaternionf::get_r(void) const;

3388 5 get_i 0 4 3546 19 LQuaternionf::get_i 0 1 1720 10
/**
 *
 */
45
inline float LQuaternionf::get_i(void) const;

3389 5 get_j 0 4 3546 19 LQuaternionf::get_j 0 1 1721 10
/**
 *
 */
45
inline float LQuaternionf::get_j(void) const;

3390 5 get_k 0 4 3546 19 LQuaternionf::get_k 0 1 1722 10
/**
 *
 */
45
inline float LQuaternionf::get_k(void) const;

3391 5 set_r 0 4 3546 19 LQuaternionf::set_r 0 1 1723 10
/**
 *
 */
41
inline void LQuaternionf::set_r(float r);

3392 5 set_i 0 4 3546 19 LQuaternionf::set_i 0 1 1724 10
/**
 *
 */
41
inline void LQuaternionf::set_i(float i);

3393 5 set_j 0 4 3546 19 LQuaternionf::set_j 0 1 1725 10
/**
 *
 */
41
inline void LQuaternionf::set_j(float j);

3394 5 set_k 0 4 3546 19 LQuaternionf::set_k 0 1 1726 10
/**
 *
 */
41
inline void LQuaternionf::set_k(float k);

3395 9 normalize 0 4 3546 23 LQuaternionf::normalize 0 1 1727 10
/**
 *
 */
42
inline bool LQuaternionf::normalize(void);

3396 14 conjugate_from 0 4 3546 28 LQuaternionf::conjugate_from 0 1 1728 466
/**
 * Computes the conjugate of the other quat, and stores the result in this
 * quat.  This is a fully general operation and makes no assumptions about the
 * type of transform represented by the quat.
 *
 * The other quat must be a different object than this quat.  However, if you
 * need to get a conjugate of a quat in place, see conjugate_in_place.
 *
 * The return value is true if the quat was successfully inverted, false if
 * there was a singularity.
 */
68
inline bool LQuaternionf::conjugate_from(LQuaternionf const &other);

3397 18 conjugate_in_place 0 4 3546 32 LQuaternionf::conjugate_in_place 0 1 1729 129
/**
 * Sets this to be the conjugate of the current quat.  Returns true if the
 * successful, false if the quat was singular.
 */
51
inline bool LQuaternionf::conjugate_in_place(void);

3398 11 invert_from 0 4 3546 25 LQuaternionf::invert_from 0 1 1730 448
/**
 * Computes the inverse of the other quat, and stores the result in this quat.
 * This is a fully general operation and makes no assumptions about the type
 * of transform represented by the quat.
 *
 * The other quat must be a different object than this quat.  However, if you
 * need to invert a quat in place, see invert_in_place.
 *
 * The return value is true if the quat was successfully inverted, false if
 * there was a singularity.
 */
65
inline bool LQuaternionf::invert_from(LQuaternionf const &other);

3399 15 invert_in_place 0 4 3546 29 LQuaternionf::invert_in_place 0 1 1731 115
/**
 * Inverts the current quat.  Returns true if the inverse is successful, false
 * if the quat was singular.
 */
48
inline bool LQuaternionf::invert_in_place(void);

3400 11 is_identity 0 4 3546 25 LQuaternionf::is_identity 0 1 1732 98
/**
 * Returns true if this quaternion represents the identity transformation: no
 * rotation.
 */
50
inline bool LQuaternionf::is_identity(void) const;

3401 18 is_almost_identity 0 4 3546 32 LQuaternionf::is_almost_identity 0 1 1733 110
/**
 * Returns true if this quaternion represents the identity transformation
 * within a given tolerance.
 */
68
inline bool LQuaternionf::is_almost_identity(float tolerance) const;

3402 10 ident_quat 0 4 3546 24 LQuaternionf::ident_quat 0 1 1734 42
/**
 * Returns an identity quaternion.
 */
65
static inline LQuaternionf const &LQuaternionf::ident_quat(void);

3403 14 get_class_type 0 4 3546 28 LQuaternionf::get_class_type 0 1 1735 0
53
static TypeHandle LQuaternionf::get_class_type(void);

3404 13 ~LQuaternionf 0 4 3546 27 LQuaternionf::~LQuaternionf 0 0 0
34
LQuaternionf::~LQuaternionf(void);

3405 12 LQuaterniond 0 4 3547 26 LQuaterniond::LQuaterniond 0 5 1736 1737 1738 1739 1740 46
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */
310
inline LQuaterniond::LQuaterniond(void);
inline LQuaterniond::LQuaterniond(LVecBase4d const &copy);
inline LQuaterniond::LQuaterniond(double r, LVecBase3d const &copy);
inline LQuaterniond::LQuaterniond(double r, double i, double j, double k);
inline LQuaterniond::LQuaterniond(LQuaterniond const &) = default;

3406 14 pure_imaginary 0 4 3547 28 LQuaterniond::pure_imaginary 0 1 1741 10
/**
 *
 */
69
static LQuaterniond LQuaterniond::pure_imaginary(LVector3d const &v);

3407 9 conjugate 0 4 3547 23 LQuaterniond::conjugate 0 1 1742 54
/**
 * Returns the complex conjugate of this quat.
 */
56
inline LQuaterniond LQuaterniond::conjugate(void) const;

3408 5 xform 0 4 3547 19 LQuaterniond::xform 0 2 1743 1744 122
/**
 * Transforms a 3-d vector by the indicated rotation
 */

/**
 * Transforms a 4-d vector by the indicated rotation
 */
131
inline LVecBase3d LQuaterniond::xform(LVecBase3d const &v) const;
inline LVecBase4d LQuaterniond::xform(LVecBase4d const &v) const;

3409 8 multiply 0 4 3547 22 LQuaterniond::multiply 0 1 1745 45
/**
 * actual multiply call (non virtual)
 */
74
inline LQuaterniond LQuaterniond::multiply(LQuaterniond const &rhs) const;

3410 10 operator - 0 68 3547 24 LQuaterniond::operator - 0 1 1746 0
57
inline LQuaterniond LQuaterniond::operator -(void) const;

3411 10 operator + 0 4 3547 24 LQuaterniond::operator + 0 1 1747 0
78
inline LQuaterniond LQuaterniond::operator +(LQuaterniond const &other) const;

3412 10 operator - 0 4 3547 24 LQuaterniond::operator - 0 1 1748 0
78
inline LQuaterniond LQuaterniond::operator -(LQuaterniond const &other) const;

3413 9 angle_rad 0 4 3547 23 LQuaterniond::angle_rad 0 1 1749 127
/**
 * Returns the angle between the orientation represented by this quaternion
 * and the other one, expressed in radians.
 */
71
inline double LQuaterniond::angle_rad(LQuaterniond const &other) const;

3414 9 angle_deg 0 4 3547 23 LQuaterniond::angle_deg 0 1 1750 127
/**
 * Returns the angle between the orientation represented by this quaternion
 * and the other one, expressed in degrees.
 */
71
inline double LQuaterniond::angle_deg(LQuaterniond const &other) const;

3415 10 operator * 0 4 3547 24 LQuaterniond::operator * 0 4 1751 1752 1753 1754 0
264
inline LQuaterniond LQuaterniond::operator *(double scalar) const;
inline LQuaterniond LQuaterniond::operator *(LQuaterniond const &) const;
inline LMatrix3d LQuaterniond::operator *(LMatrix3d const &);
inline LMatrix4d LQuaterniond::operator *(LMatrix4d const &);

3416 10 operator / 0 4 3547 24 LQuaterniond::operator / 0 1 1755 0
66
inline LQuaterniond LQuaterniond::operator /(double scalar) const;

3417 11 operator *= 0 4 3547 25 LQuaterniond::operator *= 0 1 1756 10
/**
 *
 */
69
inline LQuaterniond &LQuaterniond::operator *=(LQuaterniond const &);

3418 12 almost_equal 0 4 3547 26 LQuaterniond::almost_equal 0 2 1757 1758 218
/**
 * Returns true if two quaternions are memberwise equal within a default
 * tolerance based on the numeric type.
 */

/**
 * Returns true if two quaternions are memberwise equal within a specified
 * tolerance.
 */
163
inline bool LQuaterniond::almost_equal(LQuaterniond const &other) const;
inline bool LQuaterniond::almost_equal(LQuaterniond const &other, double threshold) const;

3419 17 is_same_direction 0 4 3547 31 LQuaterniond::is_same_direction 0 1 1759 127
/**
 * Returns true if two quaternions represent the same rotation within a
 * default tolerance based on the numeric type.
 */
77
inline bool LQuaterniond::is_same_direction(LQuaterniond const &other) const;

3420 21 almost_same_direction 0 4 3547 35 LQuaterniond::almost_same_direction 0 1 1760 103
/**
 * Returns true if two quaternions represent the same rotation within a
 * specified tolerance.
 */
99
inline bool LQuaterniond::almost_same_direction(LQuaterniond const &other, double threshold) const;

3421 6 output 0 4 3547 20 LQuaterniond::output 0 1 1761 10
/**
 *
 */
50
inline void LQuaterniond::output(ostream &) const;

3422 17 extract_to_matrix 0 4 3547 31 LQuaterniond::extract_to_matrix 0 2 1762 1763 88
/**
 * Based on the quat lib from VRPN.
 */

/**
 * Based on the quat lib from VRPN.
 */
115
void LQuaterniond::extract_to_matrix(LMatrix3d &m) const;
void LQuaterniond::extract_to_matrix(LMatrix4d &m) const;

3423 15 set_from_matrix 0 4 3547 29 LQuaterniond::set_from_matrix 0 2 1764 1765 238
/**
 *
 */

/**
 * Sets the quaternion according to the rotation represented by the matrix.
 * Originally we tried an algorithm presented by Do-While Jones, but that
 * turned out to be broken.  This is based on the quat lib from UNC.
 */
118
void LQuaterniond::set_from_matrix(LMatrix3d const &m);
inline void LQuaterniond::set_from_matrix(LMatrix4d const &m);

3424 7 set_hpr 0 4 3547 21 LQuaterniond::set_hpr 0 1 1766 132
/**
 * Sets the quaternion as the unit quaternion that is equivalent to these
 * Euler angles.  (from Real-time Rendering, p.49)
 */
86
void LQuaterniond::set_hpr(LVecBase3d const &hpr, CoordinateSystem cs = ::CS_default);

3425 7 get_hpr 0 4 3547 21 LQuaterniond::get_hpr 0 1 1767 73
/**
 * Extracts the equivalent Euler angles from the unit quaternion.
 */
75
LVecBase3d LQuaterniond::get_hpr(CoordinateSystem cs = ::CS_default) const;

3426 8 get_axis 0 4 3547 22 LQuaterniond::get_axis 0 1 1768 180
/**
 * This, along with get_angle(), returns the rotation represented by the
 * quaternion as an angle about an arbitrary axis.  This returns the axis; it
 * is not normalized.
 */
52
inline LVector3d LQuaterniond::get_axis(void) const;

3427 19 get_axis_normalized 0 4 3547 33 LQuaterniond::get_axis_normalized 0 1 1769 169
/**
 * This, along with get_angle(), returns the rotation represented by the
 * quaternion as an angle about an arbitrary axis.  This returns the
 * normalized axis.
 */
63
inline LVector3d LQuaterniond::get_axis_normalized(void) const;

3428 13 get_angle_rad 0 4 3547 27 LQuaterniond::get_angle_rad 0 1 1770 343
/**
 * This, along with get_axis(), returns the rotation represented by the
 * quaternion as an angle about an arbitrary axis.  This returns the angle, in
 * radians counterclockwise about the axis.
 *
 * It is necessary to ensure the quaternion has been normalized (for instance,
 * with a call to normalize()) before calling this method.
 */
54
inline double LQuaterniond::get_angle_rad(void) const;

3429 9 get_angle 0 4 3547 23 LQuaterniond::get_angle 0 1 1771 343
/**
 * This, along with get_axis(), returns the rotation represented by the
 * quaternion as an angle about an arbitrary axis.  This returns the angle, in
 * degrees counterclockwise about the axis.
 *
 * It is necessary to ensure the quaternion has been normalized (for instance,
 * with a call to normalize()) before calling this method.
 */
50
inline double LQuaterniond::get_angle(void) const;

3430 23 set_from_axis_angle_rad 0 4 3547 37 LQuaterniond::set_from_axis_angle_rad 0 1 1772 86
/**
 * angle_rad is the angle about the axis in radians.  axis must be normalized.
 */
91
inline void LQuaterniond::set_from_axis_angle_rad(double angle_rad, LVector3d const &axis);

3431 19 set_from_axis_angle 0 4 3547 33 LQuaterniond::set_from_axis_angle 0 1 1773 86
/**
 * angle_deg is the angle about the axis in degrees.  axis must be normalized.
 */
87
inline void LQuaterniond::set_from_axis_angle(double angle_deg, LVector3d const &axis);

3432 6 get_up 0 4 3547 20 LQuaterniond::get_up 0 1 1774 96
/**
 * Returns the orientation represented by this quaternion, expressed as an up
 * vector.
 */
80
inline LVector3d LQuaterniond::get_up(CoordinateSystem cs = ::CS_default) const;

3433 9 get_right 0 4 3547 23 LQuaterniond::get_right 0 1 1775 98
/**
 * Returns the orientation represented by this quaternion, expressed as a
 * right vector.
 */
83
inline LVector3d LQuaterniond::get_right(CoordinateSystem cs = ::CS_default) const;

3434 11 get_forward 0 4 3547 25 LQuaterniond::get_forward 0 1 1776 100
/**
 * Returns the orientation represented by this quaternion, expressed as a
 * forward vector.
 */
85
inline LVector3d LQuaterniond::get_forward(CoordinateSystem cs = ::CS_default) const;

3435 5 get_r 0 4 3547 19 LQuaterniond::get_r 0 1 1777 10
/**
 *
 */
46
inline double LQuaterniond::get_r(void) const;

3436 5 get_i 0 4 3547 19 LQuaterniond::get_i 0 1 1778 10
/**
 *
 */
46
inline double LQuaterniond::get_i(void) const;

3437 5 get_j 0 4 3547 19 LQuaterniond::get_j 0 1 1779 10
/**
 *
 */
46
inline double LQuaterniond::get_j(void) const;

3438 5 get_k 0 4 3547 19 LQuaterniond::get_k 0 1 1780 10
/**
 *
 */
46
inline double LQuaterniond::get_k(void) const;

3439 5 set_r 0 4 3547 19 LQuaterniond::set_r 0 1 1781 10
/**
 *
 */
42
inline void LQuaterniond::set_r(double r);

3440 5 set_i 0 4 3547 19 LQuaterniond::set_i 0 1 1782 10
/**
 *
 */
42
inline void LQuaterniond::set_i(double i);

3441 5 set_j 0 4 3547 19 LQuaterniond::set_j 0 1 1783 10
/**
 *
 */
42
inline void LQuaterniond::set_j(double j);

3442 5 set_k 0 4 3547 19 LQuaterniond::set_k 0 1 1784 10
/**
 *
 */
42
inline void LQuaterniond::set_k(double k);

3443 9 normalize 0 4 3547 23 LQuaterniond::normalize 0 1 1785 10
/**
 *
 */
42
inline bool LQuaterniond::normalize(void);

3444 14 conjugate_from 0 4 3547 28 LQuaterniond::conjugate_from 0 1 1786 466
/**
 * Computes the conjugate of the other quat, and stores the result in this
 * quat.  This is a fully general operation and makes no assumptions about the
 * type of transform represented by the quat.
 *
 * The other quat must be a different object than this quat.  However, if you
 * need to get a conjugate of a quat in place, see conjugate_in_place.
 *
 * The return value is true if the quat was successfully inverted, false if
 * there was a singularity.
 */
68
inline bool LQuaterniond::conjugate_from(LQuaterniond const &other);

3445 18 conjugate_in_place 0 4 3547 32 LQuaterniond::conjugate_in_place 0 1 1787 129
/**
 * Sets this to be the conjugate of the current quat.  Returns true if the
 * successful, false if the quat was singular.
 */
51
inline bool LQuaterniond::conjugate_in_place(void);

3446 11 invert_from 0 4 3547 25 LQuaterniond::invert_from 0 1 1788 448
/**
 * Computes the inverse of the other quat, and stores the result in this quat.
 * This is a fully general operation and makes no assumptions about the type
 * of transform represented by the quat.
 *
 * The other quat must be a different object than this quat.  However, if you
 * need to invert a quat in place, see invert_in_place.
 *
 * The return value is true if the quat was successfully inverted, false if
 * there was a singularity.
 */
65
inline bool LQuaterniond::invert_from(LQuaterniond const &other);

3447 15 invert_in_place 0 4 3547 29 LQuaterniond::invert_in_place 0 1 1789 115
/**
 * Inverts the current quat.  Returns true if the inverse is successful, false
 * if the quat was singular.
 */
48
inline bool LQuaterniond::invert_in_place(void);

3448 11 is_identity 0 4 3547 25 LQuaterniond::is_identity 0 1 1790 98
/**
 * Returns true if this quaternion represents the identity transformation: no
 * rotation.
 */
50
inline bool LQuaterniond::is_identity(void) const;

3449 18 is_almost_identity 0 4 3547 32 LQuaterniond::is_almost_identity 0 1 1791 110
/**
 * Returns true if this quaternion represents the identity transformation
 * within a given tolerance.
 */
69
inline bool LQuaterniond::is_almost_identity(double tolerance) const;

3450 10 ident_quat 0 4 3547 24 LQuaterniond::ident_quat 0 1 1792 42
/**
 * Returns an identity quaternion.
 */
65
static inline LQuaterniond const &LQuaterniond::ident_quat(void);

3451 14 get_class_type 0 4 3547 28 LQuaterniond::get_class_type 0 1 1793 0
53
static TypeHandle LQuaterniond::get_class_type(void);

3452 13 ~LQuaterniond 0 4 3547 27 LQuaterniond::~LQuaterniond 0 0 0
34
LQuaterniond::~LQuaterniond(void);

3453 10 LRotationf 0 4 3548 22 LRotationf::LRotationf 0 9 1794 1795 1796 1797 1798 1799 1800 1801 1802 185
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 * lmatrix3
 */

/**
 * lmatrix4
 */

/**
 * axis + angle (in degrees)
 */

/**
 * Sets the rotation from the given Euler angles.
 */
500
inline LRotationf::LRotationf(void);
inline LRotationf::LRotationf(LQuaternionf const &c);
inline LRotationf::LRotationf(LVecBase4f const &copy);
inline LRotationf::LRotationf(float r, float i, float j, float k);
inline LRotationf::LRotationf(LVector3f const &axis, float angle);
inline LRotationf::LRotationf(LMatrix3f const &m);
inline LRotationf::LRotationf(LMatrix4f const &m);
inline LRotationf::LRotationf(float h, float p, float r);
inline LRotationf::LRotationf(LRotationf const &) = default;

3454 10 operator * 0 4 3548 22 LRotationf::operator * 0 3 1803 1804 1805 0
211
inline LRotationf LRotationf::operator *(float scalar) const;
inline LRotationf LRotationf::operator *(LRotationf const &other) const;
inline LQuaternionf LRotationf::operator *(LQuaternionf const &other) const;

3455 10 operator / 0 4 3548 22 LRotationf::operator / 0 1 1806 0
61
inline LRotationf LRotationf::operator /(float scalar) const;

3456 14 get_class_type 0 4 3548 26 LRotationf::get_class_type 0 1 1807 0
51
static TypeHandle LRotationf::get_class_type(void);

3457 11 ~LRotationf 0 4 3548 23 LRotationf::~LRotationf 0 0 0
30
LRotationf::~LRotationf(void);

3458 10 LRotationd 0 4 3549 22 LRotationd::LRotationd 0 9 1808 1809 1810 1811 1812 1813 1814 1815 1816 185
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 * lmatrix3
 */

/**
 * lmatrix4
 */

/**
 * axis + angle (in degrees)
 */

/**
 * Sets the rotation from the given Euler angles.
 */
508
inline LRotationd::LRotationd(void);
inline LRotationd::LRotationd(LQuaterniond const &c);
inline LRotationd::LRotationd(LVecBase4d const &copy);
inline LRotationd::LRotationd(double r, double i, double j, double k);
inline LRotationd::LRotationd(LVector3d const &axis, double angle);
inline LRotationd::LRotationd(LMatrix3d const &m);
inline LRotationd::LRotationd(LMatrix4d const &m);
inline LRotationd::LRotationd(double h, double p, double r);
inline LRotationd::LRotationd(LRotationd const &) = default;

3459 10 operator * 0 4 3549 22 LRotationd::operator * 0 3 1817 1818 1819 0
212
inline LRotationd LRotationd::operator *(double scalar) const;
inline LRotationd LRotationd::operator *(LRotationd const &other) const;
inline LQuaterniond LRotationd::operator *(LQuaterniond const &other) const;

3460 10 operator / 0 4 3549 22 LRotationd::operator / 0 1 1820 0
62
inline LRotationd LRotationd::operator /(double scalar) const;

3461 14 get_class_type 0 4 3549 26 LRotationd::get_class_type 0 1 1821 0
51
static TypeHandle LRotationd::get_class_type(void);

3462 11 ~LRotationd 0 4 3549 23 LRotationd::~LRotationd 0 0 0
30
LRotationd::~LRotationd(void);

3463 13 LOrientationf 0 4 3550 28 LOrientationf::LOrientationf 0 7 1822 1823 1824 1825 1826 1827 1828 101
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 * vector + twist
 */

/**
 * matrix3
 */

/**
 * matrix4
 */
436
inline LOrientationf::LOrientationf(void);
inline LOrientationf::LOrientationf(LQuaternionf const &c);
inline LOrientationf::LOrientationf(float r, float i, float j, float k);
inline LOrientationf::LOrientationf(LVector3f const &point_at, float twist);
inline LOrientationf::LOrientationf(LMatrix3f const &m);
inline LOrientationf::LOrientationf(LMatrix4f const &m);
inline LOrientationf::LOrientationf(LOrientationf const &) = default;

3464 10 operator * 0 4 3550 25 LOrientationf::operator * 0 2 1829 1830 0
159
inline LOrientationf LOrientationf::operator *(LRotationf const &other) const;
inline LOrientationf LOrientationf::operator *(LQuaternionf const &other) const;

3465 14 get_class_type 0 4 3550 29 LOrientationf::get_class_type 0 1 1831 0
54
static TypeHandle LOrientationf::get_class_type(void);

3466 14 ~LOrientationf 0 4 3550 29 LOrientationf::~LOrientationf 0 0 0
36
LOrientationf::~LOrientationf(void);

3467 13 LOrientationd 0 4 3551 28 LOrientationd::LOrientationd 0 7 1832 1833 1834 1835 1836 1837 1838 101
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 * vector + twist
 */

/**
 * matrix3
 */

/**
 * matrix4
 */
441
inline LOrientationd::LOrientationd(void);
inline LOrientationd::LOrientationd(LQuaterniond const &c);
inline LOrientationd::LOrientationd(double r, double i, double j, double k);
inline LOrientationd::LOrientationd(LVector3d const &point_at, double twist);
inline LOrientationd::LOrientationd(LMatrix3d const &m);
inline LOrientationd::LOrientationd(LMatrix4d const &m);
inline LOrientationd::LOrientationd(LOrientationd const &) = default;

3468 10 operator * 0 4 3551 25 LOrientationd::operator * 0 2 1839 1840 0
159
inline LOrientationd LOrientationd::operator *(LRotationd const &other) const;
inline LOrientationd LOrientationd::operator *(LQuaterniond const &other) const;

3469 14 get_class_type 0 4 3551 29 LOrientationd::get_class_type 0 1 1841 0
54
static TypeHandle LOrientationd::get_class_type(void);

3470 14 ~LOrientationd 0 4 3551 29 LOrientationd::~LOrientationd 0 0 0
36
LOrientationd::~LOrientationd(void);

3471 19 ConfigVariableColor 0 4 3622 40 ConfigVariableColor::ConfigVariableColor 0 4 1842 1843 1844 1845 34
/**
 *
 */

/**
 *
 */

/**
 *
 */
488
inline ConfigVariableColor::ConfigVariableColor(std::string const &name);
inline ConfigVariableColor::ConfigVariableColor(std::string const &name, LColor const &default_value, std::string const &description = string(), int flags = 0);
inline ConfigVariableColor::ConfigVariableColor(std::string const &name, std::string const &default_value, std::string const &description = string(), int flags = 0);
inline ConfigVariableColor::ConfigVariableColor(ConfigVariableColor const &) = default;

3472 10 operator = 0 4 3622 31 ConfigVariableColor::operator = 0 1 1846 0
65
inline void ConfigVariableColor::operator =(LColor const &value);

3473 17 operator typecast 0 132 3622 38 ConfigVariableColor::operator typecast 0 1 1851 0
72
inline LColor const &ConfigVariableColor::operator typecast(void) const;

3474 11 operator [] 0 4 3622 32 ConfigVariableColor::operator [] 0 1 1847 0
65
inline PN_stdfloat ConfigVariableColor::operator [](int n) const;

3475 9 set_value 0 4 3622 30 ConfigVariableColor::set_value 0 1 1848 48
/**
 * Reassigns the variable's local value.
 */
64
inline void ConfigVariableColor::set_value(LColor const &value);

3476 9 get_value 0 4 3622 30 ConfigVariableColor::get_value 0 1 1849 40
/**
 * Returns the variable's value.
 */
64
inline LColor const &ConfigVariableColor::get_value(void) const;

3477 17 get_default_value 0 4 3622 38 ConfigVariableColor::get_default_value 0 1 1850 48
/**
 * Returns the variable's default value.
 */
65
inline LColor ConfigVariableColor::get_default_value(void) const;

3478 20 ~ConfigVariableColor 0 4 3622 41 ConfigVariableColor::~ConfigVariableColor 0 0 0
48
ConfigVariableColor::~ConfigVariableColor(void);

1941
1 0 0 7 2 3624 1943 0 0 0 
2 0 0 7 2 3624 1943 0 0 1 6 param0 0 3625  
3 0 0 7 8 3627 2008 0 0 0 
4 0 0 7 8 3627 2008 0 0 1 6 param0 0 3628  
5 0 0 7 8 3627 2008 0 10 /**
 *
 */ 1 10 fill_value 1 3482  
6 0 0 7 8 3627 2008 0 10 /**
 *
 */ 2 1 x 1 3482  1 y 1 3482  
7 0 0 4 9 3632 0 0 0 2 4 this 3 3627  4 size 1 3630  
8 0 0 6 12 3627 0 0 0 2 4 this 3 3627  4 copy 1 3628  
9 0 0 6 12 3627 0 0 0 2 4 this 3 3627  10 fill_value 1 3482  
10 0 0 6 13 3628 0 0 40 /**
 * Returns a zero-length vector.
 */ 0 
11 0 0 6 14 3628 0 0 35 /**
 * Returns a unit X vector.
 */ 0 
12 0 0 6 15 3628 0 0 35 /**
 * Returns a unit Y vector.
 */ 0 
13 0 0 6 16 3633 0 0 0 1 4 this 3 3628  
14 0 0 6 17 3633 0 0 0 2 4 this 3 3628  9 attr_name 1 3636  
15 0 0 6 18 3488 0 0 0 3 4 this 3 3627  9 attr_name 1 3636  6 assign 1 3633  
16 0 0 4 19 3632 0 0 10 /**
 *
 */ 3 4 this 3 3627  1 i 1 3488  10 assign_val 1 3482  
17 0 0 6 19 3482 0 0 0 2 4 this 3 3628  1 i 1 3488  
18 0 0 6 20 3488 0 0 0 0 
19 0 0 6 21 3637 0 0 91 /**
 * Returns true if any component of the vector is not-a-number, false
 * otherwise.
 */ 1 4 this 3 3628  
20 0 0 6 22 3482 0 0 10 /**
 *
 */ 2 4 this 3 3628  1 i 1 3488  
21 0 0 4 23 3632 0 0 10 /**
 *
 */ 3 4 this 3 3627  1 i 1 3488  5 value 1 3482  
22 0 0 6 24 3482 0 0 10 /**
 *
 */ 1 4 this 3 3628  
23 0 0 6 25 3482 0 0 10 /**
 *
 */ 1 4 this 3 3628  
24 0 0 4 26 3632 0 0 10 /**
 *
 */ 2 4 this 3 3627  5 value 1 3482  
25 0 0 4 27 3632 0 0 10 /**
 *
 */ 2 4 this 3 3627  5 value 1 3482  
26 0 0 4 31 3632 0 0 152 // These next functions add to an existing value.  i.e.
// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
// scripting languages: 3 4 this 3 3627  1 i 1 3488  5 value 1 3482  
27 0 0 4 32 3632 0 0 10 /**
 *
 */ 2 4 this 3 3627  5 value 1 3482  
28 0 0 4 33 3632 0 0 10 /**
 *
 */ 2 4 this 3 3627  5 value 1 3482  
29 0 0 4 34 3632 0 0 155 /**
 * Returns the address of the first of the two data elements in the vector.
 * The next element occupies the next position consecutively in memory.
 */ 1 4 this 3 3628  
30 0 0 6 35 3488 0 0 0 0 
31 0 0 4 36 3632 0 0 129 /**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */ 2 4 this 3 3627  10 fill_value 1 3482  
32 0 0 4 37 3632 0 0 10 /**
 *
 */ 3 4 this 3 3627  1 x 1 3482  1 y 1 3482  
33 0 0 6 38 3482 0 0 10 /**
 *
 */ 2 4 this 3 3628  5 other 1 3628  
34 0 0 6 39 3482 0 0 69 /**
 * Returns the square of the vector's length, cheap and easy.
 */ 1 4 this 3 3628  
35 0 0 6 40 3482 0 0 72 /**
 * Returns the length of the vector, by the Pythagorean theorem.
 */ 1 4 this 3 3628  
36 0 0 6 41 3637 0 0 127 /**
 * Normalizes the vector in place.  Returns true if the vector was normalized,
 * false if it was a zero-length vector.
 */ 1 4 this 3 3627  
37 0 0 7 42 3627 2008 0 160 /**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */ 1 4 this 3 3628  
38 0 0 7 43 3627 2008 0 152 /**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */ 2 4 this 3 3628  4 onto 1 3628  
39 0 0 6 44 3637 0 0 0 2 4 this 3 3628  5 other 1 3628  
40 0 0 6 45 3637 0 0 0 2 4 this 3 3628  5 other 1 3628  
41 0 0 6 46 3637 0 0 0 2 4 this 3 3628  5 other 1 3628  
42 0 0 6 47 3488 0 0 97 /**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */ 2 4 this 3 3628  5 other 1 3628  
43 0 0 6 47 3488 0 0 233 /**
 * Sorts vectors lexicographically, componentwise.  Returns a number less than
 * 0 if this vector sorts before the other one, greater than zero if it sorts
 * after, 0 if they are equivalent (within the indicated tolerance).
 */ 3 4 this 3 3628  5 other 1 3628  9 threshold 1 3482  
44 0 0 6 48 3630 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 1 4 this 3 3628  
45 0 0 6 48 3630 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 2 4 this 3 3628  9 threshold 1 3482  
46 0 0 6 49 3630 0 0 49 /**
 * Adds the vector into the running hash.
 */ 2 4 this 3 3628  4 hash 1 3630  
47 0 0 6 49 3630 0 0 49 /**
 * Adds the vector into the running hash.
 */ 3 4 this 3 3628  4 hash 1 3630  9 threshold 1 3482  
48 0 0 4 50 3632 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 2 4 this 3 3628  7 hashgen 1 3638  
49 0 0 4 50 3632 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 3 4 this 3 3628  7 hashgen 1 3638  9 threshold 1 3482  
50 0 0 7 51 3627 2008 0 0 1 4 this 3 3628  
51 0 0 7 52 3627 2008 0 0 2 4 this 3 3628  5 other 1 3628  
52 0 0 7 53 3627 2008 0 0 2 4 this 3 3628  5 other 1 3628  
53 0 0 7 54 3627 2008 0 0 2 4 this 3 3628  6 scalar 1 3482  
54 0 0 7 55 3627 2008 0 0 2 4 this 3 3628  6 scalar 1 3482  
55 0 0 6 56 3627 0 0 0 2 4 this 3 3627  5 other 1 3628  
56 0 0 6 57 3627 0 0 0 2 4 this 3 3627  5 other 1 3628  
57 0 0 6 58 3627 0 0 0 2 4 this 3 3627  6 scalar 1 3482  
58 0 0 6 59 3627 0 0 0 2 4 this 3 3627  6 scalar 1 3482  
59 0 0 4 60 3632 0 0 10 /**
 *
 */ 2 4 this 3 3627  5 other 1 3628  
60 0 0 7 61 3627 2008 0 0 2 4 this 3 3628  8 exponent 1 3482  
61 0 0 6 62 3633 0 0 0 2 4 this 3 3627  8 exponent 1 3482  
62 0 0 7 63 3627 2008 0 10 /**
 *
 */ 2 4 this 3 3628  5 other 1 3628  
63 0 0 7 64 3627 2008 0 10 /**
 *
 */ 2 4 this 3 3628  5 other 1 3628  
64 0 0 6 65 3637 0 0 116 /**
 * Returns true if two vectors are memberwise equal within a default tolerance
 * based on the numeric type.
 */ 2 4 this 3 3628  5 other 1 3628  
65 0 0 6 65 3637 0 0 92 /**
 * Returns true if two vectors are memberwise equal within a specified
 * tolerance.
 */ 3 4 this 3 3628  5 other 1 3628  9 threshold 1 3482  
66 0 0 4 66 3632 0 0 10 /**
 *
 */ 2 4 this 3 3628  3 out 1 3640  
67 0 0 6 67 3636 0 0 0 1 4 this 3 3628  
68 0 0 4 68 3632 0 0 332 /**
 * Writes the vector to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the vector, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */ 2 4 this 3 3628  11 destination 1 3642  
69 0 0 4 69 3632 0 0 114 /**
 * Reads the vector from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */ 2 4 this 3 3627  6 source 1 3644  
70 0 0 4 70 3632 0 0 205 /**
 * Writes the vector to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the vector using the standard width
 * setting, especially when you are writing a bam file.
 */ 2 4 this 3 3628  11 destination 1 3642  
71 0 0 4 71 3632 0 0 67 /**
 * Reads the vector from the Datagram using get_stdfloat().
 */ 2 4 this 3 3627  6 source 1 3644  
72 0 0 7 72 3647 0 0 0 0 
73 0 0 7 76 3648 2071 0 0 0 
74 0 0 7 76 3648 2071 0 0 1 6 param0 0 3649  
75 0 0 7 76 3648 2071 0 10 /**
 *
 */ 1 10 fill_value 1 3485  
76 0 0 7 76 3648 2071 0 10 /**
 *
 */ 2 1 x 1 3485  1 y 1 3485  
77 0 0 4 77 3632 0 0 0 2 4 this 3 3648  4 size 1 3630  
78 0 0 6 80 3648 0 0 0 2 4 this 3 3648  4 copy 1 3649  
79 0 0 6 80 3648 0 0 0 2 4 this 3 3648  10 fill_value 1 3485  
80 0 0 6 81 3649 0 0 40 /**
 * Returns a zero-length vector.
 */ 0 
81 0 0 6 82 3649 0 0 35 /**
 * Returns a unit X vector.
 */ 0 
82 0 0 6 83 3649 0 0 35 /**
 * Returns a unit Y vector.
 */ 0 
83 0 0 6 84 3633 0 0 0 1 4 this 3 3649  
84 0 0 6 85 3633 0 0 0 2 4 this 3 3649  9 attr_name 1 3636  
85 0 0 6 86 3488 0 0 0 3 4 this 3 3648  9 attr_name 1 3636  6 assign 1 3633  
86 0 0 4 87 3632 0 0 10 /**
 *
 */ 3 4 this 3 3648  1 i 1 3488  10 assign_val 1 3485  
87 0 0 6 87 3485 0 0 0 2 4 this 3 3649  1 i 1 3488  
88 0 0 6 88 3488 0 0 0 0 
89 0 0 6 89 3637 0 0 91 /**
 * Returns true if any component of the vector is not-a-number, false
 * otherwise.
 */ 1 4 this 3 3649  
90 0 0 6 90 3485 0 0 10 /**
 *
 */ 2 4 this 3 3649  1 i 1 3488  
91 0 0 4 91 3632 0 0 10 /**
 *
 */ 3 4 this 3 3648  1 i 1 3488  5 value 1 3485  
92 0 0 6 92 3485 0 0 10 /**
 *
 */ 1 4 this 3 3649  
93 0 0 6 93 3485 0 0 10 /**
 *
 */ 1 4 this 3 3649  
94 0 0 4 94 3632 0 0 10 /**
 *
 */ 2 4 this 3 3648  5 value 1 3485  
95 0 0 4 95 3632 0 0 10 /**
 *
 */ 2 4 this 3 3648  5 value 1 3485  
96 0 0 4 99 3632 0 0 152 // These next functions add to an existing value.  i.e.
// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
// scripting languages: 3 4 this 3 3648  1 i 1 3488  5 value 1 3485  
97 0 0 4 100 3632 0 0 10 /**
 *
 */ 2 4 this 3 3648  5 value 1 3485  
98 0 0 4 101 3632 0 0 10 /**
 *
 */ 2 4 this 3 3648  5 value 1 3485  
99 0 0 4 102 3632 0 0 155 /**
 * Returns the address of the first of the two data elements in the vector.
 * The next element occupies the next position consecutively in memory.
 */ 1 4 this 3 3649  
100 0 0 6 103 3488 0 0 0 0 
101 0 0 4 104 3632 0 0 129 /**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */ 2 4 this 3 3648  10 fill_value 1 3485  
102 0 0 4 105 3632 0 0 10 /**
 *
 */ 3 4 this 3 3648  1 x 1 3485  1 y 1 3485  
103 0 0 6 106 3485 0 0 10 /**
 *
 */ 2 4 this 3 3649  5 other 1 3649  
104 0 0 6 107 3485 0 0 69 /**
 * Returns the square of the vector's length, cheap and easy.
 */ 1 4 this 3 3649  
105 0 0 6 108 3485 0 0 72 /**
 * Returns the length of the vector, by the Pythagorean theorem.
 */ 1 4 this 3 3649  
106 0 0 6 109 3637 0 0 127 /**
 * Normalizes the vector in place.  Returns true if the vector was normalized,
 * false if it was a zero-length vector.
 */ 1 4 this 3 3648  
107 0 0 7 110 3648 2071 0 160 /**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */ 1 4 this 3 3649  
108 0 0 7 111 3648 2071 0 152 /**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */ 2 4 this 3 3649  4 onto 1 3649  
109 0 0 6 112 3637 0 0 0 2 4 this 3 3649  5 other 1 3649  
110 0 0 6 113 3637 0 0 0 2 4 this 3 3649  5 other 1 3649  
111 0 0 6 114 3637 0 0 0 2 4 this 3 3649  5 other 1 3649  
112 0 0 6 115 3488 0 0 97 /**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */ 2 4 this 3 3649  5 other 1 3649  
113 0 0 6 115 3488 0 0 233 /**
 * Sorts vectors lexicographically, componentwise.  Returns a number less than
 * 0 if this vector sorts before the other one, greater than zero if it sorts
 * after, 0 if they are equivalent (within the indicated tolerance).
 */ 3 4 this 3 3649  5 other 1 3649  9 threshold 1 3485  
114 0 0 6 116 3630 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 1 4 this 3 3649  
115 0 0 6 116 3630 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 2 4 this 3 3649  9 threshold 1 3485  
116 0 0 6 117 3630 0 0 49 /**
 * Adds the vector into the running hash.
 */ 2 4 this 3 3649  4 hash 1 3630  
117 0 0 6 117 3630 0 0 49 /**
 * Adds the vector into the running hash.
 */ 3 4 this 3 3649  4 hash 1 3630  9 threshold 1 3485  
118 0 0 4 118 3632 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 2 4 this 3 3649  7 hashgen 1 3638  
119 0 0 4 118 3632 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 3 4 this 3 3649  7 hashgen 1 3638  9 threshold 1 3485  
120 0 0 7 119 3648 2071 0 0 1 4 this 3 3649  
121 0 0 7 120 3648 2071 0 0 2 4 this 3 3649  5 other 1 3649  
122 0 0 7 121 3648 2071 0 0 2 4 this 3 3649  5 other 1 3649  
123 0 0 7 122 3648 2071 0 0 2 4 this 3 3649  6 scalar 1 3485  
124 0 0 7 123 3648 2071 0 0 2 4 this 3 3649  6 scalar 1 3485  
125 0 0 6 124 3648 0 0 0 2 4 this 3 3648  5 other 1 3649  
126 0 0 6 125 3648 0 0 0 2 4 this 3 3648  5 other 1 3649  
127 0 0 6 126 3648 0 0 0 2 4 this 3 3648  6 scalar 1 3485  
128 0 0 6 127 3648 0 0 0 2 4 this 3 3648  6 scalar 1 3485  
129 0 0 4 128 3632 0 0 10 /**
 *
 */ 2 4 this 3 3648  5 other 1 3649  
130 0 0 7 129 3648 2071 0 0 2 4 this 3 3649  8 exponent 1 3485  
131 0 0 6 130 3633 0 0 0 2 4 this 3 3648  8 exponent 1 3485  
132 0 0 7 131 3648 2071 0 10 /**
 *
 */ 2 4 this 3 3649  5 other 1 3649  
133 0 0 7 132 3648 2071 0 10 /**
 *
 */ 2 4 this 3 3649  5 other 1 3649  
134 0 0 6 133 3637 0 0 116 /**
 * Returns true if two vectors are memberwise equal within a default tolerance
 * based on the numeric type.
 */ 2 4 this 3 3649  5 other 1 3649  
135 0 0 6 133 3637 0 0 92 /**
 * Returns true if two vectors are memberwise equal within a specified
 * tolerance.
 */ 3 4 this 3 3649  5 other 1 3649  9 threshold 1 3485  
136 0 0 4 134 3632 0 0 10 /**
 *
 */ 2 4 this 3 3649  3 out 1 3640  
137 0 0 6 135 3636 0 0 0 1 4 this 3 3649  
138 0 0 4 136 3632 0 0 332 /**
 * Writes the vector to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the vector, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */ 2 4 this 3 3649  11 destination 1 3642  
139 0 0 4 137 3632 0 0 114 /**
 * Reads the vector from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */ 2 4 this 3 3648  6 source 1 3644  
140 0 0 4 138 3632 0 0 205 /**
 * Writes the vector to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the vector using the standard width
 * setting, especially when you are writing a bam file.
 */ 2 4 this 3 3649  11 destination 1 3642  
141 0 0 4 139 3632 0 0 67 /**
 * Reads the vector from the Datagram using get_stdfloat().
 */ 2 4 this 3 3648  6 source 1 3644  
142 0 0 7 140 3647 0 0 0 0 
143 0 0 7 144 3651 2130 0 0 0 
144 0 0 7 144 3651 2130 0 0 1 6 param0 0 3652  
145 0 0 7 144 3651 2130 0 10 /**
 *
 */ 1 10 fill_value 1 3488  
146 0 0 7 144 3651 2130 0 10 /**
 *
 */ 2 1 x 1 3488  1 y 1 3488  
147 0 0 4 145 3632 0 0 0 2 4 this 3 3651  4 size 1 3630  
148 0 0 6 148 3651 0 0 0 2 4 this 3 3651  4 copy 1 3652  
149 0 0 6 148 3651 0 0 0 2 4 this 3 3651  10 fill_value 1 3488  
150 0 0 6 149 3652 0 0 40 /**
 * Returns a zero-length vector.
 */ 0 
151 0 0 6 150 3652 0 0 35 /**
 * Returns a unit X vector.
 */ 0 
152 0 0 6 151 3652 0 0 35 /**
 * Returns a unit Y vector.
 */ 0 
153 0 0 6 152 3633 0 0 0 1 4 this 3 3652  
154 0 0 6 153 3633 0 0 0 2 4 this 3 3652  9 attr_name 1 3636  
155 0 0 6 154 3488 0 0 0 3 4 this 3 3651  9 attr_name 1 3636  6 assign 1 3633  
156 0 0 4 155 3632 0 0 10 /**
 *
 */ 3 4 this 3 3651  1 i 1 3488  10 assign_val 1 3488  
157 0 0 6 155 3488 0 0 0 2 4 this 3 3652  1 i 1 3488  
158 0 0 6 156 3488 0 0 0 0 
159 0 0 6 157 3637 0 0 91 /**
 * Returns true if any component of the vector is not-a-number, false
 * otherwise.
 */ 1 4 this 3 3652  
160 0 0 6 158 3488 0 0 10 /**
 *
 */ 2 4 this 3 3652  1 i 1 3488  
161 0 0 4 159 3632 0 0 10 /**
 *
 */ 3 4 this 3 3651  1 i 1 3488  5 value 1 3488  
162 0 0 6 160 3488 0 0 10 /**
 *
 */ 1 4 this 3 3652  
163 0 0 6 161 3488 0 0 10 /**
 *
 */ 1 4 this 3 3652  
164 0 0 4 162 3632 0 0 10 /**
 *
 */ 2 4 this 3 3651  5 value 1 3488  
165 0 0 4 163 3632 0 0 10 /**
 *
 */ 2 4 this 3 3651  5 value 1 3488  
166 0 0 4 167 3632 0 0 152 // These next functions add to an existing value.  i.e.
// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
// scripting languages: 3 4 this 3 3651  1 i 1 3488  5 value 1 3488  
167 0 0 4 168 3632 0 0 10 /**
 *
 */ 2 4 this 3 3651  5 value 1 3488  
168 0 0 4 169 3632 0 0 10 /**
 *
 */ 2 4 this 3 3651  5 value 1 3488  
169 0 0 4 170 3632 0 0 155 /**
 * Returns the address of the first of the two data elements in the vector.
 * The next element occupies the next position consecutively in memory.
 */ 1 4 this 3 3652  
170 0 0 6 171 3488 0 0 0 0 
171 0 0 4 172 3632 0 0 129 /**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */ 2 4 this 3 3651  10 fill_value 1 3488  
172 0 0 4 173 3632 0 0 10 /**
 *
 */ 3 4 this 3 3651  1 x 1 3488  1 y 1 3488  
173 0 0 6 174 3488 0 0 10 /**
 *
 */ 2 4 this 3 3652  5 other 1 3652  
174 0 0 6 175 3488 0 0 69 /**
 * Returns the square of the vector's length, cheap and easy.
 */ 1 4 this 3 3652  
175 0 0 6 176 3637 0 0 0 2 4 this 3 3652  5 other 1 3652  
176 0 0 6 177 3637 0 0 0 2 4 this 3 3652  5 other 1 3652  
177 0 0 6 178 3637 0 0 0 2 4 this 3 3652  5 other 1 3652  
178 0 0 6 179 3488 0 0 97 /**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */ 2 4 this 3 3652  5 other 1 3652  
179 0 0 6 180 3630 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 1 4 this 3 3652  
180 0 0 6 181 3630 0 0 49 /**
 * Adds the vector into the running hash.
 */ 2 4 this 3 3652  4 hash 1 3630  
181 0 0 4 182 3632 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 2 4 this 3 3652  7 hashgen 1 3638  
182 0 0 7 183 3651 2130 0 0 1 4 this 3 3652  
183 0 0 7 184 3651 2130 0 0 2 4 this 3 3652  5 other 1 3652  
184 0 0 7 185 3651 2130 0 0 2 4 this 3 3652  5 other 1 3652  
185 0 0 7 186 3651 2130 0 0 2 4 this 3 3652  6 scalar 1 3488  
186 0 0 7 187 3651 2130 0 0 2 4 this 3 3652  6 scalar 1 3488  
187 0 0 6 188 3651 0 0 0 2 4 this 3 3651  5 other 1 3652  
188 0 0 6 189 3651 0 0 0 2 4 this 3 3651  5 other 1 3652  
189 0 0 6 190 3651 0 0 0 2 4 this 3 3651  6 scalar 1 3488  
190 0 0 6 191 3651 0 0 0 2 4 this 3 3651  6 scalar 1 3488  
191 0 0 4 192 3632 0 0 10 /**
 *
 */ 2 4 this 3 3651  5 other 1 3652  
192 0 0 7 193 3651 2130 0 0 2 4 this 3 3652  8 exponent 1 3488  
193 0 0 6 194 3633 0 0 0 2 4 this 3 3651  8 exponent 1 3488  
194 0 0 7 195 3651 2130 0 10 /**
 *
 */ 2 4 this 3 3652  5 other 1 3652  
195 0 0 7 196 3651 2130 0 10 /**
 *
 */ 2 4 this 3 3652  5 other 1 3652  
196 0 0 6 197 3637 0 0 116 /**
 * Returns true if two vectors are memberwise equal within a default tolerance
 * based on the numeric type.
 */ 2 4 this 3 3652  5 other 1 3652  
197 0 0 6 197 3637 0 0 92 /**
 * Returns true if two vectors are memberwise equal within a specified
 * tolerance.
 */ 3 4 this 3 3652  5 other 1 3652  9 threshold 1 3488  
198 0 0 4 198 3632 0 0 10 /**
 *
 */ 2 4 this 3 3652  3 out 1 3640  
199 0 0 6 199 3636 0 0 0 1 4 this 3 3652  
200 0 0 4 200 3632 0 0 332 /**
 * Writes the vector to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the vector, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */ 2 4 this 3 3652  11 destination 1 3642  
201 0 0 4 201 3632 0 0 114 /**
 * Reads the vector from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */ 2 4 this 3 3651  6 source 1 3644  
202 0 0 4 202 3632 0 0 205 /**
 * Writes the vector to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the vector using the standard width
 * setting, especially when you are writing a bam file.
 */ 2 4 this 3 3652  11 destination 1 3642  
203 0 0 4 203 3632 0 0 67 /**
 * Reads the vector from the Datagram using get_stdfloat().
 */ 2 4 this 3 3651  6 source 1 3644  
204 0 0 7 204 3647 0 0 0 0 
205 0 0 7 207 3654 2148 0 0 0 
206 0 0 7 207 3654 2148 0 53 /**
 * Constructs a new LVector2 from a LVecBase2
 */ 1 4 copy 1 3628  
207 0 0 7 207 3654 2148 0 0 1 6 param0 0 3655  
208 0 0 7 207 3654 2148 0 79 /**
 * Constructs a new LVector2 with all components set to the fill value.
 */ 1 10 fill_value 1 3482  
209 0 0 7 207 3654 2148 0 10 /**
 *
 */ 2 1 x 1 3482  1 y 1 3482  
210 0 0 6 208 3633 0 0 0 2 4 this 3 3655  9 attr_name 1 3636  
211 0 0 6 209 3488 0 0 0 3 4 this 3 3654  9 attr_name 1 3636  6 assign 1 3633  
212 0 0 6 210 3655 0 0 40 /**
 * Returns a zero-length vector.
 */ 0 
213 0 0 6 211 3655 0 0 35 /**
 * Returns a unit X vector.
 */ 0 
214 0 0 6 212 3655 0 0 35 /**
 * Returns a unit Y vector.
 */ 0 
215 0 0 7 213 3654 2148 0 0 1 4 this 3 3655  
216 0 0 7 214 3627 2008 0 0 2 4 this 3 3655  5 other 1 3628  
217 0 0 7 214 3654 2148 0 0 2 4 this 3 3655  5 other 1 3655  
218 0 0 7 215 3627 2008 0 0 2 4 this 3 3655  5 other 1 3628  
219 0 0 7 215 3654 2148 0 0 2 4 this 3 3655  5 other 1 3655  
220 0 0 7 216 3654 2148 0 0 2 4 this 3 3655  6 scalar 1 3482  
221 0 0 7 217 3654 2148 0 0 2 4 this 3 3655  6 scalar 1 3482  
222 0 0 7 218 3654 2148 0 160 /**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */ 1 4 this 3 3655  
223 0 0 7 219 3654 2148 0 152 /**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */ 2 4 this 3 3655  4 onto 1 3628  
224 0 0 6 220 3482 0 0 92 /**
 * returns the signed angled between two vectors.  normalization is NOT
 * necessary
 */ 2 4 this 3 3655  5 other 1 3655  
225 0 0 6 221 3482 0 0 92 /**
 * returns the signed angled between two vectors.  normalization is NOT
 * necessary
 */ 2 4 this 3 3655  5 other 1 3655  
226 0 0 6 222 3636 0 0 0 1 4 this 3 3655  
227 0 0 7 223 3647 0 0 0 0 
228 0 0 7 226 3657 2166 0 0 0 
229 0 0 7 226 3657 2166 0 53 /**
 * Constructs a new LVector2 from a LVecBase2
 */ 1 4 copy 1 3649  
230 0 0 7 226 3657 2166 0 0 1 6 param0 0 3658  
231 0 0 7 226 3657 2166 0 79 /**
 * Constructs a new LVector2 with all components set to the fill value.
 */ 1 10 fill_value 1 3485  
232 0 0 7 226 3657 2166 0 10 /**
 *
 */ 2 1 x 1 3485  1 y 1 3485  
233 0 0 6 227 3633 0 0 0 2 4 this 3 3658  9 attr_name 1 3636  
234 0 0 6 228 3488 0 0 0 3 4 this 3 3657  9 attr_name 1 3636  6 assign 1 3633  
235 0 0 6 229 3658 0 0 40 /**
 * Returns a zero-length vector.
 */ 0 
236 0 0 6 230 3658 0 0 35 /**
 * Returns a unit X vector.
 */ 0 
237 0 0 6 231 3658 0 0 35 /**
 * Returns a unit Y vector.
 */ 0 
238 0 0 7 232 3657 2166 0 0 1 4 this 3 3658  
239 0 0 7 233 3648 2071 0 0 2 4 this 3 3658  5 other 1 3649  
240 0 0 7 233 3657 2166 0 0 2 4 this 3 3658  5 other 1 3658  
241 0 0 7 234 3648 2071 0 0 2 4 this 3 3658  5 other 1 3649  
242 0 0 7 234 3657 2166 0 0 2 4 this 3 3658  5 other 1 3658  
243 0 0 7 235 3657 2166 0 0 2 4 this 3 3658  6 scalar 1 3485  
244 0 0 7 236 3657 2166 0 0 2 4 this 3 3658  6 scalar 1 3485  
245 0 0 7 237 3657 2166 0 160 /**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */ 1 4 this 3 3658  
246 0 0 7 238 3657 2166 0 152 /**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */ 2 4 this 3 3658  4 onto 1 3649  
247 0 0 6 239 3485 0 0 92 /**
 * returns the signed angled between two vectors.  normalization is NOT
 * necessary
 */ 2 4 this 3 3658  5 other 1 3658  
248 0 0 6 240 3485 0 0 92 /**
 * returns the signed angled between two vectors.  normalization is NOT
 * necessary
 */ 2 4 this 3 3658  5 other 1 3658  
249 0 0 6 241 3636 0 0 0 1 4 this 3 3658  
250 0 0 7 242 3647 0 0 0 0 
251 0 0 7 245 3660 2180 0 0 0 
252 0 0 7 245 3660 2180 0 53 /**
 * Constructs a new LVector2 from a LVecBase2
 */ 1 4 copy 1 3652  
253 0 0 7 245 3660 2180 0 0 1 6 param0 0 3661  
254 0 0 7 245 3660 2180 0 79 /**
 * Constructs a new LVector2 with all components set to the fill value.
 */ 1 10 fill_value 1 3488  
255 0 0 7 245 3660 2180 0 10 /**
 *
 */ 2 1 x 1 3488  1 y 1 3488  
256 0 0 6 246 3633 0 0 0 2 4 this 3 3661  9 attr_name 1 3636  
257 0 0 6 247 3488 0 0 0 3 4 this 3 3660  9 attr_name 1 3636  6 assign 1 3633  
258 0 0 6 248 3661 0 0 40 /**
 * Returns a zero-length vector.
 */ 0 
259 0 0 6 249 3661 0 0 35 /**
 * Returns a unit X vector.
 */ 0 
260 0 0 6 250 3661 0 0 35 /**
 * Returns a unit Y vector.
 */ 0 
261 0 0 7 251 3660 2180 0 0 1 4 this 3 3661  
262 0 0 7 252 3651 2130 0 0 2 4 this 3 3661  5 other 1 3652  
263 0 0 7 252 3660 2180 0 0 2 4 this 3 3661  5 other 1 3661  
264 0 0 7 253 3651 2130 0 0 2 4 this 3 3661  5 other 1 3652  
265 0 0 7 253 3660 2180 0 0 2 4 this 3 3661  5 other 1 3661  
266 0 0 7 254 3660 2180 0 0 2 4 this 3 3661  6 scalar 1 3488  
267 0 0 7 255 3660 2180 0 0 2 4 this 3 3661  6 scalar 1 3488  
268 0 0 6 256 3636 0 0 0 1 4 this 3 3661  
269 0 0 7 257 3647 0 0 0 0 
270 0 0 7 260 3663 2196 0 0 0 
271 0 0 7 260 3663 2196 0 0 1 6 param0 0 3664  
272 0 0 7 260 3663 2196 0 52 /**
 * Constructs a new LPoint2 from a LVecBase2
 */ 1 4 copy 1 3628  
273 0 0 7 260 3663 2196 0 73 /**
 * Constructs a new LPoint2 all components set to the fill value.
 */ 1 10 fill_value 1 3482  
274 0 0 7 260 3663 2196 0 61 /**
 * Constructs a new LPoint2 with the given components
 */ 2 1 x 1 3482  1 y 1 3482  
275 0 0 6 261 3633 0 0 0 2 4 this 3 3664  9 attr_name 1 3636  
276 0 0 6 262 3488 0 0 0 3 4 this 3 3663  9 attr_name 1 3636  6 assign 1 3633  
277 0 0 6 263 3664 0 0 39 /**
 * Returns a zero-length point.
 */ 0 
278 0 0 6 264 3664 0 0 34 /**
 * Returns a unit X point.
 */ 0 
279 0 0 6 265 3664 0 0 34 /**
 * Returns a unit Y point.
 */ 0 
280 0 0 7 266 3663 2196 0 0 1 4 this 3 3664  
281 0 0 7 267 3627 2008 0 0 2 4 this 3 3664  5 other 1 3628  
282 0 0 7 267 3663 2196 0 0 2 4 this 3 3664  5 other 1 3655  
283 0 0 7 268 3654 2148 0 0 2 4 this 3 3664  5 other 1 3664  
284 0 0 7 268 3627 2008 0 0 2 4 this 3 3664  5 other 1 3628  
285 0 0 7 268 3663 2196 0 0 2 4 this 3 3664  5 other 1 3655  
286 0 0 7 269 3663 2196 0 0 2 4 this 3 3664  6 scalar 1 3482  
287 0 0 7 270 3663 2196 0 0 2 4 this 3 3664  6 scalar 1 3482  
288 0 0 7 271 3663 2196 0 160 /**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */ 1 4 this 3 3664  
289 0 0 7 272 3663 2196 0 152 /**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */ 2 4 this 3 3664  4 onto 1 3628  
290 0 0 6 273 3636 0 0 0 1 4 this 3 3664  
291 0 0 7 274 3647 0 0 0 0 
292 0 0 7 277 3666 2212 0 0 0 
293 0 0 7 277 3666 2212 0 0 1 6 param0 0 3667  
294 0 0 7 277 3666 2212 0 52 /**
 * Constructs a new LPoint2 from a LVecBase2
 */ 1 4 copy 1 3649  
295 0 0 7 277 3666 2212 0 73 /**
 * Constructs a new LPoint2 all components set to the fill value.
 */ 1 10 fill_value 1 3485  
296 0 0 7 277 3666 2212 0 61 /**
 * Constructs a new LPoint2 with the given components
 */ 2 1 x 1 3485  1 y 1 3485  
297 0 0 6 278 3633 0 0 0 2 4 this 3 3667  9 attr_name 1 3636  
298 0 0 6 279 3488 0 0 0 3 4 this 3 3666  9 attr_name 1 3636  6 assign 1 3633  
299 0 0 6 280 3667 0 0 39 /**
 * Returns a zero-length point.
 */ 0 
300 0 0 6 281 3667 0 0 34 /**
 * Returns a unit X point.
 */ 0 
301 0 0 6 282 3667 0 0 34 /**
 * Returns a unit Y point.
 */ 0 
302 0 0 7 283 3666 2212 0 0 1 4 this 3 3667  
303 0 0 7 284 3648 2071 0 0 2 4 this 3 3667  5 other 1 3649  
304 0 0 7 284 3666 2212 0 0 2 4 this 3 3667  5 other 1 3658  
305 0 0 7 285 3657 2166 0 0 2 4 this 3 3667  5 other 1 3667  
306 0 0 7 285 3648 2071 0 0 2 4 this 3 3667  5 other 1 3649  
307 0 0 7 285 3666 2212 0 0 2 4 this 3 3667  5 other 1 3658  
308 0 0 7 286 3666 2212 0 0 2 4 this 3 3667  6 scalar 1 3485  
309 0 0 7 287 3666 2212 0 0 2 4 this 3 3667  6 scalar 1 3485  
310 0 0 7 288 3666 2212 0 160 /**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */ 1 4 this 3 3667  
311 0 0 7 289 3666 2212 0 152 /**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */ 2 4 this 3 3667  4 onto 1 3649  
312 0 0 6 290 3636 0 0 0 1 4 this 3 3667  
313 0 0 7 291 3647 0 0 0 0 
314 0 0 7 294 3669 2226 0 0 0 
315 0 0 7 294 3669 2226 0 0 1 6 param0 0 3670  
316 0 0 7 294 3669 2226 0 52 /**
 * Constructs a new LPoint2 from a LVecBase2
 */ 1 4 copy 1 3652  
317 0 0 7 294 3669 2226 0 73 /**
 * Constructs a new LPoint2 all components set to the fill value.
 */ 1 10 fill_value 1 3488  
318 0 0 7 294 3669 2226 0 61 /**
 * Constructs a new LPoint2 with the given components
 */ 2 1 x 1 3488  1 y 1 3488  
319 0 0 6 295 3633 0 0 0 2 4 this 3 3670  9 attr_name 1 3636  
320 0 0 6 296 3488 0 0 0 3 4 this 3 3669  9 attr_name 1 3636  6 assign 1 3633  
321 0 0 6 297 3670 0 0 39 /**
 * Returns a zero-length point.
 */ 0 
322 0 0 6 298 3670 0 0 34 /**
 * Returns a unit X point.
 */ 0 
323 0 0 6 299 3670 0 0 34 /**
 * Returns a unit Y point.
 */ 0 
324 0 0 7 300 3669 2226 0 0 1 4 this 3 3670  
325 0 0 7 301 3651 2130 0 0 2 4 this 3 3670  5 other 1 3652  
326 0 0 7 301 3669 2226 0 0 2 4 this 3 3670  5 other 1 3661  
327 0 0 7 302 3660 2180 0 0 2 4 this 3 3670  5 other 1 3670  
328 0 0 7 302 3651 2130 0 0 2 4 this 3 3670  5 other 1 3652  
329 0 0 7 302 3669 2226 0 0 2 4 this 3 3670  5 other 1 3661  
330 0 0 7 303 3669 2226 0 0 2 4 this 3 3670  6 scalar 1 3488  
331 0 0 7 304 3669 2226 0 0 2 4 this 3 3670  6 scalar 1 3488  
332 0 0 6 305 3636 0 0 0 1 4 this 3 3670  
333 0 0 7 306 3647 0 0 0 0 
334 0 0 7 310 3672 2299 0 0 0 
335 0 0 7 310 3672 2299 0 10 /**
 *
 */ 2 4 copy 1 3628  1 z 1 3482  
336 0 0 7 310 3672 2299 0 0 1 6 param0 0 3673  
337 0 0 7 310 3672 2299 0 10 /**
 *
 */ 1 10 fill_value 1 3482  
338 0 0 7 310 3672 2299 0 10 /**
 *
 */ 3 1 x 1 3482  1 y 1 3482  1 z 1 3482  
339 0 0 4 311 3632 0 0 0 2 4 this 3 3672  4 size 1 3630  
340 0 0 6 314 3672 0 0 0 2 4 this 3 3672  4 copy 1 3673  
341 0 0 6 314 3672 0 0 0 2 4 this 3 3672  10 fill_value 1 3482  
342 0 0 6 315 3673 0 0 40 /**
 * Returns a zero-length vector.
 */ 0 
343 0 0 6 316 3673 0 0 35 /**
 * Returns a unit X vector.
 */ 0 
344 0 0 6 317 3673 0 0 35 /**
 * Returns a unit Y vector.
 */ 0 
345 0 0 6 318 3673 0 0 35 /**
 * Returns a unit Z vector.
 */ 0 
346 0 0 6 319 3633 0 0 0 1 4 this 3 3673  
347 0 0 6 320 3633 0 0 0 2 4 this 3 3673  9 attr_name 1 3636  
348 0 0 6 321 3488 0 0 0 3 4 this 3 3672  9 attr_name 1 3636  6 assign 1 3633  
349 0 0 4 322 3632 0 0 10 /**
 *
 */ 3 4 this 3 3672  1 i 1 3488  10 assign_val 1 3482  
350 0 0 6 322 3482 0 0 0 2 4 this 3 3673  1 i 1 3488  
351 0 0 6 323 3488 0 0 0 0 
352 0 0 6 324 3637 0 0 91 /**
 * Returns true if any component of the vector is not-a-number, false
 * otherwise.
 */ 1 4 this 3 3673  
353 0 0 6 325 3482 0 0 10 /**
 *
 */ 2 4 this 3 3673  1 i 1 3488  
354 0 0 6 326 3482 0 0 10 /**
 *
 */ 1 4 this 3 3673  
355 0 0 6 327 3482 0 0 10 /**
 *
 */ 1 4 this 3 3673  
356 0 0 6 328 3482 0 0 10 /**
 *
 */ 1 4 this 3 3673  
357 0 0 4 329 3632 0 0 10 /**
 *
 */ 3 4 this 3 3672  1 i 1 3488  5 value 1 3482  
358 0 0 4 330 3632 0 0 10 /**
 *
 */ 2 4 this 3 3672  5 value 1 3482  
359 0 0 4 331 3632 0 0 10 /**
 *
 */ 2 4 this 3 3672  5 value 1 3482  
360 0 0 4 332 3632 0 0 10 /**
 *
 */ 2 4 this 3 3672  5 value 1 3482  
361 0 0 7 333 3627 2008 0 100 /**
 * Returns a 2-component vector that shares just the first two components of
 * this vector.
 */ 1 4 this 3 3673  
362 0 0 7 334 3627 2008 0 105 /**
 * Returns a 2-component vector that shares just the first and last components
 * of this vector.
 */ 1 4 this 3 3673  
363 0 0 7 335 3627 2008 0 99 /**
 * Returns a 2-component vector that shares just the last two components of
 * this vector.
 */ 1 4 this 3 3673  
364 0 0 4 342 3632 0 0 152 // These next functions add to an existing value.  i.e.
// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
// scripting languages: 3 4 this 3 3672  1 i 1 3488  5 value 1 3482  
365 0 0 4 343 3632 0 0 10 /**
 *
 */ 2 4 this 3 3672  5 value 1 3482  
366 0 0 4 344 3632 0 0 10 /**
 *
 */ 2 4 this 3 3672  5 value 1 3482  
367 0 0 4 345 3632 0 0 10 /**
 *
 */ 2 4 this 3 3672  5 value 1 3482  
368 0 0 4 346 3632 0 0 162 /**
 * Returns the address of the first of the three data elements in the vector.
 * The remaining elements occupy the next positions consecutively in memory.
 */ 1 4 this 3 3673  
369 0 0 6 347 3488 0 0 0 0 
370 0 0 4 348 3632 0 0 129 /**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */ 2 4 this 3 3672  10 fill_value 1 3482  
371 0 0 4 349 3632 0 0 10 /**
 *
 */ 4 4 this 3 3672  1 x 1 3482  1 y 1 3482  1 z 1 3482  
372 0 0 6 350 3482 0 0 10 /**
 *
 */ 2 4 this 3 3673  5 other 1 3673  
373 0 0 6 351 3482 0 0 69 /**
 * Returns the square of the vector's length, cheap and easy.
 */ 1 4 this 3 3673  
374 0 0 6 352 3482 0 0 72 /**
 * Returns the length of the vector, by the Pythagorean theorem.
 */ 1 4 this 3 3673  
375 0 0 6 353 3637 0 0 127 /**
 * Normalizes the vector in place.  Returns true if the vector was normalized,
 * false if it was a zero-length vector.
 */ 1 4 this 3 3672  
376 0 0 7 354 3672 2299 0 160 /**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */ 1 4 this 3 3673  
377 0 0 7 355 3672 2299 0 152 /**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */ 2 4 this 3 3673  4 onto 1 3673  
378 0 0 7 356 3672 2299 0 10 /**
 *
 */ 2 4 this 3 3673  5 other 1 3673  
379 0 0 6 357 3637 0 0 0 2 4 this 3 3673  5 other 1 3673  
380 0 0 6 358 3637 0 0 0 2 4 this 3 3673  5 other 1 3673  
381 0 0 6 359 3637 0 0 0 2 4 this 3 3673  5 other 1 3673  
382 0 0 7 360 3672 2299 0 623 /**
 * Try to un-spin the hpr to a standard form.  Like all standards, someone
 * decides between many arbitrary possible standards.  This function assumes
 * that 0 and 360 are the same, as is 720 and -360.  Also 180 and -180 are the
 * same.  Another example is -90 and 270. Each element will be in the range
 * -180.0 to 179.99999. The original usage of this function is for human
 * readable output.
 *
 * It doesn't work so well for asserting that foo_hpr is roughly equal to
 * bar_hpr.  Try using LQuaternionf::is_same_direction() for that.  See Also:
 * get_standardized_rotation, LQuaternion::is_same_direction
 */ 1 4 this 3 3673  
383 0 0 6 361 3488 0 0 97 /**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */ 2 4 this 3 3673  5 other 1 3673  
384 0 0 6 361 3488 0 0 233 /**
 * Sorts vectors lexicographically, componentwise.  Returns a number less than
 * 0 if this vector sorts before the other one, greater than zero if it sorts
 * after, 0 if they are equivalent (within the indicated tolerance).
 */ 3 4 this 3 3673  5 other 1 3673  9 threshold 1 3482  
385 0 0 6 362 3630 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 1 4 this 3 3673  
386 0 0 6 362 3630 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 2 4 this 3 3673  9 threshold 1 3482  
387 0 0 6 363 3630 0 0 49 /**
 * Adds the vector into the running hash.
 */ 2 4 this 3 3673  4 hash 1 3630  
388 0 0 6 363 3630 0 0 49 /**
 * Adds the vector into the running hash.
 */ 3 4 this 3 3673  4 hash 1 3630  9 threshold 1 3482  
389 0 0 4 364 3632 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 2 4 this 3 3673  7 hashgen 1 3638  
390 0 0 4 364 3632 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 3 4 this 3 3673  7 hashgen 1 3638  9 threshold 1 3482  
391 0 0 7 365 3672 2299 0 0 1 4 this 3 3673  
392 0 0 7 366 3672 2299 0 0 2 4 this 3 3673  5 other 1 3673  
393 0 0 7 367 3672 2299 0 0 2 4 this 3 3673  5 other 1 3673  
394 0 0 7 368 3672 2299 0 0 2 4 this 3 3673  6 scalar 1 3482  
395 0 0 7 369 3672 2299 0 0 2 4 this 3 3673  6 scalar 1 3482  
396 0 0 6 370 3672 0 0 0 2 4 this 3 3672  5 other 1 3673  
397 0 0 6 371 3672 0 0 0 2 4 this 3 3672  5 other 1 3673  
398 0 0 6 372 3672 0 0 0 2 4 this 3 3672  6 scalar 1 3482  
399 0 0 6 373 3672 0 0 0 2 4 this 3 3672  6 scalar 1 3482  
400 0 0 4 374 3632 0 0 10 /**
 *
 */ 2 4 this 3 3672  5 other 1 3673  
401 0 0 7 375 3672 2299 0 0 2 4 this 3 3673  8 exponent 1 3482  
402 0 0 6 376 3633 0 0 0 2 4 this 3 3672  8 exponent 1 3482  
403 0 0 7 377 3672 2299 0 10 /**
 *
 */ 2 4 this 3 3673  5 other 1 3673  
404 0 0 7 378 3672 2299 0 10 /**
 *
 */ 2 4 this 3 3673  5 other 1 3673  
405 0 0 4 379 3632 0 0 10 /**
 *
 */ 2 4 this 3 3672  5 other 1 3673  
406 0 0 6 380 3637 0 0 116 /**
 * Returns true if two vectors are memberwise equal within a default tolerance
 * based on the numeric type.
 */ 2 4 this 3 3673  5 other 1 3673  
407 0 0 6 380 3637 0 0 92 /**
 * Returns true if two vectors are memberwise equal within a specified
 * tolerance.
 */ 3 4 this 3 3673  5 other 1 3673  9 threshold 1 3482  
408 0 0 4 381 3632 0 0 10 /**
 *
 */ 2 4 this 3 3673  3 out 1 3640  
409 0 0 6 382 3636 0 0 0 1 4 this 3 3673  
410 0 0 4 383 3632 0 0 332 /**
 * Writes the vector to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the vector, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */ 2 4 this 3 3673  11 destination 1 3642  
411 0 0 4 384 3632 0 0 114 /**
 * Reads the vector from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */ 2 4 this 3 3672  6 source 1 3644  
412 0 0 4 385 3632 0 0 205 /**
 * Writes the vector to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the vector using the standard width
 * setting, especially when you are writing a bam file.
 */ 2 4 this 3 3673  11 destination 1 3642  
413 0 0 4 386 3632 0 0 67 /**
 * Reads the vector from the Datagram using get_stdfloat().
 */ 2 4 this 3 3672  6 source 1 3644  
414 0 0 7 387 3647 0 0 0 0 
415 0 0 7 391 3675 2372 0 0 0 
416 0 0 7 391 3675 2372 0 10 /**
 *
 */ 2 4 copy 1 3649  1 z 1 3485  
417 0 0 7 391 3675 2372 0 0 1 6 param0 0 3676  
418 0 0 7 391 3675 2372 0 10 /**
 *
 */ 1 10 fill_value 1 3485  
419 0 0 7 391 3675 2372 0 10 /**
 *
 */ 3 1 x 1 3485  1 y 1 3485  1 z 1 3485  
420 0 0 4 392 3632 0 0 0 2 4 this 3 3675  4 size 1 3630  
421 0 0 6 395 3675 0 0 0 2 4 this 3 3675  4 copy 1 3676  
422 0 0 6 395 3675 0 0 0 2 4 this 3 3675  10 fill_value 1 3485  
423 0 0 6 396 3676 0 0 40 /**
 * Returns a zero-length vector.
 */ 0 
424 0 0 6 397 3676 0 0 35 /**
 * Returns a unit X vector.
 */ 0 
425 0 0 6 398 3676 0 0 35 /**
 * Returns a unit Y vector.
 */ 0 
426 0 0 6 399 3676 0 0 35 /**
 * Returns a unit Z vector.
 */ 0 
427 0 0 6 400 3633 0 0 0 1 4 this 3 3676  
428 0 0 6 401 3633 0 0 0 2 4 this 3 3676  9 attr_name 1 3636  
429 0 0 6 402 3488 0 0 0 3 4 this 3 3675  9 attr_name 1 3636  6 assign 1 3633  
430 0 0 4 403 3632 0 0 10 /**
 *
 */ 3 4 this 3 3675  1 i 1 3488  10 assign_val 1 3485  
431 0 0 6 403 3485 0 0 0 2 4 this 3 3676  1 i 1 3488  
432 0 0 6 404 3488 0 0 0 0 
433 0 0 6 405 3637 0 0 91 /**
 * Returns true if any component of the vector is not-a-number, false
 * otherwise.
 */ 1 4 this 3 3676  
434 0 0 6 406 3485 0 0 10 /**
 *
 */ 2 4 this 3 3676  1 i 1 3488  
435 0 0 6 407 3485 0 0 10 /**
 *
 */ 1 4 this 3 3676  
436 0 0 6 408 3485 0 0 10 /**
 *
 */ 1 4 this 3 3676  
437 0 0 6 409 3485 0 0 10 /**
 *
 */ 1 4 this 3 3676  
438 0 0 4 410 3632 0 0 10 /**
 *
 */ 3 4 this 3 3675  1 i 1 3488  5 value 1 3485  
439 0 0 4 411 3632 0 0 10 /**
 *
 */ 2 4 this 3 3675  5 value 1 3485  
440 0 0 4 412 3632 0 0 10 /**
 *
 */ 2 4 this 3 3675  5 value 1 3485  
441 0 0 4 413 3632 0 0 10 /**
 *
 */ 2 4 this 3 3675  5 value 1 3485  
442 0 0 7 414 3648 2071 0 100 /**
 * Returns a 2-component vector that shares just the first two components of
 * this vector.
 */ 1 4 this 3 3676  
443 0 0 7 415 3648 2071 0 105 /**
 * Returns a 2-component vector that shares just the first and last components
 * of this vector.
 */ 1 4 this 3 3676  
444 0 0 7 416 3648 2071 0 99 /**
 * Returns a 2-component vector that shares just the last two components of
 * this vector.
 */ 1 4 this 3 3676  
445 0 0 4 423 3632 0 0 152 // These next functions add to an existing value.  i.e.
// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
// scripting languages: 3 4 this 3 3675  1 i 1 3488  5 value 1 3485  
446 0 0 4 424 3632 0 0 10 /**
 *
 */ 2 4 this 3 3675  5 value 1 3485  
447 0 0 4 425 3632 0 0 10 /**
 *
 */ 2 4 this 3 3675  5 value 1 3485  
448 0 0 4 426 3632 0 0 10 /**
 *
 */ 2 4 this 3 3675  5 value 1 3485  
449 0 0 4 427 3632 0 0 162 /**
 * Returns the address of the first of the three data elements in the vector.
 * The remaining elements occupy the next positions consecutively in memory.
 */ 1 4 this 3 3676  
450 0 0 6 428 3488 0 0 0 0 
451 0 0 4 429 3632 0 0 129 /**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */ 2 4 this 3 3675  10 fill_value 1 3485  
452 0 0 4 430 3632 0 0 10 /**
 *
 */ 4 4 this 3 3675  1 x 1 3485  1 y 1 3485  1 z 1 3485  
453 0 0 6 431 3485 0 0 10 /**
 *
 */ 2 4 this 3 3676  5 other 1 3676  
454 0 0 6 432 3485 0 0 69 /**
 * Returns the square of the vector's length, cheap and easy.
 */ 1 4 this 3 3676  
455 0 0 6 433 3485 0 0 72 /**
 * Returns the length of the vector, by the Pythagorean theorem.
 */ 1 4 this 3 3676  
456 0 0 6 434 3637 0 0 127 /**
 * Normalizes the vector in place.  Returns true if the vector was normalized,
 * false if it was a zero-length vector.
 */ 1 4 this 3 3675  
457 0 0 7 435 3675 2372 0 160 /**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */ 1 4 this 3 3676  
458 0 0 7 436 3675 2372 0 152 /**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */ 2 4 this 3 3676  4 onto 1 3676  
459 0 0 7 437 3675 2372 0 10 /**
 *
 */ 2 4 this 3 3676  5 other 1 3676  
460 0 0 6 438 3637 0 0 0 2 4 this 3 3676  5 other 1 3676  
461 0 0 6 439 3637 0 0 0 2 4 this 3 3676  5 other 1 3676  
462 0 0 6 440 3637 0 0 0 2 4 this 3 3676  5 other 1 3676  
463 0 0 7 441 3675 2372 0 623 /**
 * Try to un-spin the hpr to a standard form.  Like all standards, someone
 * decides between many arbitrary possible standards.  This function assumes
 * that 0 and 360 are the same, as is 720 and -360.  Also 180 and -180 are the
 * same.  Another example is -90 and 270. Each element will be in the range
 * -180.0 to 179.99999. The original usage of this function is for human
 * readable output.
 *
 * It doesn't work so well for asserting that foo_hpr is roughly equal to
 * bar_hpr.  Try using LQuaternionf::is_same_direction() for that.  See Also:
 * get_standardized_rotation, LQuaternion::is_same_direction
 */ 1 4 this 3 3676  
464 0 0 6 442 3488 0 0 97 /**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */ 2 4 this 3 3676  5 other 1 3676  
465 0 0 6 442 3488 0 0 233 /**
 * Sorts vectors lexicographically, componentwise.  Returns a number less than
 * 0 if this vector sorts before the other one, greater than zero if it sorts
 * after, 0 if they are equivalent (within the indicated tolerance).
 */ 3 4 this 3 3676  5 other 1 3676  9 threshold 1 3485  
466 0 0 6 443 3630 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 1 4 this 3 3676  
467 0 0 6 443 3630 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 2 4 this 3 3676  9 threshold 1 3485  
468 0 0 6 444 3630 0 0 49 /**
 * Adds the vector into the running hash.
 */ 2 4 this 3 3676  4 hash 1 3630  
469 0 0 6 444 3630 0 0 49 /**
 * Adds the vector into the running hash.
 */ 3 4 this 3 3676  4 hash 1 3630  9 threshold 1 3485  
470 0 0 4 445 3632 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 2 4 this 3 3676  7 hashgen 1 3638  
471 0 0 4 445 3632 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 3 4 this 3 3676  7 hashgen 1 3638  9 threshold 1 3485  
472 0 0 7 446 3675 2372 0 0 1 4 this 3 3676  
473 0 0 7 447 3675 2372 0 0 2 4 this 3 3676  5 other 1 3676  
474 0 0 7 448 3675 2372 0 0 2 4 this 3 3676  5 other 1 3676  
475 0 0 7 449 3675 2372 0 0 2 4 this 3 3676  6 scalar 1 3485  
476 0 0 7 450 3675 2372 0 0 2 4 this 3 3676  6 scalar 1 3485  
477 0 0 6 451 3675 0 0 0 2 4 this 3 3675  5 other 1 3676  
478 0 0 6 452 3675 0 0 0 2 4 this 3 3675  5 other 1 3676  
479 0 0 6 453 3675 0 0 0 2 4 this 3 3675  6 scalar 1 3485  
480 0 0 6 454 3675 0 0 0 2 4 this 3 3675  6 scalar 1 3485  
481 0 0 4 455 3632 0 0 10 /**
 *
 */ 2 4 this 3 3675  5 other 1 3676  
482 0 0 7 456 3675 2372 0 0 2 4 this 3 3676  8 exponent 1 3485  
483 0 0 6 457 3633 0 0 0 2 4 this 3 3675  8 exponent 1 3485  
484 0 0 7 458 3675 2372 0 10 /**
 *
 */ 2 4 this 3 3676  5 other 1 3676  
485 0 0 7 459 3675 2372 0 10 /**
 *
 */ 2 4 this 3 3676  5 other 1 3676  
486 0 0 4 460 3632 0 0 10 /**
 *
 */ 2 4 this 3 3675  5 other 1 3676  
487 0 0 6 461 3637 0 0 116 /**
 * Returns true if two vectors are memberwise equal within a default tolerance
 * based on the numeric type.
 */ 2 4 this 3 3676  5 other 1 3676  
488 0 0 6 461 3637 0 0 92 /**
 * Returns true if two vectors are memberwise equal within a specified
 * tolerance.
 */ 3 4 this 3 3676  5 other 1 3676  9 threshold 1 3485  
489 0 0 4 462 3632 0 0 10 /**
 *
 */ 2 4 this 3 3676  3 out 1 3640  
490 0 0 6 463 3636 0 0 0 1 4 this 3 3676  
491 0 0 4 464 3632 0 0 332 /**
 * Writes the vector to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the vector, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */ 2 4 this 3 3676  11 destination 1 3642  
492 0 0 4 465 3632 0 0 114 /**
 * Reads the vector from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */ 2 4 this 3 3675  6 source 1 3644  
493 0 0 4 466 3632 0 0 205 /**
 * Writes the vector to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the vector using the standard width
 * setting, especially when you are writing a bam file.
 */ 2 4 this 3 3676  11 destination 1 3642  
494 0 0 4 467 3632 0 0 67 /**
 * Reads the vector from the Datagram using get_stdfloat().
 */ 2 4 this 3 3675  6 source 1 3644  
495 0 0 7 468 3647 0 0 0 0 
496 0 0 7 472 3678 2440 0 0 0 
497 0 0 7 472 3678 2440 0 10 /**
 *
 */ 2 4 copy 1 3652  1 z 1 3488  
498 0 0 7 472 3678 2440 0 0 1 6 param0 0 3679  
499 0 0 7 472 3678 2440 0 10 /**
 *
 */ 1 10 fill_value 1 3488  
500 0 0 7 472 3678 2440 0 10 /**
 *
 */ 3 1 x 1 3488  1 y 1 3488  1 z 1 3488  
501 0 0 4 473 3632 0 0 0 2 4 this 3 3678  4 size 1 3630  
502 0 0 6 476 3678 0 0 0 2 4 this 3 3678  4 copy 1 3679  
503 0 0 6 476 3678 0 0 0 2 4 this 3 3678  10 fill_value 1 3488  
504 0 0 6 477 3679 0 0 40 /**
 * Returns a zero-length vector.
 */ 0 
505 0 0 6 478 3679 0 0 35 /**
 * Returns a unit X vector.
 */ 0 
506 0 0 6 479 3679 0 0 35 /**
 * Returns a unit Y vector.
 */ 0 
507 0 0 6 480 3679 0 0 35 /**
 * Returns a unit Z vector.
 */ 0 
508 0 0 6 481 3633 0 0 0 1 4 this 3 3679  
509 0 0 6 482 3633 0 0 0 2 4 this 3 3679  9 attr_name 1 3636  
510 0 0 6 483 3488 0 0 0 3 4 this 3 3678  9 attr_name 1 3636  6 assign 1 3633  
511 0 0 4 484 3632 0 0 10 /**
 *
 */ 3 4 this 3 3678  1 i 1 3488  10 assign_val 1 3488  
512 0 0 6 484 3488 0 0 0 2 4 this 3 3679  1 i 1 3488  
513 0 0 6 485 3488 0 0 0 0 
514 0 0 6 486 3637 0 0 91 /**
 * Returns true if any component of the vector is not-a-number, false
 * otherwise.
 */ 1 4 this 3 3679  
515 0 0 6 487 3488 0 0 10 /**
 *
 */ 2 4 this 3 3679  1 i 1 3488  
516 0 0 6 488 3488 0 0 10 /**
 *
 */ 1 4 this 3 3679  
517 0 0 6 489 3488 0 0 10 /**
 *
 */ 1 4 this 3 3679  
518 0 0 6 490 3488 0 0 10 /**
 *
 */ 1 4 this 3 3679  
519 0 0 4 491 3632 0 0 10 /**
 *
 */ 3 4 this 3 3678  1 i 1 3488  5 value 1 3488  
520 0 0 4 492 3632 0 0 10 /**
 *
 */ 2 4 this 3 3678  5 value 1 3488  
521 0 0 4 493 3632 0 0 10 /**
 *
 */ 2 4 this 3 3678  5 value 1 3488  
522 0 0 4 494 3632 0 0 10 /**
 *
 */ 2 4 this 3 3678  5 value 1 3488  
523 0 0 7 495 3651 2130 0 100 /**
 * Returns a 2-component vector that shares just the first two components of
 * this vector.
 */ 1 4 this 3 3679  
524 0 0 7 496 3651 2130 0 105 /**
 * Returns a 2-component vector that shares just the first and last components
 * of this vector.
 */ 1 4 this 3 3679  
525 0 0 7 497 3651 2130 0 99 /**
 * Returns a 2-component vector that shares just the last two components of
 * this vector.
 */ 1 4 this 3 3679  
526 0 0 4 504 3632 0 0 152 // These next functions add to an existing value.  i.e.
// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
// scripting languages: 3 4 this 3 3678  1 i 1 3488  5 value 1 3488  
527 0 0 4 505 3632 0 0 10 /**
 *
 */ 2 4 this 3 3678  5 value 1 3488  
528 0 0 4 506 3632 0 0 10 /**
 *
 */ 2 4 this 3 3678  5 value 1 3488  
529 0 0 4 507 3632 0 0 10 /**
 *
 */ 2 4 this 3 3678  5 value 1 3488  
530 0 0 4 508 3632 0 0 162 /**
 * Returns the address of the first of the three data elements in the vector.
 * The remaining elements occupy the next positions consecutively in memory.
 */ 1 4 this 3 3679  
531 0 0 6 509 3488 0 0 0 0 
532 0 0 4 510 3632 0 0 129 /**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */ 2 4 this 3 3678  10 fill_value 1 3488  
533 0 0 4 511 3632 0 0 10 /**
 *
 */ 4 4 this 3 3678  1 x 1 3488  1 y 1 3488  1 z 1 3488  
534 0 0 6 512 3488 0 0 10 /**
 *
 */ 2 4 this 3 3679  5 other 1 3679  
535 0 0 6 513 3488 0 0 69 /**
 * Returns the square of the vector's length, cheap and easy.
 */ 1 4 this 3 3679  
536 0 0 7 514 3678 2440 0 10 /**
 *
 */ 2 4 this 3 3679  5 other 1 3679  
537 0 0 6 515 3637 0 0 0 2 4 this 3 3679  5 other 1 3679  
538 0 0 6 516 3637 0 0 0 2 4 this 3 3679  5 other 1 3679  
539 0 0 6 517 3637 0 0 0 2 4 this 3 3679  5 other 1 3679  
540 0 0 6 518 3488 0 0 97 /**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */ 2 4 this 3 3679  5 other 1 3679  
541 0 0 6 519 3630 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 1 4 this 3 3679  
542 0 0 6 520 3630 0 0 49 /**
 * Adds the vector into the running hash.
 */ 2 4 this 3 3679  4 hash 1 3630  
543 0 0 4 521 3632 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 2 4 this 3 3679  7 hashgen 1 3638  
544 0 0 7 522 3678 2440 0 0 1 4 this 3 3679  
545 0 0 7 523 3678 2440 0 0 2 4 this 3 3679  5 other 1 3679  
546 0 0 7 524 3678 2440 0 0 2 4 this 3 3679  5 other 1 3679  
547 0 0 7 525 3678 2440 0 0 2 4 this 3 3679  6 scalar 1 3488  
548 0 0 7 526 3678 2440 0 0 2 4 this 3 3679  6 scalar 1 3488  
549 0 0 6 527 3678 0 0 0 2 4 this 3 3678  5 other 1 3679  
550 0 0 6 528 3678 0 0 0 2 4 this 3 3678  5 other 1 3679  
551 0 0 6 529 3678 0 0 0 2 4 this 3 3678  6 scalar 1 3488  
552 0 0 6 530 3678 0 0 0 2 4 this 3 3678  6 scalar 1 3488  
553 0 0 4 531 3632 0 0 10 /**
 *
 */ 2 4 this 3 3678  5 other 1 3679  
554 0 0 7 532 3678 2440 0 0 2 4 this 3 3679  8 exponent 1 3488  
555 0 0 6 533 3633 0 0 0 2 4 this 3 3678  8 exponent 1 3488  
556 0 0 7 534 3678 2440 0 10 /**
 *
 */ 2 4 this 3 3679  5 other 1 3679  
557 0 0 7 535 3678 2440 0 10 /**
 *
 */ 2 4 this 3 3679  5 other 1 3679  
558 0 0 4 536 3632 0 0 10 /**
 *
 */ 2 4 this 3 3678  5 other 1 3679  
559 0 0 6 537 3637 0 0 116 /**
 * Returns true if two vectors are memberwise equal within a default tolerance
 * based on the numeric type.
 */ 2 4 this 3 3679  5 other 1 3679  
560 0 0 6 537 3637 0 0 92 /**
 * Returns true if two vectors are memberwise equal within a specified
 * tolerance.
 */ 3 4 this 3 3679  5 other 1 3679  9 threshold 1 3488  
561 0 0 4 538 3632 0 0 10 /**
 *
 */ 2 4 this 3 3679  3 out 1 3640  
562 0 0 6 539 3636 0 0 0 1 4 this 3 3679  
563 0 0 4 540 3632 0 0 332 /**
 * Writes the vector to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the vector, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */ 2 4 this 3 3679  11 destination 1 3642  
564 0 0 4 541 3632 0 0 114 /**
 * Reads the vector from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */ 2 4 this 3 3678  6 source 1 3644  
565 0 0 4 542 3632 0 0 205 /**
 * Writes the vector to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the vector using the standard width
 * setting, especially when you are writing a bam file.
 */ 2 4 this 3 3679  11 destination 1 3642  
566 0 0 4 543 3632 0 0 67 /**
 * Reads the vector from the Datagram using get_stdfloat().
 */ 2 4 this 3 3678  6 source 1 3644  
567 0 0 7 544 3647 0 0 0 0 
568 0 0 7 552 3681 2478 0 0 0 
569 0 0 7 552 3681 2478 0 10 /**
 *
 */ 2 4 copy 1 3628  1 z 1 3482  
570 0 0 7 552 3681 2478 0 10 /**
 *
 */ 1 4 copy 1 3673  
571 0 0 7 552 3681 2478 0 0 1 6 param0 0 3682  
572 0 0 7 552 3681 2478 0 10 /**
 *
 */ 1 10 fill_value 1 3482  
573 0 0 7 552 3681 2478 0 10 /**
 *
 */ 3 1 x 1 3482  1 y 1 3482  1 z 1 3482  
574 0 0 6 553 3633 0 0 0 2 4 this 3 3682  9 attr_name 1 3636  
575 0 0 6 554 3488 0 0 0 3 4 this 3 3681  9 attr_name 1 3636  6 assign 1 3633  
576 0 0 6 555 3682 0 0 40 /**
 * Returns a zero-length vector.
 */ 0 
577 0 0 6 556 3682 0 0 35 /**
 * Returns a unit X vector.
 */ 0 
578 0 0 6 557 3682 0 0 35 /**
 * Returns a unit Y vector.
 */ 0 
579 0 0 6 558 3682 0 0 35 /**
 * Returns a unit Z vector.
 */ 0 
580 0 0 7 559 3654 2148 0 100 /**
 * Returns a 2-component vector that shares just the first two components of
 * this vector.
 */ 1 4 this 3 3682  
581 0 0 7 560 3654 2148 0 105 /**
 * Returns a 2-component vector that shares just the first and last components
 * of this vector.
 */ 1 4 this 3 3682  
582 0 0 7 561 3654 2148 0 99 /**
 * Returns a 2-component vector that shares just the last two components of
 * this vector.
 */ 1 4 this 3 3682  
583 0 0 7 565 3681 2478 0 0 1 4 this 3 3682  
584 0 0 7 566 3672 2299 0 0 2 4 this 3 3682  5 other 1 3673  
585 0 0 7 566 3681 2478 0 0 2 4 this 3 3682  5 other 1 3682  
586 0 0 7 567 3672 2299 0 0 2 4 this 3 3682  5 other 1 3673  
587 0 0 7 567 3681 2478 0 0 2 4 this 3 3682  5 other 1 3682  
588 0 0 7 568 3681 2478 0 10 /**
 *
 */ 2 4 this 3 3682  5 other 1 3673  
589 0 0 7 569 3681 2478 0 160 /**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */ 1 4 this 3 3682  
590 0 0 7 570 3681 2478 0 152 /**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */ 2 4 this 3 3682  4 onto 1 3673  
591 0 0 6 571 3482 0 0 147 /**
 * Returns the unsigned angle between this vector and the other one, expressed
 * in radians.  Both vectors should be initially normalized.
 */ 2 4 this 3 3682  5 other 1 3682  
592 0 0 6 572 3482 0 0 138 /**
 * Returns the angle between this vector and the other one, expressed in
 * degrees.  Both vectors should be initially normalized.
 */ 2 4 this 3 3682  5 other 1 3682  
593 0 0 6 573 3482 0 0 259 /**
 * returns the signed angle between two vectors.  The angle is positive if the
 * rotation from this vector to other is clockwise when looking in the
 * direction of the ref vector.
 *
 * Vectors (except the ref vector) should be initially normalized.
 */ 3 4 this 3 3682  5 other 1 3682  3 ref 1 3682  
594 0 0 6 574 3482 0 0 259 /**
 * Returns the signed angle between two vectors.  The angle is positive if the
 * rotation from this vector to other is clockwise when looking in the
 * direction of the ref vector.
 *
 * Vectors (except the ref vector) should be initially normalized.
 */ 3 4 this 3 3682  5 other 1 3682  3 ref 1 3682  
595 0 0 6 575 3482 0 0 50 /**
 * This method is deprecated.  Do not use.
 */ 2 4 this 3 3682  5 other 1 3682  
596 0 0 6 576 3482 0 0 50 /**
 * This method is deprecated.  Do not use.
 */ 2 4 this 3 3682  5 other 1 3682  
597 0 0 7 577 3681 2478 0 0 2 4 this 3 3682  6 scalar 1 3482  
598 0 0 7 578 3681 2478 0 0 2 4 this 3 3682  6 scalar 1 3482  
599 0 0 7 579 3681 2478 0 65 /**
 * Returns the up vector for the given coordinate system.
 */ 1 2 cs 1 3501  
600 0 0 7 580 3681 2478 0 68 /**
 * Returns the right vector for the given coordinate system.
 */ 1 2 cs 1 3501  
601 0 0 7 581 3681 2478 0 70 /**
 * Returns the forward vector for the given coordinate system.
 */ 1 2 cs 1 3501  
602 0 0 7 582 3681 2478 0 67 /**
 * Returns the down vector for the given coordinate system.
 */ 1 2 cs 1 3501  
603 0 0 7 583 3681 2478 0 67 /**
 * Returns the left vector for the given coordinate system.
 */ 1 2 cs 1 3501  
604 0 0 7 584 3681 2478 0 67 /**
 * Returns the back vector for the given coordinate system.
 */ 1 2 cs 1 3501  
605 0 0 7 585 3681 2478 0 152 /**
 * Returns a vector that is described by its right, forward, and up
 * components, in whatever way the coordinate system represents that vector.
 */ 4 5 right 1 3482  3 fwd 1 3482  2 up 1 3482  2 cs 1 3501  
606 0 0 6 586 3636 0 0 0 1 4 this 3 3682  
607 0 0 7 587 3647 0 0 0 0 
608 0 0 7 590 3684 2512 0 0 0 
609 0 0 7 590 3684 2512 0 10 /**
 *
 */ 2 4 copy 1 3649  1 z 1 3485  
610 0 0 7 590 3684 2512 0 10 /**
 *
 */ 1 4 copy 1 3676  
611 0 0 7 590 3684 2512 0 0 1 6 param0 0 3685  
612 0 0 7 590 3684 2512 0 10 /**
 *
 */ 1 10 fill_value 1 3485  
613 0 0 7 590 3684 2512 0 10 /**
 *
 */ 3 1 x 1 3485  1 y 1 3485  1 z 1 3485  
614 0 0 6 591 3633 0 0 0 2 4 this 3 3685  9 attr_name 1 3636  
615 0 0 6 592 3488 0 0 0 3 4 this 3 3684  9 attr_name 1 3636  6 assign 1 3633  
616 0 0 6 593 3685 0 0 40 /**
 * Returns a zero-length vector.
 */ 0 
617 0 0 6 594 3685 0 0 35 /**
 * Returns a unit X vector.
 */ 0 
618 0 0 6 595 3685 0 0 35 /**
 * Returns a unit Y vector.
 */ 0 
619 0 0 6 596 3685 0 0 35 /**
 * Returns a unit Z vector.
 */ 0 
620 0 0 7 597 3657 2166 0 100 /**
 * Returns a 2-component vector that shares just the first two components of
 * this vector.
 */ 1 4 this 3 3685  
621 0 0 7 598 3657 2166 0 105 /**
 * Returns a 2-component vector that shares just the first and last components
 * of this vector.
 */ 1 4 this 3 3685  
622 0 0 7 599 3657 2166 0 99 /**
 * Returns a 2-component vector that shares just the last two components of
 * this vector.
 */ 1 4 this 3 3685  
623 0 0 7 603 3684 2512 0 0 1 4 this 3 3685  
624 0 0 7 604 3675 2372 0 0 2 4 this 3 3685  5 other 1 3676  
625 0 0 7 604 3684 2512 0 0 2 4 this 3 3685  5 other 1 3685  
626 0 0 7 605 3675 2372 0 0 2 4 this 3 3685  5 other 1 3676  
627 0 0 7 605 3684 2512 0 0 2 4 this 3 3685  5 other 1 3685  
628 0 0 7 606 3684 2512 0 10 /**
 *
 */ 2 4 this 3 3685  5 other 1 3676  
629 0 0 7 607 3684 2512 0 160 /**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */ 1 4 this 3 3685  
630 0 0 7 608 3684 2512 0 152 /**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */ 2 4 this 3 3685  4 onto 1 3676  
631 0 0 6 609 3485 0 0 147 /**
 * Returns the unsigned angle between this vector and the other one, expressed
 * in radians.  Both vectors should be initially normalized.
 */ 2 4 this 3 3685  5 other 1 3685  
632 0 0 6 610 3485 0 0 138 /**
 * Returns the angle between this vector and the other one, expressed in
 * degrees.  Both vectors should be initially normalized.
 */ 2 4 this 3 3685  5 other 1 3685  
633 0 0 6 611 3485 0 0 259 /**
 * returns the signed angle between two vectors.  The angle is positive if the
 * rotation from this vector to other is clockwise when looking in the
 * direction of the ref vector.
 *
 * Vectors (except the ref vector) should be initially normalized.
 */ 3 4 this 3 3685  5 other 1 3685  3 ref 1 3685  
634 0 0 6 612 3485 0 0 259 /**
 * Returns the signed angle between two vectors.  The angle is positive if the
 * rotation from this vector to other is clockwise when looking in the
 * direction of the ref vector.
 *
 * Vectors (except the ref vector) should be initially normalized.
 */ 3 4 this 3 3685  5 other 1 3685  3 ref 1 3685  
635 0 0 6 613 3485 0 0 50 /**
 * This method is deprecated.  Do not use.
 */ 2 4 this 3 3685  5 other 1 3685  
636 0 0 6 614 3485 0 0 50 /**
 * This method is deprecated.  Do not use.
 */ 2 4 this 3 3685  5 other 1 3685  
637 0 0 7 615 3684 2512 0 0 2 4 this 3 3685  6 scalar 1 3485  
638 0 0 7 616 3684 2512 0 0 2 4 this 3 3685  6 scalar 1 3485  
639 0 0 7 617 3684 2512 0 65 /**
 * Returns the up vector for the given coordinate system.
 */ 1 2 cs 1 3501  
640 0 0 7 618 3684 2512 0 68 /**
 * Returns the right vector for the given coordinate system.
 */ 1 2 cs 1 3501  
641 0 0 7 619 3684 2512 0 70 /**
 * Returns the forward vector for the given coordinate system.
 */ 1 2 cs 1 3501  
642 0 0 7 620 3684 2512 0 67 /**
 * Returns the down vector for the given coordinate system.
 */ 1 2 cs 1 3501  
643 0 0 7 621 3684 2512 0 67 /**
 * Returns the left vector for the given coordinate system.
 */ 1 2 cs 1 3501  
644 0 0 7 622 3684 2512 0 67 /**
 * Returns the back vector for the given coordinate system.
 */ 1 2 cs 1 3501  
645 0 0 7 623 3684 2512 0 152 /**
 * Returns a vector that is described by its right, forward, and up
 * components, in whatever way the coordinate system represents that vector.
 */ 4 5 right 1 3485  3 fwd 1 3485  2 up 1 3485  2 cs 1 3501  
646 0 0 6 624 3636 0 0 0 1 4 this 3 3685  
647 0 0 7 625 3647 0 0 0 0 
648 0 0 7 628 3687 2538 0 0 0 
649 0 0 7 628 3687 2538 0 10 /**
 *
 */ 2 4 copy 1 3652  1 z 1 3488  
650 0 0 7 628 3687 2538 0 10 /**
 *
 */ 1 4 copy 1 3679  
651 0 0 7 628 3687 2538 0 0 1 6 param0 0 3688  
652 0 0 7 628 3687 2538 0 10 /**
 *
 */ 1 10 fill_value 1 3488  
653 0 0 7 628 3687 2538 0 10 /**
 *
 */ 3 1 x 1 3488  1 y 1 3488  1 z 1 3488  
654 0 0 6 629 3633 0 0 0 2 4 this 3 3688  9 attr_name 1 3636  
655 0 0 6 630 3488 0 0 0 3 4 this 3 3687  9 attr_name 1 3636  6 assign 1 3633  
656 0 0 6 631 3688 0 0 40 /**
 * Returns a zero-length vector.
 */ 0 
657 0 0 6 632 3688 0 0 35 /**
 * Returns a unit X vector.
 */ 0 
658 0 0 6 633 3688 0 0 35 /**
 * Returns a unit Y vector.
 */ 0 
659 0 0 6 634 3688 0 0 35 /**
 * Returns a unit Z vector.
 */ 0 
660 0 0 7 635 3660 2180 0 100 /**
 * Returns a 2-component vector that shares just the first two components of
 * this vector.
 */ 1 4 this 3 3688  
661 0 0 7 636 3660 2180 0 105 /**
 * Returns a 2-component vector that shares just the first and last components
 * of this vector.
 */ 1 4 this 3 3688  
662 0 0 7 637 3660 2180 0 99 /**
 * Returns a 2-component vector that shares just the last two components of
 * this vector.
 */ 1 4 this 3 3688  
663 0 0 7 641 3687 2538 0 0 1 4 this 3 3688  
664 0 0 7 642 3678 2440 0 0 2 4 this 3 3688  5 other 1 3679  
665 0 0 7 642 3687 2538 0 0 2 4 this 3 3688  5 other 1 3688  
666 0 0 7 643 3678 2440 0 0 2 4 this 3 3688  5 other 1 3679  
667 0 0 7 643 3687 2538 0 0 2 4 this 3 3688  5 other 1 3688  
668 0 0 7 644 3687 2538 0 10 /**
 *
 */ 2 4 this 3 3688  5 other 1 3679  
669 0 0 7 645 3687 2538 0 0 2 4 this 3 3688  6 scalar 1 3488  
670 0 0 7 646 3687 2538 0 0 2 4 this 3 3688  6 scalar 1 3488  
671 0 0 7 647 3687 2538 0 65 /**
 * Returns the up vector for the given coordinate system.
 */ 1 2 cs 1 3501  
672 0 0 7 648 3687 2538 0 68 /**
 * Returns the right vector for the given coordinate system.
 */ 1 2 cs 1 3501  
673 0 0 7 649 3687 2538 0 70 /**
 * Returns the forward vector for the given coordinate system.
 */ 1 2 cs 1 3501  
674 0 0 7 650 3687 2538 0 67 /**
 * Returns the down vector for the given coordinate system.
 */ 1 2 cs 1 3501  
675 0 0 7 651 3687 2538 0 67 /**
 * Returns the left vector for the given coordinate system.
 */ 1 2 cs 1 3501  
676 0 0 7 652 3687 2538 0 67 /**
 * Returns the back vector for the given coordinate system.
 */ 1 2 cs 1 3501  
677 0 0 7 653 3687 2538 0 152 /**
 * Returns a vector that is described by its right, forward, and up
 * components, in whatever way the coordinate system represents that vector.
 */ 4 5 right 1 3488  3 fwd 1 3488  2 up 1 3488  2 cs 1 3501  
678 0 0 6 654 3636 0 0 0 1 4 this 3 3688  
679 0 0 7 655 3647 0 0 0 0 
680 0 0 7 658 3690 2561 0 0 0 
681 0 0 7 658 3690 2561 0 0 1 6 param0 0 3691  
682 0 0 7 658 3690 2561 0 10 /**
 *
 */ 2 4 copy 1 3628  1 z 1 3482  
683 0 0 7 658 3690 2561 0 10 /**
 *
 */ 1 4 copy 1 3673  
684 0 0 7 658 3690 2561 0 10 /**
 *
 */ 1 10 fill_value 1 3482  
685 0 0 7 658 3690 2561 0 10 /**
 *
 */ 3 1 x 1 3482  1 y 1 3482  1 z 1 3482  
686 0 0 6 659 3633 0 0 0 2 4 this 3 3691  9 attr_name 1 3636  
687 0 0 6 660 3488 0 0 0 3 4 this 3 3690  9 attr_name 1 3636  6 assign 1 3633  
688 0 0 6 661 3691 0 0 39 /**
 * Returns a zero-length point.
 */ 0 
689 0 0 6 662 3691 0 0 34 /**
 * Returns a unit X point.
 */ 0 
690 0 0 6 663 3691 0 0 34 /**
 * Returns a unit Y point.
 */ 0 
691 0 0 6 664 3691 0 0 34 /**
 * Returns a unit Z point.
 */ 0 
692 0 0 7 665 3663 2196 0 100 /**
 * Returns a 2-component vector that shares just the first two components of
 * this vector.
 */ 1 4 this 3 3691  
693 0 0 7 666 3663 2196 0 105 /**
 * Returns a 2-component vector that shares just the first and last components
 * of this vector.
 */ 1 4 this 3 3691  
694 0 0 7 667 3663 2196 0 99 /**
 * Returns a 2-component vector that shares just the last two components of
 * this vector.
 */ 1 4 this 3 3691  
695 0 0 7 671 3690 2561 0 0 1 4 this 3 3691  
696 0 0 7 672 3672 2299 0 0 2 4 this 3 3691  5 other 1 3673  
697 0 0 7 672 3690 2561 0 0 2 4 this 3 3691  5 other 1 3682  
698 0 0 7 673 3681 2478 0 0 2 4 this 3 3691  5 other 1 3691  
699 0 0 7 673 3672 2299 0 0 2 4 this 3 3691  5 other 1 3673  
700 0 0 7 673 3690 2561 0 0 2 4 this 3 3691  5 other 1 3682  
701 0 0 7 674 3690 2561 0 10 /**
 *
 */ 2 4 this 3 3691  5 other 1 3673  
702 0 0 7 675 3690 2561 0 160 /**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */ 1 4 this 3 3691  
703 0 0 7 676 3690 2561 0 152 /**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */ 2 4 this 3 3691  4 onto 1 3673  
704 0 0 7 677 3690 2561 0 0 2 4 this 3 3691  6 scalar 1 3482  
705 0 0 7 678 3690 2561 0 0 2 4 this 3 3691  6 scalar 1 3482  
706 0 0 6 679 3691 0 0 186 /**
 * Returns the origin of the indicated coordinate system.  This is always 0,
 * 0, 0 with all of our existing coordinate systems; it's hard to imagine it
 * ever being different.
 */ 1 2 cs 1 3501  
707 0 0 7 680 3690 2561 0 146 /**
 * Returns a point described by right, forward, up displacements from the
 * origin, wherever that maps to in the given coordinate system.
 */ 4 5 right 1 3482  3 fwd 1 3482  2 up 1 3482  2 cs 1 3501  
708 0 0 6 681 3636 0 0 0 1 4 this 3 3691  
709 0 0 7 682 3647 0 0 0 0 
710 0 0 7 685 3693 2584 0 0 0 
711 0 0 7 685 3693 2584 0 0 1 6 param0 0 3694  
712 0 0 7 685 3693 2584 0 10 /**
 *
 */ 2 4 copy 1 3649  1 z 1 3485  
713 0 0 7 685 3693 2584 0 10 /**
 *
 */ 1 4 copy 1 3676  
714 0 0 7 685 3693 2584 0 10 /**
 *
 */ 1 10 fill_value 1 3485  
715 0 0 7 685 3693 2584 0 10 /**
 *
 */ 3 1 x 1 3485  1 y 1 3485  1 z 1 3485  
716 0 0 6 686 3633 0 0 0 2 4 this 3 3694  9 attr_name 1 3636  
717 0 0 6 687 3488 0 0 0 3 4 this 3 3693  9 attr_name 1 3636  6 assign 1 3633  
718 0 0 6 688 3694 0 0 39 /**
 * Returns a zero-length point.
 */ 0 
719 0 0 6 689 3694 0 0 34 /**
 * Returns a unit X point.
 */ 0 
720 0 0 6 690 3694 0 0 34 /**
 * Returns a unit Y point.
 */ 0 
721 0 0 6 691 3694 0 0 34 /**
 * Returns a unit Z point.
 */ 0 
722 0 0 7 692 3666 2212 0 100 /**
 * Returns a 2-component vector that shares just the first two components of
 * this vector.
 */ 1 4 this 3 3694  
723 0 0 7 693 3666 2212 0 105 /**
 * Returns a 2-component vector that shares just the first and last components
 * of this vector.
 */ 1 4 this 3 3694  
724 0 0 7 694 3666 2212 0 99 /**
 * Returns a 2-component vector that shares just the last two components of
 * this vector.
 */ 1 4 this 3 3694  
725 0 0 7 698 3693 2584 0 0 1 4 this 3 3694  
726 0 0 7 699 3675 2372 0 0 2 4 this 3 3694  5 other 1 3676  
727 0 0 7 699 3693 2584 0 0 2 4 this 3 3694  5 other 1 3685  
728 0 0 7 700 3684 2512 0 0 2 4 this 3 3694  5 other 1 3694  
729 0 0 7 700 3675 2372 0 0 2 4 this 3 3694  5 other 1 3676  
730 0 0 7 700 3693 2584 0 0 2 4 this 3 3694  5 other 1 3685  
731 0 0 7 701 3693 2584 0 10 /**
 *
 */ 2 4 this 3 3694  5 other 1 3676  
732 0 0 7 702 3693 2584 0 160 /**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */ 1 4 this 3 3694  
733 0 0 7 703 3693 2584 0 152 /**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */ 2 4 this 3 3694  4 onto 1 3676  
734 0 0 7 704 3693 2584 0 0 2 4 this 3 3694  6 scalar 1 3485  
735 0 0 7 705 3693 2584 0 0 2 4 this 3 3694  6 scalar 1 3485  
736 0 0 6 706 3694 0 0 186 /**
 * Returns the origin of the indicated coordinate system.  This is always 0,
 * 0, 0 with all of our existing coordinate systems; it's hard to imagine it
 * ever being different.
 */ 1 2 cs 1 3501  
737 0 0 7 707 3693 2584 0 146 /**
 * Returns a point described by right, forward, up displacements from the
 * origin, wherever that maps to in the given coordinate system.
 */ 4 5 right 1 3485  3 fwd 1 3485  2 up 1 3485  2 cs 1 3501  
738 0 0 6 708 3636 0 0 0 1 4 this 3 3694  
739 0 0 7 709 3647 0 0 0 0 
740 0 0 7 712 3696 2605 0 0 0 
741 0 0 7 712 3696 2605 0 0 1 6 param0 0 3697  
742 0 0 7 712 3696 2605 0 10 /**
 *
 */ 2 4 copy 1 3652  1 z 1 3488  
743 0 0 7 712 3696 2605 0 10 /**
 *
 */ 1 4 copy 1 3679  
744 0 0 7 712 3696 2605 0 10 /**
 *
 */ 1 10 fill_value 1 3488  
745 0 0 7 712 3696 2605 0 10 /**
 *
 */ 3 1 x 1 3488  1 y 1 3488  1 z 1 3488  
746 0 0 6 713 3633 0 0 0 2 4 this 3 3697  9 attr_name 1 3636  
747 0 0 6 714 3488 0 0 0 3 4 this 3 3696  9 attr_name 1 3636  6 assign 1 3633  
748 0 0 6 715 3697 0 0 39 /**
 * Returns a zero-length point.
 */ 0 
749 0 0 6 716 3697 0 0 34 /**
 * Returns a unit X point.
 */ 0 
750 0 0 6 717 3697 0 0 34 /**
 * Returns a unit Y point.
 */ 0 
751 0 0 6 718 3697 0 0 34 /**
 * Returns a unit Z point.
 */ 0 
752 0 0 7 719 3669 2226 0 100 /**
 * Returns a 2-component vector that shares just the first two components of
 * this vector.
 */ 1 4 this 3 3697  
753 0 0 7 720 3669 2226 0 105 /**
 * Returns a 2-component vector that shares just the first and last components
 * of this vector.
 */ 1 4 this 3 3697  
754 0 0 7 721 3669 2226 0 99 /**
 * Returns a 2-component vector that shares just the last two components of
 * this vector.
 */ 1 4 this 3 3697  
755 0 0 7 725 3696 2605 0 0 1 4 this 3 3697  
756 0 0 7 726 3678 2440 0 0 2 4 this 3 3697  5 other 1 3679  
757 0 0 7 726 3696 2605 0 0 2 4 this 3 3697  5 other 1 3688  
758 0 0 7 727 3687 2538 0 0 2 4 this 3 3697  5 other 1 3697  
759 0 0 7 727 3678 2440 0 0 2 4 this 3 3697  5 other 1 3679  
760 0 0 7 727 3696 2605 0 0 2 4 this 3 3697  5 other 1 3688  
761 0 0 7 728 3696 2605 0 10 /**
 *
 */ 2 4 this 3 3697  5 other 1 3679  
762 0 0 7 729 3696 2605 0 0 2 4 this 3 3697  6 scalar 1 3488  
763 0 0 7 730 3696 2605 0 0 2 4 this 3 3697  6 scalar 1 3488  
764 0 0 6 731 3697 0 0 186 /**
 * Returns the origin of the indicated coordinate system.  This is always 0,
 * 0, 0 with all of our existing coordinate systems; it's hard to imagine it
 * ever being different.
 */ 1 2 cs 1 3501  
765 0 0 7 732 3696 2605 0 146 /**
 * Returns a point described by right, forward, up displacements from the
 * origin, wherever that maps to in the given coordinate system.
 */ 4 5 right 1 3488  3 fwd 1 3488  2 up 1 3488  2 cs 1 3501  
766 0 0 6 733 3636 0 0 0 1 4 this 3 3697  
767 0 0 7 734 3647 0 0 0 0 
768 0 0 7 738 3699 2679 0 0 0 
769 0 0 7 738 3699 2679 0 84 /**
 * Constructs an LVecBase4 from an LPoint3.  The w coordinate is set to 1.0.
 */ 1 5 point 1 3691  
770 0 0 7 738 3699 2679 0 10 /**
 *
 */ 2 4 copy 1 3673  1 w 1 3482  
771 0 0 7 738 3699 2679 0 0 1 6 param0 0 3700  
772 0 0 7 738 3699 2679 0 85 /**
 * Constructs an LVecBase4 from an LVector3.  The w coordinate is set to 0.0.
 */ 1 6 vector 1 3682  
773 0 0 7 738 3699 2679 0 10 /**
 *
 */ 1 4 copy 1 3702  
774 0 0 7 738 3699 2679 0 10 /**
 *
 */ 1 10 fill_value 1 3482  
775 0 0 7 738 3699 2679 0 10 /**
 *
 */ 4 1 x 1 3482  1 y 1 3482  1 z 1 3482  1 w 1 3482  
776 0 0 4 739 3632 0 0 0 2 4 this 3 3699  4 size 1 3630  
777 0 0 6 742 3699 0 0 0 2 4 this 3 3699  4 copy 1 3700  
778 0 0 6 742 3699 0 0 0 2 4 this 3 3699  10 fill_value 1 3482  
779 0 0 6 743 3700 0 0 40 /**
 * Returns a zero-length vector.
 */ 0 
780 0 0 6 744 3700 0 0 35 /**
 * Returns a unit X vector.
 */ 0 
781 0 0 6 745 3700 0 0 35 /**
 * Returns a unit Y vector.
 */ 0 
782 0 0 6 746 3700 0 0 35 /**
 * Returns a unit Z vector.
 */ 0 
783 0 0 6 747 3700 0 0 35 /**
 * Returns a unit W vector.
 */ 0 
784 0 0 6 748 3633 0 0 0 1 4 this 3 3700  
785 0 0 6 749 3633 0 0 0 2 4 this 3 3700  9 attr_name 1 3636  
786 0 0 6 750 3488 0 0 0 3 4 this 3 3699  9 attr_name 1 3636  6 assign 1 3633  
787 0 0 4 751 3632 0 0 10 /**
 *
 */ 3 4 this 3 3699  1 i 1 3488  10 assign_val 1 3482  
788 0 0 6 751 3482 0 0 0 2 4 this 3 3700  1 i 1 3488  
789 0 0 6 752 3488 0 0 0 0 
790 0 0 6 753 3637 0 0 91 /**
 * Returns true if any component of the vector is not-a-number, false
 * otherwise.
 */ 1 4 this 3 3700  
791 0 0 6 754 3482 0 0 10 /**
 *
 */ 2 4 this 3 3700  1 i 1 3488  
792 0 0 4 755 3632 0 0 10 /**
 *
 */ 3 4 this 3 3699  1 i 1 3488  5 value 1 3482  
793 0 0 6 756 3482 0 0 10 /**
 *
 */ 1 4 this 3 3700  
794 0 0 6 757 3482 0 0 10 /**
 *
 */ 1 4 this 3 3700  
795 0 0 6 758 3482 0 0 10 /**
 *
 */ 1 4 this 3 3700  
796 0 0 6 759 3482 0 0 10 /**
 *
 */ 1 4 this 3 3700  
797 0 0 7 760 3672 2299 0 58 /**
 * Returns the x, y and z component of this vector
 */ 1 4 this 3 3700  
798 0 0 7 761 3627 2008 0 55 /**
 * Returns the x and y component of this vector
 */ 1 4 this 3 3700  
799 0 0 4 762 3632 0 0 10 /**
 *
 */ 2 4 this 3 3699  5 value 1 3482  
800 0 0 4 763 3632 0 0 10 /**
 *
 */ 2 4 this 3 3699  5 value 1 3482  
801 0 0 4 764 3632 0 0 10 /**
 *
 */ 2 4 this 3 3699  5 value 1 3482  
802 0 0 4 765 3632 0 0 10 /**
 *
 */ 2 4 this 3 3699  5 value 1 3482  
803 0 0 4 771 3632 0 0 152 // These next functions add to an existing value.  i.e.
// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
// scripting languages: 3 4 this 3 3699  1 i 1 3488  5 value 1 3482  
804 0 0 4 772 3632 0 0 10 /**
 *
 */ 2 4 this 3 3699  5 value 1 3482  
805 0 0 4 773 3632 0 0 10 /**
 *
 */ 2 4 this 3 3699  5 value 1 3482  
806 0 0 4 774 3632 0 0 10 /**
 *
 */ 2 4 this 3 3699  5 value 1 3482  
807 0 0 4 775 3632 0 0 10 /**
 *
 */ 2 4 this 3 3699  5 value 1 3482  
808 0 0 4 776 3632 0 0 161 /**
 * Returns the address of the first of the four data elements in the vector.
 * The remaining elements occupy the next positions consecutively in memory.
 */ 1 4 this 3 3700  
809 0 0 6 777 3488 0 0 0 0 
810 0 0 4 779 3632 0 0 129 /**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */ 2 4 this 3 3699  10 fill_value 1 3482  
811 0 0 4 780 3632 0 0 10 /**
 *
 */ 5 4 this 3 3699  1 x 1 3482  1 y 1 3482  1 z 1 3482  1 w 1 3482  
812 0 0 6 781 3482 0 0 10 /**
 *
 */ 2 4 this 3 3700  5 other 1 3700  
813 0 0 6 782 3482 0 0 69 /**
 * Returns the square of the vector's length, cheap and easy.
 */ 1 4 this 3 3700  
814 0 0 6 783 3482 0 0 72 /**
 * Returns the length of the vector, by the Pythagorean theorem.
 */ 1 4 this 3 3700  
815 0 0 6 784 3637 0 0 127 /**
 * Normalizes the vector in place.  Returns true if the vector was normalized,
 * false if it was a zero-length vector.
 */ 1 4 this 3 3699  
816 0 0 7 785 3699 2679 0 160 /**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */ 1 4 this 3 3700  
817 0 0 7 786 3699 2679 0 152 /**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */ 2 4 this 3 3700  4 onto 1 3700  
818 0 0 6 787 3637 0 0 0 2 4 this 3 3700  5 other 1 3700  
819 0 0 6 788 3637 0 0 0 2 4 this 3 3700  5 other 1 3700  
820 0 0 6 789 3637 0 0 0 2 4 this 3 3700  5 other 1 3700  
821 0 0 6 790 3488 0 0 97 /**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */ 2 4 this 3 3700  5 other 1 3700  
822 0 0 6 790 3488 0 0 233 /**
 * Sorts vectors lexicographically, componentwise.  Returns a number less than
 * 0 if this vector sorts before the other one, greater than zero if it sorts
 * after, 0 if they are equivalent (within the indicated tolerance).
 */ 3 4 this 3 3700  5 other 1 3700  9 threshold 1 3482  
823 0 0 6 791 3630 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 1 4 this 3 3700  
824 0 0 6 791 3630 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 2 4 this 3 3700  9 threshold 1 3482  
825 0 0 6 792 3630 0 0 49 /**
 * Adds the vector into the running hash.
 */ 2 4 this 3 3700  4 hash 1 3630  
826 0 0 6 792 3630 0 0 49 /**
 * Adds the vector into the running hash.
 */ 3 4 this 3 3700  4 hash 1 3630  9 threshold 1 3482  
827 0 0 4 793 3632 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 2 4 this 3 3700  7 hashgen 1 3638  
828 0 0 4 793 3632 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 3 4 this 3 3700  7 hashgen 1 3638  9 threshold 1 3482  
829 0 0 7 794 3699 2679 0 0 1 4 this 3 3700  
830 0 0 7 795 3699 2679 0 0 2 4 this 3 3700  5 other 1 3700  
831 0 0 7 796 3699 2679 0 0 2 4 this 3 3700  5 other 1 3700  
832 0 0 7 797 3699 2679 0 0 2 4 this 3 3700  6 scalar 1 3482  
833 0 0 7 798 3699 2679 0 0 2 4 this 3 3700  6 scalar 1 3482  
834 0 0 6 799 3699 0 0 0 2 4 this 3 3699  5 other 1 3700  
835 0 0 6 800 3699 0 0 0 2 4 this 3 3699  5 other 1 3700  
836 0 0 6 801 3699 0 0 0 2 4 this 3 3699  6 scalar 1 3482  
837 0 0 6 802 3699 0 0 0 2 4 this 3 3699  6 scalar 1 3482  
838 0 0 4 803 3632 0 0 10 /**
 *
 */ 2 4 this 3 3699  5 other 1 3700  
839 0 0 7 804 3699 2679 0 0 2 4 this 3 3700  8 exponent 1 3482  
840 0 0 6 805 3633 0 0 0 2 4 this 3 3699  8 exponent 1 3482  
841 0 0 7 806 3699 2679 0 10 /**
 *
 */ 2 4 this 3 3700  5 other 1 3700  
842 0 0 7 807 3699 2679 0 10 /**
 *
 */ 2 4 this 3 3700  5 other 1 3700  
843 0 0 6 808 3637 0 0 116 /**
 * Returns true if two vectors are memberwise equal within a default tolerance
 * based on the numeric type.
 */ 2 4 this 3 3700  5 other 1 3700  
844 0 0 6 808 3637 0 0 92 /**
 * Returns true if two vectors are memberwise equal within a specified
 * tolerance.
 */ 3 4 this 3 3700  5 other 1 3700  9 threshold 1 3482  
845 0 0 4 809 3632 0 0 10 /**
 *
 */ 2 4 this 3 3700  3 out 1 3640  
846 0 0 6 810 3636 0 0 0 1 4 this 3 3700  
847 0 0 4 811 3632 0 0 332 /**
 * Writes the vector to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the vector, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */ 2 4 this 3 3700  11 destination 1 3642  
848 0 0 4 812 3632 0 0 114 /**
 * Reads the vector from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */ 2 4 this 3 3699  6 source 1 3644  
849 0 0 4 813 3632 0 0 205 /**
 * Writes the vector to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the vector using the standard width
 * setting, especially when you are writing a bam file.
 */ 2 4 this 3 3700  11 destination 1 3642  
850 0 0 4 814 3632 0 0 67 /**
 * Reads the vector from the Datagram using get_stdfloat().
 */ 2 4 this 3 3699  6 source 1 3644  
851 0 0 7 815 3647 0 0 0 0 
852 0 0 7 819 3704 2688 0 0 0 
853 0 0 7 819 3704 2688 0 10 /**
 *
 */ 1 4 copy 1 3700  
854 0 0 7 819 3704 2688 0 0 1 6 param0 0 3702  
855 0 0 7 819 3704 2688 0 10 /**
 *
 */ 1 10 fill_value 1 3482  
856 0 0 7 819 3704 2688 0 10 /**
 *
 */ 4 1 x 1 3482  1 y 1 3482  1 z 1 3482  1 w 1 3482  
857 0 0 4 820 3632 0 0 129 /**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */ 2 4 this 3 3704  10 fill_value 1 3482  
858 0 0 4 821 3632 0 0 10 /**
 *
 */ 5 4 this 3 3704  1 x 1 3482  1 y 1 3482  1 z 1 3482  1 w 1 3482  
859 0 0 4 822 3632 0 0 10 /**
 *
 */ 3 4 this 3 3704  1 i 1 3488  10 assign_val 1 3482  
860 0 0 6 822 3482 0 0 0 2 4 this 3 3702  1 i 1 3488  
861 0 0 6 823 3488 0 0 0 0 
862 0 0 4 824 3632 0 0 162 /**
 * Returns the address of the first of the three data elements in the vector.
 * The remaining elements occupy the next positions consecutively in memory.
 */ 1 4 this 3 3702  
863 0 0 6 825 3488 0 0 0 0 
864 0 0 7 826 3647 0 0 0 0 
865 0 0 7 830 3705 2762 0 0 0 
866 0 0 7 830 3705 2762 0 84 /**
 * Constructs an LVecBase4 from an LPoint3.  The w coordinate is set to 1.0.
 */ 1 5 point 1 3694  
867 0 0 7 830 3705 2762 0 10 /**
 *
 */ 2 4 copy 1 3676  1 w 1 3485  
868 0 0 7 830 3705 2762 0 0 1 6 param0 0 3706  
869 0 0 7 830 3705 2762 0 85 /**
 * Constructs an LVecBase4 from an LVector3.  The w coordinate is set to 0.0.
 */ 1 6 vector 1 3685  
870 0 0 7 830 3705 2762 0 10 /**
 *
 */ 1 4 copy 1 3708  
871 0 0 7 830 3705 2762 0 10 /**
 *
 */ 1 10 fill_value 1 3485  
872 0 0 7 830 3705 2762 0 10 /**
 *
 */ 4 1 x 1 3485  1 y 1 3485  1 z 1 3485  1 w 1 3485  
873 0 0 4 831 3632 0 0 0 2 4 this 3 3705  4 size 1 3630  
874 0 0 6 834 3705 0 0 0 2 4 this 3 3705  4 copy 1 3706  
875 0 0 6 834 3705 0 0 0 2 4 this 3 3705  10 fill_value 1 3485  
876 0 0 6 835 3706 0 0 40 /**
 * Returns a zero-length vector.
 */ 0 
877 0 0 6 836 3706 0 0 35 /**
 * Returns a unit X vector.
 */ 0 
878 0 0 6 837 3706 0 0 35 /**
 * Returns a unit Y vector.
 */ 0 
879 0 0 6 838 3706 0 0 35 /**
 * Returns a unit Z vector.
 */ 0 
880 0 0 6 839 3706 0 0 35 /**
 * Returns a unit W vector.
 */ 0 
881 0 0 6 840 3633 0 0 0 1 4 this 3 3706  
882 0 0 6 841 3633 0 0 0 2 4 this 3 3706  9 attr_name 1 3636  
883 0 0 6 842 3488 0 0 0 3 4 this 3 3705  9 attr_name 1 3636  6 assign 1 3633  
884 0 0 4 843 3632 0 0 10 /**
 *
 */ 3 4 this 3 3705  1 i 1 3488  10 assign_val 1 3485  
885 0 0 6 843 3485 0 0 0 2 4 this 3 3706  1 i 1 3488  
886 0 0 6 844 3488 0 0 0 0 
887 0 0 6 845 3637 0 0 91 /**
 * Returns true if any component of the vector is not-a-number, false
 * otherwise.
 */ 1 4 this 3 3706  
888 0 0 6 846 3485 0 0 10 /**
 *
 */ 2 4 this 3 3706  1 i 1 3488  
889 0 0 4 847 3632 0 0 10 /**
 *
 */ 3 4 this 3 3705  1 i 1 3488  5 value 1 3485  
890 0 0 6 848 3485 0 0 10 /**
 *
 */ 1 4 this 3 3706  
891 0 0 6 849 3485 0 0 10 /**
 *
 */ 1 4 this 3 3706  
892 0 0 6 850 3485 0 0 10 /**
 *
 */ 1 4 this 3 3706  
893 0 0 6 851 3485 0 0 10 /**
 *
 */ 1 4 this 3 3706  
894 0 0 7 852 3675 2372 0 58 /**
 * Returns the x, y and z component of this vector
 */ 1 4 this 3 3706  
895 0 0 7 853 3648 2071 0 55 /**
 * Returns the x and y component of this vector
 */ 1 4 this 3 3706  
896 0 0 4 854 3632 0 0 10 /**
 *
 */ 2 4 this 3 3705  5 value 1 3485  
897 0 0 4 855 3632 0 0 10 /**
 *
 */ 2 4 this 3 3705  5 value 1 3485  
898 0 0 4 856 3632 0 0 10 /**
 *
 */ 2 4 this 3 3705  5 value 1 3485  
899 0 0 4 857 3632 0 0 10 /**
 *
 */ 2 4 this 3 3705  5 value 1 3485  
900 0 0 4 863 3632 0 0 152 // These next functions add to an existing value.  i.e.
// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
// scripting languages: 3 4 this 3 3705  1 i 1 3488  5 value 1 3485  
901 0 0 4 864 3632 0 0 10 /**
 *
 */ 2 4 this 3 3705  5 value 1 3485  
902 0 0 4 865 3632 0 0 10 /**
 *
 */ 2 4 this 3 3705  5 value 1 3485  
903 0 0 4 866 3632 0 0 10 /**
 *
 */ 2 4 this 3 3705  5 value 1 3485  
904 0 0 4 867 3632 0 0 10 /**
 *
 */ 2 4 this 3 3705  5 value 1 3485  
905 0 0 4 868 3632 0 0 161 /**
 * Returns the address of the first of the four data elements in the vector.
 * The remaining elements occupy the next positions consecutively in memory.
 */ 1 4 this 3 3706  
906 0 0 6 869 3488 0 0 0 0 
907 0 0 4 871 3632 0 0 129 /**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */ 2 4 this 3 3705  10 fill_value 1 3485  
908 0 0 4 872 3632 0 0 10 /**
 *
 */ 5 4 this 3 3705  1 x 1 3485  1 y 1 3485  1 z 1 3485  1 w 1 3485  
909 0 0 6 873 3485 0 0 10 /**
 *
 */ 2 4 this 3 3706  5 other 1 3706  
910 0 0 6 874 3485 0 0 69 /**
 * Returns the square of the vector's length, cheap and easy.
 */ 1 4 this 3 3706  
911 0 0 6 875 3485 0 0 72 /**
 * Returns the length of the vector, by the Pythagorean theorem.
 */ 1 4 this 3 3706  
912 0 0 6 876 3637 0 0 127 /**
 * Normalizes the vector in place.  Returns true if the vector was normalized,
 * false if it was a zero-length vector.
 */ 1 4 this 3 3705  
913 0 0 7 877 3705 2762 0 160 /**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */ 1 4 this 3 3706  
914 0 0 7 878 3705 2762 0 152 /**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */ 2 4 this 3 3706  4 onto 1 3706  
915 0 0 6 879 3637 0 0 0 2 4 this 3 3706  5 other 1 3706  
916 0 0 6 880 3637 0 0 0 2 4 this 3 3706  5 other 1 3706  
917 0 0 6 881 3637 0 0 0 2 4 this 3 3706  5 other 1 3706  
918 0 0 6 882 3488 0 0 97 /**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */ 2 4 this 3 3706  5 other 1 3706  
919 0 0 6 882 3488 0 0 233 /**
 * Sorts vectors lexicographically, componentwise.  Returns a number less than
 * 0 if this vector sorts before the other one, greater than zero if it sorts
 * after, 0 if they are equivalent (within the indicated tolerance).
 */ 3 4 this 3 3706  5 other 1 3706  9 threshold 1 3485  
920 0 0 6 883 3630 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 1 4 this 3 3706  
921 0 0 6 883 3630 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 2 4 this 3 3706  9 threshold 1 3485  
922 0 0 6 884 3630 0 0 49 /**
 * Adds the vector into the running hash.
 */ 2 4 this 3 3706  4 hash 1 3630  
923 0 0 6 884 3630 0 0 49 /**
 * Adds the vector into the running hash.
 */ 3 4 this 3 3706  4 hash 1 3630  9 threshold 1 3485  
924 0 0 4 885 3632 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 2 4 this 3 3706  7 hashgen 1 3638  
925 0 0 4 885 3632 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 3 4 this 3 3706  7 hashgen 1 3638  9 threshold 1 3485  
926 0 0 7 886 3705 2762 0 0 1 4 this 3 3706  
927 0 0 7 887 3705 2762 0 0 2 4 this 3 3706  5 other 1 3706  
928 0 0 7 888 3705 2762 0 0 2 4 this 3 3706  5 other 1 3706  
929 0 0 7 889 3705 2762 0 0 2 4 this 3 3706  6 scalar 1 3485  
930 0 0 7 890 3705 2762 0 0 2 4 this 3 3706  6 scalar 1 3485  
931 0 0 6 891 3705 0 0 0 2 4 this 3 3705  5 other 1 3706  
932 0 0 6 892 3705 0 0 0 2 4 this 3 3705  5 other 1 3706  
933 0 0 6 893 3705 0 0 0 2 4 this 3 3705  6 scalar 1 3485  
934 0 0 6 894 3705 0 0 0 2 4 this 3 3705  6 scalar 1 3485  
935 0 0 4 895 3632 0 0 10 /**
 *
 */ 2 4 this 3 3705  5 other 1 3706  
936 0 0 7 896 3705 2762 0 0 2 4 this 3 3706  8 exponent 1 3485  
937 0 0 6 897 3633 0 0 0 2 4 this 3 3705  8 exponent 1 3485  
938 0 0 7 898 3705 2762 0 10 /**
 *
 */ 2 4 this 3 3706  5 other 1 3706  
939 0 0 7 899 3705 2762 0 10 /**
 *
 */ 2 4 this 3 3706  5 other 1 3706  
940 0 0 6 900 3637 0 0 116 /**
 * Returns true if two vectors are memberwise equal within a default tolerance
 * based on the numeric type.
 */ 2 4 this 3 3706  5 other 1 3706  
941 0 0 6 900 3637 0 0 92 /**
 * Returns true if two vectors are memberwise equal within a specified
 * tolerance.
 */ 3 4 this 3 3706  5 other 1 3706  9 threshold 1 3485  
942 0 0 4 901 3632 0 0 10 /**
 *
 */ 2 4 this 3 3706  3 out 1 3640  
943 0 0 6 902 3636 0 0 0 1 4 this 3 3706  
944 0 0 4 903 3632 0 0 332 /**
 * Writes the vector to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the vector, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */ 2 4 this 3 3706  11 destination 1 3642  
945 0 0 4 904 3632 0 0 114 /**
 * Reads the vector from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */ 2 4 this 3 3705  6 source 1 3644  
946 0 0 4 905 3632 0 0 205 /**
 * Writes the vector to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the vector using the standard width
 * setting, especially when you are writing a bam file.
 */ 2 4 this 3 3706  11 destination 1 3642  
947 0 0 4 906 3632 0 0 67 /**
 * Reads the vector from the Datagram using get_stdfloat().
 */ 2 4 this 3 3705  6 source 1 3644  
948 0 0 7 907 3647 0 0 0 0 
949 0 0 7 911 3710 2771 0 0 0 
950 0 0 7 911 3710 2771 0 10 /**
 *
 */ 1 4 copy 1 3706  
951 0 0 7 911 3710 2771 0 0 1 6 param0 0 3708  
952 0 0 7 911 3710 2771 0 10 /**
 *
 */ 1 10 fill_value 1 3485  
953 0 0 7 911 3710 2771 0 10 /**
 *
 */ 4 1 x 1 3485  1 y 1 3485  1 z 1 3485  1 w 1 3485  
954 0 0 4 912 3632 0 0 129 /**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */ 2 4 this 3 3710  10 fill_value 1 3485  
955 0 0 4 913 3632 0 0 10 /**
 *
 */ 5 4 this 3 3710  1 x 1 3485  1 y 1 3485  1 z 1 3485  1 w 1 3485  
956 0 0 4 914 3632 0 0 10 /**
 *
 */ 3 4 this 3 3710  1 i 1 3488  10 assign_val 1 3485  
957 0 0 6 914 3485 0 0 0 2 4 this 3 3708  1 i 1 3488  
958 0 0 6 915 3488 0 0 0 0 
959 0 0 4 916 3632 0 0 162 /**
 * Returns the address of the first of the three data elements in the vector.
 * The remaining elements occupy the next positions consecutively in memory.
 */ 1 4 this 3 3708  
960 0 0 6 917 3488 0 0 0 0 
961 0 0 7 918 3647 0 0 0 0 
962 0 0 7 922 3711 2841 0 0 0 
963 0 0 7 922 3711 2841 0 84 /**
 * Constructs an LVecBase4 from an LPoint3.  The w coordinate is set to 1.0.
 */ 1 5 point 1 3697  
964 0 0 7 922 3711 2841 0 10 /**
 *
 */ 2 4 copy 1 3679  1 w 1 3488  
965 0 0 7 922 3711 2841 0 0 1 6 param0 0 3712  
966 0 0 7 922 3711 2841 0 85 /**
 * Constructs an LVecBase4 from an LVector3.  The w coordinate is set to 0.0.
 */ 1 6 vector 1 3688  
967 0 0 7 922 3711 2841 0 10 /**
 *
 */ 1 4 copy 1 3714  
968 0 0 7 922 3711 2841 0 10 /**
 *
 */ 1 10 fill_value 1 3488  
969 0 0 7 922 3711 2841 0 10 /**
 *
 */ 4 1 x 1 3488  1 y 1 3488  1 z 1 3488  1 w 1 3488  
970 0 0 4 923 3632 0 0 0 2 4 this 3 3711  4 size 1 3630  
971 0 0 6 926 3711 0 0 0 2 4 this 3 3711  4 copy 1 3712  
972 0 0 6 926 3711 0 0 0 2 4 this 3 3711  10 fill_value 1 3488  
973 0 0 6 927 3712 0 0 40 /**
 * Returns a zero-length vector.
 */ 0 
974 0 0 6 928 3712 0 0 35 /**
 * Returns a unit X vector.
 */ 0 
975 0 0 6 929 3712 0 0 35 /**
 * Returns a unit Y vector.
 */ 0 
976 0 0 6 930 3712 0 0 35 /**
 * Returns a unit Z vector.
 */ 0 
977 0 0 6 931 3712 0 0 35 /**
 * Returns a unit W vector.
 */ 0 
978 0 0 6 932 3633 0 0 0 1 4 this 3 3712  
979 0 0 6 933 3633 0 0 0 2 4 this 3 3712  9 attr_name 1 3636  
980 0 0 6 934 3488 0 0 0 3 4 this 3 3711  9 attr_name 1 3636  6 assign 1 3633  
981 0 0 4 935 3632 0 0 10 /**
 *
 */ 3 4 this 3 3711  1 i 1 3488  10 assign_val 1 3488  
982 0 0 6 935 3488 0 0 0 2 4 this 3 3712  1 i 1 3488  
983 0 0 6 936 3488 0 0 0 0 
984 0 0 6 937 3637 0 0 91 /**
 * Returns true if any component of the vector is not-a-number, false
 * otherwise.
 */ 1 4 this 3 3712  
985 0 0 6 938 3488 0 0 10 /**
 *
 */ 2 4 this 3 3712  1 i 1 3488  
986 0 0 4 939 3632 0 0 10 /**
 *
 */ 3 4 this 3 3711  1 i 1 3488  5 value 1 3488  
987 0 0 6 940 3488 0 0 10 /**
 *
 */ 1 4 this 3 3712  
988 0 0 6 941 3488 0 0 10 /**
 *
 */ 1 4 this 3 3712  
989 0 0 6 942 3488 0 0 10 /**
 *
 */ 1 4 this 3 3712  
990 0 0 6 943 3488 0 0 10 /**
 *
 */ 1 4 this 3 3712  
991 0 0 7 944 3678 2440 0 58 /**
 * Returns the x, y and z component of this vector
 */ 1 4 this 3 3712  
992 0 0 7 945 3651 2130 0 55 /**
 * Returns the x and y component of this vector
 */ 1 4 this 3 3712  
993 0 0 4 946 3632 0 0 10 /**
 *
 */ 2 4 this 3 3711  5 value 1 3488  
994 0 0 4 947 3632 0 0 10 /**
 *
 */ 2 4 this 3 3711  5 value 1 3488  
995 0 0 4 948 3632 0 0 10 /**
 *
 */ 2 4 this 3 3711  5 value 1 3488  
996 0 0 4 949 3632 0 0 10 /**
 *
 */ 2 4 this 3 3711  5 value 1 3488  
997 0 0 4 955 3632 0 0 152 // These next functions add to an existing value.  i.e.
// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
// scripting languages: 3 4 this 3 3711  1 i 1 3488  5 value 1 3488  
998 0 0 4 956 3632 0 0 10 /**
 *
 */ 2 4 this 3 3711  5 value 1 3488  
999 0 0 4 957 3632 0 0 10 /**
 *
 */ 2 4 this 3 3711  5 value 1 3488  
1000 0 0 4 958 3632 0 0 10 /**
 *
 */ 2 4 this 3 3711  5 value 1 3488  
1001 0 0 4 959 3632 0 0 10 /**
 *
 */ 2 4 this 3 3711  5 value 1 3488  
1002 0 0 4 960 3632 0 0 161 /**
 * Returns the address of the first of the four data elements in the vector.
 * The remaining elements occupy the next positions consecutively in memory.
 */ 1 4 this 3 3712  
1003 0 0 6 961 3488 0 0 0 0 
1004 0 0 4 963 3632 0 0 129 /**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */ 2 4 this 3 3711  10 fill_value 1 3488  
1005 0 0 4 964 3632 0 0 10 /**
 *
 */ 5 4 this 3 3711  1 x 1 3488  1 y 1 3488  1 z 1 3488  1 w 1 3488  
1006 0 0 6 965 3488 0 0 10 /**
 *
 */ 2 4 this 3 3712  5 other 1 3712  
1007 0 0 6 966 3488 0 0 69 /**
 * Returns the square of the vector's length, cheap and easy.
 */ 1 4 this 3 3712  
1008 0 0 6 967 3637 0 0 0 2 4 this 3 3712  5 other 1 3712  
1009 0 0 6 968 3637 0 0 0 2 4 this 3 3712  5 other 1 3712  
1010 0 0 6 969 3637 0 0 0 2 4 this 3 3712  5 other 1 3712  
1011 0 0 6 970 3488 0 0 97 /**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */ 2 4 this 3 3712  5 other 1 3712  
1012 0 0 6 971 3630 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 1 4 this 3 3712  
1013 0 0 6 972 3630 0 0 49 /**
 * Adds the vector into the running hash.
 */ 2 4 this 3 3712  4 hash 1 3630  
1014 0 0 4 973 3632 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 2 4 this 3 3712  7 hashgen 1 3638  
1015 0 0 7 974 3711 2841 0 0 1 4 this 3 3712  
1016 0 0 7 975 3711 2841 0 0 2 4 this 3 3712  5 other 1 3712  
1017 0 0 7 976 3711 2841 0 0 2 4 this 3 3712  5 other 1 3712  
1018 0 0 7 977 3711 2841 0 0 2 4 this 3 3712  6 scalar 1 3488  
1019 0 0 7 978 3711 2841 0 0 2 4 this 3 3712  6 scalar 1 3488  
1020 0 0 6 979 3711 0 0 0 2 4 this 3 3711  5 other 1 3712  
1021 0 0 6 980 3711 0 0 0 2 4 this 3 3711  5 other 1 3712  
1022 0 0 6 981 3711 0 0 0 2 4 this 3 3711  6 scalar 1 3488  
1023 0 0 6 982 3711 0 0 0 2 4 this 3 3711  6 scalar 1 3488  
1024 0 0 4 983 3632 0 0 10 /**
 *
 */ 2 4 this 3 3711  5 other 1 3712  
1025 0 0 7 984 3711 2841 0 0 2 4 this 3 3712  8 exponent 1 3488  
1026 0 0 6 985 3633 0 0 0 2 4 this 3 3711  8 exponent 1 3488  
1027 0 0 7 986 3711 2841 0 10 /**
 *
 */ 2 4 this 3 3712  5 other 1 3712  
1028 0 0 7 987 3711 2841 0 10 /**
 *
 */ 2 4 this 3 3712  5 other 1 3712  
1029 0 0 6 988 3637 0 0 116 /**
 * Returns true if two vectors are memberwise equal within a default tolerance
 * based on the numeric type.
 */ 2 4 this 3 3712  5 other 1 3712  
1030 0 0 6 988 3637 0 0 92 /**
 * Returns true if two vectors are memberwise equal within a specified
 * tolerance.
 */ 3 4 this 3 3712  5 other 1 3712  9 threshold 1 3488  
1031 0 0 4 989 3632 0 0 10 /**
 *
 */ 2 4 this 3 3712  3 out 1 3640  
1032 0 0 6 990 3636 0 0 0 1 4 this 3 3712  
1033 0 0 4 991 3632 0 0 332 /**
 * Writes the vector to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the vector, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */ 2 4 this 3 3712  11 destination 1 3642  
1034 0 0 4 992 3632 0 0 114 /**
 * Reads the vector from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */ 2 4 this 3 3711  6 source 1 3644  
1035 0 0 4 993 3632 0 0 205 /**
 * Writes the vector to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the vector using the standard width
 * setting, especially when you are writing a bam file.
 */ 2 4 this 3 3712  11 destination 1 3642  
1036 0 0 4 994 3632 0 0 67 /**
 * Reads the vector from the Datagram using get_stdfloat().
 */ 2 4 this 3 3711  6 source 1 3644  
1037 0 0 7 995 3647 0 0 0 0 
1038 0 0 7 999 3716 2850 0 0 0 
1039 0 0 7 999 3716 2850 0 10 /**
 *
 */ 1 4 copy 1 3712  
1040 0 0 7 999 3716 2850 0 0 1 6 param0 0 3714  
1041 0 0 7 999 3716 2850 0 10 /**
 *
 */ 1 10 fill_value 1 3488  
1042 0 0 7 999 3716 2850 0 10 /**
 *
 */ 4 1 x 1 3488  1 y 1 3488  1 z 1 3488  1 w 1 3488  
1043 0 0 4 1000 3632 0 0 129 /**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */ 2 4 this 3 3716  10 fill_value 1 3488  
1044 0 0 4 1001 3632 0 0 10 /**
 *
 */ 5 4 this 3 3716  1 x 1 3488  1 y 1 3488  1 z 1 3488  1 w 1 3488  
1045 0 0 4 1002 3632 0 0 10 /**
 *
 */ 3 4 this 3 3716  1 i 1 3488  10 assign_val 1 3488  
1046 0 0 6 1002 3488 0 0 0 2 4 this 3 3714  1 i 1 3488  
1047 0 0 6 1003 3488 0 0 0 0 
1048 0 0 4 1004 3632 0 0 162 /**
 * Returns the address of the first of the three data elements in the vector.
 * The remaining elements occupy the next positions consecutively in memory.
 */ 1 4 this 3 3714  
1049 0 0 6 1005 3488 0 0 0 0 
1050 0 0 7 1006 3647 0 0 0 0 
1051 0 0 7 1009 3717 2870 0 0 0 
1052 0 0 7 1009 3717 2870 0 10 /**
 *
 */ 2 4 copy 1 3673  1 w 1 3482  
1053 0 0 7 1009 3717 2870 0 10 /**
 *
 */ 1 4 copy 1 3700  
1054 0 0 7 1009 3717 2870 0 0 1 6 param0 0 3718  
1055 0 0 7 1009 3717 2870 0 10 /**
 *
 */ 1 10 fill_value 1 3482  
1056 0 0 7 1009 3717 2870 0 10 /**
 *
 */ 4 1 x 1 3482  1 y 1 3482  1 z 1 3482  1 w 1 3482  
1057 0 0 6 1010 3633 0 0 0 2 4 this 3 3718  9 attr_name 1 3636  
1058 0 0 6 1011 3488 0 0 0 3 4 this 3 3717  9 attr_name 1 3636  6 assign 1 3633  
1059 0 0 6 1012 3718 0 0 40 /**
 * Returns a zero-length vector.
 */ 0 
1060 0 0 6 1013 3718 0 0 35 /**
 * Returns a unit X vector.
 */ 0 
1061 0 0 6 1014 3718 0 0 35 /**
 * Returns a unit Y vector.
 */ 0 
1062 0 0 6 1015 3718 0 0 35 /**
 * Returns a unit Z vector.
 */ 0 
1063 0 0 6 1016 3718 0 0 35 /**
 * Returns a unit W vector.
 */ 0 
1064 0 0 7 1017 3681 2478 0 58 /**
 * Returns the x, y and z component of this vector
 */ 1 4 this 3 3718  
1065 0 0 7 1018 3654 2148 0 55 /**
 * Returns the x and y component of this vector
 */ 1 4 this 3 3718  
1066 0 0 7 1021 3717 2870 0 0 1 4 this 3 3718  
1067 0 0 7 1022 3699 2679 0 0 2 4 this 3 3718  5 other 1 3700  
1068 0 0 7 1022 3717 2870 0 0 2 4 this 3 3718  5 other 1 3718  
1069 0 0 7 1023 3699 2679 0 0 2 4 this 3 3718  5 other 1 3700  
1070 0 0 7 1023 3717 2870 0 0 2 4 this 3 3718  5 other 1 3718  
1071 0 0 7 1024 3717 2870 0 0 2 4 this 3 3718  6 scalar 1 3482  
1072 0 0 7 1025 3717 2870 0 0 2 4 this 3 3718  6 scalar 1 3482  
1073 0 0 7 1026 3717 2870 0 160 /**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */ 1 4 this 3 3718  
1074 0 0 7 1027 3717 2870 0 152 /**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */ 2 4 this 3 3718  4 onto 1 3700  
1075 0 0 6 1028 3636 0 0 0 1 4 this 3 3718  
1076 0 0 7 1029 3647 0 0 0 0 
1077 0 0 7 1032 3720 2890 0 0 0 
1078 0 0 7 1032 3720 2890 0 10 /**
 *
 */ 2 4 copy 1 3676  1 w 1 3485  
1079 0 0 7 1032 3720 2890 0 10 /**
 *
 */ 1 4 copy 1 3706  
1080 0 0 7 1032 3720 2890 0 0 1 6 param0 0 3721  
1081 0 0 7 1032 3720 2890 0 10 /**
 *
 */ 1 10 fill_value 1 3485  
1082 0 0 7 1032 3720 2890 0 10 /**
 *
 */ 4 1 x 1 3485  1 y 1 3485  1 z 1 3485  1 w 1 3485  
1083 0 0 6 1033 3633 0 0 0 2 4 this 3 3721  9 attr_name 1 3636  
1084 0 0 6 1034 3488 0 0 0 3 4 this 3 3720  9 attr_name 1 3636  6 assign 1 3633  
1085 0 0 6 1035 3721 0 0 40 /**
 * Returns a zero-length vector.
 */ 0 
1086 0 0 6 1036 3721 0 0 35 /**
 * Returns a unit X vector.
 */ 0 
1087 0 0 6 1037 3721 0 0 35 /**
 * Returns a unit Y vector.
 */ 0 
1088 0 0 6 1038 3721 0 0 35 /**
 * Returns a unit Z vector.
 */ 0 
1089 0 0 6 1039 3721 0 0 35 /**
 * Returns a unit W vector.
 */ 0 
1090 0 0 7 1040 3684 2512 0 58 /**
 * Returns the x, y and z component of this vector
 */ 1 4 this 3 3721  
1091 0 0 7 1041 3657 2166 0 55 /**
 * Returns the x and y component of this vector
 */ 1 4 this 3 3721  
1092 0 0 7 1044 3720 2890 0 0 1 4 this 3 3721  
1093 0 0 7 1045 3705 2762 0 0 2 4 this 3 3721  5 other 1 3706  
1094 0 0 7 1045 3720 2890 0 0 2 4 this 3 3721  5 other 1 3721  
1095 0 0 7 1046 3705 2762 0 0 2 4 this 3 3721  5 other 1 3706  
1096 0 0 7 1046 3720 2890 0 0 2 4 this 3 3721  5 other 1 3721  
1097 0 0 7 1047 3720 2890 0 0 2 4 this 3 3721  6 scalar 1 3485  
1098 0 0 7 1048 3720 2890 0 0 2 4 this 3 3721  6 scalar 1 3485  
1099 0 0 7 1049 3720 2890 0 160 /**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */ 1 4 this 3 3721  
1100 0 0 7 1050 3720 2890 0 152 /**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */ 2 4 this 3 3721  4 onto 1 3706  
1101 0 0 6 1051 3636 0 0 0 1 4 this 3 3721  
1102 0 0 7 1052 3647 0 0 0 0 
1103 0 0 7 1055 3723 2908 0 0 0 
1104 0 0 7 1055 3723 2908 0 10 /**
 *
 */ 2 4 copy 1 3679  1 w 1 3488  
1105 0 0 7 1055 3723 2908 0 10 /**
 *
 */ 1 4 copy 1 3712  
1106 0 0 7 1055 3723 2908 0 0 1 6 param0 0 3724  
1107 0 0 7 1055 3723 2908 0 10 /**
 *
 */ 1 10 fill_value 1 3488  
1108 0 0 7 1055 3723 2908 0 10 /**
 *
 */ 4 1 x 1 3488  1 y 1 3488  1 z 1 3488  1 w 1 3488  
1109 0 0 6 1056 3633 0 0 0 2 4 this 3 3724  9 attr_name 1 3636  
1110 0 0 6 1057 3488 0 0 0 3 4 this 3 3723  9 attr_name 1 3636  6 assign 1 3633  
1111 0 0 6 1058 3724 0 0 40 /**
 * Returns a zero-length vector.
 */ 0 
1112 0 0 6 1059 3724 0 0 35 /**
 * Returns a unit X vector.
 */ 0 
1113 0 0 6 1060 3724 0 0 35 /**
 * Returns a unit Y vector.
 */ 0 
1114 0 0 6 1061 3724 0 0 35 /**
 * Returns a unit Z vector.
 */ 0 
1115 0 0 6 1062 3724 0 0 35 /**
 * Returns a unit W vector.
 */ 0 
1116 0 0 7 1063 3687 2538 0 58 /**
 * Returns the x, y and z component of this vector
 */ 1 4 this 3 3724  
1117 0 0 7 1064 3660 2180 0 55 /**
 * Returns the x and y component of this vector
 */ 1 4 this 3 3724  
1118 0 0 7 1067 3723 2908 0 0 1 4 this 3 3724  
1119 0 0 7 1068 3711 2841 0 0 2 4 this 3 3724  5 other 1 3712  
1120 0 0 7 1068 3723 2908 0 0 2 4 this 3 3724  5 other 1 3724  
1121 0 0 7 1069 3711 2841 0 0 2 4 this 3 3724  5 other 1 3712  
1122 0 0 7 1069 3723 2908 0 0 2 4 this 3 3724  5 other 1 3724  
1123 0 0 7 1070 3723 2908 0 0 2 4 this 3 3724  6 scalar 1 3488  
1124 0 0 7 1071 3723 2908 0 0 2 4 this 3 3724  6 scalar 1 3488  
1125 0 0 6 1072 3636 0 0 0 1 4 this 3 3724  
1126 0 0 7 1073 3647 0 0 0 0 
1127 0 0 7 1076 3726 2928 0 0 0 
1128 0 0 7 1076 3726 2928 0 0 1 6 param0 0 3727  
1129 0 0 7 1076 3726 2928 0 10 /**
 *
 */ 2 4 copy 1 3673  1 w 1 3482  
1130 0 0 7 1076 3726 2928 0 10 /**
 *
 */ 1 4 copy 1 3700  
1131 0 0 7 1076 3726 2928 0 10 /**
 *
 */ 1 10 fill_value 1 3482  
1132 0 0 7 1076 3726 2928 0 10 /**
 *
 */ 4 1 x 1 3482  1 y 1 3482  1 z 1 3482  1 w 1 3482  
1133 0 0 6 1077 3633 0 0 0 2 4 this 3 3727  9 attr_name 1 3636  
1134 0 0 6 1078 3488 0 0 0 3 4 this 3 3726  9 attr_name 1 3636  6 assign 1 3633  
1135 0 0 6 1079 3727 0 0 39 /**
 * Returns a zero-length point.
 */ 0 
1136 0 0 6 1080 3727 0 0 34 /**
 * Returns a unit X point.
 */ 0 
1137 0 0 6 1081 3727 0 0 34 /**
 * Returns a unit Y point.
 */ 0 
1138 0 0 6 1082 3727 0 0 34 /**
 * Returns a unit Z point.
 */ 0 
1139 0 0 6 1083 3727 0 0 34 /**
 * Returns a unit W point.
 */ 0 
1140 0 0 7 1084 3690 2561 0 58 /**
 * Returns the x, y and z component of this vector
 */ 1 4 this 3 3727  
1141 0 0 7 1085 3663 2196 0 55 /**
 * Returns the x and y component of this vector
 */ 1 4 this 3 3727  
1142 0 0 7 1088 3726 2928 0 0 1 4 this 3 3727  
1143 0 0 7 1089 3699 2679 0 0 2 4 this 3 3727  5 other 1 3700  
1144 0 0 7 1089 3726 2928 0 0 2 4 this 3 3727  5 other 1 3718  
1145 0 0 7 1090 3717 2870 0 0 2 4 this 3 3727  5 other 1 3727  
1146 0 0 7 1090 3699 2679 0 0 2 4 this 3 3727  5 other 1 3700  
1147 0 0 7 1090 3726 2928 0 0 2 4 this 3 3727  5 other 1 3718  
1148 0 0 7 1091 3726 2928 0 0 2 4 this 3 3727  6 scalar 1 3482  
1149 0 0 7 1092 3726 2928 0 0 2 4 this 3 3727  6 scalar 1 3482  
1150 0 0 7 1093 3726 2928 0 160 /**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */ 1 4 this 3 3727  
1151 0 0 7 1094 3726 2928 0 152 /**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */ 2 4 this 3 3727  4 onto 1 3700  
1152 0 0 6 1095 3636 0 0 0 1 4 this 3 3727  
1153 0 0 7 1096 3647 0 0 0 0 
1154 0 0 7 1099 3729 2948 0 0 0 
1155 0 0 7 1099 3729 2948 0 0 1 6 param0 0 3730  
1156 0 0 7 1099 3729 2948 0 10 /**
 *
 */ 2 4 copy 1 3676  1 w 1 3485  
1157 0 0 7 1099 3729 2948 0 10 /**
 *
 */ 1 4 copy 1 3706  
1158 0 0 7 1099 3729 2948 0 10 /**
 *
 */ 1 10 fill_value 1 3485  
1159 0 0 7 1099 3729 2948 0 10 /**
 *
 */ 4 1 x 1 3485  1 y 1 3485  1 z 1 3485  1 w 1 3485  
1160 0 0 6 1100 3633 0 0 0 2 4 this 3 3730  9 attr_name 1 3636  
1161 0 0 6 1101 3488 0 0 0 3 4 this 3 3729  9 attr_name 1 3636  6 assign 1 3633  
1162 0 0 6 1102 3730 0 0 39 /**
 * Returns a zero-length point.
 */ 0 
1163 0 0 6 1103 3730 0 0 34 /**
 * Returns a unit X point.
 */ 0 
1164 0 0 6 1104 3730 0 0 34 /**
 * Returns a unit Y point.
 */ 0 
1165 0 0 6 1105 3730 0 0 34 /**
 * Returns a unit Z point.
 */ 0 
1166 0 0 6 1106 3730 0 0 34 /**
 * Returns a unit W point.
 */ 0 
1167 0 0 7 1107 3693 2584 0 58 /**
 * Returns the x, y and z component of this vector
 */ 1 4 this 3 3730  
1168 0 0 7 1108 3666 2212 0 55 /**
 * Returns the x and y component of this vector
 */ 1 4 this 3 3730  
1169 0 0 7 1111 3729 2948 0 0 1 4 this 3 3730  
1170 0 0 7 1112 3705 2762 0 0 2 4 this 3 3730  5 other 1 3706  
1171 0 0 7 1112 3729 2948 0 0 2 4 this 3 3730  5 other 1 3721  
1172 0 0 7 1113 3720 2890 0 0 2 4 this 3 3730  5 other 1 3730  
1173 0 0 7 1113 3705 2762 0 0 2 4 this 3 3730  5 other 1 3706  
1174 0 0 7 1113 3729 2948 0 0 2 4 this 3 3730  5 other 1 3721  
1175 0 0 7 1114 3729 2948 0 0 2 4 this 3 3730  6 scalar 1 3485  
1176 0 0 7 1115 3729 2948 0 0 2 4 this 3 3730  6 scalar 1 3485  
1177 0 0 7 1116 3729 2948 0 160 /**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */ 1 4 this 3 3730  
1178 0 0 7 1117 3729 2948 0 152 /**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */ 2 4 this 3 3730  4 onto 1 3706  
1179 0 0 6 1118 3636 0 0 0 1 4 this 3 3730  
1180 0 0 7 1119 3647 0 0 0 0 
1181 0 0 7 1122 3732 2966 0 0 0 
1182 0 0 7 1122 3732 2966 0 0 1 6 param0 0 3733  
1183 0 0 7 1122 3732 2966 0 10 /**
 *
 */ 2 4 copy 1 3679  1 w 1 3488  
1184 0 0 7 1122 3732 2966 0 10 /**
 *
 */ 1 4 copy 1 3712  
1185 0 0 7 1122 3732 2966 0 10 /**
 *
 */ 1 10 fill_value 1 3488  
1186 0 0 7 1122 3732 2966 0 10 /**
 *
 */ 4 1 x 1 3488  1 y 1 3488  1 z 1 3488  1 w 1 3488  
1187 0 0 6 1123 3633 0 0 0 2 4 this 3 3733  9 attr_name 1 3636  
1188 0 0 6 1124 3488 0 0 0 3 4 this 3 3732  9 attr_name 1 3636  6 assign 1 3633  
1189 0 0 6 1125 3733 0 0 39 /**
 * Returns a zero-length point.
 */ 0 
1190 0 0 6 1126 3733 0 0 34 /**
 * Returns a unit X point.
 */ 0 
1191 0 0 6 1127 3733 0 0 34 /**
 * Returns a unit Y point.
 */ 0 
1192 0 0 6 1128 3733 0 0 34 /**
 * Returns a unit Z point.
 */ 0 
1193 0 0 6 1129 3733 0 0 34 /**
 * Returns a unit W point.
 */ 0 
1194 0 0 7 1130 3696 2605 0 58 /**
 * Returns the x, y and z component of this vector
 */ 1 4 this 3 3733  
1195 0 0 7 1131 3669 2226 0 55 /**
 * Returns the x and y component of this vector
 */ 1 4 this 3 3733  
1196 0 0 7 1134 3732 2966 0 0 1 4 this 3 3733  
1197 0 0 7 1135 3711 2841 0 0 2 4 this 3 3733  5 other 1 3712  
1198 0 0 7 1135 3732 2966 0 0 2 4 this 3 3733  5 other 1 3724  
1199 0 0 7 1136 3723 2908 0 0 2 4 this 3 3733  5 other 1 3733  
1200 0 0 7 1136 3711 2841 0 0 2 4 this 3 3733  5 other 1 3712  
1201 0 0 7 1136 3732 2966 0 0 2 4 this 3 3733  5 other 1 3724  
1202 0 0 7 1137 3732 2966 0 0 2 4 this 3 3733  6 scalar 1 3488  
1203 0 0 7 1138 3732 2966 0 0 2 4 this 3 3733  6 scalar 1 3488  
1204 0 0 6 1139 3636 0 0 0 1 4 this 3 3733  
1205 0 0 7 1140 3647 0 0 0 0 
1206 0 0 7 1154 3735 3052 0 10 /**
 *
 */ 0 
1207 0 0 7 1154 3735 3052 0 10 /**
 *
 */ 1 5 other 1 3736  
1208 0 0 7 1154 3735 3052 0 10 /**
 *
 */ 9 3 e00 1 3482  3 e01 1 3482  3 e02 1 3482  3 e10 1 3482  3 e11 1 3482  3 e12 1 3482  3 e20 1 3482  3 e21 1 3482  3 e22 1 3482  
1209 0 0 6 1155 3735 0 0 10 /**
 *
 */ 2 4 this 3 3735  5 other 1 3736  
1210 0 0 6 1155 3735 0 0 10 /**
 *
 */ 2 4 this 3 3735  10 fill_value 1 3482  
1211 0 0 4 1156 3632 0 0 0 2 4 this 3 3735  4 size 1 3630  
1212 0 0 6 1159 3633 0 0 0 1 4 this 3 3736  
1213 0 0 4 1160 3632 0 0 157 /**
 * Sets each element of the matrix to the indicated fill_value.  This is of
 * questionable value, but is sometimes useful when initializing to zero.
 */ 2 4 this 3 3735  10 fill_value 1 3482  
1214 0 0 4 1161 3632 0 0 10 /**
 *
 */ 10 4 this 3 3735  3 e00 1 3482  3 e01 1 3482  3 e02 1 3482  3 e10 1 3482  3 e11 1 3482  3 e12 1 3482  3 e20 1 3482  3 e21 1 3482  3 e22 1 3482  
1215 0 0 7 1162 3738 2970 0 0 2 4 this 3 3735  1 i 1 3488  
1216 0 0 7 1162 3739 2974 0 0 2 4 this 3 3736  1 i 1 3488  
1217 0 0 6 1163 3488 0 0 55 /**
 * Returns 3: the number of rows of a LMatrix3.
 */ 0 
1218 0 0 4 1164 3632 0 0 109 /**
 * Replaces the indicated row of the matrix from a two-component vector,
 * ignoring the last column.
 */ 3 4 this 3 3735  3 row 1 3488  1 v 1 3628  
1219 0 0 4 1164 3632 0 0 82 /**
 * Replaces the indicated row of the matrix from a three-component vector.
 */ 3 4 this 3 3735  3 row 1 3488  1 v 1 3673  
1220 0 0 4 1165 3632 0 0 109 /**
 * Replaces the indicated column of the matrix from a two-component vector,
 * ignoring the last row.
 */ 3 4 this 3 3735  3 col 1 3488  1 v 1 3628  
1221 0 0 4 1165 3632 0 0 85 /**
 * Replaces the indicated column of the matrix from a three-component vector.
 */ 3 4 this 3 3735  3 col 1 3488  1 v 1 3673  
1222 0 0 4 1166 3632 0 0 78 /**
 * Stores the indicated row of the matrix as a three-component vector.
 */ 3 4 this 3 3736  10 result_vec 1 3672  3 row 1 3488  
1223 0 0 7 1166 3672 2299 0 79 /**
 * Returns the indicated row of the matrix as a three-component vector.
 */ 2 4 this 3 3736  3 row 1 3488  
1224 0 0 7 1167 3672 2299 0 82 /**
 * Returns the indicated column of the matrix as a three-component vector.
 */ 2 4 this 3 3736  3 col 1 3488  
1225 0 0 7 1174 3627 2008 0 106 /**
 * Returns the indicated row of the matrix as a two-component vector, ignoring
 * the last column.
 */ 2 4 this 3 3736  3 row 1 3488  
1226 0 0 7 1175 3627 2008 0 106 /**
 * Returns the indicated column of the matrix as a two-component vector,
 * ignoring the last row.
 */ 2 4 this 3 3736  3 col 1 3488  
1227 0 0 4 1178 3632 0 0 10 /**
 *
 */ 3 4 this 3 3735  3 row 1 3488  3 col 1 3488  
1228 0 0 6 1178 3482 0 0 0 3 4 this 3 3736  3 row 1 3488  3 col 1 3488  
1229 0 0 6 1179 3637 0 0 91 /**
 * Returns true if any component of the matrix is not-a-number, false
 * otherwise.
 */ 1 4 this 3 3736  
1230 0 0 6 1180 3637 0 0 93 /**
 * Returns true if this is (close enough to) the identity matrix, false
 * otherwise.
 */ 1 4 this 3 3736  
1231 0 0 6 1181 3482 0 0 54 /**
 * Returns a particular element of the matrix.
 */ 3 4 this 3 3736  3 row 1 3488  3 col 1 3488  
1232 0 0 4 1182 3632 0 0 54 /**
 * Changes a particular element of the matrix.
 */ 4 4 this 3 3735  3 row 1 3488  3 col 1 3488  5 value 1 3482  
1233 0 0 4 1183 3632 0 0 162 /**
 * Returns the address of the first of the nine data elements in the matrix.
 * The remaining elements occupy the next eight positions in row-major order.
 */ 1 4 this 3 3736  
1234 0 0 6 1184 3488 0 0 62 /**
 * Returns the number of elements in the matrix, nine.
 */ 1 4 this 3 3736  
1235 0 0 6 1185 3637 0 0 0 2 4 this 3 3736  5 other 1 3736  
1236 0 0 6 1186 3637 0 0 0 2 4 this 3 3736  5 other 1 3736  
1237 0 0 6 1187 3637 0 0 0 2 4 this 3 3736  5 other 1 3736  
1238 0 0 6 1188 3488 0 0 97 /**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */ 2 4 this 3 3736  5 other 1 3736  
1239 0 0 6 1188 3488 0 0 234 /**
 * Sorts matrices lexicographically, componentwise.  Returns a number less
 * than 0 if this matrix sorts before the other one, greater than zero if it
 * sorts after, 0 if they are equivalent (within the indicated tolerance).
 */ 3 4 this 3 3736  5 other 1 3736  9 threshold 1 3482  
1240 0 0 6 1189 3630 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 1 4 this 3 3736  
1241 0 0 6 1189 3630 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 2 4 this 3 3736  9 threshold 1 3482  
1242 0 0 6 1190 3630 0 0 49 /**
 * Adds the vector into the running hash.
 */ 2 4 this 3 3736  4 hash 1 3630  
1243 0 0 6 1190 3630 0 0 49 /**
 * Adds the vector into the running hash.
 */ 3 4 this 3 3736  4 hash 1 3630  9 threshold 1 3482  
1244 0 0 7 1191 3672 2299 0 52 /**
 * 3-component vector or point times matrix.
 */ 2 4 this 3 3736  1 v 1 3673  
1245 0 0 7 1192 3627 2008 0 162 /**
 * The matrix transforms a 2-component point (including translation component)
 * and returns the result.  This assumes the matrix is an affine transform.
 */ 2 4 this 3 3736  1 v 1 3628  
1246 0 0 7 1193 3627 2008 0 161 /**
 * The matrix transforms a 2-component vector (without translation component)
 * and returns the result.  This assumes the matrix is an affine transform.
 */ 2 4 this 3 3736  1 v 1 3628  
1247 0 0 7 1193 3672 2299 0 194 /**
 * The matrix transforms a 3-component vector and returns the result.  This
 * assumes the matrix is an orthonormal transform.
 *
 * In practice, this is the same computation as xform().
 */ 2 4 this 3 3736  1 v 1 3673  
1248 0 0 7 1194 3672 2299 0 142 /**
 * The matrix transforms a 3-component vector (without translation component)
 * and returns the result, as a fully general operation.
 */ 2 4 this 3 3736  1 v 1 3673  
1249 0 0 4 1195 3632 0 0 52 /**
 * 3-component vector or point times matrix.
 */ 2 4 this 3 3736  1 v 1 3672  
1250 0 0 4 1196 3632 0 0 139 /**
 * The matrix transforms a 2-component point (including translation
 * component).  This assumes the matrix is an affine transform.
 */ 2 4 this 3 3736  1 v 1 3627  
1251 0 0 4 1197 3632 0 0 137 /**
 * The matrix transforms a 2-component vector (without translation component).
 * This assumes the matrix is an affine transform.
 */ 2 4 this 3 3736  1 v 1 3627  
1252 0 0 4 1197 3632 0 0 171 /**
 * The matrix transforms a 3-component vector.  This assumes the matrix is an
 * orthonormal transform.
 *
 * In practice, this is the same computation as xform().
 */ 2 4 this 3 3736  1 v 1 3672  
1253 0 0 4 1198 3632 0 0 119 /**
 * The matrix transforms a 3-component vector (without translation component),
 * as a fully general operation.
 */ 2 4 this 3 3736  1 v 1 3672  
1254 0 0 4 1199 3632 0 0 25 // this = other1 * other2 3 4 this 3 3735  6 other1 1 3736  6 other2 1 3736  
1255 0 0 7 1200 3735 3052 0 0 2 4 this 3 3736  5 other 1 3736  
1256 0 0 7 1200 3735 3052 0 0 2 4 this 3 3736  6 scalar 1 3482  
1257 0 0 7 1201 3735 3052 0 0 2 4 this 3 3736  6 scalar 1 3482  
1258 0 0 6 1202 3735 0 0 63 /**
 * Performs a memberwise addition between two matrices.
 */ 2 4 this 3 3735  5 other 1 3736  
1259 0 0 6 1203 3735 0 0 66 /**
 * Performs a memberwise subtraction between two matrices.
 */ 2 4 this 3 3735  5 other 1 3736  
1260 0 0 6 1204 3735 0 0 10 /**
 *
 */ 2 4 this 3 3735  5 other 1 3736  
1261 0 0 6 1204 3735 0 0 39 /**
 * Performs a memberwise scale.
 */ 2 4 this 3 3735  6 scalar 1 3482  
1262 0 0 6 1205 3735 0 0 39 /**
 * Performs a memberwise scale.
 */ 2 4 this 3 3735  6 scalar 1 3482  
1263 0 0 4 1206 3632 0 0 10 /**
 *
 */ 2 4 this 3 3735  5 other 1 3736  
1264 0 0 6 1207 3482 0 0 49 /**
 * Returns the determinant of the matrix.
 */ 1 4 this 3 3736  
1265 0 0 4 1208 3632 0 0 10 /**
 *
 */ 2 4 this 3 3735  5 other 1 3736  
1266 0 0 4 1209 3632 0 0 10 /**
 *
 */ 1 4 this 3 3735  
1267 0 0 6 1210 3637 0 0 463 /**
 * Computes the inverse of the other matrix, and stores the result in this
 * matrix.  This is a fully general operation and makes no assumptions about
 * the type of transform represented by the matrix.
 *
 * The other matrix must be a different object than this matrix.  However, if
 * you need to invert a matrix in place, see invert_in_place.
 *
 * The return value is true if the matrix was successfully inverted, false if
 * there was a singularity.
 */ 2 4 this 3 3735  5 other 1 3736  
1268 0 0 6 1211 3637 0 0 119 /**
 * Inverts the current matrix.  Returns true if the inverse is successful,
 * false if the matrix was singular.
 */ 1 4 this 3 3735  
1269 0 0 6 1212 3637 0 0 114 /**
 * Simultaneously computes the inverse of the indicated matrix, and then the
 * transpose of that inverse.
 */ 2 4 this 3 3735  5 other 1 3736  
1270 0 0 6 1212 3637 0 0 114 /**
 * Simultaneously computes the inverse of the indicated matrix, and then the
 * transpose of that inverse.
 */ 2 4 this 3 3735  5 other 1 3740  
1271 0 0 6 1213 3736 0 0 147 /**
 * Returns an identity matrix.
 *
 * This function definition must appear first, since some inline functions
 * below take advantage of it.
 */ 0 
1272 0 0 4 1214 3632 0 0 74 /**
 * Fills mat with a matrix that applies the indicated translation.
 */ 2 4 this 3 3735  5 trans 1 3628  
1273 0 0 4 1215 3632 0 0 98 /**
 * Fills mat with a matrix that rotates by the given angle in degrees
 * counterclockwise.
 */ 2 4 this 3 3735  5 angle 1 3482  
1274 0 0 4 1215 3632 0 0 125 /**
 * Fills mat with a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.
 */ 4 4 this 3 3735  5 angle 1 3482  4 axis 1 3673  2 cs 1 3501  
1275 0 0 4 1216 3632 0 0 95 /**
 * Fills mat with a matrix that applies the indicated scale in each of the two
 * axes.
 */ 2 4 this 3 3735  5 scale 1 3628  
1276 0 0 4 1216 3632 0 0 97 /**
 * Fills mat with a matrix that applies the indicated scale in each of the
 * three axes.
 */ 2 4 this 3 3735  5 scale 1 3673  
1277 0 0 7 1217 3735 3052 0 67 /**
 * Returns a matrix that applies the indicated translation.
 */ 1 5 trans 1 3628  
1278 0 0 7 1217 3735 3052 0 67 /**
 * Returns a matrix that applies the indicated translation.
 */ 2 2 tx 1 3482  2 ty 1 3482  
1279 0 0 7 1218 3735 3052 0 91 /**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise.
 */ 1 5 angle 1 3482  
1280 0 0 7 1218 3735 3052 0 118 /**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.
 */ 3 5 angle 1 3482  4 axis 1 3673  2 cs 1 3501  
1281 0 0 7 1219 3735 3052 0 85 /**
 * Returns a matrix that applies the indicated scale in each of the two axes.
 */ 1 5 scale 1 3628  
1282 0 0 7 1219 3735 3052 0 90 /**
 * Returns a matrix that applies the indicated scale in each of the three
 * axes.
 */ 1 5 scale 1 3673  
1283 0 0 7 1219 3735 3052 0 85 /**
 * Returns a matrix that applies the indicated scale in each of the two axes.
 */ 2 2 sx 1 3482  2 sy 1 3482  
1284 0 0 7 1219 3735 3052 0 90 /**
 * Returns a matrix that applies the indicated scale in each of the three
 * axes.
 */ 3 2 sx 1 3482  2 sy 1 3482  2 sz 1 3482  
1285 0 0 4 1220 3632 0 0 163 /**
 * Fills mat with a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.  Assumes axis has been
 * normalized.
 */ 4 4 this 3 3735  5 angle 1 3482  4 axis 1 3673  2 cs 1 3501  
1286 0 0 7 1221 3735 3052 0 156 /**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.  Assumes axis has been
 * normalized.
 */ 3 5 angle 1 3482  4 axis 1 3673  2 cs 1 3501  
1287 0 0 4 1222 3632 0 0 99 /**
 * Fills mat with a matrix that applies the indicated shear in each of the
 * three planes.
 */ 3 4 this 3 3735  5 shear 1 3673  2 cs 1 3501  
1288 0 0 7 1223 3735 3052 0 92 /**
 * Returns a matrix that applies the indicated shear in each of the three
 * planes.
 */ 2 5 shear 1 3673  2 cs 1 3501  
1289 0 0 7 1223 3735 3052 0 92 /**
 * Returns a matrix that applies the indicated shear in each of the three
 * planes.
 */ 4 4 shxy 1 3482  4 shxz 1 3482  4 shyz 1 3482  2 cs 1 3501  
1290 0 0 4 1224 3632 0 0 78 /**
 * Fills mat with a matrix that applies the indicated scale and shear.
 */ 4 4 this 3 3735  5 scale 1 3673  5 shear 1 3673  2 cs 1 3501  
1291 0 0 7 1225 3735 3052 0 71 /**
 * Returns a matrix that applies the indicated scale and shear.
 */ 3 5 scale 1 3673  5 shear 1 3673  2 cs 1 3501  
1292 0 0 7 1225 3735 3052 0 71 /**
 * Returns a matrix that applies the indicated scale and shear.
 */ 7 2 sx 1 3482  2 sy 1 3482  2 sz 1 3482  4 shxy 1 3482  4 shxz 1 3482  4 shyz 1 3482  2 cs 1 3501  
1293 0 0 6 1226 3736 0 0 119 /**
 * Returns a matrix that transforms from the indicated coordinate system to
 * the indicated coordinate system.
 */ 2 4 from 1 3501  2 to 1 3501  
1294 0 0 6 1227 3637 0 0 117 /**
 * Returns true if two matrices are memberwise equal within a default
 * tolerance based on the numeric type.
 */ 2 4 this 3 3736  5 other 1 3736  
1295 0 0 6 1227 3637 0 0 93 /**
 * Returns true if two matrices are memberwise equal within a specified
 * tolerance.
 */ 3 4 this 3 3736  5 other 1 3736  9 threshold 1 3482  
1296 0 0 4 1228 3632 0 0 10 /**
 *
 */ 2 4 this 3 3736  3 out 1 3640  
1297 0 0 4 1229 3632 0 0 10 /**
 *
 */ 3 4 this 3 3736  3 out 1 3640  12 indent_level 1 3488  
1298 0 0 6 1230 3636 0 0 0 1 4 this 3 3736  
1299 0 0 4 1231 3632 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 2 4 this 3 3736  7 hashgen 1 3638  
1300 0 0 4 1231 3632 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 3 4 this 3 3736  7 hashgen 1 3638  9 threshold 1 3482  
1301 0 0 4 1232 3632 0 0 332 /**
 * Writes the matrix to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the matrix, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */ 2 4 this 3 3736  11 destination 1 3642  
1302 0 0 4 1233 3632 0 0 114 /**
 * Reads the matrix from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */ 2 4 this 3 3735  4 scan 1 3644  
1303 0 0 4 1234 3632 0 0 205 /**
 * Writes the matrix to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the matrix using the standard width
 * setting, especially when you are writing a bam file.
 */ 2 4 this 3 3736  11 destination 1 3642  
1304 0 0 4 1235 3632 0 0 67 /**
 * Reads the matrix from the Datagram using get_stdfloat().
 */ 2 4 this 3 3735  6 source 1 3644  
1305 0 0 7 1236 3647 0 0 0 0 
1306 0 0 7 1147 3738 2970 0 0 1 6 param0 0 3742  
1307 0 0 4 1145 3632 0 0 10 /**
 *
 */ 3 4 this 3 3738  1 i 1 3488  10 assign_val 1 3482  
1308 0 0 6 1145 3482 0 0 0 2 4 this 3 3742  1 i 1 3488  
1309 0 0 6 1146 3488 0 0 58 /**
 * Returns 3: the number of columns of a LMatrix3.
 */ 0 
1310 0 0 7 1152 3739 2974 0 0 1 6 param0 0 3744  
1311 0 0 6 1150 3482 0 0 0 2 4 this 3 3744  1 i 1 3488  
1312 0 0 6 1151 3488 0 0 58 /**
 * Returns 3: the number of columns of a LMatrix3.
 */ 0 
1313 0 0 7 1252 3746 3150 0 10 /**
 *
 */ 0 
1314 0 0 7 1252 3746 3150 0 95 // Construct a 4x4 matrix given a 3x3 rotation matrix and an optional
// translation component. 1 6 upper3 1 3736  
1315 0 0 7 1252 3746 3150 0 10 /**
 *
 */ 2 6 upper3 1 3736  5 trans 1 3673  
1316 0 0 7 1252 3746 3150 0 10 /**
 *
 */ 1 5 other 1 3740  
1317 0 0 7 1252 3746 3150 0 10 /**
 *
 */ 1 5 other 1 3747  
1318 0 0 7 1252 3746 3150 0 10 /**
 *
 */ 16 3 e00 1 3482  3 e01 1 3482  3 e02 1 3482  3 e03 1 3482  3 e10 1 3482  3 e11 1 3482  3 e12 1 3482  3 e13 1 3482  3 e20 1 3482  3 e21 1 3482  3 e22 1 3482  3 e23 1 3482  3 e30 1 3482  3 e31 1 3482  3 e32 1 3482  3 e33 1 3482  
1319 0 0 6 1253 3746 0 0 10 /**
 *
 */ 2 4 this 3 3746  5 other 1 3740  
1320 0 0 6 1253 3746 0 0 10 /**
 *
 */ 2 4 this 3 3746  5 other 1 3747  
1321 0 0 6 1253 3746 0 0 10 /**
 *
 */ 2 4 this 3 3746  10 fill_value 1 3482  
1322 0 0 4 1254 3632 0 0 0 2 4 this 3 3746  4 size 1 3630  
1323 0 0 6 1257 3633 0 0 0 1 4 this 3 3740  
1324 0 0 4 1258 3632 0 0 157 /**
 * Sets each element of the matrix to the indicated fill_value.  This is of
 * questionable value, but is sometimes useful when initializing to zero.
 */ 2 4 this 3 3746  10 fill_value 1 3482  
1325 0 0 4 1259 3632 0 0 10 /**
 *
 */ 17 4 this 3 3746  3 e00 1 3482  3 e01 1 3482  3 e02 1 3482  3 e03 1 3482  3 e10 1 3482  3 e11 1 3482  3 e12 1 3482  3 e13 1 3482  3 e20 1 3482  3 e21 1 3482  3 e22 1 3482  3 e23 1 3482  3 e30 1 3482  3 e31 1 3482  3 e32 1 3482  3 e33 1 3482  
1326 0 0 4 1260 3632 0 0 45 // Get and set the upper 3x3 rotation matrix. 2 4 this 3 3746  6 upper3 1 3736  
1327 0 0 7 1261 3735 3052 0 45 /**
 * Retrieves the upper 3x3 submatrix.
 */ 1 4 this 3 3740  
1328 0 0 7 1262 3749 3058 0 0 2 4 this 3 3746  1 i 1 3488  
1329 0 0 7 1262 3750 3062 0 0 2 4 this 3 3740  1 i 1 3488  
1330 0 0 6 1263 3488 0 0 55 /**
 * Returns 4: the number of rows of a LMatrix4.
 */ 0 
1331 0 0 4 1264 3632 0 0 119 /**
 * Replaces the indicated row of the matrix with the indicated 3-component
 * vector, ignoring the last column.
 */ 3 4 this 3 3746  3 row 1 3488  1 v 1 3673  
1332 0 0 4 1264 3632 0 0 52 /**
 * Replaces the indicated row of the matrix.
 */ 3 4 this 3 3746  3 row 1 3488  1 v 1 3700  
1333 0 0 4 1265 3632 0 0 119 /**
 * Replaces the indicated column of the matrix with the indicated 3-component
 * vector, ignoring the last row.
 */ 3 4 this 3 3746  3 col 1 3488  1 v 1 3673  
1334 0 0 4 1265 3632 0 0 55 /**
 * Replaces the indicated column of the matrix.
 */ 3 4 this 3 3746  3 col 1 3488  1 v 1 3700  
1335 0 0 4 1266 3632 0 0 74 /**
 * Stores the indicated row of the matrix as a 4-component vector.
 */ 3 4 this 3 3740  10 result_vec 1 3699  3 row 1 3488  
1336 0 0 7 1266 3699 2679 0 77 /**
 * Retrieves the indicated row of the matrix as a 4-component vector.
 */ 2 4 this 3 3740  3 row 1 3488  
1337 0 0 7 1267 3699 2679 0 80 /**
 * Retrieves the indicated column of the matrix as a 4-component vector.
 */ 2 4 this 3 3740  3 col 1 3488  
1338 0 0 4 1268 3632 0 0 100 /**
 * Stores the row column of the matrix as a 3-component vector, ignoring the
 * last column.
 */ 3 4 this 3 3740  10 result_vec 1 3672  3 row 1 3488  
1339 0 0 7 1268 3672 2299 0 103 /**
 * Retrieves the row column of the matrix as a 3-component vector, ignoring
 * the last column.
 */ 2 4 this 3 3740  3 row 1 3488  
1340 0 0 7 1276 3672 2299 0 106 /**
 * Retrieves the indicated column of the matrix as a 3-component vector,
 * ignoring the last row.
 */ 2 4 this 3 3740  3 col 1 3488  
1341 0 0 4 1277 3632 0 0 10 /**
 *
 */ 3 4 this 3 3746  3 row 1 3488  3 col 1 3488  
1342 0 0 6 1277 3482 0 0 0 3 4 this 3 3740  3 row 1 3488  3 col 1 3488  
1343 0 0 6 1278 3637 0 0 91 /**
 * Returns true if any component of the matrix is not-a-number, false
 * otherwise.
 */ 1 4 this 3 3740  
1344 0 0 6 1279 3637 0 0 93 /**
 * Returns true if this is (close enough to) the identity matrix, false
 * otherwise.
 */ 1 4 this 3 3740  
1345 0 0 6 1280 3482 0 0 54 /**
 * Returns a particular element of the matrix.
 */ 3 4 this 3 3740  3 row 1 3488  3 col 1 3488  
1346 0 0 4 1281 3632 0 0 54 /**
 * Changes a particular element of the matrix.
 */ 4 4 this 3 3746  3 row 1 3488  3 col 1 3488  5 value 1 3482  
1347 0 0 4 1282 3632 0 0 162 /**
 * Returns the address of the first of the nine data elements in the matrix.
 * The remaining elements occupy the next eight positions in row-major order.
 */ 1 4 this 3 3740  
1348 0 0 6 1283 3488 0 0 60 /**
 * Returns the number of elements in the matrix, 16.
 */ 1 4 this 3 3740  
1349 0 0 4 1284 3632 0 0 101 /**
 * Returns an iterator that may be used to traverse the elements of the
 * matrix, STL-style.
 */ 1 4 this 3 3746  
1350 0 0 4 1284 3632 0 0 101 /**
 * Returns an iterator that may be used to traverse the elements of the
 * matrix, STL-style.
 */ 1 4 this 3 3740  
1351 0 0 4 1285 3632 0 0 101 /**
 * Returns an iterator that may be used to traverse the elements of the
 * matrix, STL-style.
 */ 1 4 this 3 3746  
1352 0 0 4 1285 3632 0 0 101 /**
 * Returns an iterator that may be used to traverse the elements of the
 * matrix, STL-style.
 */ 1 4 this 3 3740  
1353 0 0 6 1286 3637 0 0 0 2 4 this 3 3740  5 other 1 3740  
1354 0 0 6 1287 3637 0 0 0 2 4 this 3 3740  5 other 1 3740  
1355 0 0 6 1288 3637 0 0 0 2 4 this 3 3740  5 other 1 3740  
1356 0 0 6 1289 3488 0 0 97 /**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */ 2 4 this 3 3740  5 other 1 3740  
1357 0 0 6 1289 3488 0 0 234 /**
 * Sorts matrices lexicographically, componentwise.  Returns a number less
 * than 0 if this matrix sorts before the other one, greater than zero if it
 * sorts after, 0 if they are equivalent (within the indicated tolerance).
 */ 3 4 this 3 3740  5 other 1 3740  9 threshold 1 3482  
1358 0 0 6 1290 3630 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 1 4 this 3 3740  
1359 0 0 6 1290 3630 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 2 4 this 3 3740  9 threshold 1 3482  
1360 0 0 6 1291 3630 0 0 49 /**
 * Adds the vector into the running hash.
 */ 2 4 this 3 3740  4 hash 1 3630  
1361 0 0 6 1291 3630 0 0 49 /**
 * Adds the vector into the running hash.
 */ 3 4 this 3 3740  4 hash 1 3630  9 threshold 1 3482  
1362 0 0 7 1292 3699 2679 0 91 /**
 * 4-component vector or point times matrix.  This is a fully general
 * operation.
 */ 2 4 this 3 3740  1 v 1 3700  
1363 0 0 7 1293 3672 2299 0 162 /**
 * The matrix transforms a 3-component point (including translation component)
 * and returns the result.  This assumes the matrix is an affine transform.
 */ 2 4 this 3 3740  1 v 1 3673  
1364 0 0 7 1294 3672 2299 0 143 /**
 * The matrix transforms a 3-component point (including translation component)
 * and returns the result, as a fully general operation.
 */ 2 4 this 3 3740  1 v 1 3673  
1365 0 0 7 1295 3672 2299 0 169 /**
 * The matrix transforms a 3-component vector (without translation component)
 * and returns the result.  This assumes the matrix is an orthonormal
 * transform.
 */ 2 4 this 3 3740  1 v 1 3673  
1366 0 0 7 1296 3672 2299 0 142 /**
 * The matrix transforms a 3-component vector (without translation component)
 * and returns the result, as a fully general operation.
 */ 2 4 this 3 3740  1 v 1 3673  
1367 0 0 4 1297 3632 0 0 91 /**
 * 4-component vector or point times matrix.  This is a fully general
 * operation.
 */ 2 4 this 3 3740  1 v 1 3699  
1368 0 0 4 1298 3632 0 0 139 /**
 * The matrix transforms a 3-component point (including translation
 * component).  This assumes the matrix is an affine transform.
 */ 2 4 this 3 3740  1 v 1 3672  
1369 0 0 4 1299 3632 0 0 120 /**
 * The matrix transforms a 3-component point (including translation
 * component), as a fully general operation.
 */ 2 4 this 3 3740  1 v 1 3672  
1370 0 0 4 1300 3632 0 0 142 /**
 * The matrix transforms a 3-component vector (without translation component).
 * This assumes the matrix is an orthonormal transform.
 */ 2 4 this 3 3740  1 v 1 3672  
1371 0 0 4 1301 3632 0 0 119 /**
 * The matrix transforms a 3-component vector (without translation component),
 * as a fully general operation.
 */ 2 4 this 3 3740  1 v 1 3672  
1372 0 0 4 1302 3632 0 0 25 // this = other1 * other2 3 4 this 3 3746  6 other1 1 3740  6 other2 1 3740  
1373 0 0 7 1303 3746 3150 0 0 2 4 this 3 3740  5 other 1 3740  
1374 0 0 7 1303 3746 3150 0 0 2 4 this 3 3740  6 scalar 1 3482  
1375 0 0 7 1304 3746 3150 0 0 2 4 this 3 3740  6 scalar 1 3482  
1376 0 0 6 1305 3746 0 0 63 /**
 * Performs a memberwise addition between two matrices.
 */ 2 4 this 3 3746  5 other 1 3740  
1377 0 0 6 1306 3746 0 0 63 /**
 * Performs a memberwise addition between two matrices.
 */ 2 4 this 3 3746  5 other 1 3740  
1378 0 0 6 1307 3746 0 0 10 /**
 *
 */ 2 4 this 3 3746  5 other 1 3740  
1379 0 0 6 1307 3746 0 0 10 /**
 *
 */ 2 4 this 3 3746  6 scalar 1 3482  
1380 0 0 6 1308 3746 0 0 10 /**
 *
 */ 2 4 this 3 3746  6 scalar 1 3482  
1381 0 0 4 1309 3632 0 0 10 /**
 *
 */ 2 4 this 3 3746  5 other 1 3740  
1382 0 0 4 1310 3632 0 0 10 /**
 *
 */ 2 4 this 3 3746  5 other 1 3740  
1383 0 0 4 1311 3632 0 0 10 /**
 *
 */ 1 4 this 3 3746  
1384 0 0 6 1312 3637 0 0 461 /**
 * Computes the inverse of the other matrix, and stores the result in this
 * matrix.  This is a fully general operation and makes no assumptions about
 * the type of transform represented by the matrix.
 *
 * The other matrix must be a different object than this matrix.  However, if
 * you need to invert a matrix in place, see invert_in_place.
 *
 * The return value is true if the matrix was successfully inverted, false if
 * the was a singularity.
 */ 2 4 this 3 3746  5 other 1 3740  
1385 0 0 6 1313 3637 0 0 139 // bugbug: we could optimize this for rotationscaletranslation matrices
// (transpose upper 3x3 and take negative of translation component) 2 4 this 3 3746  5 other 1 3740  
1386 0 0 6 1314 3637 0 0 119 /**
 * Inverts the current matrix.  Returns true if the inverse is successful,
 * false if the matrix was singular.
 */ 1 4 this 3 3746  
1387 0 0 4 1315 3632 0 0 46 /**
 * Computes (*this) += other * weight.
 */ 3 4 this 3 3746  5 other 1 3740  6 weight 1 3482  
1388 0 0 6 1316 3740 0 0 147 /**
 * Returns an identity matrix.
 *
 * This function definition must appear first, since some inline functions
 * below take advantage of it.
 */ 0 
1389 0 0 6 1317 3740 0 0 46 /**
 * Returns an matrix filled with ones.
 */ 0 
1390 0 0 6 1318 3740 0 0 47 /**
 * Returns an matrix filled with zeros.
 */ 0 
1391 0 0 4 1319 3632 0 0 74 /**
 * Fills mat with a matrix that applies the indicated translation.
 */ 2 4 this 3 3746  5 trans 1 3673  
1392 0 0 4 1320 3632 0 0 122 /**
 * Sets mat to a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.
 */ 4 4 this 3 3746  5 angle 1 3482  4 axis 1 3673  2 cs 1 3501  
1393 0 0 4 1321 3632 0 0 166 /**
 * Fills mat with a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.  Assumes axis has been
 * prenormalized.
 */ 4 4 this 3 3746  5 angle 1 3482  4 axis 1 3673  2 cs 1 3501  
1394 0 0 4 1322 3632 0 0 97 /**
 * Fills mat with a matrix that applies the indicated scale in each of the
 * three axes.
 */ 2 4 this 3 3746  5 scale 1 3673  
1395 0 0 4 1323 3632 0 0 99 /**
 * Fills mat with a matrix that applies the indicated shear in each of the
 * three planes.
 */ 3 4 this 3 3746  5 shear 1 3673  2 cs 1 3501  
1396 0 0 4 1324 3632 0 0 78 /**
 * Fills mat with a matrix that applies the indicated scale and shear.
 */ 4 4 this 3 3746  5 scale 1 3673  5 shear 1 3673  2 cs 1 3501  
1397 0 0 7 1325 3746 3150 0 67 /**
 * Returns a matrix that applies the indicated translation.
 */ 1 5 trans 1 3673  
1398 0 0 7 1325 3746 3150 0 67 /**
 * Returns a matrix that applies the indicated translation.
 */ 3 2 tx 1 3482  2 ty 1 3482  2 tz 1 3482  
1399 0 0 7 1326 3746 3150 0 118 /**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.
 */ 3 5 angle 1 3482  4 axis 1 3673  2 cs 1 3501  
1400 0 0 7 1327 3746 3150 0 159 /**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.  Assumes axis has been
 * prenormalized.
 */ 3 5 angle 1 3482  4 axis 1 3673  2 cs 1 3501  
1401 0 0 7 1328 3746 3150 0 90 /**
 * Returns a matrix that applies the indicated scale in each of the three
 * axes.
 */ 1 5 scale 1 3673  
1402 0 0 7 1328 3746 3150 0 69 /**
 * Returns a matrix that applies the indicated uniform scale.
 */ 1 5 scale 1 3482  
1403 0 0 7 1328 3746 3150 0 90 /**
 * Returns a matrix that applies the indicated scale in each of the three
 * axes.
 */ 3 2 sx 1 3482  2 sy 1 3482  2 sz 1 3482  
1404 0 0 7 1329 3746 3150 0 92 /**
 * Returns a matrix that applies the indicated shear in each of the three
 * planes.
 */ 2 5 shear 1 3673  2 cs 1 3501  
1405 0 0 7 1329 3746 3150 0 92 /**
 * Returns a matrix that applies the indicated shear in each of the three
 * planes.
 */ 4 4 shxy 1 3482  4 shxz 1 3482  4 shyz 1 3482  2 cs 1 3501  
1406 0 0 7 1330 3746 3150 0 71 /**
 * Returns a matrix that applies the indicated scale and shear.
 */ 3 5 scale 1 3673  5 shear 1 3673  2 cs 1 3501  
1407 0 0 7 1330 3746 3150 0 71 /**
 * Returns a matrix that applies the indicated scale and shear.
 */ 7 2 sx 1 3482  2 sy 1 3482  2 sz 1 3482  4 shxy 1 3482  4 shxz 1 3482  4 shyz 1 3482  2 cs 1 3501  
1408 0 0 6 1331 3740 0 0 109 /**
 * Returns a matrix that transforms from the Y-up coordinate system to the
 * Z-up coordinate system.
 */ 0 
1409 0 0 6 1332 3740 0 0 109 /**
 * Returns a matrix that transforms from the Y-up coordinate system to the
 * Z-up coordinate system.
 */ 0 
1410 0 0 6 1333 3740 0 0 119 /**
 * Returns a matrix that transforms from the indicated coordinate system to
 * the indicated coordinate system.
 */ 2 4 from 1 3501  2 to 1 3501  
1411 0 0 6 1334 3637 0 0 117 /**
 * Returns true if two matrices are memberwise equal within a default
 * tolerance based on the numeric type.
 */ 2 4 this 3 3740  5 other 1 3740  
1412 0 0 6 1334 3637 0 0 199 /**
 * Returns true if two matrices are memberwise equal within a specified
 * tolerance.  This is faster than the equivalence operator as this doesn't
 * have to guarantee that it is transitive.
 */ 3 4 this 3 3740  5 other 1 3740  9 threshold 1 3482  
1413 0 0 4 1335 3632 0 0 10 /**
 *
 */ 2 4 this 3 3740  3 out 1 3640  
1414 0 0 4 1336 3632 0 0 10 /**
 *
 */ 3 4 this 3 3740  3 out 1 3640  12 indent_level 1 3488  
1415 0 0 6 1337 3636 0 0 0 1 4 this 3 3740  
1416 0 0 4 1338 3632 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 2 4 this 3 3740  7 hashgen 1 3638  
1417 0 0 4 1338 3632 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 3 4 this 3 3740  7 hashgen 1 3638  5 scale 1 3482  
1418 0 0 4 1339 3632 0 0 332 /**
 * Writes the matrix to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the matrix, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */ 2 4 this 3 3740  11 destination 1 3642  
1419 0 0 4 1340 3632 0 0 114 /**
 * Reads the matrix from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */ 2 4 this 3 3746  4 scan 1 3644  
1420 0 0 4 1341 3632 0 0 205 /**
 * Writes the matrix to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the matrix using the standard width
 * setting, especially when you are writing a bam file.
 */ 2 4 this 3 3740  11 destination 1 3642  
1421 0 0 4 1342 3632 0 0 67 /**
 * Reads the matrix from the Datagram using get_stdfloat().
 */ 2 4 this 3 3746  6 source 1 3644  
1422 0 0 7 1343 3647 0 0 0 0 
1423 0 0 7 1245 3749 3058 0 0 1 6 param0 0 3751  
1424 0 0 4 1243 3632 0 0 10 /**
 *
 */ 3 4 this 3 3749  1 i 1 3488  10 assign_val 1 3482  
1425 0 0 6 1243 3482 0 0 0 2 4 this 3 3751  1 i 1 3488  
1426 0 0 6 1244 3488 0 0 58 /**
 * Returns 4: the number of columns of a LMatrix4.
 */ 0 
1427 0 0 7 1250 3750 3062 0 0 1 6 param0 0 3753  
1428 0 0 6 1248 3482 0 0 0 2 4 this 3 3753  1 i 1 3488  
1429 0 0 6 1249 3488 0 0 58 /**
 * Returns 4: the number of columns of a LMatrix4.
 */ 0 
1430 0 0 7 1347 3755 3158 0 10 /**
 *
 */ 0 
1431 0 0 7 1347 3755 3158 0 10 /**
 *
 */ 1 4 copy 1 3740  
1432 0 0 7 1347 3755 3158 0 10 /**
 *
 */ 1 4 copy 1 3747  
1433 0 0 7 1347 3755 3158 0 10 /**
 *
 */ 16 3 e00 1 3482  3 e01 1 3482  3 e02 1 3482  3 e03 1 3482  3 e10 1 3482  3 e11 1 3482  3 e12 1 3482  3 e13 1 3482  3 e20 1 3482  3 e21 1 3482  3 e22 1 3482  3 e23 1 3482  3 e30 1 3482  3 e31 1 3482  3 e32 1 3482  3 e33 1 3482  
1434 0 0 6 1348 3755 0 0 10 /**
 *
 */ 2 4 this 3 3755  4 copy 1 3740  
1435 0 0 6 1348 3755 0 0 10 /**
 *
 */ 2 4 this 3 3755  4 copy 1 3747  
1436 0 0 4 1349 3632 0 0 10 /**
 *
 */ 17 4 this 3 3755  3 e00 1 3482  3 e01 1 3482  3 e02 1 3482  3 e03 1 3482  3 e10 1 3482  3 e11 1 3482  3 e12 1 3482  3 e13 1 3482  3 e20 1 3482  3 e21 1 3482  3 e22 1 3482  3 e23 1 3482  3 e30 1 3482  3 e31 1 3482  3 e32 1 3482  3 e33 1 3482  
1437 0 0 4 1350 3632 0 0 10 /**
 *
 */ 3 4 this 3 3755  3 row 1 3488  3 col 1 3488  
1438 0 0 6 1350 3482 0 0 0 3 4 this 3 3747  3 row 1 3488  3 col 1 3488  
1439 0 0 4 1351 3632 0 0 162 /**
 * Returns the address of the first of the nine data elements in the matrix.
 * The remaining elements occupy the next eight positions in row-major order.
 */ 1 4 this 3 3747  
1440 0 0 6 1352 3488 0 0 65 /**
 * Returns the number of elements in the matrix, sixteen.
 */ 1 4 this 3 3747  
1441 0 0 7 1353 3647 0 0 0 0 
1442 0 0 7 1367 3756 3244 0 10 /**
 *
 */ 0 
1443 0 0 7 1367 3756 3244 0 10 /**
 *
 */ 1 5 other 1 3757  
1444 0 0 7 1367 3756 3244 0 10 /**
 *
 */ 9 3 e00 1 3485  3 e01 1 3485  3 e02 1 3485  3 e10 1 3485  3 e11 1 3485  3 e12 1 3485  3 e20 1 3485  3 e21 1 3485  3 e22 1 3485  
1445 0 0 6 1368 3756 0 0 10 /**
 *
 */ 2 4 this 3 3756  5 other 1 3757  
1446 0 0 6 1368 3756 0 0 10 /**
 *
 */ 2 4 this 3 3756  10 fill_value 1 3485  
1447 0 0 4 1369 3632 0 0 0 2 4 this 3 3756  4 size 1 3630  
1448 0 0 6 1372 3633 0 0 0 1 4 this 3 3757  
1449 0 0 4 1373 3632 0 0 157 /**
 * Sets each element of the matrix to the indicated fill_value.  This is of
 * questionable value, but is sometimes useful when initializing to zero.
 */ 2 4 this 3 3756  10 fill_value 1 3485  
1450 0 0 4 1374 3632 0 0 10 /**
 *
 */ 10 4 this 3 3756  3 e00 1 3485  3 e01 1 3485  3 e02 1 3485  3 e10 1 3485  3 e11 1 3485  3 e12 1 3485  3 e20 1 3485  3 e21 1 3485  3 e22 1 3485  
1451 0 0 7 1375 3759 3162 0 0 2 4 this 3 3756  1 i 1 3488  
1452 0 0 7 1375 3760 3166 0 0 2 4 this 3 3757  1 i 1 3488  
1453 0 0 6 1376 3488 0 0 55 /**
 * Returns 3: the number of rows of a LMatrix3.
 */ 0 
1454 0 0 4 1377 3632 0 0 109 /**
 * Replaces the indicated row of the matrix from a two-component vector,
 * ignoring the last column.
 */ 3 4 this 3 3756  3 row 1 3488  1 v 1 3649  
1455 0 0 4 1377 3632 0 0 82 /**
 * Replaces the indicated row of the matrix from a three-component vector.
 */ 3 4 this 3 3756  3 row 1 3488  1 v 1 3676  
1456 0 0 4 1378 3632 0 0 109 /**
 * Replaces the indicated column of the matrix from a two-component vector,
 * ignoring the last row.
 */ 3 4 this 3 3756  3 col 1 3488  1 v 1 3649  
1457 0 0 4 1378 3632 0 0 85 /**
 * Replaces the indicated column of the matrix from a three-component vector.
 */ 3 4 this 3 3756  3 col 1 3488  1 v 1 3676  
1458 0 0 4 1379 3632 0 0 78 /**
 * Stores the indicated row of the matrix as a three-component vector.
 */ 3 4 this 3 3757  10 result_vec 1 3675  3 row 1 3488  
1459 0 0 7 1379 3675 2372 0 79 /**
 * Returns the indicated row of the matrix as a three-component vector.
 */ 2 4 this 3 3757  3 row 1 3488  
1460 0 0 7 1380 3675 2372 0 82 /**
 * Returns the indicated column of the matrix as a three-component vector.
 */ 2 4 this 3 3757  3 col 1 3488  
1461 0 0 7 1387 3648 2071 0 106 /**
 * Returns the indicated row of the matrix as a two-component vector, ignoring
 * the last column.
 */ 2 4 this 3 3757  3 row 1 3488  
1462 0 0 7 1388 3648 2071 0 106 /**
 * Returns the indicated column of the matrix as a two-component vector,
 * ignoring the last row.
 */ 2 4 this 3 3757  3 col 1 3488  
1463 0 0 4 1391 3632 0 0 10 /**
 *
 */ 3 4 this 3 3756  3 row 1 3488  3 col 1 3488  
1464 0 0 6 1391 3485 0 0 0 3 4 this 3 3757  3 row 1 3488  3 col 1 3488  
1465 0 0 6 1392 3637 0 0 91 /**
 * Returns true if any component of the matrix is not-a-number, false
 * otherwise.
 */ 1 4 this 3 3757  
1466 0 0 6 1393 3637 0 0 93 /**
 * Returns true if this is (close enough to) the identity matrix, false
 * otherwise.
 */ 1 4 this 3 3757  
1467 0 0 6 1394 3485 0 0 54 /**
 * Returns a particular element of the matrix.
 */ 3 4 this 3 3757  3 row 1 3488  3 col 1 3488  
1468 0 0 4 1395 3632 0 0 54 /**
 * Changes a particular element of the matrix.
 */ 4 4 this 3 3756  3 row 1 3488  3 col 1 3488  5 value 1 3485  
1469 0 0 4 1396 3632 0 0 162 /**
 * Returns the address of the first of the nine data elements in the matrix.
 * The remaining elements occupy the next eight positions in row-major order.
 */ 1 4 this 3 3757  
1470 0 0 6 1397 3488 0 0 62 /**
 * Returns the number of elements in the matrix, nine.
 */ 1 4 this 3 3757  
1471 0 0 6 1398 3637 0 0 0 2 4 this 3 3757  5 other 1 3757  
1472 0 0 6 1399 3637 0 0 0 2 4 this 3 3757  5 other 1 3757  
1473 0 0 6 1400 3637 0 0 0 2 4 this 3 3757  5 other 1 3757  
1474 0 0 6 1401 3488 0 0 97 /**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */ 2 4 this 3 3757  5 other 1 3757  
1475 0 0 6 1401 3488 0 0 234 /**
 * Sorts matrices lexicographically, componentwise.  Returns a number less
 * than 0 if this matrix sorts before the other one, greater than zero if it
 * sorts after, 0 if they are equivalent (within the indicated tolerance).
 */ 3 4 this 3 3757  5 other 1 3757  9 threshold 1 3485  
1476 0 0 6 1402 3630 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 1 4 this 3 3757  
1477 0 0 6 1402 3630 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 2 4 this 3 3757  9 threshold 1 3485  
1478 0 0 6 1403 3630 0 0 49 /**
 * Adds the vector into the running hash.
 */ 2 4 this 3 3757  4 hash 1 3630  
1479 0 0 6 1403 3630 0 0 49 /**
 * Adds the vector into the running hash.
 */ 3 4 this 3 3757  4 hash 1 3630  9 threshold 1 3485  
1480 0 0 7 1404 3675 2372 0 52 /**
 * 3-component vector or point times matrix.
 */ 2 4 this 3 3757  1 v 1 3676  
1481 0 0 7 1405 3648 2071 0 162 /**
 * The matrix transforms a 2-component point (including translation component)
 * and returns the result.  This assumes the matrix is an affine transform.
 */ 2 4 this 3 3757  1 v 1 3649  
1482 0 0 7 1406 3648 2071 0 161 /**
 * The matrix transforms a 2-component vector (without translation component)
 * and returns the result.  This assumes the matrix is an affine transform.
 */ 2 4 this 3 3757  1 v 1 3649  
1483 0 0 7 1406 3675 2372 0 194 /**
 * The matrix transforms a 3-component vector and returns the result.  This
 * assumes the matrix is an orthonormal transform.
 *
 * In practice, this is the same computation as xform().
 */ 2 4 this 3 3757  1 v 1 3676  
1484 0 0 7 1407 3675 2372 0 142 /**
 * The matrix transforms a 3-component vector (without translation component)
 * and returns the result, as a fully general operation.
 */ 2 4 this 3 3757  1 v 1 3676  
1485 0 0 4 1408 3632 0 0 52 /**
 * 3-component vector or point times matrix.
 */ 2 4 this 3 3757  1 v 1 3675  
1486 0 0 4 1409 3632 0 0 139 /**
 * The matrix transforms a 2-component point (including translation
 * component).  This assumes the matrix is an affine transform.
 */ 2 4 this 3 3757  1 v 1 3648  
1487 0 0 4 1410 3632 0 0 137 /**
 * The matrix transforms a 2-component vector (without translation component).
 * This assumes the matrix is an affine transform.
 */ 2 4 this 3 3757  1 v 1 3648  
1488 0 0 4 1410 3632 0 0 171 /**
 * The matrix transforms a 3-component vector.  This assumes the matrix is an
 * orthonormal transform.
 *
 * In practice, this is the same computation as xform().
 */ 2 4 this 3 3757  1 v 1 3675  
1489 0 0 4 1411 3632 0 0 119 /**
 * The matrix transforms a 3-component vector (without translation component),
 * as a fully general operation.
 */ 2 4 this 3 3757  1 v 1 3675  
1490 0 0 4 1412 3632 0 0 25 // this = other1 * other2 3 4 this 3 3756  6 other1 1 3757  6 other2 1 3757  
1491 0 0 7 1413 3756 3244 0 0 2 4 this 3 3757  5 other 1 3757  
1492 0 0 7 1413 3756 3244 0 0 2 4 this 3 3757  6 scalar 1 3485  
1493 0 0 7 1414 3756 3244 0 0 2 4 this 3 3757  6 scalar 1 3485  
1494 0 0 6 1415 3756 0 0 63 /**
 * Performs a memberwise addition between two matrices.
 */ 2 4 this 3 3756  5 other 1 3757  
1495 0 0 6 1416 3756 0 0 66 /**
 * Performs a memberwise subtraction between two matrices.
 */ 2 4 this 3 3756  5 other 1 3757  
1496 0 0 6 1417 3756 0 0 10 /**
 *
 */ 2 4 this 3 3756  5 other 1 3757  
1497 0 0 6 1417 3756 0 0 39 /**
 * Performs a memberwise scale.
 */ 2 4 this 3 3756  6 scalar 1 3485  
1498 0 0 6 1418 3756 0 0 39 /**
 * Performs a memberwise scale.
 */ 2 4 this 3 3756  6 scalar 1 3485  
1499 0 0 4 1419 3632 0 0 10 /**
 *
 */ 2 4 this 3 3756  5 other 1 3757  
1500 0 0 6 1420 3485 0 0 49 /**
 * Returns the determinant of the matrix.
 */ 1 4 this 3 3757  
1501 0 0 4 1421 3632 0 0 10 /**
 *
 */ 2 4 this 3 3756  5 other 1 3757  
1502 0 0 4 1422 3632 0 0 10 /**
 *
 */ 1 4 this 3 3756  
1503 0 0 6 1423 3637 0 0 463 /**
 * Computes the inverse of the other matrix, and stores the result in this
 * matrix.  This is a fully general operation and makes no assumptions about
 * the type of transform represented by the matrix.
 *
 * The other matrix must be a different object than this matrix.  However, if
 * you need to invert a matrix in place, see invert_in_place.
 *
 * The return value is true if the matrix was successfully inverted, false if
 * there was a singularity.
 */ 2 4 this 3 3756  5 other 1 3757  
1504 0 0 6 1424 3637 0 0 119 /**
 * Inverts the current matrix.  Returns true if the inverse is successful,
 * false if the matrix was singular.
 */ 1 4 this 3 3756  
1505 0 0 6 1425 3637 0 0 114 /**
 * Simultaneously computes the inverse of the indicated matrix, and then the
 * transpose of that inverse.
 */ 2 4 this 3 3756  5 other 1 3757  
1506 0 0 6 1425 3637 0 0 114 /**
 * Simultaneously computes the inverse of the indicated matrix, and then the
 * transpose of that inverse.
 */ 2 4 this 3 3756  5 other 1 3761  
1507 0 0 6 1426 3757 0 0 147 /**
 * Returns an identity matrix.
 *
 * This function definition must appear first, since some inline functions
 * below take advantage of it.
 */ 0 
1508 0 0 4 1427 3632 0 0 74 /**
 * Fills mat with a matrix that applies the indicated translation.
 */ 2 4 this 3 3756  5 trans 1 3649  
1509 0 0 4 1428 3632 0 0 98 /**
 * Fills mat with a matrix that rotates by the given angle in degrees
 * counterclockwise.
 */ 2 4 this 3 3756  5 angle 1 3485  
1510 0 0 4 1428 3632 0 0 125 /**
 * Fills mat with a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.
 */ 4 4 this 3 3756  5 angle 1 3485  4 axis 1 3676  2 cs 1 3501  
1511 0 0 4 1429 3632 0 0 95 /**
 * Fills mat with a matrix that applies the indicated scale in each of the two
 * axes.
 */ 2 4 this 3 3756  5 scale 1 3649  
1512 0 0 4 1429 3632 0 0 97 /**
 * Fills mat with a matrix that applies the indicated scale in each of the
 * three axes.
 */ 2 4 this 3 3756  5 scale 1 3676  
1513 0 0 7 1430 3756 3244 0 67 /**
 * Returns a matrix that applies the indicated translation.
 */ 1 5 trans 1 3649  
1514 0 0 7 1430 3756 3244 0 67 /**
 * Returns a matrix that applies the indicated translation.
 */ 2 2 tx 1 3485  2 ty 1 3485  
1515 0 0 7 1431 3756 3244 0 91 /**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise.
 */ 1 5 angle 1 3485  
1516 0 0 7 1431 3756 3244 0 118 /**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.
 */ 3 5 angle 1 3485  4 axis 1 3676  2 cs 1 3501  
1517 0 0 7 1432 3756 3244 0 85 /**
 * Returns a matrix that applies the indicated scale in each of the two axes.
 */ 1 5 scale 1 3649  
1518 0 0 7 1432 3756 3244 0 90 /**
 * Returns a matrix that applies the indicated scale in each of the three
 * axes.
 */ 1 5 scale 1 3676  
1519 0 0 7 1432 3756 3244 0 85 /**
 * Returns a matrix that applies the indicated scale in each of the two axes.
 */ 2 2 sx 1 3485  2 sy 1 3485  
1520 0 0 7 1432 3756 3244 0 90 /**
 * Returns a matrix that applies the indicated scale in each of the three
 * axes.
 */ 3 2 sx 1 3485  2 sy 1 3485  2 sz 1 3485  
1521 0 0 4 1433 3632 0 0 163 /**
 * Fills mat with a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.  Assumes axis has been
 * normalized.
 */ 4 4 this 3 3756  5 angle 1 3485  4 axis 1 3676  2 cs 1 3501  
1522 0 0 7 1434 3756 3244 0 156 /**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.  Assumes axis has been
 * normalized.
 */ 3 5 angle 1 3485  4 axis 1 3676  2 cs 1 3501  
1523 0 0 4 1435 3632 0 0 99 /**
 * Fills mat with a matrix that applies the indicated shear in each of the
 * three planes.
 */ 3 4 this 3 3756  5 shear 1 3676  2 cs 1 3501  
1524 0 0 7 1436 3756 3244 0 92 /**
 * Returns a matrix that applies the indicated shear in each of the three
 * planes.
 */ 2 5 shear 1 3676  2 cs 1 3501  
1525 0 0 7 1436 3756 3244 0 92 /**
 * Returns a matrix that applies the indicated shear in each of the three
 * planes.
 */ 4 4 shxy 1 3485  4 shxz 1 3485  4 shyz 1 3485  2 cs 1 3501  
1526 0 0 4 1437 3632 0 0 78 /**
 * Fills mat with a matrix that applies the indicated scale and shear.
 */ 4 4 this 3 3756  5 scale 1 3676  5 shear 1 3676  2 cs 1 3501  
1527 0 0 7 1438 3756 3244 0 71 /**
 * Returns a matrix that applies the indicated scale and shear.
 */ 3 5 scale 1 3676  5 shear 1 3676  2 cs 1 3501  
1528 0 0 7 1438 3756 3244 0 71 /**
 * Returns a matrix that applies the indicated scale and shear.
 */ 7 2 sx 1 3485  2 sy 1 3485  2 sz 1 3485  4 shxy 1 3485  4 shxz 1 3485  4 shyz 1 3485  2 cs 1 3501  
1529 0 0 6 1439 3757 0 0 119 /**
 * Returns a matrix that transforms from the indicated coordinate system to
 * the indicated coordinate system.
 */ 2 4 from 1 3501  2 to 1 3501  
1530 0 0 6 1440 3637 0 0 117 /**
 * Returns true if two matrices are memberwise equal within a default
 * tolerance based on the numeric type.
 */ 2 4 this 3 3757  5 other 1 3757  
1531 0 0 6 1440 3637 0 0 93 /**
 * Returns true if two matrices are memberwise equal within a specified
 * tolerance.
 */ 3 4 this 3 3757  5 other 1 3757  9 threshold 1 3485  
1532 0 0 4 1441 3632 0 0 10 /**
 *
 */ 2 4 this 3 3757  3 out 1 3640  
1533 0 0 4 1442 3632 0 0 10 /**
 *
 */ 3 4 this 3 3757  3 out 1 3640  12 indent_level 1 3488  
1534 0 0 6 1443 3636 0 0 0 1 4 this 3 3757  
1535 0 0 4 1444 3632 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 2 4 this 3 3757  7 hashgen 1 3638  
1536 0 0 4 1444 3632 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 3 4 this 3 3757  7 hashgen 1 3638  9 threshold 1 3485  
1537 0 0 4 1445 3632 0 0 332 /**
 * Writes the matrix to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the matrix, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */ 2 4 this 3 3757  11 destination 1 3642  
1538 0 0 4 1446 3632 0 0 114 /**
 * Reads the matrix from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */ 2 4 this 3 3756  4 scan 1 3644  
1539 0 0 4 1447 3632 0 0 205 /**
 * Writes the matrix to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the matrix using the standard width
 * setting, especially when you are writing a bam file.
 */ 2 4 this 3 3757  11 destination 1 3642  
1540 0 0 4 1448 3632 0 0 67 /**
 * Reads the matrix from the Datagram using get_stdfloat().
 */ 2 4 this 3 3756  6 source 1 3644  
1541 0 0 7 1449 3647 0 0 0 0 
1542 0 0 7 1360 3759 3162 0 0 1 6 param0 0 3763  
1543 0 0 4 1358 3632 0 0 10 /**
 *
 */ 3 4 this 3 3759  1 i 1 3488  10 assign_val 1 3485  
1544 0 0 6 1358 3485 0 0 0 2 4 this 3 3763  1 i 1 3488  
1545 0 0 6 1359 3488 0 0 58 /**
 * Returns 3: the number of columns of a LMatrix3.
 */ 0 
1546 0 0 7 1365 3760 3166 0 0 1 6 param0 0 3765  
1547 0 0 6 1363 3485 0 0 0 2 4 this 3 3765  1 i 1 3488  
1548 0 0 6 1364 3488 0 0 58 /**
 * Returns 3: the number of columns of a LMatrix3.
 */ 0 
1549 0 0 7 1463 3767 3340 0 10 /**
 *
 */ 0 
1550 0 0 7 1463 3767 3340 0 95 // Construct a 4x4 matrix given a 3x3 rotation matrix and an optional
// translation component. 1 6 upper3 1 3757  
1551 0 0 7 1463 3767 3340 0 10 /**
 *
 */ 2 6 upper3 1 3757  5 trans 1 3676  
1552 0 0 7 1463 3767 3340 0 10 /**
 *
 */ 1 5 other 1 3761  
1553 0 0 7 1463 3767 3340 0 10 /**
 *
 */ 1 5 other 1 3768  
1554 0 0 7 1463 3767 3340 0 10 /**
 *
 */ 16 3 e00 1 3485  3 e01 1 3485  3 e02 1 3485  3 e03 1 3485  3 e10 1 3485  3 e11 1 3485  3 e12 1 3485  3 e13 1 3485  3 e20 1 3485  3 e21 1 3485  3 e22 1 3485  3 e23 1 3485  3 e30 1 3485  3 e31 1 3485  3 e32 1 3485  3 e33 1 3485  
1555 0 0 6 1464 3767 0 0 10 /**
 *
 */ 2 4 this 3 3767  5 other 1 3761  
1556 0 0 6 1464 3767 0 0 10 /**
 *
 */ 2 4 this 3 3767  5 other 1 3768  
1557 0 0 6 1464 3767 0 0 10 /**
 *
 */ 2 4 this 3 3767  10 fill_value 1 3485  
1558 0 0 4 1465 3632 0 0 0 2 4 this 3 3767  4 size 1 3630  
1559 0 0 6 1468 3633 0 0 0 1 4 this 3 3761  
1560 0 0 4 1469 3632 0 0 157 /**
 * Sets each element of the matrix to the indicated fill_value.  This is of
 * questionable value, but is sometimes useful when initializing to zero.
 */ 2 4 this 3 3767  10 fill_value 1 3485  
1561 0 0 4 1470 3632 0 0 10 /**
 *
 */ 17 4 this 3 3767  3 e00 1 3485  3 e01 1 3485  3 e02 1 3485  3 e03 1 3485  3 e10 1 3485  3 e11 1 3485  3 e12 1 3485  3 e13 1 3485  3 e20 1 3485  3 e21 1 3485  3 e22 1 3485  3 e23 1 3485  3 e30 1 3485  3 e31 1 3485  3 e32 1 3485  3 e33 1 3485  
1562 0 0 4 1471 3632 0 0 45 // Get and set the upper 3x3 rotation matrix. 2 4 this 3 3767  6 upper3 1 3757  
1563 0 0 7 1472 3756 3244 0 45 /**
 * Retrieves the upper 3x3 submatrix.
 */ 1 4 this 3 3761  
1564 0 0 7 1473 3770 3248 0 0 2 4 this 3 3767  1 i 1 3488  
1565 0 0 7 1473 3771 3252 0 0 2 4 this 3 3761  1 i 1 3488  
1566 0 0 6 1474 3488 0 0 55 /**
 * Returns 4: the number of rows of a LMatrix4.
 */ 0 
1567 0 0 4 1475 3632 0 0 119 /**
 * Replaces the indicated row of the matrix with the indicated 3-component
 * vector, ignoring the last column.
 */ 3 4 this 3 3767  3 row 1 3488  1 v 1 3676  
1568 0 0 4 1475 3632 0 0 52 /**
 * Replaces the indicated row of the matrix.
 */ 3 4 this 3 3767  3 row 1 3488  1 v 1 3706  
1569 0 0 4 1476 3632 0 0 119 /**
 * Replaces the indicated column of the matrix with the indicated 3-component
 * vector, ignoring the last row.
 */ 3 4 this 3 3767  3 col 1 3488  1 v 1 3676  
1570 0 0 4 1476 3632 0 0 55 /**
 * Replaces the indicated column of the matrix.
 */ 3 4 this 3 3767  3 col 1 3488  1 v 1 3706  
1571 0 0 4 1477 3632 0 0 74 /**
 * Stores the indicated row of the matrix as a 4-component vector.
 */ 3 4 this 3 3761  10 result_vec 1 3705  3 row 1 3488  
1572 0 0 7 1477 3705 2762 0 77 /**
 * Retrieves the indicated row of the matrix as a 4-component vector.
 */ 2 4 this 3 3761  3 row 1 3488  
1573 0 0 7 1478 3705 2762 0 80 /**
 * Retrieves the indicated column of the matrix as a 4-component vector.
 */ 2 4 this 3 3761  3 col 1 3488  
1574 0 0 4 1479 3632 0 0 100 /**
 * Stores the row column of the matrix as a 3-component vector, ignoring the
 * last column.
 */ 3 4 this 3 3761  10 result_vec 1 3675  3 row 1 3488  
1575 0 0 7 1479 3675 2372 0 103 /**
 * Retrieves the row column of the matrix as a 3-component vector, ignoring
 * the last column.
 */ 2 4 this 3 3761  3 row 1 3488  
1576 0 0 7 1487 3675 2372 0 106 /**
 * Retrieves the indicated column of the matrix as a 3-component vector,
 * ignoring the last row.
 */ 2 4 this 3 3761  3 col 1 3488  
1577 0 0 4 1488 3632 0 0 10 /**
 *
 */ 3 4 this 3 3767  3 row 1 3488  3 col 1 3488  
1578 0 0 6 1488 3485 0 0 0 3 4 this 3 3761  3 row 1 3488  3 col 1 3488  
1579 0 0 6 1489 3637 0 0 91 /**
 * Returns true if any component of the matrix is not-a-number, false
 * otherwise.
 */ 1 4 this 3 3761  
1580 0 0 6 1490 3637 0 0 93 /**
 * Returns true if this is (close enough to) the identity matrix, false
 * otherwise.
 */ 1 4 this 3 3761  
1581 0 0 6 1491 3485 0 0 54 /**
 * Returns a particular element of the matrix.
 */ 3 4 this 3 3761  3 row 1 3488  3 col 1 3488  
1582 0 0 4 1492 3632 0 0 54 /**
 * Changes a particular element of the matrix.
 */ 4 4 this 3 3767  3 row 1 3488  3 col 1 3488  5 value 1 3485  
1583 0 0 4 1493 3632 0 0 162 /**
 * Returns the address of the first of the nine data elements in the matrix.
 * The remaining elements occupy the next eight positions in row-major order.
 */ 1 4 this 3 3761  
1584 0 0 6 1494 3488 0 0 60 /**
 * Returns the number of elements in the matrix, 16.
 */ 1 4 this 3 3761  
1585 0 0 4 1495 3632 0 0 101 /**
 * Returns an iterator that may be used to traverse the elements of the
 * matrix, STL-style.
 */ 1 4 this 3 3767  
1586 0 0 4 1495 3632 0 0 101 /**
 * Returns an iterator that may be used to traverse the elements of the
 * matrix, STL-style.
 */ 1 4 this 3 3761  
1587 0 0 4 1496 3632 0 0 101 /**
 * Returns an iterator that may be used to traverse the elements of the
 * matrix, STL-style.
 */ 1 4 this 3 3767  
1588 0 0 4 1496 3632 0 0 101 /**
 * Returns an iterator that may be used to traverse the elements of the
 * matrix, STL-style.
 */ 1 4 this 3 3761  
1589 0 0 6 1497 3637 0 0 0 2 4 this 3 3761  5 other 1 3761  
1590 0 0 6 1498 3637 0 0 0 2 4 this 3 3761  5 other 1 3761  
1591 0 0 6 1499 3637 0 0 0 2 4 this 3 3761  5 other 1 3761  
1592 0 0 6 1500 3488 0 0 97 /**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */ 2 4 this 3 3761  5 other 1 3761  
1593 0 0 6 1500 3488 0 0 234 /**
 * Sorts matrices lexicographically, componentwise.  Returns a number less
 * than 0 if this matrix sorts before the other one, greater than zero if it
 * sorts after, 0 if they are equivalent (within the indicated tolerance).
 */ 3 4 this 3 3761  5 other 1 3761  9 threshold 1 3485  
1594 0 0 6 1501 3630 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 1 4 this 3 3761  
1595 0 0 6 1501 3630 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 2 4 this 3 3761  9 threshold 1 3485  
1596 0 0 6 1502 3630 0 0 49 /**
 * Adds the vector into the running hash.
 */ 2 4 this 3 3761  4 hash 1 3630  
1597 0 0 6 1502 3630 0 0 49 /**
 * Adds the vector into the running hash.
 */ 3 4 this 3 3761  4 hash 1 3630  9 threshold 1 3485  
1598 0 0 7 1503 3705 2762 0 91 /**
 * 4-component vector or point times matrix.  This is a fully general
 * operation.
 */ 2 4 this 3 3761  1 v 1 3706  
1599 0 0 7 1504 3675 2372 0 162 /**
 * The matrix transforms a 3-component point (including translation component)
 * and returns the result.  This assumes the matrix is an affine transform.
 */ 2 4 this 3 3761  1 v 1 3676  
1600 0 0 7 1505 3675 2372 0 143 /**
 * The matrix transforms a 3-component point (including translation component)
 * and returns the result, as a fully general operation.
 */ 2 4 this 3 3761  1 v 1 3676  
1601 0 0 7 1506 3675 2372 0 169 /**
 * The matrix transforms a 3-component vector (without translation component)
 * and returns the result.  This assumes the matrix is an orthonormal
 * transform.
 */ 2 4 this 3 3761  1 v 1 3676  
1602 0 0 7 1507 3675 2372 0 142 /**
 * The matrix transforms a 3-component vector (without translation component)
 * and returns the result, as a fully general operation.
 */ 2 4 this 3 3761  1 v 1 3676  
1603 0 0 4 1508 3632 0 0 91 /**
 * 4-component vector or point times matrix.  This is a fully general
 * operation.
 */ 2 4 this 3 3761  1 v 1 3705  
1604 0 0 4 1509 3632 0 0 139 /**
 * The matrix transforms a 3-component point (including translation
 * component).  This assumes the matrix is an affine transform.
 */ 2 4 this 3 3761  1 v 1 3675  
1605 0 0 4 1510 3632 0 0 120 /**
 * The matrix transforms a 3-component point (including translation
 * component), as a fully general operation.
 */ 2 4 this 3 3761  1 v 1 3675  
1606 0 0 4 1511 3632 0 0 142 /**
 * The matrix transforms a 3-component vector (without translation component).
 * This assumes the matrix is an orthonormal transform.
 */ 2 4 this 3 3761  1 v 1 3675  
1607 0 0 4 1512 3632 0 0 119 /**
 * The matrix transforms a 3-component vector (without translation component),
 * as a fully general operation.
 */ 2 4 this 3 3761  1 v 1 3675  
1608 0 0 4 1513 3632 0 0 25 // this = other1 * other2 3 4 this 3 3767  6 other1 1 3761  6 other2 1 3761  
1609 0 0 7 1514 3767 3340 0 0 2 4 this 3 3761  5 other 1 3761  
1610 0 0 7 1514 3767 3340 0 0 2 4 this 3 3761  6 scalar 1 3485  
1611 0 0 7 1515 3767 3340 0 0 2 4 this 3 3761  6 scalar 1 3485  
1612 0 0 6 1516 3767 0 0 63 /**
 * Performs a memberwise addition between two matrices.
 */ 2 4 this 3 3767  5 other 1 3761  
1613 0 0 6 1517 3767 0 0 63 /**
 * Performs a memberwise addition between two matrices.
 */ 2 4 this 3 3767  5 other 1 3761  
1614 0 0 6 1518 3767 0 0 10 /**
 *
 */ 2 4 this 3 3767  5 other 1 3761  
1615 0 0 6 1518 3767 0 0 10 /**
 *
 */ 2 4 this 3 3767  6 scalar 1 3485  
1616 0 0 6 1519 3767 0 0 10 /**
 *
 */ 2 4 this 3 3767  6 scalar 1 3485  
1617 0 0 4 1520 3632 0 0 10 /**
 *
 */ 2 4 this 3 3767  5 other 1 3761  
1618 0 0 4 1521 3632 0 0 10 /**
 *
 */ 2 4 this 3 3767  5 other 1 3761  
1619 0 0 4 1522 3632 0 0 10 /**
 *
 */ 1 4 this 3 3767  
1620 0 0 6 1523 3637 0 0 461 /**
 * Computes the inverse of the other matrix, and stores the result in this
 * matrix.  This is a fully general operation and makes no assumptions about
 * the type of transform represented by the matrix.
 *
 * The other matrix must be a different object than this matrix.  However, if
 * you need to invert a matrix in place, see invert_in_place.
 *
 * The return value is true if the matrix was successfully inverted, false if
 * the was a singularity.
 */ 2 4 this 3 3767  5 other 1 3761  
1621 0 0 6 1524 3637 0 0 139 // bugbug: we could optimize this for rotationscaletranslation matrices
// (transpose upper 3x3 and take negative of translation component) 2 4 this 3 3767  5 other 1 3761  
1622 0 0 6 1525 3637 0 0 119 /**
 * Inverts the current matrix.  Returns true if the inverse is successful,
 * false if the matrix was singular.
 */ 1 4 this 3 3767  
1623 0 0 4 1526 3632 0 0 46 /**
 * Computes (*this) += other * weight.
 */ 3 4 this 3 3767  5 other 1 3761  6 weight 1 3485  
1624 0 0 6 1527 3761 0 0 147 /**
 * Returns an identity matrix.
 *
 * This function definition must appear first, since some inline functions
 * below take advantage of it.
 */ 0 
1625 0 0 6 1528 3761 0 0 46 /**
 * Returns an matrix filled with ones.
 */ 0 
1626 0 0 6 1529 3761 0 0 47 /**
 * Returns an matrix filled with zeros.
 */ 0 
1627 0 0 4 1530 3632 0 0 74 /**
 * Fills mat with a matrix that applies the indicated translation.
 */ 2 4 this 3 3767  5 trans 1 3676  
1628 0 0 4 1531 3632 0 0 122 /**
 * Sets mat to a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.
 */ 4 4 this 3 3767  5 angle 1 3485  4 axis 1 3676  2 cs 1 3501  
1629 0 0 4 1532 3632 0 0 166 /**
 * Fills mat with a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.  Assumes axis has been
 * prenormalized.
 */ 4 4 this 3 3767  5 angle 1 3485  4 axis 1 3676  2 cs 1 3501  
1630 0 0 4 1533 3632 0 0 97 /**
 * Fills mat with a matrix that applies the indicated scale in each of the
 * three axes.
 */ 2 4 this 3 3767  5 scale 1 3676  
1631 0 0 4 1534 3632 0 0 99 /**
 * Fills mat with a matrix that applies the indicated shear in each of the
 * three planes.
 */ 3 4 this 3 3767  5 shear 1 3676  2 cs 1 3501  
1632 0 0 4 1535 3632 0 0 78 /**
 * Fills mat with a matrix that applies the indicated scale and shear.
 */ 4 4 this 3 3767  5 scale 1 3676  5 shear 1 3676  2 cs 1 3501  
1633 0 0 7 1536 3767 3340 0 67 /**
 * Returns a matrix that applies the indicated translation.
 */ 1 5 trans 1 3676  
1634 0 0 7 1536 3767 3340 0 67 /**
 * Returns a matrix that applies the indicated translation.
 */ 3 2 tx 1 3485  2 ty 1 3485  2 tz 1 3485  
1635 0 0 7 1537 3767 3340 0 118 /**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.
 */ 3 5 angle 1 3485  4 axis 1 3676  2 cs 1 3501  
1636 0 0 7 1538 3767 3340 0 159 /**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.  Assumes axis has been
 * prenormalized.
 */ 3 5 angle 1 3485  4 axis 1 3676  2 cs 1 3501  
1637 0 0 7 1539 3767 3340 0 90 /**
 * Returns a matrix that applies the indicated scale in each of the three
 * axes.
 */ 1 5 scale 1 3676  
1638 0 0 7 1539 3767 3340 0 69 /**
 * Returns a matrix that applies the indicated uniform scale.
 */ 1 5 scale 1 3485  
1639 0 0 7 1539 3767 3340 0 90 /**
 * Returns a matrix that applies the indicated scale in each of the three
 * axes.
 */ 3 2 sx 1 3485  2 sy 1 3485  2 sz 1 3485  
1640 0 0 7 1540 3767 3340 0 92 /**
 * Returns a matrix that applies the indicated shear in each of the three
 * planes.
 */ 2 5 shear 1 3676  2 cs 1 3501  
1641 0 0 7 1540 3767 3340 0 92 /**
 * Returns a matrix that applies the indicated shear in each of the three
 * planes.
 */ 4 4 shxy 1 3485  4 shxz 1 3485  4 shyz 1 3485  2 cs 1 3501  
1642 0 0 7 1541 3767 3340 0 71 /**
 * Returns a matrix that applies the indicated scale and shear.
 */ 3 5 scale 1 3676  5 shear 1 3676  2 cs 1 3501  
1643 0 0 7 1541 3767 3340 0 71 /**
 * Returns a matrix that applies the indicated scale and shear.
 */ 7 2 sx 1 3485  2 sy 1 3485  2 sz 1 3485  4 shxy 1 3485  4 shxz 1 3485  4 shyz 1 3485  2 cs 1 3501  
1644 0 0 6 1542 3761 0 0 109 /**
 * Returns a matrix that transforms from the Y-up coordinate system to the
 * Z-up coordinate system.
 */ 0 
1645 0 0 6 1543 3761 0 0 109 /**
 * Returns a matrix that transforms from the Y-up coordinate system to the
 * Z-up coordinate system.
 */ 0 
1646 0 0 6 1544 3761 0 0 119 /**
 * Returns a matrix that transforms from the indicated coordinate system to
 * the indicated coordinate system.
 */ 2 4 from 1 3501  2 to 1 3501  
1647 0 0 6 1545 3637 0 0 117 /**
 * Returns true if two matrices are memberwise equal within a default
 * tolerance based on the numeric type.
 */ 2 4 this 3 3761  5 other 1 3761  
1648 0 0 6 1545 3637 0 0 199 /**
 * Returns true if two matrices are memberwise equal within a specified
 * tolerance.  This is faster than the equivalence operator as this doesn't
 * have to guarantee that it is transitive.
 */ 3 4 this 3 3761  5 other 1 3761  9 threshold 1 3485  
1649 0 0 4 1546 3632 0 0 10 /**
 *
 */ 2 4 this 3 3761  3 out 1 3640  
1650 0 0 4 1547 3632 0 0 10 /**
 *
 */ 3 4 this 3 3761  3 out 1 3640  12 indent_level 1 3488  
1651 0 0 6 1548 3636 0 0 0 1 4 this 3 3761  
1652 0 0 4 1549 3632 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 2 4 this 3 3761  7 hashgen 1 3638  
1653 0 0 4 1549 3632 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 3 4 this 3 3761  7 hashgen 1 3638  5 scale 1 3485  
1654 0 0 4 1550 3632 0 0 332 /**
 * Writes the matrix to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the matrix, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */ 2 4 this 3 3761  11 destination 1 3642  
1655 0 0 4 1551 3632 0 0 114 /**
 * Reads the matrix from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */ 2 4 this 3 3767  4 scan 1 3644  
1656 0 0 4 1552 3632 0 0 205 /**
 * Writes the matrix to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the matrix using the standard width
 * setting, especially when you are writing a bam file.
 */ 2 4 this 3 3761  11 destination 1 3642  
1657 0 0 4 1553 3632 0 0 67 /**
 * Reads the matrix from the Datagram using get_stdfloat().
 */ 2 4 this 3 3767  6 source 1 3644  
1658 0 0 7 1554 3647 0 0 0 0 
1659 0 0 7 1456 3770 3248 0 0 1 6 param0 0 3772  
1660 0 0 4 1454 3632 0 0 10 /**
 *
 */ 3 4 this 3 3770  1 i 1 3488  10 assign_val 1 3485  
1661 0 0 6 1454 3485 0 0 0 2 4 this 3 3772  1 i 1 3488  
1662 0 0 6 1455 3488 0 0 58 /**
 * Returns 4: the number of columns of a LMatrix4.
 */ 0 
1663 0 0 7 1461 3771 3252 0 0 1 6 param0 0 3774  
1664 0 0 6 1459 3485 0 0 0 2 4 this 3 3774  1 i 1 3488  
1665 0 0 6 1460 3488 0 0 58 /**
 * Returns 4: the number of columns of a LMatrix4.
 */ 0 
1666 0 0 7 1558 3776 3348 0 10 /**
 *
 */ 0 
1667 0 0 7 1558 3776 3348 0 10 /**
 *
 */ 1 4 copy 1 3761  
1668 0 0 7 1558 3776 3348 0 10 /**
 *
 */ 1 4 copy 1 3768  
1669 0 0 7 1558 3776 3348 0 10 /**
 *
 */ 16 3 e00 1 3485  3 e01 1 3485  3 e02 1 3485  3 e03 1 3485  3 e10 1 3485  3 e11 1 3485  3 e12 1 3485  3 e13 1 3485  3 e20 1 3485  3 e21 1 3485  3 e22 1 3485  3 e23 1 3485  3 e30 1 3485  3 e31 1 3485  3 e32 1 3485  3 e33 1 3485  
1670 0 0 6 1559 3776 0 0 10 /**
 *
 */ 2 4 this 3 3776  4 copy 1 3761  
1671 0 0 6 1559 3776 0 0 10 /**
 *
 */ 2 4 this 3 3776  4 copy 1 3768  
1672 0 0 4 1560 3632 0 0 10 /**
 *
 */ 17 4 this 3 3776  3 e00 1 3485  3 e01 1 3485  3 e02 1 3485  3 e03 1 3485  3 e10 1 3485  3 e11 1 3485  3 e12 1 3485  3 e13 1 3485  3 e20 1 3485  3 e21 1 3485  3 e22 1 3485  3 e23 1 3485  3 e30 1 3485  3 e31 1 3485  3 e32 1 3485  3 e33 1 3485  
1673 0 0 4 1561 3632 0 0 10 /**
 *
 */ 3 4 this 3 3776  3 row 1 3488  3 col 1 3488  
1674 0 0 6 1561 3485 0 0 0 3 4 this 3 3768  3 row 1 3488  3 col 1 3488  
1675 0 0 4 1562 3632 0 0 162 /**
 * Returns the address of the first of the nine data elements in the matrix.
 * The remaining elements occupy the next eight positions in row-major order.
 */ 1 4 this 3 3768  
1676 0 0 6 1563 3488 0 0 65 /**
 * Returns the number of elements in the matrix, sixteen.
 */ 1 4 this 3 3768  
1677 0 0 7 1564 3647 0 0 0 0 
1678 0 0 7 1575 3777 3404 0 10 /**
 *
 */ 0 
1679 0 0 7 1575 3777 3404 0 0 1 6 param0 0 3778  
1680 0 0 7 1575 3777 3404 0 10 /**
 *
 */ 1 4 copy 1 3700  
1681 0 0 7 1575 3777 3404 0 10 /**
 *
 */ 2 1 r 1 3482  4 copy 1 3673  
1682 0 0 7 1575 3777 3404 0 10 /**
 *
 */ 4 1 r 1 3482  1 i 1 3482  1 j 1 3482  1 k 1 3482  
1683 0 0 7 1576 3777 3404 0 10 /**
 *
 */ 1 1 v 1 3682  
1684 0 0 7 1577 3777 3404 0 54 /**
 * Returns the complex conjugate of this quat.
 */ 1 4 this 3 3778  
1685 0 0 7 1578 3672 2299 0 60 /**
 * Transforms a 3-d vector by the indicated rotation
 */ 2 4 this 3 3778  1 v 1 3673  
1686 0 0 7 1578 3699 2679 0 60 /**
 * Transforms a 4-d vector by the indicated rotation
 */ 2 4 this 3 3778  1 v 1 3700  
1687 0 0 7 1579 3777 3404 0 45 /**
 * actual multiply call (non virtual)
 */ 2 4 this 3 3778  3 rhs 1 3778  
1688 0 0 7 1580 3777 3404 0 0 1 4 this 3 3778  
1689 0 0 7 1581 3777 3404 0 0 2 4 this 3 3778  5 other 1 3778  
1690 0 0 7 1582 3777 3404 0 0 2 4 this 3 3778  5 other 1 3778  
1691 0 0 6 1583 3482 0 0 127 /**
 * Returns the angle between the orientation represented by this quaternion
 * and the other one, expressed in radians.
 */ 2 4 this 3 3778  5 other 1 3778  
1692 0 0 6 1584 3482 0 0 127 /**
 * Returns the angle between the orientation represented by this quaternion
 * and the other one, expressed in degrees.
 */ 2 4 this 3 3778  5 other 1 3778  
1693 0 0 7 1585 3735 3052 0 0 2 4 this 3 3777  6 param0 0 3736  
1694 0 0 7 1585 3746 3150 0 0 2 4 this 3 3777  6 param0 0 3740  
1695 0 0 7 1585 3777 3404 0 0 2 4 this 3 3778  6 param0 0 3778  
1696 0 0 7 1585 3777 3404 0 0 2 4 this 3 3778  6 scalar 1 3482  
1697 0 0 7 1586 3777 3404 0 0 2 4 this 3 3778  6 scalar 1 3482  
1698 0 0 6 1587 3777 0 0 10 /**
 *
 */ 2 4 this 3 3777  6 param0 0 3778  
1699 0 0 6 1588 3637 0 0 120 /**
 * Returns true if two quaternions are memberwise equal within a default
 * tolerance based on the numeric type.
 */ 2 4 this 3 3778  5 other 1 3778  
1700 0 0 6 1588 3637 0 0 96 /**
 * Returns true if two quaternions are memberwise equal within a specified
 * tolerance.
 */ 3 4 this 3 3778  5 other 1 3778  9 threshold 1 3482  
1701 0 0 6 1589 3637 0 0 127 /**
 * Returns true if two quaternions represent the same rotation within a
 * default tolerance based on the numeric type.
 */ 2 4 this 3 3778  5 other 1 3778  
1702 0 0 6 1590 3637 0 0 103 /**
 * Returns true if two quaternions represent the same rotation within a
 * specified tolerance.
 */ 3 4 this 3 3778  5 other 1 3778  9 threshold 1 3482  
1703 0 0 4 1591 3632 0 0 10 /**
 *
 */ 2 4 this 3 3778  6 param0 0 3640  
1704 0 0 4 1592 3632 0 0 43 /**
 * Based on the quat lib from VRPN.
 */ 2 4 this 3 3778  1 m 1 3735  
1705 0 0 4 1592 3632 0 0 43 /**
 * Based on the quat lib from VRPN.
 */ 2 4 this 3 3778  1 m 1 3746  
1706 0 0 4 1593 3632 0 0 226 /**
 * Sets the quaternion according to the rotation represented by the matrix.
 * Originally we tried an algorithm presented by Do-While Jones, but that
 * turned out to be broken.  This is based on the quat lib from UNC.
 */ 2 4 this 3 3777  1 m 1 3736  
1707 0 0 4 1593 3632 0 0 10 /**
 *
 */ 2 4 this 3 3777  1 m 1 3740  
1708 0 0 4 1594 3632 0 0 132 /**
 * Sets the quaternion as the unit quaternion that is equivalent to these
 * Euler angles.  (from Real-time Rendering, p.49)
 */ 3 4 this 3 3777  3 hpr 1 3673  2 cs 1 3501  
1709 0 0 7 1595 3672 2299 0 73 /**
 * Extracts the equivalent Euler angles from the unit quaternion.
 */ 2 4 this 3 3778  2 cs 1 3501  
1710 0 0 7 1596 3681 2478 0 180 /**
 * This, along with get_angle(), returns the rotation represented by the
 * quaternion as an angle about an arbitrary axis.  This returns the axis; it
 * is not normalized.
 */ 1 4 this 3 3778  
1711 0 0 7 1597 3681 2478 0 169 /**
 * This, along with get_angle(), returns the rotation represented by the
 * quaternion as an angle about an arbitrary axis.  This returns the
 * normalized axis.
 */ 1 4 this 3 3778  
1712 0 0 6 1598 3482 0 0 343 /**
 * This, along with get_axis(), returns the rotation represented by the
 * quaternion as an angle about an arbitrary axis.  This returns the angle, in
 * radians counterclockwise about the axis.
 *
 * It is necessary to ensure the quaternion has been normalized (for instance,
 * with a call to normalize()) before calling this method.
 */ 1 4 this 3 3778  
1713 0 0 6 1599 3482 0 0 343 /**
 * This, along with get_axis(), returns the rotation represented by the
 * quaternion as an angle about an arbitrary axis.  This returns the angle, in
 * degrees counterclockwise about the axis.
 *
 * It is necessary to ensure the quaternion has been normalized (for instance,
 * with a call to normalize()) before calling this method.
 */ 1 4 this 3 3778  
1714 0 0 4 1600 3632 0 0 86 /**
 * angle_rad is the angle about the axis in radians.  axis must be normalized.
 */ 3 4 this 3 3777  9 angle_rad 1 3482  4 axis 1 3682  
1715 0 0 4 1601 3632 0 0 86 /**
 * angle_deg is the angle about the axis in degrees.  axis must be normalized.
 */ 3 4 this 3 3777  9 angle_deg 1 3482  4 axis 1 3682  
1716 0 0 7 1602 3681 2478 0 96 /**
 * Returns the orientation represented by this quaternion, expressed as an up
 * vector.
 */ 2 4 this 3 3778  2 cs 1 3501  
1717 0 0 7 1603 3681 2478 0 98 /**
 * Returns the orientation represented by this quaternion, expressed as a
 * right vector.
 */ 2 4 this 3 3778  2 cs 1 3501  
1718 0 0 7 1604 3681 2478 0 100 /**
 * Returns the orientation represented by this quaternion, expressed as a
 * forward vector.
 */ 2 4 this 3 3778  2 cs 1 3501  
1719 0 0 6 1605 3482 0 0 10 /**
 *
 */ 1 4 this 3 3778  
1720 0 0 6 1606 3482 0 0 10 /**
 *
 */ 1 4 this 3 3778  
1721 0 0 6 1607 3482 0 0 10 /**
 *
 */ 1 4 this 3 3778  
1722 0 0 6 1608 3482 0 0 10 /**
 *
 */ 1 4 this 3 3778  
1723 0 0 4 1609 3632 0 0 10 /**
 *
 */ 2 4 this 3 3777  1 r 1 3482  
1724 0 0 4 1610 3632 0 0 10 /**
 *
 */ 2 4 this 3 3777  1 i 1 3482  
1725 0 0 4 1611 3632 0 0 10 /**
 *
 */ 2 4 this 3 3777  1 j 1 3482  
1726 0 0 4 1612 3632 0 0 10 /**
 *
 */ 2 4 this 3 3777  1 k 1 3482  
1727 0 0 6 1613 3637 0 0 10 /**
 *
 */ 1 4 this 3 3777  
1728 0 0 6 1614 3637 0 0 466 /**
 * Computes the conjugate of the other quat, and stores the result in this
 * quat.  This is a fully general operation and makes no assumptions about the
 * type of transform represented by the quat.
 *
 * The other quat must be a different object than this quat.  However, if you
 * need to get a conjugate of a quat in place, see conjugate_in_place.
 *
 * The return value is true if the quat was successfully inverted, false if
 * there was a singularity.
 */ 2 4 this 3 3777  5 other 1 3778  
1729 0 0 6 1615 3637 0 0 129 /**
 * Sets this to be the conjugate of the current quat.  Returns true if the
 * successful, false if the quat was singular.
 */ 1 4 this 3 3777  
1730 0 0 6 1616 3637 0 0 448 /**
 * Computes the inverse of the other quat, and stores the result in this quat.
 * This is a fully general operation and makes no assumptions about the type
 * of transform represented by the quat.
 *
 * The other quat must be a different object than this quat.  However, if you
 * need to invert a quat in place, see invert_in_place.
 *
 * The return value is true if the quat was successfully inverted, false if
 * there was a singularity.
 */ 2 4 this 3 3777  5 other 1 3778  
1731 0 0 6 1617 3637 0 0 115 /**
 * Inverts the current quat.  Returns true if the inverse is successful, false
 * if the quat was singular.
 */ 1 4 this 3 3777  
1732 0 0 6 1618 3637 0 0 98 /**
 * Returns true if this quaternion represents the identity transformation: no
 * rotation.
 */ 1 4 this 3 3778  
1733 0 0 6 1619 3637 0 0 110 /**
 * Returns true if this quaternion represents the identity transformation
 * within a given tolerance.
 */ 2 4 this 3 3778  9 tolerance 1 3482  
1734 0 0 6 1620 3778 0 0 42 /**
 * Returns an identity quaternion.
 */ 0 
1735 0 0 7 1621 3647 0 0 0 0 
1736 0 0 7 1624 3780 3452 0 10 /**
 *
 */ 0 
1737 0 0 7 1624 3780 3452 0 0 1 6 param0 0 3781  
1738 0 0 7 1624 3780 3452 0 10 /**
 *
 */ 1 4 copy 1 3706  
1739 0 0 7 1624 3780 3452 0 10 /**
 *
 */ 2 1 r 1 3485  4 copy 1 3676  
1740 0 0 7 1624 3780 3452 0 10 /**
 *
 */ 4 1 r 1 3485  1 i 1 3485  1 j 1 3485  1 k 1 3485  
1741 0 0 7 1625 3780 3452 0 10 /**
 *
 */ 1 1 v 1 3685  
1742 0 0 7 1626 3780 3452 0 54 /**
 * Returns the complex conjugate of this quat.
 */ 1 4 this 3 3781  
1743 0 0 7 1627 3675 2372 0 60 /**
 * Transforms a 3-d vector by the indicated rotation
 */ 2 4 this 3 3781  1 v 1 3676  
1744 0 0 7 1627 3705 2762 0 60 /**
 * Transforms a 4-d vector by the indicated rotation
 */ 2 4 this 3 3781  1 v 1 3706  
1745 0 0 7 1628 3780 3452 0 45 /**
 * actual multiply call (non virtual)
 */ 2 4 this 3 3781  3 rhs 1 3781  
1746 0 0 7 1629 3780 3452 0 0 1 4 this 3 3781  
1747 0 0 7 1630 3780 3452 0 0 2 4 this 3 3781  5 other 1 3781  
1748 0 0 7 1631 3780 3452 0 0 2 4 this 3 3781  5 other 1 3781  
1749 0 0 6 1632 3485 0 0 127 /**
 * Returns the angle between the orientation represented by this quaternion
 * and the other one, expressed in radians.
 */ 2 4 this 3 3781  5 other 1 3781  
1750 0 0 6 1633 3485 0 0 127 /**
 * Returns the angle between the orientation represented by this quaternion
 * and the other one, expressed in degrees.
 */ 2 4 this 3 3781  5 other 1 3781  
1751 0 0 7 1634 3756 3244 0 0 2 4 this 3 3780  6 param0 0 3757  
1752 0 0 7 1634 3767 3340 0 0 2 4 this 3 3780  6 param0 0 3761  
1753 0 0 7 1634 3780 3452 0 0 2 4 this 3 3781  6 param0 0 3781  
1754 0 0 7 1634 3780 3452 0 0 2 4 this 3 3781  6 scalar 1 3485  
1755 0 0 7 1635 3780 3452 0 0 2 4 this 3 3781  6 scalar 1 3485  
1756 0 0 6 1636 3780 0 0 10 /**
 *
 */ 2 4 this 3 3780  6 param0 0 3781  
1757 0 0 6 1637 3637 0 0 120 /**
 * Returns true if two quaternions are memberwise equal within a default
 * tolerance based on the numeric type.
 */ 2 4 this 3 3781  5 other 1 3781  
1758 0 0 6 1637 3637 0 0 96 /**
 * Returns true if two quaternions are memberwise equal within a specified
 * tolerance.
 */ 3 4 this 3 3781  5 other 1 3781  9 threshold 1 3485  
1759 0 0 6 1638 3637 0 0 127 /**
 * Returns true if two quaternions represent the same rotation within a
 * default tolerance based on the numeric type.
 */ 2 4 this 3 3781  5 other 1 3781  
1760 0 0 6 1639 3637 0 0 103 /**
 * Returns true if two quaternions represent the same rotation within a
 * specified tolerance.
 */ 3 4 this 3 3781  5 other 1 3781  9 threshold 1 3485  
1761 0 0 4 1640 3632 0 0 10 /**
 *
 */ 2 4 this 3 3781  6 param0 0 3640  
1762 0 0 4 1641 3632 0 0 43 /**
 * Based on the quat lib from VRPN.
 */ 2 4 this 3 3781  1 m 1 3756  
1763 0 0 4 1641 3632 0 0 43 /**
 * Based on the quat lib from VRPN.
 */ 2 4 this 3 3781  1 m 1 3767  
1764 0 0 4 1642 3632 0 0 226 /**
 * Sets the quaternion according to the rotation represented by the matrix.
 * Originally we tried an algorithm presented by Do-While Jones, but that
 * turned out to be broken.  This is based on the quat lib from UNC.
 */ 2 4 this 3 3780  1 m 1 3757  
1765 0 0 4 1642 3632 0 0 10 /**
 *
 */ 2 4 this 3 3780  1 m 1 3761  
1766 0 0 4 1643 3632 0 0 132 /**
 * Sets the quaternion as the unit quaternion that is equivalent to these
 * Euler angles.  (from Real-time Rendering, p.49)
 */ 3 4 this 3 3780  3 hpr 1 3676  2 cs 1 3501  
1767 0 0 7 1644 3675 2372 0 73 /**
 * Extracts the equivalent Euler angles from the unit quaternion.
 */ 2 4 this 3 3781  2 cs 1 3501  
1768 0 0 7 1645 3684 2512 0 180 /**
 * This, along with get_angle(), returns the rotation represented by the
 * quaternion as an angle about an arbitrary axis.  This returns the axis; it
 * is not normalized.
 */ 1 4 this 3 3781  
1769 0 0 7 1646 3684 2512 0 169 /**
 * This, along with get_angle(), returns the rotation represented by the
 * quaternion as an angle about an arbitrary axis.  This returns the
 * normalized axis.
 */ 1 4 this 3 3781  
1770 0 0 6 1647 3485 0 0 343 /**
 * This, along with get_axis(), returns the rotation represented by the
 * quaternion as an angle about an arbitrary axis.  This returns the angle, in
 * radians counterclockwise about the axis.
 *
 * It is necessary to ensure the quaternion has been normalized (for instance,
 * with a call to normalize()) before calling this method.
 */ 1 4 this 3 3781  
1771 0 0 6 1648 3485 0 0 343 /**
 * This, along with get_axis(), returns the rotation represented by the
 * quaternion as an angle about an arbitrary axis.  This returns the angle, in
 * degrees counterclockwise about the axis.
 *
 * It is necessary to ensure the quaternion has been normalized (for instance,
 * with a call to normalize()) before calling this method.
 */ 1 4 this 3 3781  
1772 0 0 4 1649 3632 0 0 86 /**
 * angle_rad is the angle about the axis in radians.  axis must be normalized.
 */ 3 4 this 3 3780  9 angle_rad 1 3485  4 axis 1 3685  
1773 0 0 4 1650 3632 0 0 86 /**
 * angle_deg is the angle about the axis in degrees.  axis must be normalized.
 */ 3 4 this 3 3780  9 angle_deg 1 3485  4 axis 1 3685  
1774 0 0 7 1651 3684 2512 0 96 /**
 * Returns the orientation represented by this quaternion, expressed as an up
 * vector.
 */ 2 4 this 3 3781  2 cs 1 3501  
1775 0 0 7 1652 3684 2512 0 98 /**
 * Returns the orientation represented by this quaternion, expressed as a
 * right vector.
 */ 2 4 this 3 3781  2 cs 1 3501  
1776 0 0 7 1653 3684 2512 0 100 /**
 * Returns the orientation represented by this quaternion, expressed as a
 * forward vector.
 */ 2 4 this 3 3781  2 cs 1 3501  
1777 0 0 6 1654 3485 0 0 10 /**
 *
 */ 1 4 this 3 3781  
1778 0 0 6 1655 3485 0 0 10 /**
 *
 */ 1 4 this 3 3781  
1779 0 0 6 1656 3485 0 0 10 /**
 *
 */ 1 4 this 3 3781  
1780 0 0 6 1657 3485 0 0 10 /**
 *
 */ 1 4 this 3 3781  
1781 0 0 4 1658 3632 0 0 10 /**
 *
 */ 2 4 this 3 3780  1 r 1 3485  
1782 0 0 4 1659 3632 0 0 10 /**
 *
 */ 2 4 this 3 3780  1 i 1 3485  
1783 0 0 4 1660 3632 0 0 10 /**
 *
 */ 2 4 this 3 3780  1 j 1 3485  
1784 0 0 4 1661 3632 0 0 10 /**
 *
 */ 2 4 this 3 3780  1 k 1 3485  
1785 0 0 6 1662 3637 0 0 10 /**
 *
 */ 1 4 this 3 3780  
1786 0 0 6 1663 3637 0 0 466 /**
 * Computes the conjugate of the other quat, and stores the result in this
 * quat.  This is a fully general operation and makes no assumptions about the
 * type of transform represented by the quat.
 *
 * The other quat must be a different object than this quat.  However, if you
 * need to get a conjugate of a quat in place, see conjugate_in_place.
 *
 * The return value is true if the quat was successfully inverted, false if
 * there was a singularity.
 */ 2 4 this 3 3780  5 other 1 3781  
1787 0 0 6 1664 3637 0 0 129 /**
 * Sets this to be the conjugate of the current quat.  Returns true if the
 * successful, false if the quat was singular.
 */ 1 4 this 3 3780  
1788 0 0 6 1665 3637 0 0 448 /**
 * Computes the inverse of the other quat, and stores the result in this quat.
 * This is a fully general operation and makes no assumptions about the type
 * of transform represented by the quat.
 *
 * The other quat must be a different object than this quat.  However, if you
 * need to invert a quat in place, see invert_in_place.
 *
 * The return value is true if the quat was successfully inverted, false if
 * there was a singularity.
 */ 2 4 this 3 3780  5 other 1 3781  
1789 0 0 6 1666 3637 0 0 115 /**
 * Inverts the current quat.  Returns true if the inverse is successful, false
 * if the quat was singular.
 */ 1 4 this 3 3780  
1790 0 0 6 1667 3637 0 0 98 /**
 * Returns true if this quaternion represents the identity transformation: no
 * rotation.
 */ 1 4 this 3 3781  
1791 0 0 6 1668 3637 0 0 110 /**
 * Returns true if this quaternion represents the identity transformation
 * within a given tolerance.
 */ 2 4 this 3 3781  9 tolerance 1 3485  
1792 0 0 6 1669 3781 0 0 42 /**
 * Returns an identity quaternion.
 */ 0 
1793 0 0 7 1670 3647 0 0 0 0 
1794 0 0 7 1673 3783 3457 0 10 /**
 *
 */ 0 
1795 0 0 7 1673 3783 3457 0 19 /**
 * lmatrix3
 */ 1 1 m 1 3736  
1796 0 0 7 1673 3783 3457 0 19 /**
 * lmatrix4
 */ 1 1 m 1 3740  
1797 0 0 7 1673 3783 3457 0 10 /**
 *
 */ 1 1 c 1 3778  
1798 0 0 7 1673 3783 3457 0 0 1 6 param0 0 3784  
1799 0 0 7 1673 3783 3457 0 10 /**
 *
 */ 1 4 copy 1 3700  
1800 0 0 7 1673 3783 3457 0 36 /**
 * axis + angle (in degrees)
 */ 2 4 axis 1 3682  5 angle 1 3482  
1801 0 0 7 1673 3783 3457 0 57 /**
 * Sets the rotation from the given Euler angles.
 */ 3 1 h 1 3482  1 p 1 3482  1 r 1 3482  
1802 0 0 7 1673 3783 3457 0 10 /**
 *
 */ 4 1 r 1 3482  1 i 1 3482  1 j 1 3482  1 k 1 3482  
1803 0 0 7 1674 3777 3404 0 0 2 4 this 3 3784  5 other 1 3778  
1804 0 0 7 1674 3783 3457 0 0 2 4 this 3 3784  5 other 1 3784  
1805 0 0 7 1674 3783 3457 0 0 2 4 this 3 3784  6 scalar 1 3482  
1806 0 0 7 1675 3783 3457 0 0 2 4 this 3 3784  6 scalar 1 3482  
1807 0 0 7 1676 3647 0 0 0 0 
1808 0 0 7 1679 3786 3462 0 10 /**
 *
 */ 0 
1809 0 0 7 1679 3786 3462 0 19 /**
 * lmatrix3
 */ 1 1 m 1 3757  
1810 0 0 7 1679 3786 3462 0 19 /**
 * lmatrix4
 */ 1 1 m 1 3761  
1811 0 0 7 1679 3786 3462 0 10 /**
 *
 */ 1 1 c 1 3781  
1812 0 0 7 1679 3786 3462 0 0 1 6 param0 0 3787  
1813 0 0 7 1679 3786 3462 0 10 /**
 *
 */ 1 4 copy 1 3706  
1814 0 0 7 1679 3786 3462 0 36 /**
 * axis + angle (in degrees)
 */ 2 4 axis 1 3685  5 angle 1 3485  
1815 0 0 7 1679 3786 3462 0 57 /**
 * Sets the rotation from the given Euler angles.
 */ 3 1 h 1 3485  1 p 1 3485  1 r 1 3485  
1816 0 0 7 1679 3786 3462 0 10 /**
 *
 */ 4 1 r 1 3485  1 i 1 3485  1 j 1 3485  1 k 1 3485  
1817 0 0 7 1680 3780 3452 0 0 2 4 this 3 3787  5 other 1 3781  
1818 0 0 7 1680 3786 3462 0 0 2 4 this 3 3787  5 other 1 3787  
1819 0 0 7 1680 3786 3462 0 0 2 4 this 3 3787  6 scalar 1 3485  
1820 0 0 7 1681 3786 3462 0 0 2 4 this 3 3787  6 scalar 1 3485  
1821 0 0 7 1682 3647 0 0 0 0 
1822 0 0 7 1685 3789 3466 0 10 /**
 *
 */ 0 
1823 0 0 7 1685 3789 3466 0 18 /**
 * matrix3
 */ 1 1 m 1 3736  
1824 0 0 7 1685 3789 3466 0 18 /**
 * matrix4
 */ 1 1 m 1 3740  
1825 0 0 7 1685 3789 3466 0 0 1 6 param0 0 3790  
1826 0 0 7 1685 3789 3466 0 10 /**
 *
 */ 1 1 c 1 3778  
1827 0 0 7 1685 3789 3466 0 25 /**
 * vector + twist
 */ 2 8 point_at 1 3682  5 twist 1 3482  
1828 0 0 7 1685 3789 3466 0 10 /**
 *
 */ 4 1 r 1 3482  1 i 1 3482  1 j 1 3482  1 k 1 3482  
1829 0 0 7 1686 3789 3466 0 0 2 4 this 3 3790  5 other 1 3778  
1830 0 0 7 1686 3789 3466 0 0 2 4 this 3 3790  5 other 1 3784  
1831 0 0 7 1687 3647 0 0 0 0 
1832 0 0 7 1690 3792 3470 0 10 /**
 *
 */ 0 
1833 0 0 7 1690 3792 3470 0 18 /**
 * matrix3
 */ 1 1 m 1 3757  
1834 0 0 7 1690 3792 3470 0 18 /**
 * matrix4
 */ 1 1 m 1 3761  
1835 0 0 7 1690 3792 3470 0 0 1 6 param0 0 3793  
1836 0 0 7 1690 3792 3470 0 10 /**
 *
 */ 1 1 c 1 3781  
1837 0 0 7 1690 3792 3470 0 25 /**
 * vector + twist
 */ 2 8 point_at 1 3685  5 twist 1 3485  
1838 0 0 7 1690 3792 3470 0 10 /**
 *
 */ 4 1 r 1 3485  1 i 1 3485  1 j 1 3485  1 k 1 3485  
1839 0 0 7 1691 3792 3470 0 0 2 4 this 3 3793  5 other 1 3781  
1840 0 0 7 1691 3792 3470 0 0 2 4 this 3 3793  5 other 1 3787  
1841 0 0 7 1692 3647 0 0 0 0 
1842 0 0 7 1766 3797 3478 0 0 1 6 param0 0 3795  
1843 0 0 7 1766 3797 3478 0 10 /**
 *
 */ 1 4 name 1 3636  
1844 0 0 7 1766 3797 3478 0 10 /**
 *
 */ 4 4 name 1 3636  13 default_value 1 3798  11 description 1 3636  5 flags 1 3488  
1845 0 0 7 1766 3797 3478 0 10 /**
 *
 */ 4 4 name 1 3636  13 default_value 1 3636  11 description 1 3636  5 flags 1 3488  
1846 0 0 6 1767 3797 0 0 0 2 4 this 3 3797  5 value 1 3798  
1847 0 0 6 1769 3800 0 0 0 2 4 this 3 3795  1 n 1 3488  
1848 0 0 4 1770 3632 0 0 48 /**
 * Reassigns the variable's local value.
 */ 2 4 this 3 3797  5 value 1 3798  
1849 0 0 6 1771 3798 0 0 40 /**
 * Returns the variable's value.
 */ 1 4 this 3 3795  
1850 0 0 7 1772 3801 0 0 48 /**
 * Returns the variable's default value.
 */ 1 4 this 3 3795  
1851 0 0 6 1768 3798 0 0 0 1 4 this 3 3795  
1852 0 0 6 4 3485 0 0 0 1 1 f 1 3485  
1853 0 0 6 4 3482 0 0 0 1 1 f 1 3482  
1854 0 0 6 5 3485 0 0 0 1 1 f 1 3485  
1855 0 0 6 5 3482 0 0 0 1 1 f 1 3482  
1856 0 0 6 547 3501 0 0 0 0 
1857 0 0 6 548 3501 0 0 0 1 3 str 1 3636  
1858 0 0 6 549 3636 0 0 0 1 2 cs 1 3501  
1859 0 0 6 550 3637 0 0 0 1 2 cs 1 3501  
1860 0 0 7 1238 3756 3244 0 0 1 1 a 1 3757  
1861 0 0 7 1238 3735 3052 0 0 1 1 a 1 3736  
1862 0 0 7 1238 3767 3340 0 0 1 1 a 1 3761  
1863 0 0 7 1238 3746 3150 0 0 1 1 a 1 3740  
1864 0 0 7 1239 3756 3244 0 0 1 1 a 1 3757  
1865 0 0 7 1239 3735 3052 0 0 1 1 a 1 3736  
1866 0 0 7 1239 3767 3340 0 0 1 1 a 1 3761  
1867 0 0 7 1239 3746 3150 0 0 1 1 a 1 3740  
1868 0 0 7 1239 3780 3452 0 0 1 1 a 1 3781  
1869 0 0 7 1239 3777 3404 0 0 1 1 a 1 3778  
1870 0 0 7 1566 3756 3244 0 0 2 1 m 1 3757  1 q 1 3781  
1871 0 0 7 1566 3735 3052 0 0 2 1 m 1 3736  1 q 1 3778  
1872 0 0 7 1566 3767 3340 0 0 2 1 m 1 3761  1 q 1 3781  
1873 0 0 7 1566 3746 3150 0 0 2 1 m 1 3740  1 q 1 3778  
1874 0 0 7 1566 3666 2212 0 0 2 1 v 1 3667  1 m 1 3757  
1875 0 0 7 1566 3663 2196 0 0 2 1 v 1 3664  1 m 1 3736  
1876 0 0 7 1566 3693 2584 0 0 2 1 v 1 3694  1 m 1 3757  
1877 0 0 7 1566 3693 2584 0 0 2 1 v 1 3694  1 m 1 3761  
1878 0 0 7 1566 3690 2561 0 0 2 1 v 1 3691  1 m 1 3736  
1879 0 0 7 1566 3690 2561 0 0 2 1 v 1 3691  1 m 1 3740  
1880 0 0 7 1566 3729 2948 0 0 2 1 v 1 3730  1 m 1 3761  
1881 0 0 7 1566 3726 2928 0 0 2 1 v 1 3727  1 m 1 3740  
1882 0 0 7 1566 3675 2372 0 0 2 1 v 1 3676  1 m 1 3757  
1883 0 0 7 1566 3672 2299 0 0 2 1 v 1 3673  1 m 1 3736  
1884 0 0 7 1566 3705 2762 0 0 2 1 v 1 3706  1 m 1 3761  
1885 0 0 7 1566 3699 2679 0 0 2 1 v 1 3700  1 m 1 3740  
1886 0 0 7 1566 3657 2166 0 0 2 1 v 1 3658  1 m 1 3757  
1887 0 0 7 1566 3654 2148 0 0 2 1 v 1 3655  1 m 1 3736  
1888 0 0 7 1566 3684 2512 0 0 2 1 v 1 3685  1 m 1 3757  
1889 0 0 7 1566 3684 2512 0 0 2 1 v 1 3685  1 m 1 3761  
1890 0 0 7 1566 3681 2478 0 0 2 1 v 1 3682  1 m 1 3736  
1891 0 0 7 1566 3681 2478 0 0 2 1 v 1 3682  1 m 1 3740  
1892 0 0 7 1566 3720 2890 0 0 2 1 v 1 3721  1 m 1 3761  
1893 0 0 7 1566 3717 2870 0 0 2 1 v 1 3718  1 m 1 3740  
1894 0 0 4 1567 3632 0 0 0 2 1 v 1 3666  1 m 1 3757  
1895 0 0 4 1567 3632 0 0 0 2 1 v 1 3663  1 m 1 3736  
1896 0 0 4 1567 3632 0 0 0 2 1 v 1 3693  1 m 1 3757  
1897 0 0 4 1567 3632 0 0 0 2 1 v 1 3693  1 m 1 3761  
1898 0 0 4 1567 3632 0 0 0 2 1 v 1 3690  1 m 1 3736  
1899 0 0 4 1567 3632 0 0 0 2 1 v 1 3690  1 m 1 3740  
1900 0 0 4 1567 3632 0 0 0 2 1 v 1 3675  1 m 1 3757  
1901 0 0 4 1567 3632 0 0 0 2 1 v 1 3672  1 m 1 3736  
1902 0 0 4 1567 3632 0 0 0 2 1 v 1 3705  1 m 1 3761  
1903 0 0 4 1567 3632 0 0 0 2 1 v 1 3699  1 m 1 3740  
1904 0 0 4 1567 3632 0 0 0 2 1 v 1 3657  1 m 1 3757  
1905 0 0 4 1567 3632 0 0 0 2 1 v 1 3654  1 m 1 3736  
1906 0 0 4 1567 3632 0 0 0 2 1 v 1 3684  1 m 1 3757  
1907 0 0 4 1567 3632 0 0 0 2 1 v 1 3684  1 m 1 3761  
1908 0 0 4 1567 3632 0 0 0 2 1 v 1 3681  1 m 1 3736  
1909 0 0 4 1567 3632 0 0 0 2 1 v 1 3681  1 m 1 3740  
1910 0 0 4 1568 3632 0 0 0 2 4 dest 1 3642  5 value 1 3757  
1911 0 0 4 1568 3632 0 0 0 2 4 dest 1 3642  5 value 1 3736  
1912 0 0 4 1568 3632 0 0 0 2 4 dest 1 3642  5 value 1 3761  
1913 0 0 4 1568 3632 0 0 0 2 4 dest 1 3642  5 value 1 3740  
1914 0 0 4 1569 3632 0 0 0 2 6 result 1 3756  6 source 1 3644  
1915 0 0 4 1569 3632 0 0 0 2 6 result 1 3735  6 source 1 3644  
1916 0 0 4 1569 3632 0 0 0 2 6 result 1 3767  6 source 1 3644  
1917 0 0 4 1569 3632 0 0 0 2 6 result 1 3746  6 source 1 3644  
1918 0 0 4 1570 3632 0 0 0 4 3 mat 1 3756  5 scale 1 3676  3 hpr 1 3676  2 cs 1 3501  
1919 0 0 4 1570 3632 0 0 0 5 3 mat 1 3756  5 scale 1 3676  5 shear 1 3676  3 hpr 1 3676  2 cs 1 3501  
1920 0 0 4 1570 3632 0 0 0 4 3 mat 1 3735  5 scale 1 3673  3 hpr 1 3673  2 cs 1 3501  
1921 0 0 4 1570 3632 0 0 0 5 3 mat 1 3735  5 scale 1 3673  5 shear 1 3673  3 hpr 1 3673  2 cs 1 3501  
1922 0 0 4 1570 3632 0 0 0 5 3 mat 1 3767  5 scale 1 3676  3 hpr 1 3676  9 translate 1 3676  2 cs 1 3501  
1923 0 0 4 1570 3632 0 0 0 6 3 mat 1 3767  5 scale 1 3676  5 shear 1 3676  3 hpr 1 3676  9 translate 1 3676  2 cs 1 3501  
1924 0 0 4 1570 3632 0 0 0 3 3 mat 1 3767  10 components 1 3802  2 cs 1 3501  
1925 0 0 4 1570 3632 0 0 0 5 3 mat 1 3746  5 scale 1 3673  3 hpr 1 3673  9 translate 1 3673  2 cs 1 3501  
1926 0 0 4 1570 3632 0 0 0 6 3 mat 1 3746  5 scale 1 3673  5 shear 1 3673  3 hpr 1 3673  9 translate 1 3673  2 cs 1 3501  
1927 0 0 4 1570 3632 0 0 0 3 3 mat 1 3746  10 components 1 3804  2 cs 1 3501  
1928 0 0 6 1571 3637 0 0 0 4 3 mat 1 3757  5 scale 1 3675  3 hpr 1 3675  2 cs 1 3501  
1929 0 0 6 1571 3637 0 0 0 5 3 mat 1 3757  5 scale 1 3675  5 shear 1 3675  3 hpr 1 3675  2 cs 1 3501  
1930 0 0 6 1571 3637 0 0 0 4 3 mat 1 3736  5 scale 1 3672  3 hpr 1 3672  2 cs 1 3501  
1931 0 0 6 1571 3637 0 0 0 5 3 mat 1 3736  5 scale 1 3672  5 shear 1 3672  3 hpr 1 3672  2 cs 1 3501  
1932 0 0 6 1571 3637 0 0 0 5 3 mat 1 3761  5 scale 1 3675  3 hpr 1 3675  9 translate 1 3675  2 cs 1 3501  
1933 0 0 6 1571 3637 0 0 0 6 3 mat 1 3761  5 scale 1 3675  5 shear 1 3675  3 hpr 1 3675  9 translate 1 3675  2 cs 1 3501  
1934 0 0 6 1571 3637 0 0 0 3 3 mat 1 3761  10 components 1 3806  2 CS 1 3501  
1935 0 0 6 1571 3637 0 0 0 5 3 mat 1 3740  5 scale 1 3672  3 hpr 1 3672  9 translate 1 3672  2 cs 1 3501  
1936 0 0 6 1571 3637 0 0 0 6 3 mat 1 3740  5 scale 1 3672  5 shear 1 3672  3 hpr 1 3672  9 translate 1 3672  2 cs 1 3501  
1937 0 0 6 1571 3637 0 0 0 3 3 mat 1 3740  10 components 1 3807  2 CS 1 3501  
1938 0 0 6 1572 3637 0 0 0 5 3 mat 1 3757  5 scale 1 3675  5 shear 1 3675  3 hpr 1 3675  2 cs 1 3501  
1939 0 0 6 1572 3637 0 0 0 5 3 mat 1 3736  5 scale 1 3672  5 shear 1 3672  3 hpr 1 3672  2 cs 1 3501  
1940 0 0 7 1573 3675 2372 0 0 1 7 old_hpr 1 3676  
1941 0 0 7 1573 3672 2299 0 0 1 7 old_hpr 1 3673  
329
3479 11 MathNumbers 0 141313 11 MathNumbers 11 MathNumbers 0 0 0 1 1942 1943 0 0 0 0 0 0 0 0

3480 10 LVecBase2f 0 141313 10 LVecBase2f 10 LVecBase2f 0 0 0 1 1946 2008 2 3808 3809 61 1947 1948 1949 1950 1951 1952 1953 1954 1955 1956 1957 1958 1959 1960 1961 1962 1963 1964 1965 1966 1967 1968 1969 1970 1971 1972 1973 1974 1975 1976 1977 1978 1979 1980 1981 1982 1983 1984 1985 1986 1987 1988 1989 1990 1991 1992 1993 1994 1995 1996 1997 1998 1999 2000 2001 2002 2003 2004 2005 2006 2007 0 0 0 0 1 3481 75
/**
 * This is the base class for all two-component vectors and points.
 */

3481 0 0 794624 12 LVecBase2f:: 0 3480 0 0 0 0 0 0 0 0 0 2 14 num_components 26 LVecBase2f::num_components 0
2 6 is_int 18 LVecBase2f::is_int 0
0 0 0

3482 5 float 0 8194 5 float 5 float 0 2 0 0 0 0 0 0 0 0 0 0 0

3483 10 LVecBase2d 0 141313 10 LVecBase2d 10 LVecBase2d 0 0 0 1 2009 2071 2 3810 3811 61 2010 2011 2012 2013 2014 2015 2016 2017 2018 2019 2020 2021 2022 2023 2024 2025 2026 2027 2028 2029 2030 2031 2032 2033 2034 2035 2036 2037 2038 2039 2040 2041 2042 2043 2044 2045 2046 2047 2048 2049 2050 2051 2052 2053 2054 2055 2056 2057 2058 2059 2060 2061 2062 2063 2064 2065 2066 2067 2068 2069 2070 0 0 0 0 1 3484 75
/**
 * This is the base class for all two-component vectors and points.
 */

3484 0 0 794624 12 LVecBase2d:: 0 3483 0 0 0 0 0 0 0 0 0 2 14 num_components 26 LVecBase2d::num_components 0
2 6 is_int 18 LVecBase2d::is_int 0
0 0 0

3485 6 double 0 8194 6 double 6 double 0 3 0 0 0 0 0 0 0 0 0 0 0

3486 10 LVecBase2i 0 141313 10 LVecBase2i 10 LVecBase2i 0 0 0 1 2072 2130 2 3812 3813 57 2073 2074 2075 2076 2077 2078 2079 2080 2081 2082 2083 2084 2085 2086 2087 2088 2089 2090 2091 2092 2093 2094 2095 2096 2097 2098 2099 2100 2101 2102 2103 2104 2105 2106 2107 2108 2109 2110 2111 2112 2113 2114 2115 2116 2117 2118 2119 2120 2121 2122 2123 2124 2125 2126 2127 2128 2129 0 0 0 0 1 3487 75
/**
 * This is the base class for all two-component vectors and points.
 */

3487 0 0 794624 12 LVecBase2i:: 0 3486 0 0 0 0 0 0 0 0 0 2 14 num_components 26 LVecBase2i::num_components 0
2 6 is_int 18 LVecBase2i::is_int 0
1 0 0

3488 3 int 0 8194 3 int 3 int 0 1 0 0 0 0 0 0 0 0 0 0 0

3489 9 LVector2f 0 141313 9 LVector2f 9 LVector2f 0 0 0 1 2131 2148 0 16 2132 2133 2134 2135 2136 2137 2138 2139 2140 2141 2142 2143 2144 2145 2146 2147 0 0 1 0 3480 0 0 0 0 49
/**
 * This is a two-component vector offset.
 */

3490 9 LVector2d 0 141313 9 LVector2d 9 LVector2d 0 0 0 1 2149 2166 0 16 2150 2151 2152 2153 2154 2155 2156 2157 2158 2159 2160 2161 2162 2163 2164 2165 0 0 1 0 3483 0 0 0 0 49
/**
 * This is a two-component vector offset.
 */

3491 9 LVector2i 0 141313 9 LVector2i 9 LVector2i 0 0 0 1 2167 2180 0 12 2168 2169 2170 2171 2172 2173 2174 2175 2176 2177 2178 2179 0 0 1 0 3486 0 0 0 0 49
/**
 * This is a two-component vector offset.
 */

3492 8 LPoint2f 0 141313 8 LPoint2f 8 LPoint2f 0 0 0 1 2181 2196 0 14 2182 2183 2184 2185 2186 2187 2188 2189 2190 2191 2192 2193 2194 2195 0 0 1 0 3480 0 0 0 0 50
/**
 * This is a two-component point in space.
 */

3493 8 LPoint2d 0 141313 8 LPoint2d 8 LPoint2d 0 0 0 1 2197 2212 0 14 2198 2199 2200 2201 2202 2203 2204 2205 2206 2207 2208 2209 2210 2211 0 0 1 0 3483 0 0 0 0 50
/**
 * This is a two-component point in space.
 */

3494 8 LPoint2i 0 141313 8 LPoint2i 8 LPoint2i 0 0 0 1 2213 2226 0 12 2214 2215 2216 2217 2218 2219 2220 2221 2222 2223 2224 2225 0 0 1 0 3486 0 0 0 0 50
/**
 * This is a two-component point in space.
 */

3495 10 LVecBase3f 0 141313 10 LVecBase3f 10 LVecBase3f 0 0 0 1 2227 2299 6 3814 3815 3816 3817 3818 3819 71 2228 2229 2230 2231 2232 2233 2234 2235 2236 2237 2238 2239 2240 2241 2242 2243 2244 2245 2246 2247 2248 2249 2250 2251 2252 2253 2254 2255 2256 2257 2258 2259 2260 2261 2262 2263 2264 2265 2266 2267 2268 2269 2270 2271 2272 2273 2274 2275 2276 2277 2278 2279 2280 2281 2282 2283 2284 2285 2286 2287 2288 2289 2290 2291 2292 2293 2294 2295 2296 2297 2298 0 0 0 0 1 3496 77
/**
 * This is the base class for all three-component vectors and points.
 */

3496 0 0 794624 12 LVecBase3f:: 0 3495 0 0 0 0 0 0 0 0 0 2 14 num_components 26 LVecBase3f::num_components 0
3 6 is_int 18 LVecBase3f::is_int 0
0 0 0

3497 10 LVecBase3d 0 141313 10 LVecBase3d 10 LVecBase3d 0 0 0 1 2300 2372 6 3820 3821 3822 3823 3824 3825 71 2301 2302 2303 2304 2305 2306 2307 2308 2309 2310 2311 2312 2313 2314 2315 2316 2317 2318 2319 2320 2321 2322 2323 2324 2325 2326 2327 2328 2329 2330 2331 2332 2333 2334 2335 2336 2337 2338 2339 2340 2341 2342 2343 2344 2345 2346 2347 2348 2349 2350 2351 2352 2353 2354 2355 2356 2357 2358 2359 2360 2361 2362 2363 2364 2365 2366 2367 2368 2369 2370 2371 0 0 0 0 1 3498 77
/**
 * This is the base class for all three-component vectors and points.
 */

3498 0 0 794624 12 LVecBase3d:: 0 3497 0 0 0 0 0 0 0 0 0 2 14 num_components 26 LVecBase3d::num_components 0
3 6 is_int 18 LVecBase3d::is_int 0
0 0 0

3499 10 LVecBase3i 0 141313 10 LVecBase3i 10 LVecBase3i 0 0 0 1 2373 2440 6 3826 3827 3828 3829 3830 3831 66 2374 2375 2376 2377 2378 2379 2380 2381 2382 2383 2384 2385 2386 2387 2388 2389 2390 2391 2392 2393 2394 2395 2396 2397 2398 2399 2400 2401 2402 2403 2404 2405 2406 2407 2408 2409 2410 2411 2412 2413 2414 2415 2416 2417 2418 2419 2420 2421 2422 2423 2424 2425 2426 2427 2428 2429 2430 2431 2432 2433 2434 2435 2436 2437 2438 2439 0 0 0 0 1 3500 77
/**
 * This is the base class for all three-component vectors and points.
 */

3500 0 0 794624 12 LVecBase3i:: 0 3499 0 0 0 0 0 0 0 0 0 2 14 num_components 26 LVecBase3i::num_components 0
3 6 is_int 18 LVecBase3i::is_int 0
1 0 0

3501 16 CoordinateSystem 0 532481 16 CoordinateSystem 16 CoordinateSystem 0 0 0 0 0 0 0 0 0 0 6 10 CS_default 10 CS_default 210
// The CS_default entry does not refer to a particular coordinate system,
// but rather to the value stored in default_coordinate_system, which in
// turn is loaded from the config variable "coordinate-system".
0 12 CS_zup_right 12 CS_zup_right 0
1 12 CS_yup_right 12 CS_yup_right 0
2 11 CS_zup_left 11 CS_zup_left 0
3 11 CS_yup_left 11 CS_yup_left 0
4 10 CS_invalid 10 CS_invalid 156
// CS_invalid is not a coordinate system at all.  It can be used in user-
// input processing code to indicate a contradictory coordinate system
// request.
5 0 0

3502 9 LVector3f 0 141313 9 LVector3f 9 LVector3f 0 0 0 1 2445 2478 3 3832 3833 3834 32 2446 2447 2448 2449 2450 2451 2452 2453 2454 2455 2456 2457 2458 2459 2460 2461 2462 2463 2464 2465 2466 2467 2468 2469 2470 2471 2472 2473 2474 2475 2476 2477 0 0 1 0 3495 0 0 0 0 338
/**
 * This is a three-component vector distance (as opposed to a three-component
 * point, which represents a particular point in space).  Some of the methods
 * are slightly different between LPoint3 and LVector3; in particular,
 * subtraction of two points yields a vector, while addition of a vector and a
 * point yields a point.
 */

3503 9 LVector3d 0 141313 9 LVector3d 9 LVector3d 0 0 0 1 2479 2512 3 3835 3836 3837 32 2480 2481 2482 2483 2484 2485 2486 2487 2488 2489 2490 2491 2492 2493 2494 2495 2496 2497 2498 2499 2500 2501 2502 2503 2504 2505 2506 2507 2508 2509 2510 2511 0 0 1 0 3497 0 0 0 0 338
/**
 * This is a three-component vector distance (as opposed to a three-component
 * point, which represents a particular point in space).  Some of the methods
 * are slightly different between LPoint3 and LVector3; in particular,
 * subtraction of two points yields a vector, while addition of a vector and a
 * point yields a point.
 */

3504 9 LVector3i 0 141313 9 LVector3i 9 LVector3i 0 0 0 1 2513 2538 3 3838 3839 3840 24 2514 2515 2516 2517 2518 2519 2520 2521 2522 2523 2524 2525 2526 2527 2528 2529 2530 2531 2532 2533 2534 2535 2536 2537 0 0 1 0 3499 0 0 0 0 338
/**
 * This is a three-component vector distance (as opposed to a three-component
 * point, which represents a particular point in space).  Some of the methods
 * are slightly different between LPoint3 and LVector3; in particular,
 * subtraction of two points yields a vector, while addition of a vector and a
 * point yields a point.
 */

3505 8 LPoint3f 0 141313 8 LPoint3f 8 LPoint3f 0 0 0 1 2539 2561 3 3841 3842 3843 21 2540 2541 2542 2543 2544 2545 2546 2547 2548 2549 2550 2551 2552 2553 2554 2555 2556 2557 2558 2559 2560 0 0 1 0 3495 0 0 0 0 337
/**
 * This is a three-component point in space (as opposed to a three-component
 * vector, which represents a direction and a distance).  Some of the methods
 * are slightly different between LPoint3 and LVector3; in particular,
 * subtraction of two points yields a vector, while addition of a vector and a
 * point yields a point.
 */

3506 8 LPoint3d 0 141313 8 LPoint3d 8 LPoint3d 0 0 0 1 2562 2584 3 3844 3845 3846 21 2563 2564 2565 2566 2567 2568 2569 2570 2571 2572 2573 2574 2575 2576 2577 2578 2579 2580 2581 2582 2583 0 0 1 0 3497 0 0 0 0 337
/**
 * This is a three-component point in space (as opposed to a three-component
 * vector, which represents a direction and a distance).  Some of the methods
 * are slightly different between LPoint3 and LVector3; in particular,
 * subtraction of two points yields a vector, while addition of a vector and a
 * point yields a point.
 */

3507 8 LPoint3i 0 141313 8 LPoint3i 8 LPoint3i 0 0 0 1 2585 2605 3 3847 3848 3849 19 2586 2587 2588 2589 2590 2591 2592 2593 2594 2595 2596 2597 2598 2599 2600 2601 2602 2603 2604 0 0 1 0 3499 0 0 0 0 337
/**
 * This is a three-component point in space (as opposed to a three-component
 * vector, which represents a direction and a distance).  Some of the methods
 * are slightly different between LPoint3 and LVector3; in particular,
 * subtraction of two points yields a vector, while addition of a vector and a
 * point yields a point.
 */

3508 10 LVecBase4f 0 141313 10 LVecBase4f 10 LVecBase4f 0 0 0 1 2606 2679 5 3850 3851 3852 3853 3854 72 2607 2608 2609 2610 2611 2612 2613 2614 2615 2616 2617 2618 2619 2620 2621 2622 2623 2624 2625 2626 2627 2628 2629 2630 2631 2632 2633 2634 2635 2636 2637 2638 2639 2640 2641 2642 2643 2644 2645 2646 2647 2648 2649 2650 2651 2652 2653 2654 2655 2656 2657 2658 2659 2660 2661 2662 2663 2664 2665 2666 2667 2668 2669 2670 2671 2672 2673 2674 2675 2676 2677 2678 0 0 0 0 1 3509 77
/**
 * This is the base class for all three-component vectors and points.
 */

3509 0 0 794624 12 LVecBase4f:: 0 3508 0 0 0 0 0 0 0 0 0 2 14 num_components 26 LVecBase4f::num_components 0
4 6 is_int 18 LVecBase4f::is_int 0
0 0 0

3510 19 UnalignedLVecBase4f 0 141313 19 UnalignedLVecBase4f 19 UnalignedLVecBase4f 0 0 0 1 2680 2688 0 7 2681 2682 2683 2684 2685 2686 2687 0 0 0 0 1 3511 391
/**
 * This is an "unaligned" LVecBase4.  It has no functionality other than to
 * store numbers, and it will pack them in as tightly as possible, avoiding
 * any SSE2 alignment requirements shared by the primary LVecBase4 class.
 *
 * Use it only when you need to pack numbers tightly without respect to
 * alignment, and then copy it to a proper LVecBase4 to get actual use from
 * it.
 */

3511 0 0 794624 21 UnalignedLVecBase4f:: 0 3510 0 0 0 0 0 0 0 0 0 2 14 num_components 35 UnalignedLVecBase4f::num_components 0
4 6 is_int 27 UnalignedLVecBase4f::is_int 0
0 0 0

3512 10 LVecBase4d 0 141313 10 LVecBase4d 10 LVecBase4d 0 0 0 1 2689 2762 5 3855 3856 3857 3858 3859 72 2690 2691 2692 2693 2694 2695 2696 2697 2698 2699 2700 2701 2702 2703 2704 2705 2706 2707 2708 2709 2710 2711 2712 2713 2714 2715 2716 2717 2718 2719 2720 2721 2722 2723 2724 2725 2726 2727 2728 2729 2730 2731 2732 2733 2734 2735 2736 2737 2738 2739 2740 2741 2742 2743 2744 2745 2746 2747 2748 2749 2750 2751 2752 2753 2754 2755 2756 2757 2758 2759 2760 2761 0 0 0 0 1 3513 77
/**
 * This is the base class for all three-component vectors and points.
 */

3513 0 0 794624 12 LVecBase4d:: 0 3512 0 0 0 0 0 0 0 0 0 2 14 num_components 26 LVecBase4d::num_components 0
4 6 is_int 18 LVecBase4d::is_int 0
0 0 0

3514 19 UnalignedLVecBase4d 0 141313 19 UnalignedLVecBase4d 19 UnalignedLVecBase4d 0 0 0 1 2763 2771 0 7 2764 2765 2766 2767 2768 2769 2770 0 0 0 0 1 3515 391
/**
 * This is an "unaligned" LVecBase4.  It has no functionality other than to
 * store numbers, and it will pack them in as tightly as possible, avoiding
 * any SSE2 alignment requirements shared by the primary LVecBase4 class.
 *
 * Use it only when you need to pack numbers tightly without respect to
 * alignment, and then copy it to a proper LVecBase4 to get actual use from
 * it.
 */

3515 0 0 794624 21 UnalignedLVecBase4d:: 0 3514 0 0 0 0 0 0 0 0 0 2 14 num_components 35 UnalignedLVecBase4d::num_components 0
4 6 is_int 27 UnalignedLVecBase4d::is_int 0
0 0 0

3516 10 LVecBase4i 0 141313 10 LVecBase4i 10 LVecBase4i 0 0 0 1 2772 2841 5 3860 3861 3862 3863 3864 68 2773 2774 2775 2776 2777 2778 2779 2780 2781 2782 2783 2784 2785 2786 2787 2788 2789 2790 2791 2792 2793 2794 2795 2796 2797 2798 2799 2800 2801 2802 2803 2804 2805 2806 2807 2808 2809 2810 2811 2812 2813 2814 2815 2816 2817 2818 2819 2820 2821 2822 2823 2824 2825 2826 2827 2828 2829 2830 2831 2832 2833 2834 2835 2836 2837 2838 2839 2840 0 0 0 0 1 3517 77
/**
 * This is the base class for all three-component vectors and points.
 */

3517 0 0 794624 12 LVecBase4i:: 0 3516 0 0 0 0 0 0 0 0 0 2 14 num_components 26 LVecBase4i::num_components 0
4 6 is_int 18 LVecBase4i::is_int 0
1 0 0

3518 19 UnalignedLVecBase4i 0 141313 19 UnalignedLVecBase4i 19 UnalignedLVecBase4i 0 0 0 1 2842 2850 0 7 2843 2844 2845 2846 2847 2848 2849 0 0 0 0 1 3519 391
/**
 * This is an "unaligned" LVecBase4.  It has no functionality other than to
 * store numbers, and it will pack them in as tightly as possible, avoiding
 * any SSE2 alignment requirements shared by the primary LVecBase4 class.
 *
 * Use it only when you need to pack numbers tightly without respect to
 * alignment, and then copy it to a proper LVecBase4 to get actual use from
 * it.
 */

3519 0 0 794624 21 UnalignedLVecBase4i:: 0 3518 0 0 0 0 0 0 0 0 0 2 14 num_components 35 UnalignedLVecBase4i::num_components 0
4 6 is_int 27 UnalignedLVecBase4i::is_int 0
1 0 0

3520 9 LVector4f 0 141313 9 LVector4f 9 LVector4f 0 0 0 1 2851 2870 2 3865 3866 18 2852 2853 2854 2855 2856 2857 2858 2859 2860 2861 2862 2863 2864 2865 2866 2867 2868 2869 0 0 1 0 3508 0 0 0 0 52
/**
 * This is a four-component vector distance.
 */

3521 9 LVector4d 0 141313 9 LVector4d 9 LVector4d 0 0 0 1 2871 2890 2 3867 3868 18 2872 2873 2874 2875 2876 2877 2878 2879 2880 2881 2882 2883 2884 2885 2886 2887 2888 2889 0 0 1 0 3512 0 0 0 0 52
/**
 * This is a four-component vector distance.
 */

3522 9 LVector4i 0 141313 9 LVector4i 9 LVector4i 0 0 0 1 2891 2908 2 3869 3870 16 2892 2893 2894 2895 2896 2897 2898 2899 2900 2901 2902 2903 2904 2905 2906 2907 0 0 1 0 3516 0 0 0 0 52
/**
 * This is a four-component vector distance.
 */

3523 8 LPoint4f 0 141313 8 LPoint4f 8 LPoint4f 0 0 0 1 2909 2928 2 3871 3872 18 2910 2911 2912 2913 2914 2915 2916 2917 2918 2919 2920 2921 2922 2923 2924 2925 2926 2927 0 0 1 0 3508 0 0 0 0 51
/**
 * This is a four-component point in space.
 */

3524 8 LPoint4d 0 141313 8 LPoint4d 8 LPoint4d 0 0 0 1 2929 2948 2 3873 3874 18 2930 2931 2932 2933 2934 2935 2936 2937 2938 2939 2940 2941 2942 2943 2944 2945 2946 2947 0 0 1 0 3512 0 0 0 0 51
/**
 * This is a four-component point in space.
 */

3525 8 LPoint4i 0 141313 8 LPoint4i 8 LPoint4i 0 0 0 1 2949 2966 2 3875 3876 16 2950 2951 2952 2953 2954 2955 2956 2957 2958 2959 2960 2961 2962 2963 2964 2965 0 0 1 0 3516 0 0 0 0 51
/**
 * This is a four-component point in space.
 */

3526 9 LMatrix3f 0 141313 9 LMatrix3f 9 LMatrix3f 0 0 0 1 2975 3052 2 3877 3878 74 2976 2977 2978 2979 2980 2981 2982 2983 2984 2985 2986 2987 2988 2991 2992 2993 2994 2995 2996 2997 2998 2999 3000 3001 3002 3003 3004 3005 3006 3007 3008 3009 3010 3011 3012 3013 3014 3015 3016 3017 3018 3019 3020 3021 3022 3023 3024 3025 3026 3027 3028 3029 3030 3031 3032 3033 3034 3035 3036 3037 3038 3039 3040 3041 3042 3043 3044 3045 3046 3047 3048 3049 3050 3051 4 3885 3886 3887 3888 0 0 0 3 3527 3528 3529 231
/**
 * This is a 3-by-3 transform matrix.  It typically will represent either a
 * rotation-and-scale (no translation) matrix in 3-d, or a full affine matrix
 * (rotation, scale, translation) in 2-d, e.g.  for a texture matrix.
 */

3527 0 0 794624 11 LMatrix3f:: 0 3526 0 0 0 0 0 0 0 0 0 2 14 num_components 25 LMatrix3f::num_components 0
9 6 is_int 17 LMatrix3f::is_int 0
0 0 0

3528 3 Row 0 403457 14 LMatrix3f::Row 14 LMatrix3f::Row 3526 0 0 1 2969 2970 0 2 2967 2968 0 0 0 0 0 66
// These helper classes are used to support two-level operator [].

3529 4 CRow 0 403457 15 LMatrix3f::CRow 15 LMatrix3f::CRow 3526 0 0 1 2973 2974 0 2 2971 2972 0 0 0 0 0 0

3530 9 LMatrix4f 0 141313 9 LMatrix4f 9 LMatrix4f 0 0 0 1 3063 3150 2 3879 3880 84 3064 3065 3066 3067 3068 3069 3070 3071 3072 3073 3074 3075 3076 3077 3078 3079 3082 3083 3084 3085 3086 3087 3088 3089 3090 3091 3092 3093 3094 3095 3096 3097 3098 3099 3100 3101 3102 3103 3104 3105 3106 3107 3108 3109 3110 3111 3112 3113 3114 3115 3116 3117 3118 3119 3120 3121 3122 3123 3124 3125 3126 3127 3128 3129 3130 3131 3132 3133 3134 3135 3136 3137 3138 3139 3140 3141 3142 3143 3144 3145 3146 3147 3148 3149 3 3889 3890 3891 0 0 0 3 3531 3532 3533 45
/**
 * This is a 4-by-4 transform matrix.
 */

3531 0 0 794624 11 LMatrix4f:: 0 3530 0 0 0 0 0 0 0 0 0 2 14 num_components 25 LMatrix4f::num_components 0
16 6 is_int 17 LMatrix4f::is_int 0
0 0 0

3532 3 Row 0 403457 14 LMatrix4f::Row 14 LMatrix4f::Row 3530 0 0 1 3057 3058 0 2 3055 3056 0 0 0 0 0 66
// These helper classes are used to support two-level operator [].

3533 4 CRow 0 403457 15 LMatrix4f::CRow 15 LMatrix4f::CRow 3530 0 0 1 3061 3062 0 2 3059 3060 0 0 0 0 0 0

3534 18 UnalignedLMatrix4f 0 141313 18 UnalignedLMatrix4f 18 UnalignedLMatrix4f 0 0 0 1 3151 3158 0 6 3152 3153 3154 3155 3156 3157 0 0 0 0 1 3535 385
/**
 * This is an "unaligned" LMatrix4.  It has no functionality other than to
 * store numbers, and it will pack them in as tightly as possible, avoiding
 * any SSE2 alignment requirements shared by the primary LMatrix4 class.
 *
 * Use it only when you need to pack numbers tightly without respect to
 * alignment, and then copy it to a proper LMatrix4 to get actual use from it.
 */

3535 0 0 794624 20 UnalignedLMatrix4f:: 0 3534 0 0 0 0 0 0 0 0 0 1 14 num_components 34 UnalignedLMatrix4f::num_components 0
16 0 0

3536 9 LMatrix3d 0 141313 9 LMatrix3d 9 LMatrix3d 0 0 0 1 3167 3244 2 3881 3882 74 3168 3169 3170 3171 3172 3173 3174 3175 3176 3177 3178 3179 3180 3183 3184 3185 3186 3187 3188 3189 3190 3191 3192 3193 3194 3195 3196 3197 3198 3199 3200 3201 3202 3203 3204 3205 3206 3207 3208 3209 3210 3211 3212 3213 3214 3215 3216 3217 3218 3219 3220 3221 3222 3223 3224 3225 3226 3227 3228 3229 3230 3231 3232 3233 3234 3235 3236 3237 3238 3239 3240 3241 3242 3243 4 3892 3893 3894 3895 0 0 0 3 3537 3538 3539 231
/**
 * This is a 3-by-3 transform matrix.  It typically will represent either a
 * rotation-and-scale (no translation) matrix in 3-d, or a full affine matrix
 * (rotation, scale, translation) in 2-d, e.g.  for a texture matrix.
 */

3537 0 0 794624 11 LMatrix3d:: 0 3536 0 0 0 0 0 0 0 0 0 2 14 num_components 25 LMatrix3d::num_components 0
9 6 is_int 17 LMatrix3d::is_int 0
0 0 0

3538 3 Row 0 403457 14 LMatrix3d::Row 14 LMatrix3d::Row 3536 0 0 1 3161 3162 0 2 3159 3160 0 0 0 0 0 66
// These helper classes are used to support two-level operator [].

3539 4 CRow 0 403457 15 LMatrix3d::CRow 15 LMatrix3d::CRow 3536 0 0 1 3165 3166 0 2 3163 3164 0 0 0 0 0 0

3540 9 LMatrix4d 0 141313 9 LMatrix4d 9 LMatrix4d 0 0 0 1 3253 3340 2 3883 3884 84 3254 3255 3256 3257 3258 3259 3260 3261 3262 3263 3264 3265 3266 3267 3268 3269 3272 3273 3274 3275 3276 3277 3278 3279 3280 3281 3282 3283 3284 3285 3286 3287 3288 3289 3290 3291 3292 3293 3294 3295 3296 3297 3298 3299 3300 3301 3302 3303 3304 3305 3306 3307 3308 3309 3310 3311 3312 3313 3314 3315 3316 3317 3318 3319 3320 3321 3322 3323 3324 3325 3326 3327 3328 3329 3330 3331 3332 3333 3334 3335 3336 3337 3338 3339 3 3896 3897 3898 0 0 0 3 3541 3542 3543 45
/**
 * This is a 4-by-4 transform matrix.
 */

3541 0 0 794624 11 LMatrix4d:: 0 3540 0 0 0 0 0 0 0 0 0 2 14 num_components 25 LMatrix4d::num_components 0
16 6 is_int 17 LMatrix4d::is_int 0
0 0 0

3542 3 Row 0 403457 14 LMatrix4d::Row 14 LMatrix4d::Row 3540 0 0 1 3247 3248 0 2 3245 3246 0 0 0 0 0 66
// These helper classes are used to support two-level operator [].

3543 4 CRow 0 403457 15 LMatrix4d::CRow 15 LMatrix4d::CRow 3540 0 0 1 3251 3252 0 2 3249 3250 0 0 0 0 0 0

3544 18 UnalignedLMatrix4d 0 141313 18 UnalignedLMatrix4d 18 UnalignedLMatrix4d 0 0 0 1 3341 3348 0 6 3342 3343 3344 3345 3346 3347 0 0 0 0 1 3545 385
/**
 * This is an "unaligned" LMatrix4.  It has no functionality other than to
 * store numbers, and it will pack them in as tightly as possible, avoiding
 * any SSE2 alignment requirements shared by the primary LMatrix4 class.
 *
 * Use it only when you need to pack numbers tightly without respect to
 * alignment, and then copy it to a proper LMatrix4 to get actual use from it.
 */

3545 0 0 794624 20 UnalignedLMatrix4d:: 0 3544 0 0 0 0 0 0 0 0 0 1 14 num_components 34 UnalignedLMatrix4d::num_components 0
16 0 0

3546 12 LQuaternionf 0 141313 12 LQuaternionf 12 LQuaternionf 0 0 0 1 3357 3404 0 46 3358 3359 3360 3361 3362 3363 3364 3365 3366 3367 3368 3369 3370 3371 3372 3373 3374 3375 3376 3377 3378 3379 3380 3381 3382 3383 3384 3385 3386 3387 3388 3389 3390 3391 3392 3393 3394 3395 3396 3397 3398 3399 3400 3401 3402 3403 0 0 1 0 3508 0 0 0 0 44
/**
 * This is the base quaternion class
 */

3547 12 LQuaterniond 0 141313 12 LQuaterniond 12 LQuaterniond 0 0 0 1 3405 3452 0 46 3406 3407 3408 3409 3410 3411 3412 3413 3414 3415 3416 3417 3418 3419 3420 3421 3422 3423 3424 3425 3426 3427 3428 3429 3430 3431 3432 3433 3434 3435 3436 3437 3438 3439 3440 3441 3442 3443 3444 3445 3446 3447 3448 3449 3450 3451 0 0 1 0 3512 0 0 0 0 44
/**
 * This is the base quaternion class
 */

3548 10 LRotationf 0 141313 10 LRotationf 10 LRotationf 0 0 0 1 3453 3457 0 3 3454 3455 3456 0 0 1 0 3546 0 0 0 0 61
/**
 * This is a unit quaternion representing a rotation.
 */

3549 10 LRotationd 0 141313 10 LRotationd 10 LRotationd 0 0 0 1 3458 3462 0 3 3459 3460 3461 0 0 1 0 3547 0 0 0 0 61
/**
 * This is a unit quaternion representing a rotation.
 */

3550 13 LOrientationf 0 141313 13 LOrientationf 13 LOrientationf 0 0 0 1 3463 3466 0 2 3464 3465 0 0 1 0 3546 0 0 0 0 65
/**
 * This is a unit quaternion representing an orientation.
 */

3551 13 LOrientationd 0 141313 13 LOrientationd 13 LOrientationd 0 0 0 1 3467 3470 0 2 3468 3469 0 0 1 0 3547 0 0 0 0 65
/**
 * This is a unit quaternion representing an orientation.
 */

3552 8 LVertexf 0 2105345 8 LVertexf 8 LVertexf 0 0 3505 0 0 0 0 0 0 0 0 0 0

3553 8 LNormalf 0 2105345 8 LNormalf 8 LNormalf 0 0 3502 0 0 0 0 0 0 0 0 0 0

3554 10 LTexCoordf 0 2105345 10 LTexCoordf 10 LTexCoordf 0 0 3492 0 0 0 0 0 0 0 0 0 0

3555 11 LTexCoord3f 0 2105345 11 LTexCoord3f 11 LTexCoord3f 0 0 3505 0 0 0 0 0 0 0 0 0 0

3556 7 LColorf 0 2105345 7 LColorf 7 LColorf 0 0 3508 0 0 0 0 0 0 0 0 0 0

3557 10 LRGBColorf 0 2105345 10 LRGBColorf 10 LRGBColorf 0 0 3495 0 0 0 0 0 0 0 0 0 0

3558 8 LVertexd 0 2105345 8 LVertexd 8 LVertexd 0 0 3506 0 0 0 0 0 0 0 0 0 0

3559 8 LNormald 0 2105345 8 LNormald 8 LNormald 0 0 3503 0 0 0 0 0 0 0 0 0 0

3560 10 LTexCoordd 0 2105345 10 LTexCoordd 10 LTexCoordd 0 0 3493 0 0 0 0 0 0 0 0 0 0

3561 11 LTexCoord3d 0 2105345 11 LTexCoord3d 11 LTexCoord3d 0 0 3506 0 0 0 0 0 0 0 0 0 0

3562 7 LColord 0 2105345 7 LColord 7 LColord 0 0 3512 0 0 0 0 0 0 0 0 0 0

3563 10 LRGBColord 0 2105345 10 LRGBColord 10 LRGBColord 0 0 3497 0 0 0 0 0 0 0 0 0 0

3564 5 Mat4F 0 2105345 5 Mat4F 5 Mat4F 0 0 3530 0 0 0 0 0 0 0 0 0 0

3565 5 Mat3F 0 2105345 5 Mat3F 5 Mat3F 0 0 3526 0 0 0 0 0 0 0 0 0 0

3566 7 VBase4F 0 2105345 7 VBase4F 7 VBase4F 0 0 3508 0 0 0 0 0 0 0 0 0 0

3567 5 Vec4F 0 2105345 5 Vec4F 5 Vec4F 0 0 3520 0 0 0 0 0 0 0 0 0 0

3568 7 Point4F 0 2105345 7 Point4F 7 Point4F 0 0 3523 0 0 0 0 0 0 0 0 0 0

3569 7 VBase3F 0 2105345 7 VBase3F 7 VBase3F 0 0 3495 0 0 0 0 0 0 0 0 0 0

3570 5 Vec3F 0 2105345 5 Vec3F 5 Vec3F 0 0 3502 0 0 0 0 0 0 0 0 0 0

3571 7 Point3F 0 2105345 7 Point3F 7 Point3F 0 0 3505 0 0 0 0 0 0 0 0 0 0

3572 7 VBase2F 0 2105345 7 VBase2F 7 VBase2F 0 0 3480 0 0 0 0 0 0 0 0 0 0

3573 5 Vec2F 0 2105345 5 Vec2F 5 Vec2F 0 0 3489 0 0 0 0 0 0 0 0 0 0

3574 7 Point2F 0 2105345 7 Point2F 7 Point2F 0 0 3492 0 0 0 0 0 0 0 0 0 0

3575 5 QuatF 0 2105345 5 QuatF 5 QuatF 0 0 3546 0 0 0 0 0 0 0 0 0 0

3576 5 Mat4D 0 2105345 5 Mat4D 5 Mat4D 0 0 3540 0 0 0 0 0 0 0 0 0 0

3577 5 Mat3D 0 2105345 5 Mat3D 5 Mat3D 0 0 3536 0 0 0 0 0 0 0 0 0 0

3578 7 VBase4D 0 2105345 7 VBase4D 7 VBase4D 0 0 3512 0 0 0 0 0 0 0 0 0 0

3579 5 Vec4D 0 2105345 5 Vec4D 5 Vec4D 0 0 3521 0 0 0 0 0 0 0 0 0 0

3580 7 Point4D 0 2105345 7 Point4D 7 Point4D 0 0 3524 0 0 0 0 0 0 0 0 0 0

3581 7 VBase3D 0 2105345 7 VBase3D 7 VBase3D 0 0 3497 0 0 0 0 0 0 0 0 0 0

3582 5 Vec3D 0 2105345 5 Vec3D 5 Vec3D 0 0 3503 0 0 0 0 0 0 0 0 0 0

3583 7 Point3D 0 2105345 7 Point3D 7 Point3D 0 0 3506 0 0 0 0 0 0 0 0 0 0

3584 7 VBase2D 0 2105345 7 VBase2D 7 VBase2D 0 0 3483 0 0 0 0 0 0 0 0 0 0

3585 5 Vec2D 0 2105345 5 Vec2D 5 Vec2D 0 0 3490 0 0 0 0 0 0 0 0 0 0

3586 7 Point2D 0 2105345 7 Point2D 7 Point2D 0 0 3493 0 0 0 0 0 0 0 0 0 0

3587 5 QuatD 0 2105345 5 QuatD 5 QuatD 0 0 3547 0 0 0 0 0 0 0 0 0 0

3588 9 LVecBase2 0 2105345 9 LVecBase2 9 LVecBase2 0 0 3480 0 0 0 0 0 0 0 0 0 0

3589 7 LPoint2 0 2105345 7 LPoint2 7 LPoint2 0 0 3492 0 0 0 0 0 0 0 0 0 0

3590 8 LVector2 0 2105345 8 LVector2 8 LVector2 0 0 3489 0 0 0 0 0 0 0 0 0 0

3591 9 LVecBase3 0 2105345 9 LVecBase3 9 LVecBase3 0 0 3495 0 0 0 0 0 0 0 0 0 0

3592 7 LPoint3 0 2105345 7 LPoint3 7 LPoint3 0 0 3505 0 0 0 0 0 0 0 0 0 0

3593 8 LVector3 0 2105345 8 LVector3 8 LVector3 0 0 3502 0 0 0 0 0 0 0 0 0 0

3594 9 LVecBase4 0 2105345 9 LVecBase4 9 LVecBase4 0 0 3508 0 0 0 0 0 0 0 0 0 0

3595 7 LPoint4 0 2105345 7 LPoint4 7 LPoint4 0 0 3523 0 0 0 0 0 0 0 0 0 0

3596 8 LVector4 0 2105345 8 LVector4 8 LVector4 0 0 3520 0 0 0 0 0 0 0 0 0 0

3597 11 LQuaternion 0 2105345 11 LQuaternion 11 LQuaternion 0 0 3546 0 0 0 0 0 0 0 0 0 0

3598 9 LRotation 0 2105345 9 LRotation 9 LRotation 0 0 3548 0 0 0 0 0 0 0 0 0 0

3599 12 LOrientation 0 2105345 12 LOrientation 12 LOrientation 0 0 3550 0 0 0 0 0 0 0 0 0 0

3600 8 LMatrix3 0 2105345 8 LMatrix3 8 LMatrix3 0 0 3526 0 0 0 0 0 0 0 0 0 0

3601 8 LMatrix4 0 2105345 8 LMatrix4 8 LMatrix4 0 0 3530 0 0 0 0 0 0 0 0 0 0

3602 7 LVertex 0 2105345 7 LVertex 7 LVertex 0 0 3552 0 0 0 0 0 0 0 0 0 0

3603 7 LNormal 0 2105345 7 LNormal 7 LNormal 0 0 3553 0 0 0 0 0 0 0 0 0 0

3604 9 LTexCoord 0 2105345 9 LTexCoord 9 LTexCoord 0 0 3554 0 0 0 0 0 0 0 0 0 0

3605 10 LTexCoord3 0 2105345 10 LTexCoord3 10 LTexCoord3 0 0 3555 0 0 0 0 0 0 0 0 0 0

3606 6 LColor 0 2105345 6 LColor 6 LColor 0 0 3556 0 0 0 0 0 0 0 0 0 0

3607 9 LRGBColor 0 2105345 9 LRGBColor 9 LRGBColor 0 0 3557 0 0 0 0 0 0 0 0 0 0

3608 18 UnalignedLVecBase4 0 2105345 18 UnalignedLVecBase4 18 UnalignedLVecBase4 0 0 3510 0 0 0 0 0 0 0 0 0 0

3609 17 UnalignedLMatrix4 0 2105345 17 UnalignedLMatrix4 17 UnalignedLMatrix4 0 0 3534 0 0 0 0 0 0 0 0 0 0

3610 4 Mat4 0 2105345 4 Mat4 4 Mat4 0 0 3530 0 0 0 0 0 0 0 0 0 0

3611 4 Mat3 0 2105345 4 Mat3 4 Mat3 0 0 3526 0 0 0 0 0 0 0 0 0 0

3612 6 VBase4 0 2105345 6 VBase4 6 VBase4 0 0 3508 0 0 0 0 0 0 0 0 0 0

3613 4 Vec4 0 2105345 4 Vec4 4 Vec4 0 0 3520 0 0 0 0 0 0 0 0 0 0

3614 6 Point4 0 2105345 6 Point4 6 Point4 0 0 3523 0 0 0 0 0 0 0 0 0 0

3615 6 VBase3 0 2105345 6 VBase3 6 VBase3 0 0 3495 0 0 0 0 0 0 0 0 0 0

3616 4 Vec3 0 2105345 4 Vec3 4 Vec3 0 0 3502 0 0 0 0 0 0 0 0 0 0

3617 6 Point3 0 2105345 6 Point3 6 Point3 0 0 3505 0 0 0 0 0 0 0 0 0 0

3618 6 VBase2 0 2105345 6 VBase2 6 VBase2 0 0 3480 0 0 0 0 0 0 0 0 0 0

3619 4 Vec2 0 2105345 4 Vec2 4 Vec2 0 0 3489 0 0 0 0 0 0 0 0 0 0

3620 6 Point2 0 2105345 6 Point2 6 Point2 0 0 3492 0 0 0 0 0 0 0 0 0 0

3621 4 Quat 0 2105345 4 Quat 4 Quat 0 0 3546 0 0 0 0 0 0 0 0 0 0

3622 19 ConfigVariableColor 0 141313 19 ConfigVariableColor 19 ConfigVariableColor 0 0 0 1 3471 3478 0 5 3472 3474 3475 3476 3477 0 1 3473 1 0 3623 0 0 0 0 538
/**
 * This is a convenience class to specialize ConfigVariable as a set of
 * floating-point types representing a color value.
 *
 * It interprets the color differently depending on how many words were
 * specified: if only one, it is interpreted as a shade of gray with alpha 1.
 * If two values were specified, a grayscale and alpha pair.  If three, a set
 * of R, G, B values with alpha 1, and if four, a complete RGBA color.
 *
 * This isn't defined in dtool because it relies on the LColor class, which is
 * defined in linmath.
 */

3623 14 ConfigVariable 0 2049 14 ConfigVariable 14 ConfigVariable 0 0 0 0 0 0 0 0 0 0 0 0 415
/**
 * This is a generic, untyped ConfigVariable.  It is also the base class for
 * the typed ConfigVariables, and contains all of the code common to
 * ConfigVariables of all types (except ConfigVariableList, which is a bit of
 * a special case).
 *
 * Mostly, this class serves as a thin wrapper around ConfigVariableCore
 * and/or ConfigDeclaration, more or less duplicating the interface presented
 * there.
 */

3624 13 MathNumbers * 0 8576 13 MathNumbers * 13 MathNumbers * 0 0 3479 0 0 0 0 0 0 0 0 0 0

3625 19 MathNumbers const * 0 8576 19 MathNumbers const * 19 MathNumbers const * 0 0 3626 0 0 0 0 0 0 0 0 0 0

3626 17 MathNumbers const 0 8832 17 MathNumbers const 17 MathNumbers const 0 0 3479 0 0 0 0 0 0 0 0 0 0

3627 12 LVecBase2f * 0 8576 12 LVecBase2f * 12 LVecBase2f * 0 0 3480 0 0 0 0 0 0 0 0 0 0

3628 18 LVecBase2f const * 0 8576 18 LVecBase2f const * 18 LVecBase2f const * 0 0 3629 0 0 0 0 0 0 0 0 0 0

3629 16 LVecBase2f const 0 8832 16 LVecBase2f const 16 LVecBase2f const 0 0 3480 0 0 0 0 0 0 0 0 0 0

3630 6 size_t 0 2105344 11 std::size_t 11 std::size_t 0 0 3631 0 0 0 0 0 0 0 0 0 0

3631 22 unsigned long long int 0 8230 22 unsigned long long int 22 unsigned long long int 0 8 0 0 0 0 0 0 0 0 0 0 0

3632 4 void 0 8194 4 void 4 void 0 6 0 0 0 0 0 0 0 0 0 0 0

3633 10 PyObject * 0 8576 10 PyObject * 10 PyObject * 0 0 3634 0 0 0 0 0 0 0 0 0 0

3634 8 PyObject 0 2105344 8 PyObject 8 PyObject 0 0 3635 0 0 0 0 0 0 0 0 0 0

3635 7 _object 0 1024 7 _object 7 _object 0 0 0 0 0 0 0 0 0 0 0 0 0

3636 13 atomic string 0 2 13 atomic string 13 atomic string 0 7 0 0 0 0 0 0 0 0 0 0 0

3637 4 bool 0 8194 4 bool 4 bool 0 4 0 0 0 0 0 0 0 0 0 0 0

3638 23 ChecksumHashGenerator * 0 8576 23 ChecksumHashGenerator * 23 ChecksumHashGenerator * 0 0 3639 0 0 0 0 0 0 0 0 0 0

3639 21 ChecksumHashGenerator 0 2048 21 ChecksumHashGenerator 21 ChecksumHashGenerator 0 0 0 0 0 0 0 0 0 0 0 0 125
/**
 * This is a specific kind of HashGenerator that simply adds up all of the
 * ints.  Nothing fancy, and pretty quick.
 */

3640 9 ostream * 0 8576 9 ostream * 9 ostream * 0 0 3641 0 0 0 0 0 0 0 0 0 0

3641 7 ostream 0 2048 7 ostream 7 ostream 0 0 0 0 0 0 0 0 0 0 0 0 0

3642 10 Datagram * 0 8576 10 Datagram * 10 Datagram * 0 0 3643 0 0 0 0 0 0 0 0 0 0

3643 8 Datagram 0 2048 8 Datagram 8 Datagram 0 0 0 0 0 0 0 0 0 0 0 0 565
/**
 * An ordered list of data elements, formatted in memory for transmission over
 * a socket or writing to a data file.
 *
 * Data elements should be added one at a time, in order, to the Datagram.
 * The nature and contents of the data elements are totally up to the user.
 * When a Datagram has been transmitted and received, its data elements may be
 * extracted using a DatagramIterator; it is up to the caller to know the
 * correct type of each data element in order.
 *
 * A Datagram is itself headerless; it is simply a collection of data
 * elements.
 */

3644 18 DatagramIterator * 0 8576 18 DatagramIterator * 18 DatagramIterator * 0 0 3645 0 0 0 0 0 0 0 0 0 0

3645 16 DatagramIterator 0 2048 16 DatagramIterator 16 DatagramIterator 0 0 0 0 0 0 0 0 0 0 0 0 215
/**
 * A class to retrieve the individual data elements previously stored in a
 * Datagram.  Elements may be retrieved one at a time; it is up to the caller
 * to know the correct type and order of each element.
 */

3646 10 TypeHandle 0 16779264 10 TypeHandle 10 TypeHandle 0 0 0 0 0 0 0 0 0 0 0 0 732
/**
 * TypeHandle is the identifier used to differentiate C++ class types.  Any
 * C++ classes that inherit from some base class, and must be differentiated
 * at run time, should store a static TypeHandle object that can be queried
 * through a static member function named get_class_type().  Most of the time,
 * it is also desirable to inherit from TypedObject, which provides some
 * virtual functions to return the TypeHandle for a particular instance.
 *
 * At its essence, a TypeHandle is simply a unique identifier that is assigned
 * by the TypeRegistry.  The TypeRegistry stores a tree of TypeHandles, so
 * that ancestry of a particular type may be queried, and the type name may be
 * retrieved for run-time display.
 */

3647 12 TypeHandle * 0 8576 12 TypeHandle * 12 TypeHandle * 0 0 3646 0 0 0 0 0 0 0 0 0 0

3648 12 LVecBase2d * 0 8576 12 LVecBase2d * 12 LVecBase2d * 0 0 3483 0 0 0 0 0 0 0 0 0 0

3649 18 LVecBase2d const * 0 8576 18 LVecBase2d const * 18 LVecBase2d const * 0 0 3650 0 0 0 0 0 0 0 0 0 0

3650 16 LVecBase2d const 0 8832 16 LVecBase2d const 16 LVecBase2d const 0 0 3483 0 0 0 0 0 0 0 0 0 0

3651 12 LVecBase2i * 0 8576 12 LVecBase2i * 12 LVecBase2i * 0 0 3486 0 0 0 0 0 0 0 0 0 0

3652 18 LVecBase2i const * 0 8576 18 LVecBase2i const * 18 LVecBase2i const * 0 0 3653 0 0 0 0 0 0 0 0 0 0

3653 16 LVecBase2i const 0 8832 16 LVecBase2i const 16 LVecBase2i const 0 0 3486 0 0 0 0 0 0 0 0 0 0

3654 11 LVector2f * 0 8576 11 LVector2f * 11 LVector2f * 0 0 3489 0 0 0 0 0 0 0 0 0 0

3655 17 LVector2f const * 0 8576 17 LVector2f const * 17 LVector2f const * 0 0 3656 0 0 0 0 0 0 0 0 0 0

3656 15 LVector2f const 0 8832 15 LVector2f const 15 LVector2f const 0 0 3489 0 0 0 0 0 0 0 0 0 0

3657 11 LVector2d * 0 8576 11 LVector2d * 11 LVector2d * 0 0 3490 0 0 0 0 0 0 0 0 0 0

3658 17 LVector2d const * 0 8576 17 LVector2d const * 17 LVector2d const * 0 0 3659 0 0 0 0 0 0 0 0 0 0

3659 15 LVector2d const 0 8832 15 LVector2d const 15 LVector2d const 0 0 3490 0 0 0 0 0 0 0 0 0 0

3660 11 LVector2i * 0 8576 11 LVector2i * 11 LVector2i * 0 0 3491 0 0 0 0 0 0 0 0 0 0

3661 17 LVector2i const * 0 8576 17 LVector2i const * 17 LVector2i const * 0 0 3662 0 0 0 0 0 0 0 0 0 0

3662 15 LVector2i const 0 8832 15 LVector2i const 15 LVector2i const 0 0 3491 0 0 0 0 0 0 0 0 0 0

3663 10 LPoint2f * 0 8576 10 LPoint2f * 10 LPoint2f * 0 0 3492 0 0 0 0 0 0 0 0 0 0

3664 16 LPoint2f const * 0 8576 16 LPoint2f const * 16 LPoint2f const * 0 0 3665 0 0 0 0 0 0 0 0 0 0

3665 14 LPoint2f const 0 8832 14 LPoint2f const 14 LPoint2f const 0 0 3492 0 0 0 0 0 0 0 0 0 0

3666 10 LPoint2d * 0 8576 10 LPoint2d * 10 LPoint2d * 0 0 3493 0 0 0 0 0 0 0 0 0 0

3667 16 LPoint2d const * 0 8576 16 LPoint2d const * 16 LPoint2d const * 0 0 3668 0 0 0 0 0 0 0 0 0 0

3668 14 LPoint2d const 0 8832 14 LPoint2d const 14 LPoint2d const 0 0 3493 0 0 0 0 0 0 0 0 0 0

3669 10 LPoint2i * 0 8576 10 LPoint2i * 10 LPoint2i * 0 0 3494 0 0 0 0 0 0 0 0 0 0

3670 16 LPoint2i const * 0 8576 16 LPoint2i const * 16 LPoint2i const * 0 0 3671 0 0 0 0 0 0 0 0 0 0

3671 14 LPoint2i const 0 8832 14 LPoint2i const 14 LPoint2i const 0 0 3494 0 0 0 0 0 0 0 0 0 0

3672 12 LVecBase3f * 0 8576 12 LVecBase3f * 12 LVecBase3f * 0 0 3495 0 0 0 0 0 0 0 0 0 0

3673 18 LVecBase3f const * 0 8576 18 LVecBase3f const * 18 LVecBase3f const * 0 0 3674 0 0 0 0 0 0 0 0 0 0

3674 16 LVecBase3f const 0 8832 16 LVecBase3f const 16 LVecBase3f const 0 0 3495 0 0 0 0 0 0 0 0 0 0

3675 12 LVecBase3d * 0 8576 12 LVecBase3d * 12 LVecBase3d * 0 0 3497 0 0 0 0 0 0 0 0 0 0

3676 18 LVecBase3d const * 0 8576 18 LVecBase3d const * 18 LVecBase3d const * 0 0 3677 0 0 0 0 0 0 0 0 0 0

3677 16 LVecBase3d const 0 8832 16 LVecBase3d const 16 LVecBase3d const 0 0 3497 0 0 0 0 0 0 0 0 0 0

3678 12 LVecBase3i * 0 8576 12 LVecBase3i * 12 LVecBase3i * 0 0 3499 0 0 0 0 0 0 0 0 0 0

3679 18 LVecBase3i const * 0 8576 18 LVecBase3i const * 18 LVecBase3i const * 0 0 3680 0 0 0 0 0 0 0 0 0 0

3680 16 LVecBase3i const 0 8832 16 LVecBase3i const 16 LVecBase3i const 0 0 3499 0 0 0 0 0 0 0 0 0 0

3681 11 LVector3f * 0 8576 11 LVector3f * 11 LVector3f * 0 0 3502 0 0 0 0 0 0 0 0 0 0

3682 17 LVector3f const * 0 8576 17 LVector3f const * 17 LVector3f const * 0 0 3683 0 0 0 0 0 0 0 0 0 0

3683 15 LVector3f const 0 8832 15 LVector3f const 15 LVector3f const 0 0 3502 0 0 0 0 0 0 0 0 0 0

3684 11 LVector3d * 0 8576 11 LVector3d * 11 LVector3d * 0 0 3503 0 0 0 0 0 0 0 0 0 0

3685 17 LVector3d const * 0 8576 17 LVector3d const * 17 LVector3d const * 0 0 3686 0 0 0 0 0 0 0 0 0 0

3686 15 LVector3d const 0 8832 15 LVector3d const 15 LVector3d const 0 0 3503 0 0 0 0 0 0 0 0 0 0

3687 11 LVector3i * 0 8576 11 LVector3i * 11 LVector3i * 0 0 3504 0 0 0 0 0 0 0 0 0 0

3688 17 LVector3i const * 0 8576 17 LVector3i const * 17 LVector3i const * 0 0 3689 0 0 0 0 0 0 0 0 0 0

3689 15 LVector3i const 0 8832 15 LVector3i const 15 LVector3i const 0 0 3504 0 0 0 0 0 0 0 0 0 0

3690 10 LPoint3f * 0 8576 10 LPoint3f * 10 LPoint3f * 0 0 3505 0 0 0 0 0 0 0 0 0 0

3691 16 LPoint3f const * 0 8576 16 LPoint3f const * 16 LPoint3f const * 0 0 3692 0 0 0 0 0 0 0 0 0 0

3692 14 LPoint3f const 0 8832 14 LPoint3f const 14 LPoint3f const 0 0 3505 0 0 0 0 0 0 0 0 0 0

3693 10 LPoint3d * 0 8576 10 LPoint3d * 10 LPoint3d * 0 0 3506 0 0 0 0 0 0 0 0 0 0

3694 16 LPoint3d const * 0 8576 16 LPoint3d const * 16 LPoint3d const * 0 0 3695 0 0 0 0 0 0 0 0 0 0

3695 14 LPoint3d const 0 8832 14 LPoint3d const 14 LPoint3d const 0 0 3506 0 0 0 0 0 0 0 0 0 0

3696 10 LPoint3i * 0 8576 10 LPoint3i * 10 LPoint3i * 0 0 3507 0 0 0 0 0 0 0 0 0 0

3697 16 LPoint3i const * 0 8576 16 LPoint3i const * 16 LPoint3i const * 0 0 3698 0 0 0 0 0 0 0 0 0 0

3698 14 LPoint3i const 0 8832 14 LPoint3i const 14 LPoint3i const 0 0 3507 0 0 0 0 0 0 0 0 0 0

3699 12 LVecBase4f * 0 8576 12 LVecBase4f * 12 LVecBase4f * 0 0 3508 0 0 0 0 0 0 0 0 0 0

3700 18 LVecBase4f const * 0 8576 18 LVecBase4f const * 18 LVecBase4f const * 0 0 3701 0 0 0 0 0 0 0 0 0 0

3701 16 LVecBase4f const 0 8832 16 LVecBase4f const 16 LVecBase4f const 0 0 3508 0 0 0 0 0 0 0 0 0 0

3702 27 UnalignedLVecBase4f const * 0 8576 27 UnalignedLVecBase4f const * 27 UnalignedLVecBase4f const * 0 0 3703 0 0 0 0 0 0 0 0 0 0

3703 25 UnalignedLVecBase4f const 0 8832 25 UnalignedLVecBase4f const 25 UnalignedLVecBase4f const 0 0 3510 0 0 0 0 0 0 0 0 0 0

3704 21 UnalignedLVecBase4f * 0 8576 21 UnalignedLVecBase4f * 21 UnalignedLVecBase4f * 0 0 3510 0 0 0 0 0 0 0 0 0 0

3705 12 LVecBase4d * 0 8576 12 LVecBase4d * 12 LVecBase4d * 0 0 3512 0 0 0 0 0 0 0 0 0 0

3706 18 LVecBase4d const * 0 8576 18 LVecBase4d const * 18 LVecBase4d const * 0 0 3707 0 0 0 0 0 0 0 0 0 0

3707 16 LVecBase4d const 0 8832 16 LVecBase4d const 16 LVecBase4d const 0 0 3512 0 0 0 0 0 0 0 0 0 0

3708 27 UnalignedLVecBase4d const * 0 8576 27 UnalignedLVecBase4d const * 27 UnalignedLVecBase4d const * 0 0 3709 0 0 0 0 0 0 0 0 0 0

3709 25 UnalignedLVecBase4d const 0 8832 25 UnalignedLVecBase4d const 25 UnalignedLVecBase4d const 0 0 3514 0 0 0 0 0 0 0 0 0 0

3710 21 UnalignedLVecBase4d * 0 8576 21 UnalignedLVecBase4d * 21 UnalignedLVecBase4d * 0 0 3514 0 0 0 0 0 0 0 0 0 0

3711 12 LVecBase4i * 0 8576 12 LVecBase4i * 12 LVecBase4i * 0 0 3516 0 0 0 0 0 0 0 0 0 0

3712 18 LVecBase4i const * 0 8576 18 LVecBase4i const * 18 LVecBase4i const * 0 0 3713 0 0 0 0 0 0 0 0 0 0

3713 16 LVecBase4i const 0 8832 16 LVecBase4i const 16 LVecBase4i const 0 0 3516 0 0 0 0 0 0 0 0 0 0

3714 27 UnalignedLVecBase4i const * 0 8576 27 UnalignedLVecBase4i const * 27 UnalignedLVecBase4i const * 0 0 3715 0 0 0 0 0 0 0 0 0 0

3715 25 UnalignedLVecBase4i const 0 8832 25 UnalignedLVecBase4i const 25 UnalignedLVecBase4i const 0 0 3518 0 0 0 0 0 0 0 0 0 0

3716 21 UnalignedLVecBase4i * 0 8576 21 UnalignedLVecBase4i * 21 UnalignedLVecBase4i * 0 0 3518 0 0 0 0 0 0 0 0 0 0

3717 11 LVector4f * 0 8576 11 LVector4f * 11 LVector4f * 0 0 3520 0 0 0 0 0 0 0 0 0 0

3718 17 LVector4f const * 0 8576 17 LVector4f const * 17 LVector4f const * 0 0 3719 0 0 0 0 0 0 0 0 0 0

3719 15 LVector4f const 0 8832 15 LVector4f const 15 LVector4f const 0 0 3520 0 0 0 0 0 0 0 0 0 0

3720 11 LVector4d * 0 8576 11 LVector4d * 11 LVector4d * 0 0 3521 0 0 0 0 0 0 0 0 0 0

3721 17 LVector4d const * 0 8576 17 LVector4d const * 17 LVector4d const * 0 0 3722 0 0 0 0 0 0 0 0 0 0

3722 15 LVector4d const 0 8832 15 LVector4d const 15 LVector4d const 0 0 3521 0 0 0 0 0 0 0 0 0 0

3723 11 LVector4i * 0 8576 11 LVector4i * 11 LVector4i * 0 0 3522 0 0 0 0 0 0 0 0 0 0

3724 17 LVector4i const * 0 8576 17 LVector4i const * 17 LVector4i const * 0 0 3725 0 0 0 0 0 0 0 0 0 0

3725 15 LVector4i const 0 8832 15 LVector4i const 15 LVector4i const 0 0 3522 0 0 0 0 0 0 0 0 0 0

3726 10 LPoint4f * 0 8576 10 LPoint4f * 10 LPoint4f * 0 0 3523 0 0 0 0 0 0 0 0 0 0

3727 16 LPoint4f const * 0 8576 16 LPoint4f const * 16 LPoint4f const * 0 0 3728 0 0 0 0 0 0 0 0 0 0

3728 14 LPoint4f const 0 8832 14 LPoint4f const 14 LPoint4f const 0 0 3523 0 0 0 0 0 0 0 0 0 0

3729 10 LPoint4d * 0 8576 10 LPoint4d * 10 LPoint4d * 0 0 3524 0 0 0 0 0 0 0 0 0 0

3730 16 LPoint4d const * 0 8576 16 LPoint4d const * 16 LPoint4d const * 0 0 3731 0 0 0 0 0 0 0 0 0 0

3731 14 LPoint4d const 0 8832 14 LPoint4d const 14 LPoint4d const 0 0 3524 0 0 0 0 0 0 0 0 0 0

3732 10 LPoint4i * 0 8576 10 LPoint4i * 10 LPoint4i * 0 0 3525 0 0 0 0 0 0 0 0 0 0

3733 16 LPoint4i const * 0 8576 16 LPoint4i const * 16 LPoint4i const * 0 0 3734 0 0 0 0 0 0 0 0 0 0

3734 14 LPoint4i const 0 8832 14 LPoint4i const 14 LPoint4i const 0 0 3525 0 0 0 0 0 0 0 0 0 0

3735 11 LMatrix3f * 0 8576 11 LMatrix3f * 11 LMatrix3f * 0 0 3526 0 0 0 0 0 0 0 0 0 0

3736 17 LMatrix3f const * 0 8576 17 LMatrix3f const * 17 LMatrix3f const * 0 0 3737 0 0 0 0 0 0 0 0 0 0

3737 15 LMatrix3f const 0 8832 15 LMatrix3f const 15 LMatrix3f const 0 0 3526 0 0 0 0 0 0 0 0 0 0

3738 5 Row * 0 8576 16 LMatrix3f::Row * 16 LMatrix3f::Row * 0 0 3528 0 0 0 0 0 0 0 0 0 0

3739 6 CRow * 0 8576 17 LMatrix3f::CRow * 17 LMatrix3f::CRow * 0 0 3529 0 0 0 0 0 0 0 0 0 0

3740 17 LMatrix4f const * 0 8576 17 LMatrix4f const * 17 LMatrix4f const * 0 0 3741 0 0 0 0 0 0 0 0 0 0

3741 15 LMatrix4f const 0 8832 15 LMatrix4f const 15 LMatrix4f const 0 0 3530 0 0 0 0 0 0 0 0 0 0

3742 11 Row const * 0 8576 22 LMatrix3f::Row const * 22 LMatrix3f::Row const * 0 0 3743 0 0 0 0 0 0 0 0 0 0

3743 9 Row const 0 8832 20 LMatrix3f::Row const 20 LMatrix3f::Row const 0 0 3528 0 0 0 0 0 0 0 0 0 0

3744 12 CRow const * 0 8576 23 LMatrix3f::CRow const * 23 LMatrix3f::CRow const * 0 0 3745 0 0 0 0 0 0 0 0 0 0

3745 10 CRow const 0 8832 21 LMatrix3f::CRow const 21 LMatrix3f::CRow const 0 0 3529 0 0 0 0 0 0 0 0 0 0

3746 11 LMatrix4f * 0 8576 11 LMatrix4f * 11 LMatrix4f * 0 0 3530 0 0 0 0 0 0 0 0 0 0

3747 26 UnalignedLMatrix4f const * 0 8576 26 UnalignedLMatrix4f const * 26 UnalignedLMatrix4f const * 0 0 3748 0 0 0 0 0 0 0 0 0 0

3748 24 UnalignedLMatrix4f const 0 8832 24 UnalignedLMatrix4f const 24 UnalignedLMatrix4f const 0 0 3534 0 0 0 0 0 0 0 0 0 0

3749 5 Row * 0 8576 16 LMatrix4f::Row * 16 LMatrix4f::Row * 0 0 3532 0 0 0 0 0 0 0 0 0 0

3750 6 CRow * 0 8576 17 LMatrix4f::CRow * 17 LMatrix4f::CRow * 0 0 3533 0 0 0 0 0 0 0 0 0 0

3751 11 Row const * 0 8576 22 LMatrix4f::Row const * 22 LMatrix4f::Row const * 0 0 3752 0 0 0 0 0 0 0 0 0 0

3752 9 Row const 0 8832 20 LMatrix4f::Row const 20 LMatrix4f::Row const 0 0 3532 0 0 0 0 0 0 0 0 0 0

3753 12 CRow const * 0 8576 23 LMatrix4f::CRow const * 23 LMatrix4f::CRow const * 0 0 3754 0 0 0 0 0 0 0 0 0 0

3754 10 CRow const 0 8832 21 LMatrix4f::CRow const 21 LMatrix4f::CRow const 0 0 3533 0 0 0 0 0 0 0 0 0 0

3755 20 UnalignedLMatrix4f * 0 8576 20 UnalignedLMatrix4f * 20 UnalignedLMatrix4f * 0 0 3534 0 0 0 0 0 0 0 0 0 0

3756 11 LMatrix3d * 0 8576 11 LMatrix3d * 11 LMatrix3d * 0 0 3536 0 0 0 0 0 0 0 0 0 0

3757 17 LMatrix3d const * 0 8576 17 LMatrix3d const * 17 LMatrix3d const * 0 0 3758 0 0 0 0 0 0 0 0 0 0

3758 15 LMatrix3d const 0 8832 15 LMatrix3d const 15 LMatrix3d const 0 0 3536 0 0 0 0 0 0 0 0 0 0

3759 5 Row * 0 8576 16 LMatrix3d::Row * 16 LMatrix3d::Row * 0 0 3538 0 0 0 0 0 0 0 0 0 0

3760 6 CRow * 0 8576 17 LMatrix3d::CRow * 17 LMatrix3d::CRow * 0 0 3539 0 0 0 0 0 0 0 0 0 0

3761 17 LMatrix4d const * 0 8576 17 LMatrix4d const * 17 LMatrix4d const * 0 0 3762 0 0 0 0 0 0 0 0 0 0

3762 15 LMatrix4d const 0 8832 15 LMatrix4d const 15 LMatrix4d const 0 0 3540 0 0 0 0 0 0 0 0 0 0

3763 11 Row const * 0 8576 22 LMatrix3d::Row const * 22 LMatrix3d::Row const * 0 0 3764 0 0 0 0 0 0 0 0 0 0

3764 9 Row const 0 8832 20 LMatrix3d::Row const 20 LMatrix3d::Row const 0 0 3538 0 0 0 0 0 0 0 0 0 0

3765 12 CRow const * 0 8576 23 LMatrix3d::CRow const * 23 LMatrix3d::CRow const * 0 0 3766 0 0 0 0 0 0 0 0 0 0

3766 10 CRow const 0 8832 21 LMatrix3d::CRow const 21 LMatrix3d::CRow const 0 0 3539 0 0 0 0 0 0 0 0 0 0

3767 11 LMatrix4d * 0 8576 11 LMatrix4d * 11 LMatrix4d * 0 0 3540 0 0 0 0 0 0 0 0 0 0

3768 26 UnalignedLMatrix4d const * 0 8576 26 UnalignedLMatrix4d const * 26 UnalignedLMatrix4d const * 0 0 3769 0 0 0 0 0 0 0 0 0 0

3769 24 UnalignedLMatrix4d const 0 8832 24 UnalignedLMatrix4d const 24 UnalignedLMatrix4d const 0 0 3544 0 0 0 0 0 0 0 0 0 0

3770 5 Row * 0 8576 16 LMatrix4d::Row * 16 LMatrix4d::Row * 0 0 3542 0 0 0 0 0 0 0 0 0 0

3771 6 CRow * 0 8576 17 LMatrix4d::CRow * 17 LMatrix4d::CRow * 0 0 3543 0 0 0 0 0 0 0 0 0 0

3772 11 Row const * 0 8576 22 LMatrix4d::Row const * 22 LMatrix4d::Row const * 0 0 3773 0 0 0 0 0 0 0 0 0 0

3773 9 Row const 0 8832 20 LMatrix4d::Row const 20 LMatrix4d::Row const 0 0 3542 0 0 0 0 0 0 0 0 0 0

3774 12 CRow const * 0 8576 23 LMatrix4d::CRow const * 23 LMatrix4d::CRow const * 0 0 3775 0 0 0 0 0 0 0 0 0 0

3775 10 CRow const 0 8832 21 LMatrix4d::CRow const 21 LMatrix4d::CRow const 0 0 3543 0 0 0 0 0 0 0 0 0 0

3776 20 UnalignedLMatrix4d * 0 8576 20 UnalignedLMatrix4d * 20 UnalignedLMatrix4d * 0 0 3544 0 0 0 0 0 0 0 0 0 0

3777 14 LQuaternionf * 0 8576 14 LQuaternionf * 14 LQuaternionf * 0 0 3546 0 0 0 0 0 0 0 0 0 0

3778 20 LQuaternionf const * 0 8576 20 LQuaternionf const * 20 LQuaternionf const * 0 0 3779 0 0 0 0 0 0 0 0 0 0

3779 18 LQuaternionf const 0 8832 18 LQuaternionf const 18 LQuaternionf const 0 0 3546 0 0 0 0 0 0 0 0 0 0

3780 14 LQuaterniond * 0 8576 14 LQuaterniond * 14 LQuaterniond * 0 0 3547 0 0 0 0 0 0 0 0 0 0

3781 20 LQuaterniond const * 0 8576 20 LQuaterniond const * 20 LQuaterniond const * 0 0 3782 0 0 0 0 0 0 0 0 0 0

3782 18 LQuaterniond const 0 8832 18 LQuaterniond const 18 LQuaterniond const 0 0 3547 0 0 0 0 0 0 0 0 0 0

3783 12 LRotationf * 0 8576 12 LRotationf * 12 LRotationf * 0 0 3548 0 0 0 0 0 0 0 0 0 0

3784 18 LRotationf const * 0 8576 18 LRotationf const * 18 LRotationf const * 0 0 3785 0 0 0 0 0 0 0 0 0 0

3785 16 LRotationf const 0 8832 16 LRotationf const 16 LRotationf const 0 0 3548 0 0 0 0 0 0 0 0 0 0

3786 12 LRotationd * 0 8576 12 LRotationd * 12 LRotationd * 0 0 3549 0 0 0 0 0 0 0 0 0 0

3787 18 LRotationd const * 0 8576 18 LRotationd const * 18 LRotationd const * 0 0 3788 0 0 0 0 0 0 0 0 0 0

3788 16 LRotationd const 0 8832 16 LRotationd const 16 LRotationd const 0 0 3549 0 0 0 0 0 0 0 0 0 0

3789 15 LOrientationf * 0 8576 15 LOrientationf * 15 LOrientationf * 0 0 3550 0 0 0 0 0 0 0 0 0 0

3790 21 LOrientationf const * 0 8576 21 LOrientationf const * 21 LOrientationf const * 0 0 3791 0 0 0 0 0 0 0 0 0 0

3791 19 LOrientationf const 0 8832 19 LOrientationf const 19 LOrientationf const 0 0 3550 0 0 0 0 0 0 0 0 0 0

3792 15 LOrientationd * 0 8576 15 LOrientationd * 15 LOrientationd * 0 0 3551 0 0 0 0 0 0 0 0 0 0

3793 21 LOrientationd const * 0 8576 21 LOrientationd const * 21 LOrientationd const * 0 0 3794 0 0 0 0 0 0 0 0 0 0

3794 19 LOrientationd const 0 8832 19 LOrientationd const 19 LOrientationd const 0 0 3551 0 0 0 0 0 0 0 0 0 0

3795 27 ConfigVariableColor const * 0 8576 27 ConfigVariableColor const * 27 ConfigVariableColor const * 0 0 3796 0 0 0 0 0 0 0 0 0 0

3796 25 ConfigVariableColor const 0 8832 25 ConfigVariableColor const 25 ConfigVariableColor const 0 0 3622 0 0 0 0 0 0 0 0 0 0

3797 21 ConfigVariableColor * 0 8576 21 ConfigVariableColor * 21 ConfigVariableColor * 0 0 3622 0 0 0 0 0 0 0 0 0 0

3798 14 LColor const * 0 8576 14 LColor const * 14 LColor const * 0 0 3799 0 0 0 0 0 0 0 0 0 0

3799 12 LColor const 0 8832 12 LColor const 12 LColor const 0 0 3606 0 0 0 0 0 0 0 0 0 0

3800 11 PN_stdfloat 0 2105344 11 PN_stdfloat 11 PN_stdfloat 0 0 3482 0 0 0 0 0 0 0 0 0 0

3801 8 LColor * 0 8576 8 LColor * 8 LColor * 0 0 3606 0 0 0 0 0 0 0 0 0 0

3802 38 double const [::num_matrix_components] 0 4202496 38 double const [::num_matrix_components] 38 double const [::num_matrix_components] 0 0 3803 12 0 0 0 0 0 0 0 0 0 0

3803 12 double const 0 8832 12 double const 12 double const 0 0 3485 0 0 0 0 0 0 0 0 0 0

3804 37 float const [::num_matrix_components] 0 4202496 37 float const [::num_matrix_components] 37 float const [::num_matrix_components] 0 0 3805 12 0 0 0 0 0 0 0 0 0 0

3805 11 float const 0 8832 11 float const 11 float const 0 0 3482 0 0 0 0 0 0 0 0 0 0

3806 32 double [::num_matrix_components] 0 4202496 32 double [::num_matrix_components] 32 double [::num_matrix_components] 0 0 3485 12 0 0 0 0 0 0 0 0 0 0

3807 31 float [::num_matrix_components] 0 4202496 31 float [::num_matrix_components] 31 float [::num_matrix_components] 0 0 3482 12 0 0 0 0 0 0 0 0 0 0

0
77
3808 1 x 0 6 0 1962 1964 0 0 0 0 13 LVecBase2f::x 0

3809 1 y 0 6 0 1963 1965 0 0 0 0 13 LVecBase2f::y 0

3810 1 x 0 6 0 2025 2027 0 0 0 0 13 LVecBase2d::x 0

3811 1 y 0 6 0 2026 2028 0 0 0 0 13 LVecBase2d::y 0

3812 1 x 0 6 0 2088 2090 0 0 0 0 13 LVecBase2i::x 0

3813 1 y 0 6 0 2089 2091 0 0 0 0 13 LVecBase2i::y 0

3814 1 x 0 6 0 2243 2247 0 0 0 0 13 LVecBase3f::x 0

3815 1 y 0 6 0 2244 2248 0 0 0 0 13 LVecBase3f::y 0

3816 1 z 0 6 0 2245 2249 0 0 0 0 13 LVecBase3f::z 0

3817 2 xy 0 2 0 2250 0 0 0 0 0 14 LVecBase3f::xy 0

3818 2 xz 0 2 0 2251 0 0 0 0 0 14 LVecBase3f::xz 0

3819 2 yz 0 2 0 2252 0 0 0 0 0 14 LVecBase3f::yz 0

3820 1 x 0 6 0 2316 2320 0 0 0 0 13 LVecBase3d::x 0

3821 1 y 0 6 0 2317 2321 0 0 0 0 13 LVecBase3d::y 0

3822 1 z 0 6 0 2318 2322 0 0 0 0 13 LVecBase3d::z 0

3823 2 xy 0 2 0 2323 0 0 0 0 0 14 LVecBase3d::xy 0

3824 2 xz 0 2 0 2324 0 0 0 0 0 14 LVecBase3d::xz 0

3825 2 yz 0 2 0 2325 0 0 0 0 0 14 LVecBase3d::yz 0

3826 1 x 0 6 0 2389 2393 0 0 0 0 13 LVecBase3i::x 0

3827 1 y 0 6 0 2390 2394 0 0 0 0 13 LVecBase3i::y 0

3828 1 z 0 6 0 2391 2395 0 0 0 0 13 LVecBase3i::z 0

3829 2 xy 0 2 0 2396 0 0 0 0 0 14 LVecBase3i::xy 0

3830 2 xz 0 2 0 2397 0 0 0 0 0 14 LVecBase3i::xz 0

3831 2 yz 0 2 0 2398 0 0 0 0 0 14 LVecBase3i::yz 0

3832 2 xy 0 2 0 2452 0 0 0 0 0 13 LVector3f::xy 0

3833 2 xz 0 2 0 2453 0 0 0 0 0 13 LVector3f::xz 0

3834 2 yz 0 2 0 2454 0 0 0 0 0 13 LVector3f::yz 0

3835 2 xy 0 2 0 2486 0 0 0 0 0 13 LVector3d::xy 0

3836 2 xz 0 2 0 2487 0 0 0 0 0 13 LVector3d::xz 0

3837 2 yz 0 2 0 2488 0 0 0 0 0 13 LVector3d::yz 0

3838 2 xy 0 2 0 2520 0 0 0 0 0 13 LVector3i::xy 0

3839 2 xz 0 2 0 2521 0 0 0 0 0 13 LVector3i::xz 0

3840 2 yz 0 2 0 2522 0 0 0 0 0 13 LVector3i::yz 0

3841 2 xy 0 2 0 2546 0 0 0 0 0 12 LPoint3f::xy 0

3842 2 xz 0 2 0 2547 0 0 0 0 0 12 LPoint3f::xz 0

3843 2 yz 0 2 0 2548 0 0 0 0 0 12 LPoint3f::yz 0

3844 2 xy 0 2 0 2569 0 0 0 0 0 12 LPoint3d::xy 0

3845 2 xz 0 2 0 2570 0 0 0 0 0 12 LPoint3d::xz 0

3846 2 yz 0 2 0 2571 0 0 0 0 0 12 LPoint3d::yz 0

3847 2 xy 0 2 0 2592 0 0 0 0 0 12 LPoint3i::xy 0

3848 2 xz 0 2 0 2593 0 0 0 0 0 12 LPoint3i::xz 0

3849 2 yz 0 2 0 2594 0 0 0 0 0 12 LPoint3i::yz 0

3850 1 x 0 6 0 2624 2630 0 0 0 0 13 LVecBase4f::x 0

3851 1 y 0 6 0 2625 2631 0 0 0 0 13 LVecBase4f::y 0

3852 1 z 0 6 0 2626 2632 0 0 0 0 13 LVecBase4f::z 0

3853 3 xyz 0 2 0 2628 0 0 0 0 0 15 LVecBase4f::xyz 0

3854 2 xy 0 2 0 2629 0 0 0 0 0 14 LVecBase4f::xy 0

3855 1 x 0 6 0 2707 2713 0 0 0 0 13 LVecBase4d::x 0

3856 1 y 0 6 0 2708 2714 0 0 0 0 13 LVecBase4d::y 0

3857 1 z 0 6 0 2709 2715 0 0 0 0 13 LVecBase4d::z 0

3858 3 xyz 0 2 0 2711 0 0 0 0 0 15 LVecBase4d::xyz 0

3859 2 xy 0 2 0 2712 0 0 0 0 0 14 LVecBase4d::xy 0

3860 1 x 0 6 0 2790 2796 0 0 0 0 13 LVecBase4i::x 0

3861 1 y 0 6 0 2791 2797 0 0 0 0 13 LVecBase4i::y 0

3862 1 z 0 6 0 2792 2798 0 0 0 0 13 LVecBase4i::z 0

3863 3 xyz 0 2 0 2794 0 0 0 0 0 15 LVecBase4i::xyz 0

3864 2 xy 0 2 0 2795 0 0 0 0 0 14 LVecBase4i::xy 0

3865 3 xyz 0 2 0 2859 0 0 0 0 0 14 LVector4f::xyz 0

3866 2 xy 0 2 0 2860 0 0 0 0 0 13 LVector4f::xy 0

3867 3 xyz 0 2 0 2879 0 0 0 0 0 14 LVector4d::xyz 0

3868 2 xy 0 2 0 2880 0 0 0 0 0 13 LVector4d::xy 0

3869 3 xyz 0 2 0 2899 0 0 0 0 0 14 LVector4i::xyz 0

3870 2 xy 0 2 0 2900 0 0 0 0 0 13 LVector4i::xy 0

3871 3 xyz 0 2 0 2917 0 0 0 0 0 13 LPoint4f::xyz 0

3872 2 xy 0 2 0 2918 0 0 0 0 0 12 LPoint4f::xy 0

3873 3 xyz 0 2 0 2937 0 0 0 0 0 13 LPoint4d::xyz 0

3874 2 xy 0 2 0 2938 0 0 0 0 0 12 LPoint4d::xy 0

3875 3 xyz 0 2 0 2957 0 0 0 0 0 13 LPoint4i::xyz 0

3876 2 xy 0 2 0 2958 0 0 0 0 0 12 LPoint4i::xy 0

3877 4 rows 0 66 0 2989 0 0 0 0 2984 15 LMatrix3f::rows 0

3878 4 cols 0 66 0 2990 0 0 0 0 2984 15 LMatrix3f::cols 0

3879 4 rows 0 66 0 3080 0 0 0 0 3074 15 LMatrix4f::rows 0

3880 4 cols 0 66 0 3081 0 0 0 0 3074 15 LMatrix4f::cols 0

3881 4 rows 0 66 0 3181 0 0 0 0 3176 15 LMatrix3d::rows 0

3882 4 cols 0 66 0 3182 0 0 0 0 3176 15 LMatrix3d::cols 0

3883 4 rows 0 66 0 3270 0 0 0 0 3264 15 LMatrix4d::rows 0

3884 4 cols 0 66 0 3271 0 0 0 0 3264 15 LMatrix4d::cols 0

14
3885 8 get_rows 0 2984 2987 19 LMatrix3f::get_rows 0

3886 8 get_cols 0 2984 2988 19 LMatrix3f::get_cols 0

3887 9 get_col2s 0 2984 2992 20 LMatrix3f::get_col2s 0

3888 9 get_row2s 0 2984 2991 20 LMatrix3f::get_row2s 0

3889 8 get_rows 0 3074 3077 19 LMatrix4f::get_rows 0

3890 8 get_cols 0 3074 3078 19 LMatrix4f::get_cols 0

3891 9 get_row3s 0 3074 3079 20 LMatrix4f::get_row3s 0

3892 8 get_rows 0 3176 3179 19 LMatrix3d::get_rows 0

3893 8 get_cols 0 3176 3180 19 LMatrix3d::get_cols 0

3894 9 get_col2s 0 3176 3184 20 LMatrix3d::get_col2s 0

3895 9 get_row2s 0 3176 3183 20 LMatrix3d::get_row2s 0

3896 8 get_rows 0 3264 3267 19 LMatrix4d::get_rows 0

3897 8 get_cols 0 3264 3268 19 LMatrix4d::get_cols 0

3898 9 get_row3s 0 3264 3269 20 LMatrix4d::get_row3s 0

