1508346355
3 2
11 libp3movies 4 Aas2 12 panda3d.core 
88
101 37 upcast_to_TypedWritableReferenceCount 0 12 189 49 MovieAudio::upcast_to_TypedWritableReferenceCount 0 1 7 53
upcast from MovieAudio to TypedWritableReferenceCount
85
TypedWritableReferenceCount *MovieAudio::upcast_to_TypedWritableReferenceCount(void);

102 22 downcast_to_MovieAudio 0 12 190 51 TypedWritableReferenceCount::downcast_to_MovieAudio 0 1 8 55
downcast from TypedWritableReferenceCount to MovieAudio
70
MovieAudio *TypedWritableReferenceCount::downcast_to_MovieAudio(void);

103 17 upcast_to_Namable 0 12 189 29 MovieAudio::upcast_to_Namable 0 1 9 33
upcast from MovieAudio to Namable
45
Namable *MovieAudio::upcast_to_Namable(void);

104 22 downcast_to_MovieAudio 0 12 191 31 Namable::downcast_to_MovieAudio 0 1 10 35
downcast from Namable to MovieAudio
50
MovieAudio *Namable::downcast_to_MovieAudio(void);

105 10 MovieAudio 0 4 189 22 MovieAudio::MovieAudio 0 2 1 2 200
/**
 * This constructor returns a null audio stream --- a stream of total silence,
 * at 8000 samples per second.  To get more interesting audio, you need to
 * construct a subclass of this class.
 */
125
MovieAudio::MovieAudio(std::string const &name = "Blank Audio");
inline MovieAudio::MovieAudio(MovieAudio const &) = default;

106 11 ~MovieAudio 0 6 189 23 MovieAudio::~MovieAudio 0 0 10
/**
 *
 */
38
virtual MovieAudio::~MovieAudio(void);

107 4 open 0 6 189 16 MovieAudio::open 0 1 3 56
/**
 * Open this audio, returning a MovieAudioCursor
 */
61
virtual PointerTo< MovieAudioCursor > MovieAudio::open(void);

108 3 get 0 4 189 15 MovieAudio::get 0 1 4 103
/**
 * Obtains a MovieAudio that references a file.  Just calls
 * MovieTypeRegistry::make_audio().
 */
69
static PointerTo< MovieAudio > MovieAudio::get(Filename const &name);

109 12 get_filename 0 4 189 24 MovieAudio::get_filename 0 1 5 142
/**
 * Returns the movie's filename.  A movie is not guaranteed to have a
 * filename, if not, then this function returns a null filename.
 */
60
inline Filename const &MovieAudio::get_filename(void) const;

110 14 get_class_type 0 4 189 26 MovieAudio::get_class_type 0 1 6 0
51
static TypeHandle MovieAudio::get_class_type(void);

111 9 FlacAudio 0 4 194 20 FlacAudio::FlacAudio 0 2 11 12 14
/**
 * xxx
 */
101
FlacAudio::FlacAudio(Filename const &name);
inline FlacAudio::FlacAudio(FlacAudio const &) = default;

112 4 make 0 4 194 15 FlacAudio::make 0 1 13 55
/**
 * Obtains a MovieAudio that references a file.
 */
69
static PointerTo< MovieAudio > FlacAudio::make(Filename const &name);

113 14 get_class_type 0 4 194 25 FlacAudio::get_class_type 0 1 14 0
50
static TypeHandle FlacAudio::get_class_type(void);

114 16 MovieAudioCursor 0 4 195 34 MovieAudioCursor::MovieAudioCursor 0 2 15 16 200
/**
 * This constructor returns a null audio stream --- a stream of total silence,
 * at 8000 samples per second.  To get more interesting audio, you need to
 * construct a subclass of this class.
 */
131
MovieAudioCursor::MovieAudioCursor(MovieAudio *src);
inline MovieAudioCursor::MovieAudioCursor(MovieAudioCursor const &) = default;

115 10 get_source 0 4 195 28 MovieAudioCursor::get_source 0 1 17 63
/**
 * Returns the MovieAudio which this cursor references.
 */
72
inline PointerTo< MovieAudio > MovieAudioCursor::get_source(void) const;

116 10 audio_rate 0 4 195 28 MovieAudioCursor::audio_rate 0 1 18 41
/**
 * Returns the audio sample rate.
 */
52
inline int MovieAudioCursor::audio_rate(void) const;

117 14 audio_channels 0 4 195 32 MovieAudioCursor::audio_channels 0 1 19 83
/**
 * Returns the number of audio channels (ie, two for stereo, one for mono).
 */
56
inline int MovieAudioCursor::audio_channels(void) const;

118 6 length 0 4 195 24 MovieAudioCursor::length 0 1 20 742
/**
 * Returns the length of the movie.  Attempting to read audio samples beyond
 * the specified length will produce silent samples.
 *
 * Some kinds of Movie, such as internet TV station, might not have a
 * predictable length.  In that case, the length will be set to a very large
 * number: 1.0E10.
 *
 * Some AVI files have incorrect length values encoded into them - they may be
 * a second or two long or short.  When playing such an AVI using the Movie
 * class, you may see a slightly truncated video, or a slightly elongated
 * video (padded with black frames).  There are utilities out there to fix the
 * length values in AVI files.
 *
 * An audio consumer needs to check the length, the ready status, and the
 * aborted flag.
 */
51
inline double MovieAudioCursor::length(void) const;

119 8 can_seek 0 4 195 26 MovieAudioCursor::can_seek 0 1 21 429
/**
 * Returns true if the movie can seek.  If this is true, seeking is still not
 * guaranteed to be fast: for some movies, seeking is implemented by rewinding
 * to the beginning and then fast-forwarding to the desired location.  Even if
 * the movie cannot seek, the seek method can still advance to an arbitrary
 * location by reading samples and discarding them.  However, to move
 * backward, can_seek must return true.
 */
51
inline bool MovieAudioCursor::can_seek(void) const;

120 13 can_seek_fast 0 4 195 31 MovieAudioCursor::can_seek_fast 0 1 22 61
/**
 * Returns true if seek operations are constant time.
 */
56
inline bool MovieAudioCursor::can_seek_fast(void) const;

121 4 tell 0 4 195 22 MovieAudioCursor::tell 0 1 23 54
/**
 * Returns the current offset within the file.
 */
49
inline double MovieAudioCursor::tell(void) const;

122 12 skip_samples 0 4 195 30 MovieAudioCursor::skip_samples 0 1 24 86
/**
 * Skip audio samples from the stream.  This is mostly for debugging purposes.
 */
50
inline void MovieAudioCursor::skip_samples(int n);

123 7 aborted 0 4 195 25 MovieAudioCursor::aborted 0 1 25 138
/**
 * If aborted is true, it means that the "ready" samples are not being
 * replenished.  See the method "ready" for an explanation.
 */
50
inline bool MovieAudioCursor::aborted(void) const;

124 5 ready 0 6 195 23 MovieAudioCursor::ready 0 1 26 1120
/**
 * Returns the number of audio samples that are ready to read.  This is
 * primarily relevant for sources like microphones which produce samples at a
 * fixed rate.  If you try to read more samples than are ready, the result
 * will be silent samples.
 *
 * Some audio streams do not have a limit on how fast they can produce
 * samples.  Such streams will always return 0x40000000 as the ready-count.
 * This may well exceed the length of the audio stream.  You therefore need to
 * check length separately.
 *
 * If the aborted flag is set, that means the ready count is no longer being
 * replenished.  For example, a MovieAudioCursor might be reading from an
 * internet radio station, and it might buffer data to avoid underruns.  If it
 * loses connection to the radio station, it will set the aborted flag to
 * indicate that the buffer is no longer being replenished.  But it is still
 * ok to read the samples that are in the buffer, at least until they run out.
 * Once those are gone, there will be no more.
 *
 * An audio consumer needs to check the length, the ready status, and the
 * aborted flag.
 */
48
virtual int MovieAudioCursor::ready(void) const;

125 4 seek 0 6 195 22 MovieAudioCursor::seek 0 1 27 746
/**
 * Skips to the specified offset within the file.
 *
 * If the movie reports that it cannot seek, then this method can still
 * advance by reading samples and discarding them.  However, to move backward,
 * can_seek must be true.
 *
 * If the movie reports that it can_seek, it doesn't mean that it can do so
 * quickly.  It may have to rewind the movie and then fast forward to the
 * desired location.  Only if can_seek_fast returns true can seek operations
 * be done in constant time.
 *
 * Seeking may not be precise, because AVI files often have inaccurate
 * indices.  After seeking, tell will indicate that the cursor is at the
 * target location.  However, in truth, the data you read may come from a
 * slightly offset location.
 */
51
virtual void MovieAudioCursor::seek(double offset);

126 12 read_samples 0 4 195 30 MovieAudioCursor::read_samples 0 2 28 29 798
/**
 * Read audio samples from the stream.  N is the number of samples you wish to
 * read.  Your buffer must be equal in size to N * channels.  Multiple-channel
 * audio will be interleaved.
 */

/**
 * Read audio samples from the stream into a Datagram.  N is the number of
 * samples you wish to read.  Multiple-channel audio will be interleaved.
 *
 * This is not particularly efficient, but it may be a convenient way to
 * manipulate samples in python.
 */

/**
 * Read audio samples from the stream and returns them as a string.  The
 * samples are stored little-endian in the string.  N is the number of samples
 * you wish to read.  Multiple-channel audio will be interleaved.
 *
 * This is not particularly efficient, but it may be a convenient way to
 * manipulate samples in python.
 */
108
void MovieAudioCursor::read_samples(int n, Datagram *dg);
std::string MovieAudioCursor::read_samples(int n);

127 14 get_class_type 0 4 195 32 MovieAudioCursor::get_class_type 0 1 30 0
57
static TypeHandle MovieAudioCursor::get_class_type(void);

128 15 FlacAudioCursor 0 4 196 32 FlacAudioCursor::FlacAudioCursor 0 2 31 32 129
/**
 * Reads the .wav header from the indicated stream.  This leaves the read
 * pointer positioned at the start of the data.
 */
142
FlacAudioCursor::FlacAudioCursor(FlacAudio *src, istream *stream);
inline FlacAudioCursor::FlacAudioCursor(FlacAudioCursor const &) = default;

129 14 get_class_type 0 4 196 31 FlacAudioCursor::get_class_type 0 1 33 0
56
static TypeHandle FlacAudioCursor::get_class_type(void);

130 37 upcast_to_TypedWritableReferenceCount 0 12 197 49 MovieVideo::upcast_to_TypedWritableReferenceCount 0 1 41 53
upcast from MovieVideo to TypedWritableReferenceCount
85
TypedWritableReferenceCount *MovieVideo::upcast_to_TypedWritableReferenceCount(void);

131 22 downcast_to_MovieVideo 0 12 190 51 TypedWritableReferenceCount::downcast_to_MovieVideo 0 1 42 55
downcast from TypedWritableReferenceCount to MovieVideo
70
MovieVideo *TypedWritableReferenceCount::downcast_to_MovieVideo(void);

132 17 upcast_to_Namable 0 12 197 29 MovieVideo::upcast_to_Namable 0 1 43 33
upcast from MovieVideo to Namable
45
Namable *MovieVideo::upcast_to_Namable(void);

133 22 downcast_to_MovieVideo 0 12 191 31 Namable::downcast_to_MovieVideo 0 1 44 35
downcast from Namable to MovieVideo
50
MovieVideo *Namable::downcast_to_MovieVideo(void);

134 10 MovieVideo 0 4 197 22 MovieVideo::MovieVideo 0 2 34 35 212
/**
 * This constructor returns a null video stream --- a stream of plain blue and
 * white frames that last one second each.  To get more interesting video, you
 * need to construct a subclass of this class.
 */
125
MovieVideo::MovieVideo(std::string const &name = "Blank Video");
inline MovieVideo::MovieVideo(MovieVideo const &) = default;

135 11 ~MovieVideo 0 6 197 23 MovieVideo::~MovieVideo 0 0 10
/**
 *
 */
38
virtual MovieVideo::~MovieVideo(void);

136 4 open 0 6 197 16 MovieVideo::open 0 1 36 107
/**
 * Open this video, returning a MovieVideoCursor of the appropriate type.
 * Returns NULL on error.
 */
61
virtual PointerTo< MovieVideoCursor > MovieVideo::open(void);

137 3 get 0 4 197 15 MovieVideo::get 0 1 37 103
/**
 * Obtains a MovieVideo that references a file.  Just calls
 * MovieTypeRegistry::make_video().
 */
69
static PointerTo< MovieVideo > MovieVideo::get(Filename const &name);

138 12 get_filename 0 4 197 24 MovieVideo::get_filename 0 1 38 144
/**
 * Returns the movie's filename.  A movie is not guaranteed to have a
 * filename, if not, then this function returns an empty filename.
 */
60
inline Filename const &MovieVideo::get_filename(void) const;

139 16 get_subfile_info 0 4 197 28 MovieVideo::get_subfile_info 0 1 39 150
/**
 * If the movie is to be loaded from a subfile on disk, this returns the
 * subfile info.  Check info.is_empty() to see if this is valid data.
 */
67
inline SubfileInfo const &MovieVideo::get_subfile_info(void) const;

140 14 get_class_type 0 4 197 26 MovieVideo::get_class_type 0 1 40 0
51
static TypeHandle MovieVideo::get_class_type(void);

141 12 InkblotVideo 0 4 200 26 InkblotVideo::InkblotVideo 0 2 45 46 14
/**
 * xxx
 */
117
InkblotVideo::InkblotVideo(int x, int y, int fps);
inline InkblotVideo::InkblotVideo(InkblotVideo const &) = default;

142 14 get_class_type 0 4 200 28 InkblotVideo::get_class_type 0 1 47 0
53
static TypeHandle InkblotVideo::get_class_type(void);

143 10 get_source 0 4 201 28 MovieVideoCursor::get_source 0 1 49 59
/**
 * Get the MovieVideo which this cursor references.
 */
65
PointerTo< MovieVideo > MovieVideoCursor::get_source(void) const;

144 6 size_x 0 4 201 24 MovieVideoCursor::size_x 0 1 50 48
/**
 * Get the horizontal size of the movie.
 */
48
inline int MovieVideoCursor::size_x(void) const;

145 6 size_y 0 4 201 24 MovieVideoCursor::size_y 0 1 51 46
/**
 * Get the vertical size of the movie.
 */
48
inline int MovieVideoCursor::size_y(void) const;

146 18 get_num_components 0 4 201 36 MovieVideoCursor::get_num_components 0 1 52 68
/**
 * Returns 4 if the movie has an alpha channel, 3 otherwise.
 */
60
inline int MovieVideoCursor::get_num_components(void) const;

147 6 length 0 4 201 24 MovieVideoCursor::length 0 1 53 1170
/**
 * Returns the length of the movie.
 *
 * Some kinds of Movie, such as internet TV station, might not have a
 * predictable length.  In that case, the length will be set to a very large
 * number: 1.0E10. If the internet TV station goes offline, the video or audio
 * stream will set its abort flag.  Reaching the end of the movie (ie, the
 * specified length) normally does not cause the abort flag to be set.
 *
 * The video and audio streams produced by get_video and get_audio are always
 * of unlimited duration - you can always read another video frame or another
 * audio sample.  This is true even if the specified length is reached, or an
 * abort is flagged.  If either stream runs out of data, it will synthesize
 * blank video frames and silent audio samples as necessary to satisfy read
 * requests.
 *
 * Some AVI files have incorrect length values encoded into them - usually,
 * they're a second or two long or short.  When playing such an AVI using the
 * Movie class, you may see a slightly truncated video, or a slightly
 * elongated video (padded with black frames).  There are utilities out there
 * to fix the length values in AVI files.
 *
 */
51
inline double MovieVideoCursor::length(void) const;

148 8 can_seek 0 4 201 26 MovieVideoCursor::can_seek 0 1 54 430
/**
 * Returns true if the movie can seek.  If this is true, seeking is still not
 * guaranteed to be fast: for some movies, seeking is implemented by rewinding
 * to the beginning and then fast-forwarding to the desired location.  Even if
 * the movie cannot seek, the fetch methods can still advance to an arbitrary
 * location by reading frames and discarding them.  However, to move backward,
 * can_seek must return true.
 */
51
inline bool MovieVideoCursor::can_seek(void) const;

149 13 can_seek_fast 0 4 201 31 MovieVideoCursor::can_seek_fast 0 1 55 61
/**
 * Returns true if seek operations are constant time.
 */
56
inline bool MovieVideoCursor::can_seek_fast(void) const;

150 7 aborted 0 4 201 25 MovieVideoCursor::aborted 0 1 56 260
/**
 * Returns true if the video has aborted prematurely.  For example, this could
 * occur if the Movie was actually an internet TV station, and the connection
 * was lost.  Reaching the normal end of the video does not constitute an
 * 'abort' condition.
 */
50
inline bool MovieVideoCursor::aborted(void) const;

151 5 ready 0 4 201 23 MovieVideoCursor::ready 0 1 57 156
/**
 * Returns true if the cursor is a streaming source, and if a video frame is
 * ready to be read.  For non- streaming sources, this is always false.
 */
48
inline bool MovieVideoCursor::ready(void) const;

152 9 streaming 0 4 201 27 MovieVideoCursor::streaming 0 1 58 528
/**
 * Returns true if the video frames are being "pushed" at us by something that
 * operates at its own speed - for example, a webcam.  In this case, the
 * frames come when they're ready to come.  Attempting to read too soon will
 * produce nothing, reading too late will cause frames to be dropped.  In this
 * case, the ready flag can be used to determine whether or not a frame is
 * ready for reading.
 *
 * When streaming, you should still pay attention to last_start, but the value
 * of next_start is only a guess.
 */
52
inline bool MovieVideoCursor::streaming(void) const;

153 13 setup_texture 0 4 201 31 MovieVideoCursor::setup_texture 0 1 59 130
/**
 * Set up the specified Texture object to contain content from this movie.
 * This should be called once, not every frame.
 */
57
void MovieVideoCursor::setup_texture(Texture *tex) const;

154 8 set_time 0 6 201 26 MovieVideoCursor::set_time 0 1 60 850
/**
 * Updates the cursor to the indicated time.  If loop_count >= 1, the time is
 * clamped to the movie's length * loop_count.  If loop_count <= 0, the time
 * is understood to be modulo the movie's length.
 *
 * Returns true if a new frame is now available, false otherwise.  If this
 * returns true, you should immediately follow this with exactly *one* call to
 * fetch_buffer().
 *
 * If the movie reports that it can_seek, you may also specify a time value
 * less than the previous value you passed to set_time().  Otherwise, you may
 * only specify a time value greater than or equal to the previous value.
 *
 * If the movie reports that it can_seek, it doesn't mean that it can do so
 * quickly.  It may have to rewind the movie and then fast forward to the
 * desired location.  Only if can_seek_fast returns true can it seek rapidly.
 */
74
virtual bool MovieVideoCursor::set_time(double timestamp, int loop_count);

155 17 compare_timestamp 0 6 202 43 MovieVideoCursor::Buffer::compare_timestamp 0 1 67 335
/**
 * Used to sort different buffers to ensure they correspond to the same source
 * frame, particularly important when synchronizing the different pages of a
 * multi-page texture.
 *
 * Returns 0 if the two buffers are of the same frame, <0 if this one comes
 * earlier than the other one, and >0 if the other one comes earlier.
 */
101
virtual int MovieVideoCursor::Buffer::compare_timestamp(MovieVideoCursor::Buffer const *other) const;

156 13 get_timestamp 0 6 202 39 MovieVideoCursor::Buffer::get_timestamp 0 1 68 236
/**
 * Returns the nearest timestamp value of this particular buffer.  Ideally,
 * MovieVideoCursor::set_time() for this timestamp would return this buffer
 * again.  This need be defined only if compare_timestamp() is also defined.
 */
67
virtual double MovieVideoCursor::Buffer::get_timestamp(void) const;

157 14 get_class_type 0 4 202 40 MovieVideoCursor::Buffer::get_class_type 0 1 69 0
65
static TypeHandle MovieVideoCursor::Buffer::get_class_type(void);

158 6 Buffer 0 4 202 32 MovieVideoCursor::Buffer::Buffer 0 1 66 10
/**
 *
 */
84
inline MovieVideoCursor::Buffer::Buffer(MovieVideoCursor::Buffer const &) = default;

159 12 fetch_buffer 0 6 201 30 MovieVideoCursor::fetch_buffer 0 1 61 331
/**
 * Gets the current video frame (as specified by set_time()) from the movie
 * and returns it in a pre-allocated buffer.  You may simply let the buffer
 * dereference and delete itself when you are done with it.
 *
 * This may return NULL (even if set_time() returned true) if the frame is not
 * available for some reason.
 */
83
virtual PointerTo< MovieVideoCursor::Buffer > MovieVideoCursor::fetch_buffer(void);

160 16 apply_to_texture 0 6 201 34 MovieVideoCursor::apply_to_texture 0 1 62 66
/**
 * Stores this buffer's contents in the indicated texture.
 */
110
virtual void MovieVideoCursor::apply_to_texture(MovieVideoCursor::Buffer const *buffer, Texture *t, int page);

161 20 apply_to_texture_rgb 0 6 201 38 MovieVideoCursor::apply_to_texture_rgb 0 1 63 140
/**
 * Copies this buffer's contents into the RGB channels of the supplied
 * texture.  The alpha channel of the texture is not touched.
 */
114
virtual void MovieVideoCursor::apply_to_texture_rgb(MovieVideoCursor::Buffer const *buffer, Texture *t, int page);

162 22 apply_to_texture_alpha 0 6 201 40 MovieVideoCursor::apply_to_texture_alpha 0 1 64 141
/**
 * Copies this buffer's contents into the alpha channel of the supplied
 * texture.  The RGB channels of the texture are not touched.
 */
131
virtual void MovieVideoCursor::apply_to_texture_alpha(MovieVideoCursor::Buffer const *buffer, Texture *t, int page, int alpha_src);

163 14 get_class_type 0 4 201 32 MovieVideoCursor::get_class_type 0 1 65 0
57
static TypeHandle MovieVideoCursor::get_class_type(void);

164 16 MovieVideoCursor 0 4 201 34 MovieVideoCursor::MovieVideoCursor 0 1 48 121
/**
 * This is a virtual base class and should not be created directly.  Instead,
 * create a more specialized class.
 */
78
inline MovieVideoCursor::MovieVideoCursor(MovieVideoCursor const &) = default;

165 18 InkblotVideoCursor 0 4 204 38 InkblotVideoCursor::InkblotVideoCursor 0 2 70 71 14
/**
 * xxx
 */
143
InkblotVideoCursor::InkblotVideoCursor(InkblotVideo *src);
inline InkblotVideoCursor::InkblotVideoCursor(InkblotVideoCursor const &) = default;

166 14 get_class_type 0 4 204 34 InkblotVideoCursor::get_class_type 0 1 72 0
59
static TypeHandle InkblotVideoCursor::get_class_type(void);

167 15 get_num_options 0 4 205 32 MicrophoneAudio::get_num_options 0 1 73 218
/**
 * Returns the number of microphone options.  An "option" consists of a device
 * plus a set of configuration parameters.  For example, "Soundblaster Audigy
 * Line in at 44,100 samples/sec" would be an option.
 */
50
static int MicrophoneAudio::get_num_options(void);

168 10 get_option 0 4 205 27 MicrophoneAudio::get_option 0 1 74 45
/**
 * Returns the nth microphone option.
 */
71
static PointerTo< MicrophoneAudio > MicrophoneAudio::get_option(int n);

169 12 get_channels 0 4 205 29 MicrophoneAudio::get_channels 0 1 75 42
/**
 * Returns the number of channels.
 */
53
inline int MicrophoneAudio::get_channels(void) const;

170 8 get_rate 0 4 205 25 MicrophoneAudio::get_rate 0 1 76 35
/**
 * Returns the sample rate.
 */
49
inline int MicrophoneAudio::get_rate(void) const;

171 0 0 0 0 0 0 0 0
0

172 14 get_class_type 0 4 205 31 MicrophoneAudio::get_class_type 0 1 77 0
56
static TypeHandle MicrophoneAudio::get_class_type(void);

173 13 UserDataAudio 0 4 208 28 UserDataAudio::UserDataAudio 0 2 78 79 104
/**
 * This constructor returns a UserDataAudio --- a means to supply raw audio
 * samples manually.
 */
154
UserDataAudio::UserDataAudio(int rate, int channels, bool remove_after_read = true);
inline UserDataAudio::UserDataAudio(UserDataAudio const &) = default;

174 6 append 0 4 208 21 UserDataAudio::append 0 2 80 81 413
/**
 * Appends audio samples to the buffer.
 */

/**
 * Appends audio samples to the buffer from a datagram.  This is intended to
 * make it easy to send streaming raw audio over a network.
 */

/**
 * Appends audio samples to the buffer from a string.  The samples must be
 * stored little-endian in the string.  This is not particularly efficient,
 * but it may be convenient to deal with samples in python.
 */
174
void UserDataAudio::append(int16_t *data, int n);
void UserDataAudio::append(DatagramIterator *src, int len = 1073741824);
void UserDataAudio::append(std::string const &str);

175 4 done 0 4 208 19 UserDataAudio::done 0 1 82 143
// A promise not to write any more samples.

/**
 * Promises not to append any more samples, ie, this marks the end of the
 * audio stream.
 */
31
void UserDataAudio::done(void);

176 14 get_class_type 0 4 208 29 UserDataAudio::get_class_type 0 1 83 0
54
static TypeHandle UserDataAudio::get_class_type(void);

177 19 UserDataAudioCursor 0 4 209 40 UserDataAudioCursor::UserDataAudioCursor 0 2 84 85 10
/**
 *
 */
149
UserDataAudioCursor::UserDataAudioCursor(UserDataAudio *src);
inline UserDataAudioCursor::UserDataAudioCursor(UserDataAudioCursor const &) = default;

178 14 get_class_type 0 4 209 35 UserDataAudioCursor::get_class_type 0 1 86 0
60
static TypeHandle UserDataAudioCursor::get_class_type(void);

179 11 VorbisAudio 0 4 210 24 VorbisAudio::VorbisAudio 0 2 87 88 14
/**
 * xxx
 */
111
VorbisAudio::VorbisAudio(Filename const &name);
inline VorbisAudio::VorbisAudio(VorbisAudio const &) = default;

180 4 make 0 4 210 17 VorbisAudio::make 0 1 89 55
/**
 * Obtains a MovieAudio that references a file.
 */
71
static PointerTo< MovieAudio > VorbisAudio::make(Filename const &name);

181 14 get_class_type 0 4 210 27 VorbisAudio::get_class_type 0 1 90 0
52
static TypeHandle VorbisAudio::get_class_type(void);

182 17 VorbisAudioCursor 0 4 211 36 VorbisAudioCursor::VorbisAudioCursor 0 2 91 92 129
/**
 * Reads the .wav header from the indicated stream.  This leaves the read
 * pointer positioned at the start of the data.
 */
154
VorbisAudioCursor::VorbisAudioCursor(VorbisAudio *src, istream *stream);
inline VorbisAudioCursor::VorbisAudioCursor(VorbisAudioCursor const &) = default;

183 14 get_class_type 0 4 211 33 VorbisAudioCursor::get_class_type 0 1 93 0
58
static TypeHandle VorbisAudioCursor::get_class_type(void);

184 8 WavAudio 0 4 212 18 WavAudio::WavAudio 0 2 94 95 14
/**
 * xxx
 */
96
WavAudio::WavAudio(Filename const &name);
inline WavAudio::WavAudio(WavAudio const &) = default;

185 4 make 0 4 212 14 WavAudio::make 0 1 96 55
/**
 * Obtains a MovieAudio that references a file.
 */
68
static PointerTo< MovieAudio > WavAudio::make(Filename const &name);

186 14 get_class_type 0 4 212 24 WavAudio::get_class_type 0 1 97 0
49
static TypeHandle WavAudio::get_class_type(void);

187 14 WavAudioCursor 0 4 213 30 WavAudioCursor::WavAudioCursor 0 2 98 99 129
/**
 * Reads the .wav header from the indicated stream.  This leaves the read
 * pointer positioned at the start of the data.
 */
136
WavAudioCursor::WavAudioCursor(WavAudio *src, istream *stream);
inline WavAudioCursor::WavAudioCursor(WavAudioCursor const &) = default;

188 14 get_class_type 0 4 213 30 WavAudioCursor::get_class_type 0 1 100 0
55
static TypeHandle WavAudioCursor::get_class_type(void);

100
1 0 0 7 8 216 106 0 0 1 6 param0 0 214  
2 0 0 7 8 216 106 0 200 /**
 * This constructor returns a null audio stream --- a stream of total silence,
 * at 8000 samples per second.  To get more interesting audio, you need to
 * construct a subclass of this class.
 */ 1 4 name 1 217  
3 0 0 7 10 218 0 0 56 /**
 * Open this audio, returning a MovieAudioCursor
 */ 1 4 this 3 216  
4 0 0 7 11 216 106 0 103 /**
 * Obtains a MovieAudio that references a file.  Just calls
 * MovieTypeRegistry::make_audio().
 */ 1 4 name 1 219  
5 0 0 6 12 219 0 0 142 /**
 * Returns the movie's filename.  A movie is not guaranteed to have a
 * filename, if not, then this function returns a null filename.
 */ 1 4 this 3 214  
6 0 0 7 16 221 0 0 0 0 
7 0 0 7 3 222 0 0 0 1 4 this 3 216  
8 0 0 7 4 216 106 0 0 1 4 this 3 222  
9 0 0 6 6 223 0 0 0 1 4 this 3 216  
10 0 0 7 7 216 106 0 0 1 4 this 3 223  
11 0 0 7 18 224 106 0 14 /**
 * xxx
 */ 1 4 name 1 219  
12 0 0 7 18 224 106 0 0 1 6 param0 0 225  
13 0 0 7 19 216 106 0 55 /**
 * Obtains a MovieAudio that references a file.
 */ 1 4 name 1 219  
14 0 0 7 20 221 0 0 0 0 
15 0 0 7 22 218 0 0 200 /**
 * This constructor returns a null audio stream --- a stream of total silence,
 * at 8000 samples per second.  To get more interesting audio, you need to
 * construct a subclass of this class.
 */ 1 3 src 1 216  
16 0 0 7 22 218 0 0 0 1 6 param0 0 227  
17 0 0 7 23 216 106 0 63 /**
 * Returns the MovieAudio which this cursor references.
 */ 1 4 this 3 227  
18 0 0 6 24 207 0 0 41 /**
 * Returns the audio sample rate.
 */ 1 4 this 3 227  
19 0 0 6 25 207 0 0 83 /**
 * Returns the number of audio channels (ie, two for stereo, one for mono).
 */ 1 4 this 3 227  
20 0 0 6 26 229 0 0 742 /**
 * Returns the length of the movie.  Attempting to read audio samples beyond
 * the specified length will produce silent samples.
 *
 * Some kinds of Movie, such as internet TV station, might not have a
 * predictable length.  In that case, the length will be set to a very large
 * number: 1.0E10.
 *
 * Some AVI files have incorrect length values encoded into them - they may be
 * a second or two long or short.  When playing such an AVI using the Movie
 * class, you may see a slightly truncated video, or a slightly elongated
 * video (padded with black frames).  There are utilities out there to fix the
 * length values in AVI files.
 *
 * An audio consumer needs to check the length, the ready status, and the
 * aborted flag.
 */ 1 4 this 3 227  
21 0 0 6 27 230 0 0 429 /**
 * Returns true if the movie can seek.  If this is true, seeking is still not
 * guaranteed to be fast: for some movies, seeking is implemented by rewinding
 * to the beginning and then fast-forwarding to the desired location.  Even if
 * the movie cannot seek, the seek method can still advance to an arbitrary
 * location by reading samples and discarding them.  However, to move
 * backward, can_seek must return true.
 */ 1 4 this 3 227  
22 0 0 6 28 230 0 0 61 /**
 * Returns true if seek operations are constant time.
 */ 1 4 this 3 227  
23 0 0 6 29 229 0 0 54 /**
 * Returns the current offset within the file.
 */ 1 4 this 3 227  
24 0 0 4 30 231 0 0 86 /**
 * Skip audio samples from the stream.  This is mostly for debugging purposes.
 */ 2 4 this 3 218  1 n 1 207  
25 0 0 6 31 230 0 0 138 /**
 * If aborted is true, it means that the "ready" samples are not being
 * replenished.  See the method "ready" for an explanation.
 */ 1 4 this 3 227  
26 0 0 6 32 207 0 0 1120 /**
 * Returns the number of audio samples that are ready to read.  This is
 * primarily relevant for sources like microphones which produce samples at a
 * fixed rate.  If you try to read more samples than are ready, the result
 * will be silent samples.
 *
 * Some audio streams do not have a limit on how fast they can produce
 * samples.  Such streams will always return 0x40000000 as the ready-count.
 * This may well exceed the length of the audio stream.  You therefore need to
 * check length separately.
 *
 * If the aborted flag is set, that means the ready count is no longer being
 * replenished.  For example, a MovieAudioCursor might be reading from an
 * internet radio station, and it might buffer data to avoid underruns.  If it
 * loses connection to the radio station, it will set the aborted flag to
 * indicate that the buffer is no longer being replenished.  But it is still
 * ok to read the samples that are in the buffer, at least until they run out.
 * Once those are gone, there will be no more.
 *
 * An audio consumer needs to check the length, the ready status, and the
 * aborted flag.
 */ 1 4 this 3 227  
27 0 0 4 33 231 0 0 746 /**
 * Skips to the specified offset within the file.
 *
 * If the movie reports that it cannot seek, then this method can still
 * advance by reading samples and discarding them.  However, to move backward,
 * can_seek must be true.
 *
 * If the movie reports that it can_seek, it doesn't mean that it can do so
 * quickly.  It may have to rewind the movie and then fast forward to the
 * desired location.  Only if can_seek_fast returns true can seek operations
 * be done in constant time.
 *
 * Seeking may not be precise, because AVI files often have inaccurate
 * indices.  After seeking, tell will indicate that the cursor is at the
 * target location.  However, in truth, the data you read may come from a
 * slightly offset location.
 */ 2 4 this 3 218  6 offset 1 229  
28 0 0 6 34 217 0 0 334 /**
 * Read audio samples from the stream and returns them as a string.  The
 * samples are stored little-endian in the string.  N is the number of samples
 * you wish to read.  Multiple-channel audio will be interleaved.
 *
 * This is not particularly efficient, but it may be a convenient way to
 * manipulate samples in python.
 */ 2 4 this 3 218  1 n 1 207  
29 0 0 4 34 231 0 0 265 /**
 * Read audio samples from the stream into a Datagram.  N is the number of
 * samples you wish to read.  Multiple-channel audio will be interleaved.
 *
 * This is not particularly efficient, but it may be a convenient way to
 * manipulate samples in python.
 */ 3 4 this 3 218  1 n 1 207  2 dg 1 232  
30 0 0 7 35 221 0 0 0 0 
31 0 0 7 37 236 0 0 129 /**
 * Reads the .wav header from the indicated stream.  This leaves the read
 * pointer positioned at the start of the data.
 */ 2 3 src 1 224  6 stream 1 234  
32 0 0 7 37 236 0 0 0 1 6 param0 0 237  
33 0 0 7 38 221 0 0 0 0 
34 0 0 7 44 241 135 0 0 1 6 param0 0 239  
35 0 0 7 44 241 135 0 212 /**
 * This constructor returns a null video stream --- a stream of plain blue and
 * white frames that last one second each.  To get more interesting video, you
 * need to construct a subclass of this class.
 */ 1 4 name 1 217  
36 0 0 7 46 242 0 0 107 /**
 * Open this video, returning a MovieVideoCursor of the appropriate type.
 * Returns NULL on error.
 */ 1 4 this 3 241  
37 0 0 7 47 241 135 0 103 /**
 * Obtains a MovieVideo that references a file.  Just calls
 * MovieTypeRegistry::make_video().
 */ 1 4 name 1 219  
38 0 0 6 48 219 0 0 144 /**
 * Returns the movie's filename.  A movie is not guaranteed to have a
 * filename, if not, then this function returns an empty filename.
 */ 1 4 this 3 239  
39 0 0 6 49 243 0 0 150 /**
 * If the movie is to be loaded from a subfile on disk, this returns the
 * subfile info.  Check info.is_empty() to see if this is valid data.
 */ 1 4 this 3 239  
40 0 0 7 54 221 0 0 0 0 
41 0 0 7 40 222 0 0 0 1 4 this 3 241  
42 0 0 7 41 241 135 0 0 1 4 this 3 222  
43 0 0 6 42 223 0 0 0 1 4 this 3 241  
44 0 0 7 43 241 135 0 0 1 4 this 3 223  
45 0 0 7 56 246 135 0 0 1 6 param0 0 244  
46 0 0 7 56 246 135 0 14 /**
 * xxx
 */ 3 1 x 1 207  1 y 1 207  3 fps 1 207  
47 0 0 7 57 221 0 0 0 0 
48 0 0 7 82 242 0 0 0 1 6 param0 0 247  
49 0 0 7 59 241 135 0 59 /**
 * Get the MovieVideo which this cursor references.
 */ 1 4 this 3 247  
50 0 0 6 60 207 0 0 48 /**
 * Get the horizontal size of the movie.
 */ 1 4 this 3 247  
51 0 0 6 61 207 0 0 46 /**
 * Get the vertical size of the movie.
 */ 1 4 this 3 247  
52 0 0 6 62 207 0 0 68 /**
 * Returns 4 if the movie has an alpha channel, 3 otherwise.
 */ 1 4 this 3 247  
53 0 0 6 63 229 0 0 1170 /**
 * Returns the length of the movie.
 *
 * Some kinds of Movie, such as internet TV station, might not have a
 * predictable length.  In that case, the length will be set to a very large
 * number: 1.0E10. If the internet TV station goes offline, the video or audio
 * stream will set its abort flag.  Reaching the end of the movie (ie, the
 * specified length) normally does not cause the abort flag to be set.
 *
 * The video and audio streams produced by get_video and get_audio are always
 * of unlimited duration - you can always read another video frame or another
 * audio sample.  This is true even if the specified length is reached, or an
 * abort is flagged.  If either stream runs out of data, it will synthesize
 * blank video frames and silent audio samples as necessary to satisfy read
 * requests.
 *
 * Some AVI files have incorrect length values encoded into them - usually,
 * they're a second or two long or short.  When playing such an AVI using the
 * Movie class, you may see a slightly truncated video, or a slightly
 * elongated video (padded with black frames).  There are utilities out there
 * to fix the length values in AVI files.
 *
 */ 1 4 this 3 247  
54 0 0 6 64 230 0 0 430 /**
 * Returns true if the movie can seek.  If this is true, seeking is still not
 * guaranteed to be fast: for some movies, seeking is implemented by rewinding
 * to the beginning and then fast-forwarding to the desired location.  Even if
 * the movie cannot seek, the fetch methods can still advance to an arbitrary
 * location by reading frames and discarding them.  However, to move backward,
 * can_seek must return true.
 */ 1 4 this 3 247  
55 0 0 6 65 230 0 0 61 /**
 * Returns true if seek operations are constant time.
 */ 1 4 this 3 247  
56 0 0 6 66 230 0 0 260 /**
 * Returns true if the video has aborted prematurely.  For example, this could
 * occur if the Movie was actually an internet TV station, and the connection
 * was lost.  Reaching the normal end of the video does not constitute an
 * 'abort' condition.
 */ 1 4 this 3 247  
57 0 0 6 67 230 0 0 156 /**
 * Returns true if the cursor is a streaming source, and if a video frame is
 * ready to be read.  For non- streaming sources, this is always false.
 */ 1 4 this 3 247  
58 0 0 6 68 230 0 0 528 /**
 * Returns true if the video frames are being "pushed" at us by something that
 * operates at its own speed - for example, a webcam.  In this case, the
 * frames come when they're ready to come.  Attempting to read too soon will
 * produce nothing, reading too late will cause frames to be dropped.  In this
 * case, the ready flag can be used to determine whether or not a frame is
 * ready for reading.
 *
 * When streaming, you should still pay attention to last_start, but the value
 * of next_start is only a guess.
 */ 1 4 this 3 247  
59 0 0 4 69 231 0 0 130 /**
 * Set up the specified Texture object to contain content from this movie.
 * This should be called once, not every frame.
 */ 2 4 this 3 247  3 tex 1 249  
60 0 0 6 70 230 0 0 850 /**
 * Updates the cursor to the indicated time.  If loop_count >= 1, the time is
 * clamped to the movie's length * loop_count.  If loop_count <= 0, the time
 * is understood to be modulo the movie's length.
 *
 * Returns true if a new frame is now available, false otherwise.  If this
 * returns true, you should immediately follow this with exactly *one* call to
 * fetch_buffer().
 *
 * If the movie reports that it can_seek, you may also specify a time value
 * less than the previous value you passed to set_time().  Otherwise, you may
 * only specify a time value greater than or equal to the previous value.
 *
 * If the movie reports that it can_seek, it doesn't mean that it can do so
 * quickly.  It may have to rewind the movie and then fast forward to the
 * desired location.  Only if can_seek_fast returns true can it seek rapidly.
 */ 3 4 this 3 242  9 timestamp 1 229  10 loop_count 1 207  
61 0 0 7 77 251 0 0 331 /**
 * Gets the current video frame (as specified by set_time()) from the movie
 * and returns it in a pre-allocated buffer.  You may simply let the buffer
 * dereference and delete itself when you are done with it.
 *
 * This may return NULL (even if set_time() returned true) if the frame is not
 * available for some reason.
 */ 1 4 this 3 242  
62 0 0 4 78 231 0 0 66 /**
 * Stores this buffer's contents in the indicated texture.
 */ 4 4 this 3 242  6 buffer 1 252  1 t 1 249  4 page 1 207  
63 0 0 4 79 231 0 0 140 /**
 * Copies this buffer's contents into the RGB channels of the supplied
 * texture.  The alpha channel of the texture is not touched.
 */ 4 4 this 3 242  6 buffer 1 252  1 t 1 249  4 page 1 207  
64 0 0 4 80 231 0 0 141 /**
 * Copies this buffer's contents into the alpha channel of the supplied
 * texture.  The RGB channels of the texture are not touched.
 */ 5 4 this 3 242  6 buffer 1 252  1 t 1 249  4 page 1 207  9 alpha_src 1 207  
65 0 0 7 81 221 0 0 0 0 
66 0 0 7 76 251 0 0 0 1 6 param0 0 252  
67 0 0 6 73 207 0 0 335 /**
 * Used to sort different buffers to ensure they correspond to the same source
 * frame, particularly important when synchronizing the different pages of a
 * multi-page texture.
 *
 * Returns 0 if the two buffers are of the same frame, <0 if this one comes
 * earlier than the other one, and >0 if the other one comes earlier.
 */ 2 4 this 3 252  5 other 1 252  
68 0 0 6 74 229 0 0 236 /**
 * Returns the nearest timestamp value of this particular buffer.  Ideally,
 * MovieVideoCursor::set_time() for this timestamp would return this buffer
 * again.  This need be defined only if compare_timestamp() is also defined.
 */ 1 4 this 3 252  
69 0 0 7 75 221 0 0 0 0 
70 0 0 7 84 254 0 0 14 /**
 * xxx
 */ 1 3 src 1 246  
71 0 0 7 84 254 0 0 0 1 6 param0 0 255  
72 0 0 7 85 221 0 0 0 0 
73 0 0 6 87 207 0 0 218 /**
 * Returns the number of microphone options.  An "option" consists of a device
 * plus a set of configuration parameters.  For example, "Soundblaster Audigy
 * Line in at 44,100 samples/sec" would be an option.
 */ 0 
74 0 0 7 88 257 106 0 45 /**
 * Returns the nth microphone option.
 */ 1 1 n 1 207  
75 0 0 6 90 207 0 0 42 /**
 * Returns the number of channels.
 */ 1 4 this 3 258  
76 0 0 6 91 207 0 0 35 /**
 * Returns the sample rate.
 */ 1 4 this 3 258  
77 0 0 7 98 221 0 0 0 0 
78 0 0 7 100 262 106 0 0 1 6 param0 0 260  
79 0 0 7 100 262 106 0 104 /**
 * This constructor returns a UserDataAudio --- a means to supply raw audio
 * samples manually.
 */ 3 4 rate 1 207  8 channels 1 207  17 remove_after_read 1 230  
80 0 0 4 101 231 0 0 144 /**
 * Appends audio samples to the buffer from a datagram.  This is intended to
 * make it easy to send streaming raw audio over a network.
 */ 3 4 this 3 262  3 src 1 263  3 len 1 207  
81 0 0 4 101 231 0 0 218 /**
 * Appends audio samples to the buffer from a string.  The samples must be
 * stored little-endian in the string.  This is not particularly efficient,
 * but it may be convenient to deal with samples in python.
 */ 2 4 this 3 262  3 str 1 217  
82 0 0 4 102 231 0 0 98 /**
 * Promises not to append any more samples, ie, this marks the end of the
 * audio stream.
 */ 1 4 this 3 262  
83 0 0 7 103 221 0 0 0 0 
84 0 0 7 105 265 0 0 10 /**
 *
 */ 1 3 src 1 262  
85 0 0 7 105 265 0 0 0 1 6 param0 0 266  
86 0 0 7 106 221 0 0 0 0 
87 0 0 7 108 268 106 0 14 /**
 * xxx
 */ 1 4 name 1 219  
88 0 0 7 108 268 106 0 0 1 6 param0 0 269  
89 0 0 7 109 216 106 0 55 /**
 * Obtains a MovieAudio that references a file.
 */ 1 4 name 1 219  
90 0 0 7 110 221 0 0 0 0 
91 0 0 7 112 271 0 0 129 /**
 * Reads the .wav header from the indicated stream.  This leaves the read
 * pointer positioned at the start of the data.
 */ 2 3 src 1 268  6 stream 1 234  
92 0 0 7 112 271 0 0 0 1 6 param0 0 272  
93 0 0 7 113 221 0 0 0 0 
94 0 0 7 115 274 106 0 14 /**
 * xxx
 */ 1 4 name 1 219  
95 0 0 7 115 274 106 0 0 1 6 param0 0 275  
96 0 0 7 116 216 106 0 55 /**
 * Obtains a MovieAudio that references a file.
 */ 1 4 name 1 219  
97 0 0 7 117 221 0 0 0 0 
98 0 0 7 119 277 0 0 129 /**
 * Reads the .wav header from the indicated stream.  This leaves the read
 * pointer positioned at the start of the data.
 */ 2 3 src 1 274  6 stream 1 234  
99 0 0 7 119 277 0 0 0 1 6 param0 0 278  
100 0 0 7 120 221 0 0 0 0 
91
189 10 MovieAudio 0 26625 10 MovieAudio 10 MovieAudio 0 0 0 1 105 106 1 280 4 107 108 109 110 0 0 2 3 190 101 102 3 191 103 104 0 0 397
/**
 * A MovieAudio is actually any source that provides a sequence of audio
 * samples.  That could include an AVI file, a microphone, or an internet TV
 * station.
 *
 * The difference between a MovieAudio and a MovieAudioCursor is like the
 * difference between a filename and a file handle.  The MovieAudio just
 * indicates a particular movie.  The MovieAudioCursor is what allows access.
 */

190 27 TypedWritableReferenceCount 0 2049 27 TypedWritableReferenceCount 27 TypedWritableReferenceCount 0 0 0 0 0 0 0 0 0 0 0 0 414
/**
 * A base class for things which need to inherit from both TypedWritable and
 * from ReferenceCount.  It's convenient to define this intermediate base
 * class instead of multiply inheriting from the two classes each time they
 * are needed, so that we can sensibly pass around pointers to things which
 * are both TypedWritables and ReferenceCounters.
 *
 * See also TypedObject for detailed instructions.
 */

191 7 Namable 0 2049 7 Namable 7 Namable 0 0 0 0 0 0 0 0 0 0 0 0 125
/**
 * A base class for all things which can have a name.  The name is either
 * empty or nonempty, but it is never NULL.
 */

192 14 Filename const 0 8832 14 Filename const 14 Filename const 0 0 193 0 0 0 0 0 0 0 0 0 0

193 8 Filename 0 2048 8 Filename 8 Filename 0 0 0 0 0 0 0 0 0 0 0 0 550
/**
 * The name of a file, such as a texture file or an Egg file.  Stores the full
 * pathname, and includes functions for extracting out the directory prefix
 * part and the file extension and stuff.
 *
 * A Filename is also aware of the mapping between the Unix-like filename
 * convention we use internally, and the local OS's specific filename
 * convention, and it knows how to perform basic OS-specific I/O, like testing
 * for file existence and searching a searchpath, as well as the best way to
 * open an fstream for reading or writing.
 */

194 9 FlacAudio 0 75777 9 FlacAudio 9 FlacAudio 0 0 0 1 111 106 0 2 112 113 0 0 1 0 189 0 0 0 0 82
/**
 * Reads FLAC audio files.  Ogg-encapsulated FLAC files are not supported.
 */

195 16 MovieAudioCursor 0 75777 16 MovieAudioCursor 16 MovieAudioCursor 0 0 0 1 114 0 0 13 115 116 117 118 119 120 121 122 123 124 125 126 127 0 0 1 0 190 0 0 0 0 501
/**
 * A MovieAudio is actually any source that provides a sequence of audio
 * samples.  That could include an AVI file, a microphone, or an internet TV
 * station.  A MovieAudioCursor is a handle that lets you read data
 * sequentially from a MovieAudio.
 *
 * Thread safety: each individual MovieAudioCursor must be owned and accessed
 * by a single thread.  It is OK for two different threads to open the same
 * file at the same time, as long as they use separate MovieAudioCursor
 * objects.
 */

196 15 FlacAudioCursor 0 75777 15 FlacAudioCursor 15 FlacAudioCursor 0 0 0 1 128 0 0 1 129 0 0 1 0 195 0 0 0 0 104
/**
 * Interfaces with the libvorbisfile library to implement decoding of Ogg
 * Vorbis audio files.
 */

197 10 MovieVideo 0 26625 10 MovieVideo 10 MovieVideo 0 0 0 1 134 135 2 281 282 5 136 137 138 139 140 0 0 2 3 190 130 131 3 191 132 133 0 0 400
/**
 * A MovieVideo is actually any source that provides a sequence of video
 * frames.  That could include an AVI file, a digital camera, or an internet
 * TV station.
 *
 * The difference between a MovieVideo and a MovieVideoCursor is like the
 * difference between a filename and a file handle.  The MovieVideo just
 * indicates a particular movie.  The MovieVideoCursor is what allows access.
 */

198 17 SubfileInfo const 0 8832 17 SubfileInfo const 17 SubfileInfo const 0 0 199 0 0 0 0 0 0 0 0 0 0

199 11 SubfileInfo 0 2048 11 SubfileInfo 11 SubfileInfo 0 0 0 0 0 0 0 0 0 0 0 0 200
/**
 * This class records a particular byte sub-range within an existing file on
 * disk.  Generally, the filename is understood as a physical file on disk,
 * and not to be looked up via the vfs.
 */

200 12 InkblotVideo 0 75777 12 InkblotVideo 12 InkblotVideo 0 0 0 1 141 135 0 1 142 0 0 1 0 197 0 0 0 0 85
/**
 * A cellular automaton that generates an amusing pattern of swirling colors.
 */

201 16 MovieVideoCursor 0 75777 16 MovieVideoCursor 16 MovieVideoCursor 0 0 0 1 164 0 0 17 143 144 145 146 147 148 149 150 151 152 153 154 159 160 161 162 163 0 0 1 0 190 0 0 0 1 202 504
/**
 * A MovieVideo is actually any source that provides a sequence of video
 * frames.  That could include an AVI file, a digital camera, or an internet
 * TV station.  A MovieVideoCursor is a handle that lets you read data
 * sequentially from a MovieVideo.
 *
 * Thread safety: each individual MovieVideoCursor must be owned and accessed
 * by a single thread.  It is OK for two different threads to open the same
 * file at the same time, as long as they use separate MovieVideoCursor
 * objects.
 */

202 6 Buffer 0 337921 24 MovieVideoCursor::Buffer 24 MovieVideoCursor::Buffer 201 0 0 1 158 0 0 3 155 156 157 0 0 1 0 203 0 0 0 0 0

203 19 TypedReferenceCount 0 2049 19 TypedReferenceCount 19 TypedReferenceCount 0 0 0 0 0 0 0 0 0 0 0 0 410
/**
 * A base class for things which need to inherit from both TypedObject and
 * from ReferenceCount.  It's convenient to define this intermediate base
 * class instead of multiply inheriting from the two classes each time they
 * are needed, so that we can sensibly pass around pointers to things which
 * are both TypedObjects and ReferenceCounters.
 *
 * See also TypedObject for detailed instructions.
 */

204 18 InkblotVideoCursor 0 75777 18 InkblotVideoCursor 18 InkblotVideoCursor 0 0 0 1 165 0 0 1 166 0 0 1 0 201 0 0 0 0 85
/**
 * A cellular automaton that generates an amusing pattern of swirling colors.
 */

205 15 MicrophoneAudio 0 75777 15 MicrophoneAudio 15 MicrophoneAudio 0 0 0 0 106 3 283 284 285 5 167 168 169 170 172 1 286 0 1 0 189 0 0 0 0 99
/**
 * Class MicrophoneAudio provides the means to read raw audio samples from a
 * microphone.
 */

206 28 PointerTo< MicrophoneAudio > 0 2048 28 PointerTo< MicrophoneAudio > 28 PointerTo< MicrophoneAudio > 0 0 0 0 0 0 0 0 0 0 0 0 0

207 3 int 0 8194 3 int 3 int 0 1 0 0 0 0 0 0 0 0 0 0 0

208 13 UserDataAudio 0 75777 13 UserDataAudio 13 UserDataAudio 0 0 0 1 173 106 0 3 174 175 176 0 0 1 0 189 0 0 0 0 358
/**
 * A UserDataAudio is a way for the user to manually supply raw audio samples.
 * remove_after_read means the data will be removed if read once.  Else data
 * will be stored (enable looping and seeking). Expects data as 16 bit signed
 * (word); Example for stereo: 1.word = 1.channel,2.word = 2.channel, 3.word =
 * 1.channel,4.word = 2.channel, etc.
 */

209 19 UserDataAudioCursor 0 75777 19 UserDataAudioCursor 19 UserDataAudioCursor 0 0 0 1 177 0 0 1 178 0 0 1 0 195 0 0 0 0 98
/**
 * A UserDataAudioCursor is a means to manually supply a sequence of raw audio
 * samples.
 */

210 11 VorbisAudio 0 75777 11 VorbisAudio 11 VorbisAudio 0 0 0 1 179 106 0 2 180 181 0 0 1 0 189 0 0 0 0 104
/**
 * Interfaces with the libvorbisfile library to implement decoding of Ogg
 * Vorbis audio files.
 */

211 17 VorbisAudioCursor 0 75777 17 VorbisAudioCursor 17 VorbisAudioCursor 0 0 0 1 182 0 0 1 183 0 0 1 0 195 0 0 0 0 104
/**
 * Interfaces with the libvorbisfile library to implement decoding of Ogg
 * Vorbis audio files.
 */

212 8 WavAudio 0 75777 8 WavAudio 8 WavAudio 0 0 0 1 184 106 0 2 185 186 0 0 1 0 189 0 0 0 0 104
/**
 * A native PCM .wav loader.  Supported formats are linear PCM, IEEE float,
 * A-law and mu-law.
 */

213 14 WavAudioCursor 0 75777 14 WavAudioCursor 14 WavAudioCursor 0 0 0 1 187 0 0 1 188 0 0 1 0 195 0 0 0 0 111
/**
 * Used for reading PCM .wav files.  Supported formats are linear PCM, IEEE
 * float, A-law and mu-law.
 */

214 18 MovieAudio const * 0 8576 18 MovieAudio const * 18 MovieAudio const * 0 0 215 0 0 0 0 0 0 0 0 0 0

215 16 MovieAudio const 0 8832 16 MovieAudio const 16 MovieAudio const 0 0 189 0 0 0 0 0 0 0 0 0 0

216 12 MovieAudio * 0 8576 12 MovieAudio * 12 MovieAudio * 0 0 189 0 0 0 0 0 0 0 0 0 0

217 13 atomic string 0 2 13 atomic string 13 atomic string 0 7 0 0 0 0 0 0 0 0 0 0 0

218 18 MovieAudioCursor * 0 8576 18 MovieAudioCursor * 18 MovieAudioCursor * 0 0 195 0 0 0 0 0 0 0 0 0 0

219 16 Filename const * 0 8576 16 Filename const * 16 Filename const * 0 0 192 0 0 0 0 0 0 0 0 0 0

220 10 TypeHandle 0 16779264 10 TypeHandle 10 TypeHandle 0 0 0 0 0 0 0 0 0 0 0 0 732
/**
 * TypeHandle is the identifier used to differentiate C++ class types.  Any
 * C++ classes that inherit from some base class, and must be differentiated
 * at run time, should store a static TypeHandle object that can be queried
 * through a static member function named get_class_type().  Most of the time,
 * it is also desirable to inherit from TypedObject, which provides some
 * virtual functions to return the TypeHandle for a particular instance.
 *
 * At its essence, a TypeHandle is simply a unique identifier that is assigned
 * by the TypeRegistry.  The TypeRegistry stores a tree of TypeHandles, so
 * that ancestry of a particular type may be queried, and the type name may be
 * retrieved for run-time display.
 */

221 12 TypeHandle * 0 8576 12 TypeHandle * 12 TypeHandle * 0 0 220 0 0 0 0 0 0 0 0 0 0

222 29 TypedWritableReferenceCount * 0 8576 29 TypedWritableReferenceCount * 29 TypedWritableReferenceCount * 0 0 190 0 0 0 0 0 0 0 0 0 0

223 9 Namable * 0 8576 9 Namable * 9 Namable * 0 0 191 0 0 0 0 0 0 0 0 0 0

224 11 FlacAudio * 0 8576 11 FlacAudio * 11 FlacAudio * 0 0 194 0 0 0 0 0 0 0 0 0 0

225 17 FlacAudio const * 0 8576 17 FlacAudio const * 17 FlacAudio const * 0 0 226 0 0 0 0 0 0 0 0 0 0

226 15 FlacAudio const 0 8832 15 FlacAudio const 15 FlacAudio const 0 0 194 0 0 0 0 0 0 0 0 0 0

227 24 MovieAudioCursor const * 0 8576 24 MovieAudioCursor const * 24 MovieAudioCursor const * 0 0 228 0 0 0 0 0 0 0 0 0 0

228 22 MovieAudioCursor const 0 8832 22 MovieAudioCursor const 22 MovieAudioCursor const 0 0 195 0 0 0 0 0 0 0 0 0 0

229 6 double 0 8194 6 double 6 double 0 3 0 0 0 0 0 0 0 0 0 0 0

230 4 bool 0 8194 4 bool 4 bool 0 4 0 0 0 0 0 0 0 0 0 0 0

231 4 void 0 8194 4 void 4 void 0 6 0 0 0 0 0 0 0 0 0 0 0

232 10 Datagram * 0 8576 10 Datagram * 10 Datagram * 0 0 233 0 0 0 0 0 0 0 0 0 0

233 8 Datagram 0 2048 8 Datagram 8 Datagram 0 0 0 0 0 0 0 0 0 0 0 0 565
/**
 * An ordered list of data elements, formatted in memory for transmission over
 * a socket or writing to a data file.
 *
 * Data elements should be added one at a time, in order, to the Datagram.
 * The nature and contents of the data elements are totally up to the user.
 * When a Datagram has been transmitted and received, its data elements may be
 * extracted using a DatagramIterator; it is up to the caller to know the
 * correct type of each data element in order.
 *
 * A Datagram is itself headerless; it is simply a collection of data
 * elements.
 */

234 9 istream * 0 8576 9 istream * 9 istream * 0 0 235 0 0 0 0 0 0 0 0 0 0

235 7 istream 0 2048 7 istream 7 istream 0 0 0 0 0 0 0 0 0 0 0 0 0

236 17 FlacAudioCursor * 0 8576 17 FlacAudioCursor * 17 FlacAudioCursor * 0 0 196 0 0 0 0 0 0 0 0 0 0

237 23 FlacAudioCursor const * 0 8576 23 FlacAudioCursor const * 23 FlacAudioCursor const * 0 0 238 0 0 0 0 0 0 0 0 0 0

238 21 FlacAudioCursor const 0 8832 21 FlacAudioCursor const 21 FlacAudioCursor const 0 0 196 0 0 0 0 0 0 0 0 0 0

239 18 MovieVideo const * 0 8576 18 MovieVideo const * 18 MovieVideo const * 0 0 240 0 0 0 0 0 0 0 0 0 0

240 16 MovieVideo const 0 8832 16 MovieVideo const 16 MovieVideo const 0 0 197 0 0 0 0 0 0 0 0 0 0

241 12 MovieVideo * 0 8576 12 MovieVideo * 12 MovieVideo * 0 0 197 0 0 0 0 0 0 0 0 0 0

242 18 MovieVideoCursor * 0 8576 18 MovieVideoCursor * 18 MovieVideoCursor * 0 0 201 0 0 0 0 0 0 0 0 0 0

243 19 SubfileInfo const * 0 8576 19 SubfileInfo const * 19 SubfileInfo const * 0 0 198 0 0 0 0 0 0 0 0 0 0

244 20 InkblotVideo const * 0 8576 20 InkblotVideo const * 20 InkblotVideo const * 0 0 245 0 0 0 0 0 0 0 0 0 0

245 18 InkblotVideo const 0 8832 18 InkblotVideo const 18 InkblotVideo const 0 0 200 0 0 0 0 0 0 0 0 0 0

246 14 InkblotVideo * 0 8576 14 InkblotVideo * 14 InkblotVideo * 0 0 200 0 0 0 0 0 0 0 0 0 0

247 24 MovieVideoCursor const * 0 8576 24 MovieVideoCursor const * 24 MovieVideoCursor const * 0 0 248 0 0 0 0 0 0 0 0 0 0

248 22 MovieVideoCursor const 0 8832 22 MovieVideoCursor const 22 MovieVideoCursor const 0 0 201 0 0 0 0 0 0 0 0 0 0

249 9 Texture * 0 8576 9 Texture * 9 Texture * 0 0 250 0 0 0 0 0 0 0 0 0 0

250 7 Texture 0 2048 7 Texture 7 Texture 0 0 0 0 0 0 0 0 0 0 0 0 688
/**
 * Represents a texture object, which is typically a single 2-d image but may
 * also represent a 1-d or 3-d texture image, or the six 2-d faces of a cube
 * map texture.
 *
 * A texture's image data might be stored in system RAM (see get_ram_image())
 * or its image may be represented in texture memory on one or more
 * GraphicsStateGuardians (see prepare()), or both.  The typical usage pattern
 * is that a texture is loaded from an image file on disk, which copies its
 * image data into system RAM; then the first time the texture is rendered its
 * image data is copied to texture memory (actually, to the graphics API), and
 * the system RAM image is automatically freed.
 */

251 8 Buffer * 0 8576 26 MovieVideoCursor::Buffer * 26 MovieVideoCursor::Buffer * 0 0 202 0 0 0 0 0 0 0 0 0 0

252 14 Buffer const * 0 8576 32 MovieVideoCursor::Buffer const * 32 MovieVideoCursor::Buffer const * 0 0 253 0 0 0 0 0 0 0 0 0 0

253 12 Buffer const 0 8832 30 MovieVideoCursor::Buffer const 30 MovieVideoCursor::Buffer const 0 0 202 0 0 0 0 0 0 0 0 0 0

254 20 InkblotVideoCursor * 0 8576 20 InkblotVideoCursor * 20 InkblotVideoCursor * 0 0 204 0 0 0 0 0 0 0 0 0 0

255 26 InkblotVideoCursor const * 0 8576 26 InkblotVideoCursor const * 26 InkblotVideoCursor const * 0 0 256 0 0 0 0 0 0 0 0 0 0

256 24 InkblotVideoCursor const 0 8832 24 InkblotVideoCursor const 24 InkblotVideoCursor const 0 0 204 0 0 0 0 0 0 0 0 0 0

257 17 MicrophoneAudio * 0 8576 17 MicrophoneAudio * 17 MicrophoneAudio * 0 0 205 0 0 0 0 0 0 0 0 0 0

258 23 MicrophoneAudio const * 0 8576 23 MicrophoneAudio const * 23 MicrophoneAudio const * 0 0 259 0 0 0 0 0 0 0 0 0 0

259 21 MicrophoneAudio const 0 8832 21 MicrophoneAudio const 21 MicrophoneAudio const 0 0 205 0 0 0 0 0 0 0 0 0 0

260 21 UserDataAudio const * 0 8576 21 UserDataAudio const * 21 UserDataAudio const * 0 0 261 0 0 0 0 0 0 0 0 0 0

261 19 UserDataAudio const 0 8832 19 UserDataAudio const 19 UserDataAudio const 0 0 208 0 0 0 0 0 0 0 0 0 0

262 15 UserDataAudio * 0 8576 15 UserDataAudio * 15 UserDataAudio * 0 0 208 0 0 0 0 0 0 0 0 0 0

263 18 DatagramIterator * 0 8576 18 DatagramIterator * 18 DatagramIterator * 0 0 264 0 0 0 0 0 0 0 0 0 0

264 16 DatagramIterator 0 2048 16 DatagramIterator 16 DatagramIterator 0 0 0 0 0 0 0 0 0 0 0 0 215
/**
 * A class to retrieve the individual data elements previously stored in a
 * Datagram.  Elements may be retrieved one at a time; it is up to the caller
 * to know the correct type and order of each element.
 */

265 21 UserDataAudioCursor * 0 8576 21 UserDataAudioCursor * 21 UserDataAudioCursor * 0 0 209 0 0 0 0 0 0 0 0 0 0

266 27 UserDataAudioCursor const * 0 8576 27 UserDataAudioCursor const * 27 UserDataAudioCursor const * 0 0 267 0 0 0 0 0 0 0 0 0 0

267 25 UserDataAudioCursor const 0 8832 25 UserDataAudioCursor const 25 UserDataAudioCursor const 0 0 209 0 0 0 0 0 0 0 0 0 0

268 13 VorbisAudio * 0 8576 13 VorbisAudio * 13 VorbisAudio * 0 0 210 0 0 0 0 0 0 0 0 0 0

269 19 VorbisAudio const * 0 8576 19 VorbisAudio const * 19 VorbisAudio const * 0 0 270 0 0 0 0 0 0 0 0 0 0

270 17 VorbisAudio const 0 8832 17 VorbisAudio const 17 VorbisAudio const 0 0 210 0 0 0 0 0 0 0 0 0 0

271 19 VorbisAudioCursor * 0 8576 19 VorbisAudioCursor * 19 VorbisAudioCursor * 0 0 211 0 0 0 0 0 0 0 0 0 0

272 25 VorbisAudioCursor const * 0 8576 25 VorbisAudioCursor const * 25 VorbisAudioCursor const * 0 0 273 0 0 0 0 0 0 0 0 0 0

273 23 VorbisAudioCursor const 0 8832 23 VorbisAudioCursor const 23 VorbisAudioCursor const 0 0 211 0 0 0 0 0 0 0 0 0 0

274 10 WavAudio * 0 8576 10 WavAudio * 10 WavAudio * 0 0 212 0 0 0 0 0 0 0 0 0 0

275 16 WavAudio const * 0 8576 16 WavAudio const * 16 WavAudio const * 0 0 276 0 0 0 0 0 0 0 0 0 0

276 14 WavAudio const 0 8832 14 WavAudio const 14 WavAudio const 0 0 212 0 0 0 0 0 0 0 0 0 0

277 16 WavAudioCursor * 0 8576 16 WavAudioCursor * 16 WavAudioCursor * 0 0 213 0 0 0 0 0 0 0 0 0 0

278 22 WavAudioCursor const * 0 8576 22 WavAudioCursor const * 22 WavAudioCursor const * 0 0 279 0 0 0 0 0 0 0 0 0 0

279 20 WavAudioCursor const 0 8832 20 WavAudioCursor const 20 WavAudioCursor const 0 0 213 0 0 0 0 0 0 0 0 0 0

0
6
280 8 filename 0 2 0 109 0 0 0 0 0 20 MovieAudio::filename 0

281 8 filename 0 2 0 138 0 0 0 0 0 20 MovieVideo::filename 0

282 12 subfile_info 0 2 0 139 0 0 0 0 0 24 MovieVideo::subfile_info 0

283 7 options 0 66 0 171 0 0 0 0 167 24 MicrophoneAudio::options 0

284 8 channels 0 2 0 169 0 0 0 0 0 25 MicrophoneAudio::channels 0

285 4 rate 0 2 0 170 0 0 0 0 0 21 MicrophoneAudio::rate 0

1
286 11 get_options 0 167 168 28 MicrophoneAudio::get_options 0

