1508346830
3 2
12 libp3collide 4 dlaq 12 panda3d.core 
273
277 20 get_collision_origin 0 6 550 36 CollisionSolid::get_collision_origin 0 1 1 0
69
virtual LPoint3 CollisionSolid::get_collision_origin(void) const = 0;

278 12 set_tangible 0 4 550 28 CollisionSolid::set_tangible 0 1 2 295
/**
 * Sets the current state of the 'tangible' flag.  Set this true to make the
 * solid tangible, so that a CollisionHandlerPusher will not allow another
 * object to intersect it, or false to make it intangible, so that a
 * CollisionHandlerPusher will ignore it except to throw an event.
 */
56
inline void CollisionSolid::set_tangible(bool tangible);

279 11 is_tangible 0 4 550 27 CollisionSolid::is_tangible 0 1 3 266
/**
 * Returns whether the solid is considered 'tangible' or not.  An intangible
 * solid has no effect in a CollisionHandlerPusher (except to throw an event);
 * it's useful for defining 'trigger' planes and spheres, that cause an effect
 * when passed through.
 */
52
inline bool CollisionSolid::is_tangible(void) const;

280 20 set_effective_normal 0 4 550 36 CollisionSolid::set_effective_normal 0 1 4 388
/**
 * Records a false normal for this CollisionSolid that will be reported by the
 * collision system with all collisions into it, instead of its actual normal.
 * This is useful as a workaround for the problem of an avatar wanting to
 * stand on a sloping ground; by storing a false normal, the ground appears to
 * be perfectly level, and the avatar does not tend to slide down it.
 */
83
inline void CollisionSolid::set_effective_normal(LVector3 const &effective_normal);

281 22 clear_effective_normal 0 4 550 38 CollisionSolid::clear_effective_normal 0 1 5 71
/**
 * Removes the normal previously set by set_effective_normal().
 */
57
inline void CollisionSolid::clear_effective_normal(void);

282 20 has_effective_normal 0 4 550 36 CollisionSolid::has_effective_normal 0 1 6 98
/**
 * Returns true if a special normal was set by set_effective_normal(), false
 * otherwise.
 */
61
inline bool CollisionSolid::has_effective_normal(void) const;

283 20 get_effective_normal 0 4 550 36 CollisionSolid::get_effective_normal 0 1 7 145
/**
 * Returns the normal that was set by set_effective_normal().  It is an error
 * to call this unless has_effective_normal() returns true.
 */
72
inline LVector3 const &CollisionSolid::get_effective_normal(void) const;

284 28 set_respect_effective_normal 0 4 550 44 CollisionSolid::set_respect_effective_normal 0 1 8 296
/**
 * This is only meaningful for CollisionSolids that will be added to a
 * traverser as colliders.  It is normally true, but if set false, it means
 * that this particular solid does not care about the "effective" normal of
 * other solids it meets, but rather always uses the true normal.
 */
88
inline void CollisionSolid::set_respect_effective_normal(bool respect_effective_normal);

285 28 get_respect_effective_normal 0 4 550 44 CollisionSolid::get_respect_effective_normal 0 1 9 46
/**
 * See set_respect_effective_normal().
 */
69
inline bool CollisionSolid::get_respect_effective_normal(void) const;

286 10 get_bounds 0 4 550 26 CollisionSolid::get_bounds 0 1 10 47
/**
 * Returns the solid's bounding volume.
 */
72
ConstPointerTo< BoundingVolume > CollisionSolid::get_bounds(void) const;

287 10 set_bounds 0 4 550 26 CollisionSolid::set_bounds 0 1 11 47
/**
 * Returns the solid's bounding volume.
 */
71
void CollisionSolid::set_bounds(BoundingVolume const &bounding_volume);

288 6 output 0 6 550 22 CollisionSolid::output 0 1 12 10
/**
 *
 */
56
virtual void CollisionSolid::output(ostream &out) const;

289 5 write 0 6 550 21 CollisionSolid::write 0 1 13 10
/**
 *
 */
77
virtual void CollisionSolid::write(ostream &out, int indent_level = 0) const;

290 14 get_class_type 0 4 550 30 CollisionSolid::get_class_type 0 1 14 0
55
static TypeHandle CollisionSolid::get_class_type(void);

291 12 CollisionBox 0 4 556 26 CollisionBox::CollisionBox 0 2 15 16 256
/**
 * Create the Box by giving a Center and distances of each of the sides of
 * box from the Center.
 */

/**
 * Create the Box by Specifying the Diagonal Points
 */

/**
 * Creates an invalid Box.  Only used when reading from a bam file.
 */

/**
 *
 */
177
inline CollisionBox::CollisionBox(LPoint3 const &center, PN_stdfloat x, PN_stdfloat y, PN_stdfloat z);
inline CollisionBox::CollisionBox(LPoint3 const &min, LPoint3 const &max);

292 14 get_num_points 0 4 556 28 CollisionBox::get_num_points 0 1 17 68
/**
 * Returns 8: the number of vertices of a rectangular solid.
 */
52
inline int CollisionBox::get_num_points(void) const;

293 14 get_point_aabb 0 4 556 28 CollisionBox::get_point_aabb 0 1 18 67
/**
 * Returns the nth vertex of the Axis Aligned Bounding Box.
 */
57
inline LPoint3 CollisionBox::get_point_aabb(int n) const;

294 9 get_point 0 4 556 23 CollisionBox::get_point 0 1 19 45
/**
 * Returns the nth vertex of the OBB.
 */
52
inline LPoint3 CollisionBox::get_point(int n) const;

295 14 get_num_planes 0 4 556 28 CollisionBox::get_num_planes 0 1 20 65
/**
 * Returns 6: the number of faces of a rectangular solid.
 */
52
inline int CollisionBox::get_num_planes(void) const;

296 9 set_plane 0 4 556 23 CollisionBox::set_plane 0 1 21 57
/**
 * Creates the nth face of the rectangular solid.
 */
51
inline LPlane CollisionBox::set_plane(int n) const;

297 9 get_plane 0 4 556 23 CollisionBox::get_plane 0 1 22 57
/**
 * Returns the nth face of the rectangular solid.
 */
51
inline LPlane CollisionBox::get_plane(int n) const;

298 10 set_center 0 4 556 24 CollisionBox::set_center 0 2 23 24 22
/**
 *
 */

/**
 *
 */
143
inline void CollisionBox::set_center(LPoint3 const &center);
inline void CollisionBox::set_center(PN_stdfloat x, PN_stdfloat y, PN_stdfloat z);

299 10 get_center 0 4 556 24 CollisionBox::get_center 0 1 25 10
/**
 *
 */
59
inline LPoint3 const &CollisionBox::get_center(void) const;

300 7 get_min 0 4 556 21 CollisionBox::get_min 0 1 26 10
/**
 *
 */
56
inline LPoint3 const &CollisionBox::get_min(void) const;

301 7 get_max 0 4 556 21 CollisionBox::get_max 0 1 27 10
/**
 *
 */
56
inline LPoint3 const &CollisionBox::get_max(void) const;

302 14 get_dimensions 0 4 556 28 CollisionBox::get_dimensions 0 1 28 10
/**
 *
 */
57
inline LVector3 CollisionBox::get_dimensions(void) const;

303 14 get_class_type 0 4 556 28 CollisionBox::get_class_type 0 1 29 0
53
static TypeHandle CollisionBox::get_class_type(void);

304 13 ~CollisionBox 0 4 556 27 CollisionBox::~CollisionBox 0 0 0
34
CollisionBox::~CollisionBox(void);

305 14 get_class_type 0 4 560 32 CollisionHandler::get_class_type 0 1 31 0
57
static TypeHandle CollisionHandler::get_class_type(void);

306 16 CollisionHandler 0 4 560 34 CollisionHandler::CollisionHandler 0 1 30 10
/**
 *
 */
78
inline CollisionHandler::CollisionHandler(CollisionHandler const &) = default;

307 17 ~CollisionHandler 0 4 560 35 CollisionHandler::~CollisionHandler 0 0 0
42
CollisionHandler::~CollisionHandler(void);

308 13 CollisionNode 0 4 562 28 CollisionNode::CollisionNode 0 1 32 22
/**
 *
 */

/**
 *
 */
54
CollisionNode::CollisionNode(std::string const &name);

309 16 set_collide_mask 0 4 562 31 CollisionNode::set_collide_mask 0 1 33 98
/**
 * Simultaneously sets both the "from" and "into" CollideMask values to the
 * same thing.
 */
62
inline void CollisionNode::set_collide_mask(CollideMask mask);

310 21 set_from_collide_mask 0 4 562 36 CollisionNode::set_from_collide_mask 0 1 34 222
/**
 * Sets the "from" CollideMask.  In order for a collision to be detected from
 * this object into another object, the intersection of this object's "from"
 * mask and the other object's "into" mask must be nonzero.
 */
60
void CollisionNode::set_from_collide_mask(CollideMask mask);

311 21 set_into_collide_mask 0 4 562 36 CollisionNode::set_into_collide_mask 0 1 35 222
/**
 * Sets the "into" CollideMask.  In order for a collision to be detected from
 * another object into this object, the intersection of the other object's
 * "from" mask and this object's "into" mask must be nonzero.
 */
67
inline void CollisionNode::set_into_collide_mask(CollideMask mask);

312 21 get_from_collide_mask 0 4 562 36 CollisionNode::get_from_collide_mask 0 1 36 233
/**
 * Returns the current "from" CollideMask.  In order for a collision to be
 * detected from this object into another object, the intersection of this
 * object's "from" mask and the other object's "into" mask must be nonzero.
 */
68
inline CollideMask CollisionNode::get_from_collide_mask(void) const;

313 21 get_into_collide_mask 0 4 562 36 CollisionNode::get_into_collide_mask 0 1 37 233
/**
 * Returns the current "into" CollideMask.  In order for a collision to be
 * detected from another object into this object, the intersection of the
 * other object's "from" mask and this object's "into" mask must be nonzero.
 */
68
inline CollideMask CollisionNode::get_into_collide_mask(void) const;

314 12 clear_solids 0 4 562 27 CollisionNode::clear_solids 0 1 38 44
/**
 * Removes all solids from the node.
 */
46
inline void CollisionNode::clear_solids(void);

315 14 get_num_solids 0 4 562 29 CollisionNode::get_num_solids 0 1 39 10
/**
 *
 */
53
inline int CollisionNode::get_num_solids(void) const;

316 9 get_solid 0 4 562 24 CollisionNode::get_solid 0 1 40 10
/**
 *
 */
78
inline ConstPointerTo< CollisionSolid > CollisionNode::get_solid(int n) const;

317 12 modify_solid 0 4 562 27 CollisionNode::modify_solid 0 1 41 10
/**
 *
 */
70
inline PointerTo< CollisionSolid > CollisionNode::modify_solid(int n);

318 9 set_solid 0 4 562 24 CollisionNode::set_solid 0 1 42 55
/**
 * Replaces the solid with the indicated index.
 */
67
inline void CollisionNode::set_solid(int n, CollisionSolid *solid);

319 12 remove_solid 0 4 562 27 CollisionNode::remove_solid 0 1 43 110
/**
 * Removes the solid with the indicated index.  This will shift all subsequent
 * indices down by one.
 */
47
inline void CollisionNode::remove_solid(int n);

320 9 add_solid 0 4 562 24 CollisionNode::add_solid 0 1 44 121
/**
 * Adds the indicated solid to the node.  Returns the index of the new solid
 * within the node's list of solids.
 */
65
inline int CollisionNode::add_solid(CollisionSolid const *solid);

321 0 0 0 0 0 0 0 0
0

322 17 get_collider_sort 0 4 562 32 CollisionNode::get_collider_sort 0 1 45 114
/**
 * Returns the collider_sort value that has been set for this particular node.
 * See set_collider_sort().
 */
56
inline int CollisionNode::get_collider_sort(void) const;

323 17 set_collider_sort 0 4 562 32 CollisionNode::set_collider_sort 0 1 46 594
/**
 * Sets a particular collider_sort value on this node.  This controls the
 * order in which colliders (that is, "from nodes") are grouped together for
 * the collision traversal.
 *
 * If there are 32 or fewer colliders added to any particular
 * CollisionTraverser, then this value has no meaning.  It is only useful if
 * there are many colliders, which may force the CollisionTraverser to make
 * multiple passes through the data; in that case, it may be a useful
 * optimization to group colliders that have similar bounding volumes together
 * (by giving them similar sort values).
 */
55
inline void CollisionNode::set_collider_sort(int sort);

324 24 get_default_collide_mask 0 4 562 39 CollisionNode::get_default_collide_mask 0 1 47 80
/**
 * Returns the default into_collide_mask assigned to new CollisionNodes.
 */
72
static inline CollideMask CollisionNode::get_default_collide_mask(void);

325 14 get_class_type 0 4 562 29 CollisionNode::get_class_type 0 1 48 0
54
static TypeHandle CollisionNode::get_class_type(void);

326 18 CollisionTraverser 0 4 569 38 CollisionTraverser::CollisionTraverser 0 2 49 50 10
/**
 *
 */
159
CollisionTraverser::CollisionTraverser(std::string const &name = "ctrav");
inline CollisionTraverser::CollisionTraverser(CollisionTraverser const &) = default;

327 19 ~CollisionTraverser 0 4 569 39 CollisionTraverser::~CollisionTraverser 0 0 10
/**
 *
 */
46
CollisionTraverser::~CollisionTraverser(void);

328 26 set_respect_prev_transform 0 4 569 46 CollisionTraverser::set_respect_prev_transform 0 1 51 370
/**
 * Sets the flag that indicates whether the prev_transform stored on a node
 * (as updated via set_fluid_pos(), etc.) is respected to calculate
 * collisions.  If this is true, certain types of collision tests will be
 * enhanced by the information about objects in motion.  If this is false,
 * objects are always considered to be static.  The default is false.
 */
70
inline void CollisionTraverser::set_respect_prev_transform(bool flag);

329 26 get_respect_prev_transform 0 4 569 46 CollisionTraverser::get_respect_prev_transform 0 1 52 162
/**
 * Returns the flag that indicates whether the prev_transform stored on a node
 * is respected to calculate collisions.  See set_respect_prev_transform().
 */
71
inline bool CollisionTraverser::get_respect_prev_transform(void) const;

330 12 add_collider 0 4 569 32 CollisionTraverser::add_collider 0 1 53 437
/**
 * Adds a new CollisionNode, representing an object that will be tested for
 * collisions into other objects, along with the handler that will serve each
 * detected collision.  Each CollisionNode may be served by only one handler
 * at a time, but a given handler may serve many CollisionNodes.
 *
 * The handler that serves a particular node may be changed from time to time
 * by calling add_collider() again on the same node.
 */
91
void CollisionTraverser::add_collider(NodePath const &collider, CollisionHandler *handler);

331 15 remove_collider 0 4 569 35 CollisionTraverser::remove_collider 0 1 54 263
/**
 * Removes the collider (and its associated handler) from the set of
 * CollisionNodes that will be tested each frame for collisions into other
 * objects.  Returns true if the definition was found and removed, false if it
 * wasn't present to begin with.
 */
67
bool CollisionTraverser::remove_collider(NodePath const &collider);

332 12 has_collider 0 4 569 32 CollisionTraverser::has_collider 0 1 55 145
/**
 * Returns true if the indicated node is current in the set of nodes that will
 * be tested each frame for collisions into other objects.
 */
70
bool CollisionTraverser::has_collider(NodePath const &collider) const;

333 17 get_num_colliders 0 4 569 37 CollisionTraverser::get_num_colliders 0 1 56 108
/**
 * Returns the number of CollisionNodes that have been added to the traverser
 * via add_collider().
 */
54
int CollisionTraverser::get_num_colliders(void) const;

334 12 get_collider 0 4 569 32 CollisionTraverser::get_collider 0 1 57 100
/**
 * Returns the nth CollisionNode that has been added to the traverser via
 * add_collider().
 */
55
NodePath CollisionTraverser::get_collider(int n) const;

335 11 get_handler 0 4 569 31 CollisionTraverser::get_handler 0 1 58 169
/**
 * Returns the handler that is currently assigned to serve the indicated
 * collision node, or NULL if the node is not on the traverser's set of active
 * nodes.
 */
82
CollisionHandler *CollisionTraverser::get_handler(NodePath const &collider) const;

336 15 clear_colliders 0 4 569 35 CollisionTraverser::clear_colliders 0 1 59 90
/**
 * Completely empties the set of collision nodes and their associated
 * handlers.
 */
47
void CollisionTraverser::clear_colliders(void);

337 0 0 0 0 0 0 0 0
0

338 8 traverse 0 4 569 28 CollisionTraverser::traverse 0 1 60 10
/**
 *
 */
56
void CollisionTraverser::traverse(NodePath const &root);

339 12 set_recorder 0 4 569 32 CollisionTraverser::set_recorder 0 1 61 777
/**
 * Uses the indicated CollisionRecorder object to start recording the
 * intersection tests made by each subsequent call to traverse() on this
 * object.  A particular CollisionRecorder object can only record one
 * traverser at a time; if this object has already been assigned to another
 * traverser, that assignment is broken.
 *
 * This is intended to be used in a debugging mode to try to determine what
 * work is being performed by the collision traversal.  Usually, attaching a
 * recorder will impose significant runtime overhead.
 *
 * This does not transfer ownership of the CollisionRecorder pointer;
 * maintenance of that remains the caller's responsibility.  If the
 * CollisionRecorder is destructed, it will cleanly remove itself from the
 * traverser.
 */
67
void CollisionTraverser::set_recorder(CollisionRecorder *recorder);

340 12 has_recorder 0 4 569 32 CollisionTraverser::has_recorder 0 1 62 120
/**
 * Returns true if the CollisionTraverser has a CollisionRecorder object
 * currently assigned, false otherwise.
 */
57
inline bool CollisionTraverser::has_recorder(void) const;

341 12 get_recorder 0 4 569 32 CollisionTraverser::get_recorder 0 1 63 99
/**
 * Returns the CollisionRecorder currently assigned, or NULL if no recorder is
 * assigned.
 */
71
inline CollisionRecorder *CollisionTraverser::get_recorder(void) const;

342 14 clear_recorder 0 4 569 34 CollisionTraverser::clear_recorder 0 1 64 107
/**
 * Removes the CollisionRecorder from the traverser and restores normal low-
 * overhead operation.
 */
53
inline void CollisionTraverser::clear_recorder(void);

343 6 output 0 4 573 25 CollisionRecorder::output 0 1 70 10
/**
 *
 */
51
void CollisionRecorder::output(ostream &out) const;

344 14 get_class_type 0 4 573 33 CollisionRecorder::get_class_type 0 1 71 0
58
static TypeHandle CollisionRecorder::get_class_type(void);

345 15 show_collisions 0 4 569 35 CollisionTraverser::show_collisions 0 1 65 300
/**
 * This is a high-level function to create a CollisionVisualizer object to
 * render the collision tests performed by this traverser.  The supplied root
 * should be any node in the scene graph; typically, the top node (e.g.
 * render).  The CollisionVisualizer will be attached to this node.
 */
79
CollisionVisualizer *CollisionTraverser::show_collisions(NodePath const &root);

346 15 hide_collisions 0 4 569 35 CollisionTraverser::hide_collisions 0 1 66 69
/**
 * Undoes the effect of a previous call to show_collisions().
 */
47
void CollisionTraverser::hide_collisions(void);

347 6 output 0 4 569 26 CollisionTraverser::output 0 1 67 10
/**
 *
 */
52
void CollisionTraverser::output(ostream &out) const;

348 5 write 0 4 569 25 CollisionTraverser::write 0 1 68 10
/**
 *
 */
69
void CollisionTraverser::write(ostream &out, int indent_level) const;

349 14 get_class_type 0 4 569 34 CollisionTraverser::get_class_type 0 1 69 0
59
static TypeHandle CollisionTraverser::get_class_type(void);

350 8 get_from 0 4 575 24 CollisionEntry::get_from 0 1 72 104
/**
 * Returns the CollisionSolid pointer for the particular solid that triggered
 * this collision.
 */
66
inline CollisionSolid const *CollisionEntry::get_from(void) const;

351 8 has_into 0 4 575 24 CollisionEntry::has_into 0 1 73 288
/**
 * Returns true if the "into" solid is, in fact, a CollisionSolid, and its
 * pointer is known (in which case get_into() may be called to retrieve it).
 * If this returns false, the collision was detected into a GeomNode, and
 * there is no CollisionSolid pointer to be retrieved.
 */
49
inline bool CollisionEntry::has_into(void) const;

352 8 get_into 0 4 575 24 CollisionEntry::get_into 0 1 74 243
/**
 * Returns the CollisionSolid pointer for the particular solid was collided
 * into.  This pointer might be NULL if the collision was into a piece of
 * visible geometry, instead of a normal CollisionSolid collision; see
 * has_into().
 */
66
inline CollisionSolid const *CollisionEntry::get_into(void) const;

353 13 get_from_node 0 4 575 29 CollisionEntry::get_from_node 0 1 75 182
/**
 * Returns the node that contains the CollisionSolid that triggered this
 * collision.  This will be a node that has been added to a CollisionTraverser
 * via add_collider().
 */
64
inline CollisionNode *CollisionEntry::get_from_node(void) const;

354 13 get_into_node 0 4 575 29 CollisionEntry::get_into_node 0 1 76 254
/**
 * Returns the node that contains the CollisionSolid that was collided into.
 * This returns a PandaNode pointer instead of something more specific,
 * because it might be either a CollisionNode or a GeomNode.
 *
 * Also see get_into_node_path().
 */
60
inline PandaNode *CollisionEntry::get_into_node(void) const;

355 18 get_from_node_path 0 4 575 34 CollisionEntry::get_from_node_path 0 1 77 224
/**
 * Returns the NodePath that represents the CollisionNode that contains the
 * CollisionSolid that triggered this collision.  This will be a NodePath that
 * has been added to a CollisionTraverser via add_collider().
 */
63
inline NodePath CollisionEntry::get_from_node_path(void) const;

356 18 get_into_node_path 0 4 575 34 CollisionEntry::get_into_node_path 0 1 78 338
/**
 * Returns the NodePath that represents the specific CollisionNode or GeomNode
 * instance that was collided into.  This is the same node returned by
 * get_into_node(), represented as a NodePath; however, it may be more useful
 * because the NodePath can resolve the particular instance of the node, if
 * there is more than one.
 */
63
inline NodePath CollisionEntry::get_into_node_path(void) const;

357 5 set_t 0 4 575 21 CollisionEntry::set_t 0 1 79 82
/**
 * Sets a time value for this collision relative to other CollisionEntries
 */
49
inline void CollisionEntry::set_t(PN_stdfloat t);

358 5 get_t 0 4 575 21 CollisionEntry::get_t 0 1 80 83
/**
 * returns time value for this collision relative to other CollisionEntries
 */
53
inline PN_stdfloat CollisionEntry::get_t(void) const;

359 8 collided 0 4 575 24 CollisionEntry::collided 0 1 81 188
/**
 * returns true if this represents an actual collision as opposed to a
 * potential collision, needed for iterative collision resolution where path
 * of collider changes mid-frame
 */
49
inline bool CollisionEntry::collided(void) const;

360 14 reset_collided 0 4 575 30 CollisionEntry::reset_collided 0 1 82 45
/**
 * prepare for another collision test
 */
49
inline void CollisionEntry::reset_collided(void);

361 26 get_respect_prev_transform 0 4 575 42 CollisionEntry::get_respect_prev_transform 0 1 83 203
/**
 * Returns true if the collision was detected by a CollisionTraverser whose
 * respect_prev_transform flag was set true, meaning we should consider motion
 * significant in evaluating collisions.
 */
67
inline bool CollisionEntry::get_respect_prev_transform(void) const;

362 17 set_surface_point 0 4 575 33 CollisionEntry::set_surface_point 0 1 84 178
/**
 * Stores the point, on the surface of the "into" object, at which a collision
 * is detected.
 *
 * This point is specified in the coordinate space of the "into" object.
 */
68
inline void CollisionEntry::set_surface_point(LPoint3 const &point);

363 18 set_surface_normal 0 4 575 34 CollisionEntry::set_surface_normal 0 1 85 171
/**
 * Stores the surface normal of the "into" object at the point of the
 * intersection.
 *
 * This normal is specified in the coordinate space of the "into" object.
 */
71
inline void CollisionEntry::set_surface_normal(LVector3 const &normal);

364 18 set_interior_point 0 4 575 34 CollisionEntry::set_interior_point 0 1 86 352
/**
 * Stores the point, within the interior of the "into" object, which
 * represents the depth to which the "from" object has penetrated.  This can
 * also be described as the intersection point on the surface of the "from"
 * object (which is inside the "into" object).
 *
 * This point is specified in the coordinate space of the "into" object.
 */
69
inline void CollisionEntry::set_interior_point(LPoint3 const &point);

365 17 has_surface_point 0 4 575 33 CollisionEntry::has_surface_point 0 1 87 174
/**
 * Returns true if the surface point has been specified, false otherwise.  See
 * get_surface_point().  Some types of collisions may not compute the surface
 * point.
 */
58
inline bool CollisionEntry::has_surface_point(void) const;

366 18 has_surface_normal 0 4 575 34 CollisionEntry::has_surface_normal 0 1 88 176
/**
 * Returns true if the surface normal has been specified, false otherwise.
 * See get_surface_normal().  Some types of collisions may not compute the
 * surface normal.
 */
59
inline bool CollisionEntry::has_surface_normal(void) const;

367 18 has_interior_point 0 4 575 34 CollisionEntry::has_interior_point 0 1 89 176
/**
 * Returns true if the interior point has been specified, false otherwise.
 * See get_interior_point().  Some types of collisions may not compute the
 * interior point.
 */
59
inline bool CollisionEntry::has_interior_point(void) const;

368 15 set_contact_pos 0 4 575 31 CollisionEntry::set_contact_pos 0 1 90 190
/**
 * Stores the position of the "from" object at the instant at which the
 * collision is first detected.
 *
 * This position is specified in the coordinate space of the "into" object.
 */
64
inline void CollisionEntry::set_contact_pos(LPoint3 const &pos);

369 18 set_contact_normal 0 4 575 34 CollisionEntry::set_contact_normal 0 1 91 154
/**
 * Stores the surface normal of the "into" object at the contact pos.
 *
 * This normal is specified in the coordinate space of the "into" object.
 */
71
inline void CollisionEntry::set_contact_normal(LVector3 const &normal);

370 15 has_contact_pos 0 4 575 31 CollisionEntry::has_contact_pos 0 1 92 172
/**
 * Returns true if the contact position has been specified, false otherwise.
 * See get_contact_pos().  Some types of collisions may not compute the
 * contact pos.
 */
56
inline bool CollisionEntry::has_contact_pos(void) const;

371 18 has_contact_normal 0 4 575 34 CollisionEntry::has_contact_normal 0 1 93 176
/**
 * Returns true if the contact normal has been specified, false otherwise.
 * See get_contact_normal().  Some types of collisions may not compute the
 * contact normal.
 */
59
inline bool CollisionEntry::has_contact_normal(void) const;

372 17 get_surface_point 0 4 575 33 CollisionEntry::get_surface_point 0 1 94 330
/**
 * Returns the point, on the surface of the "into" object, at which a
 * collision is detected.  This can be thought of as the first point of
 * intersection.  However the contact point is the actual first point of
 * intersection.
 *
 * The point will be converted into whichever coordinate space the caller
 * specifies.
 */
71
LPoint3 CollisionEntry::get_surface_point(NodePath const &space) const;

373 18 get_surface_normal 0 4 575 34 CollisionEntry::get_surface_normal 0 1 95 200
/**
 * Returns the surface normal of the "into" object at the point at which a
 * collision is detected.
 *
 * The normal will be converted into whichever coordinate space the caller
 * specifies.
 */
73
LVector3 CollisionEntry::get_surface_normal(NodePath const &space) const;

374 18 get_interior_point 0 4 575 34 CollisionEntry::get_interior_point 0 1 96 431
/**
 * Returns the point, within the interior of the "into" object, which
 * represents the depth to which the "from" object has penetrated.  This can
 * also be described as the intersection point on the surface of the "from"
 * object (which is inside the "into" object).  It can be thought of as the
 * deepest point of intersection.
 *
 * The point will be converted into whichever coordinate space the caller
 * specifies.
 */
72
LPoint3 CollisionEntry::get_interior_point(NodePath const &space) const;

375 7 get_all 0 4 575 23 CollisionEntry::get_all 0 1 97 244
/**
 * Simultaneously transforms the surface point, surface normal, and interior
 * point of the collision into the indicated coordinate space.
 *
 * Returns true if all three properties are available, or false if any one of
 * them is not.
 */
133
bool CollisionEntry::get_all(NodePath const &space, LPoint3 &surface_point, LVector3 &surface_normal, LPoint3 &interior_point) const;

376 15 get_contact_pos 0 4 575 31 CollisionEntry::get_contact_pos 0 1 98 200
/**
 * Returns the position of the "from" object at the instant that a collision
 * is first detected.
 *
 * The position will be converted into whichever coordinate space the caller
 * specifies.
 */
69
LPoint3 CollisionEntry::get_contact_pos(NodePath const &space) const;

377 18 get_contact_normal 0 4 575 34 CollisionEntry::get_contact_normal 0 1 99 175
/**
 * Returns the surface normal of the "into" object at the contact position.
 *
 * The normal will be converted into whichever coordinate space the caller
 * specifies.
 */
73
LVector3 CollisionEntry::get_contact_normal(NodePath const &space) const;

378 20 get_all_contact_info 0 4 575 36 CollisionEntry::get_all_contact_info 0 1 100 230
/**
 * Simultaneously transforms the contact position and contact normal of the
 * collision into the indicated coordinate space.
 *
 * Returns true if all three properties are available, or false if any one of
 * them is not.
 */
119
bool CollisionEntry::get_all_contact_info(NodePath const &space, LPoint3 &contact_pos, LVector3 &contact_normal) const;

379 6 output 0 4 575 22 CollisionEntry::output 0 1 101 10
/**
 *
 */
48
void CollisionEntry::output(ostream &out) const;

380 5 write 0 4 575 21 CollisionEntry::write 0 1 102 10
/**
 *
 */
69
void CollisionEntry::write(ostream &out, int indent_level = 0) const;

381 14 get_class_type 0 4 575 30 CollisionEntry::get_class_type 0 1 103 0
55
static TypeHandle CollisionEntry::get_class_type(void);

382 15 ~CollisionEntry 0 4 575 31 CollisionEntry::~CollisionEntry 0 0 0
38
CollisionEntry::~CollisionEntry(void);

383 14 CollisionPlane 0 4 583 30 CollisionPlane::CollisionPlane 0 2 104 105 168
/**
 * This is only for the convenience of CollisionPolygon.  Normally, you should
 * not attempt to create an uninitialized CollisionPlane.
 */

/**
 *
 */

/**
 *
 */
126
inline CollisionPlane::CollisionPlane(LPlane const &plane);
inline CollisionPlane::CollisionPlane(CollisionPlane const &copy);

384 10 get_normal 0 4 583 26 CollisionPlane::get_normal 0 1 106 10
/**
 *
 */
55
inline LVector3 CollisionPlane::get_normal(void) const;

385 13 dist_to_plane 0 4 583 29 CollisionPlane::dist_to_plane 0 1 107 10
/**
 *
 */
77
inline PN_stdfloat CollisionPlane::dist_to_plane(LPoint3 const &point) const;

386 9 set_plane 0 4 583 25 CollisionPlane::set_plane 0 1 108 10
/**
 *
 */
59
inline void CollisionPlane::set_plane(LPlane const &plane);

387 9 get_plane 0 4 583 25 CollisionPlane::get_plane 0 1 109 10
/**
 *
 */
59
inline LPlane const &CollisionPlane::get_plane(void) const;

388 4 flip 0 4 583 20 CollisionPlane::flip 0 1 110 57
/**
 * Convenience method to flip the plane in-place.
 */
39
inline void CollisionPlane::flip(void);

389 14 get_class_type 0 4 583 30 CollisionPlane::get_class_type 0 1 111 0
55
static TypeHandle CollisionPlane::get_class_type(void);

390 15 ~CollisionPlane 0 4 583 31 CollisionPlane::~CollisionPlane 0 0 0
38
CollisionPlane::~CollisionPlane(void);

391 18 CollisionFloorMesh 0 4 587 38 CollisionFloorMesh::CollisionFloorMesh 0 1 112 156
/**
 * This is only for the convenience of CollisionPolygon.  Normally, you should
 * not attempt to create an uninitialized CollisionPlane.
 */

/**
 *
 */
52
inline CollisionFloorMesh::CollisionFloorMesh(void);

392 10 add_vertex 0 4 587 30 CollisionFloorMesh::add_vertex 0 1 113 47
/**
 * store away a vertex to index against
 */
64
inline void CollisionFloorMesh::add_vertex(LPoint3 const &vert);

393 12 add_triangle 0 4 587 32 CollisionFloorMesh::add_triangle 0 1 114 42
/**
 * store a triangle for processing
 */
101
void CollisionFloorMesh::add_triangle(unsigned int pointA, unsigned int pointB, unsigned int pointC);

394 16 get_num_vertices 0 4 587 36 CollisionFloorMesh::get_num_vertices 0 1 115 0
69
inline unsigned int CollisionFloorMesh::get_num_vertices(void) const;

395 10 get_vertex 0 4 587 30 CollisionFloorMesh::get_vertex 0 1 116 0
79
inline LPoint3 const &CollisionFloorMesh::get_vertex(unsigned int index) const;

396 17 get_num_triangles 0 4 587 37 CollisionFloorMesh::get_num_triangles 0 1 117 0
70
inline unsigned int CollisionFloorMesh::get_num_triangles(void) const;

397 12 get_triangle 0 4 587 32 CollisionFloorMesh::get_triangle 0 1 118 0
75
inline LPoint3i CollisionFloorMesh::get_triangle(unsigned int index) const;

398 0 0 0 0 0 0 0 0
0

399 0 0 0 0 0 0 0 0
0

400 14 get_class_type 0 4 587 34 CollisionFloorMesh::get_class_type 0 1 119 0
59
static TypeHandle CollisionFloorMesh::get_class_type(void);

401 19 ~CollisionFloorMesh 0 4 587 39 CollisionFloorMesh::~CollisionFloorMesh 0 0 0
46
CollisionFloorMesh::~CollisionFloorMesh(void);

402 16 CollisionPolygon 0 4 589 34 CollisionPolygon::CollisionPolygon 0 3 120 121 122 127
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 * Creates an invalid polygon.  Only used when reading from a bam file.
 */

/**
 *
 */
310
inline CollisionPolygon::CollisionPolygon(LVecBase3 const &a, LVecBase3 const &b, LVecBase3 const &c);
inline CollisionPolygon::CollisionPolygon(LVecBase3 const &a, LVecBase3 const &b, LVecBase3 const &c, LVecBase3 const &d);
inline CollisionPolygon::CollisionPolygon(LPoint3 const *begin, LPoint3 const *end);

403 14 get_num_points 0 4 589 32 CollisionPolygon::get_num_points 0 1 123 66
/**
 * Returns the number of vertices of the CollisionPolygon.
 */
56
inline int CollisionPolygon::get_num_points(void) const;

404 9 get_point 0 4 589 27 CollisionPolygon::get_point 0 1 124 82
/**
 * Returns the nth vertex of the CollisionPolygon, expressed in 3-D space.
 */
56
inline LPoint3 CollisionPolygon::get_point(int n) const;

405 13 verify_points 0 4 589 31 CollisionPolygon::verify_points 0 3 125 126 127 676
/**
 * Verifies that the indicated set of points will define a valid
 * CollisionPolygon: that is, at least three non-collinear points, with no
 * points repeated.
 */

/**
 * Verifies that the indicated set of points will define a valid
 * CollisionPolygon: that is, at least three non-collinear points, with no
 * points repeated.
 */

/**
 * Verifies that the indicated set of points will define a valid
 * CollisionPolygon: that is, at least three non-collinear points, with no
 * points repeated.
 *
 * This does not check that the polygon defined is convex; that check is made
 * later, once we have projected the points to 2-d space where the decision is
 * easier.
 */
316
static inline bool CollisionPolygon::verify_points(LPoint3 const &a, LPoint3 const &b, LPoint3 const &c);
static inline bool CollisionPolygon::verify_points(LPoint3 const &a, LPoint3 const &b, LPoint3 const &c, LPoint3 const &d);
static bool CollisionPolygon::verify_points(LPoint3 const *begin, LPoint3 const *end);

406 8 is_valid 0 4 589 26 CollisionPolygon::is_valid 0 1 128 122
/**
 * Returns true if the CollisionPolygon is valid (that is, it has at least
 * three vertices), or false otherwise.
 */
44
bool CollisionPolygon::is_valid(void) const;

407 10 is_concave 0 4 589 28 CollisionPolygon::is_concave 0 1 129 106
/**
 * Returns true if the CollisionPolygon appears to be concave, or false if it
 * is safely convex.
 */
46
bool CollisionPolygon::is_concave(void) const;

408 0 0 0 0 0 0 0 0
0

409 14 get_class_type 0 4 589 32 CollisionPolygon::get_class_type 0 1 130 0
57
static TypeHandle CollisionPolygon::get_class_type(void);

410 17 ~CollisionPolygon 0 4 589 35 CollisionPolygon::~CollisionPolygon 0 0 0
42
CollisionPolygon::~CollisionPolygon(void);

411 21 CollisionHandlerEvent 0 4 590 44 CollisionHandlerEvent::CollisionHandlerEvent 0 2 131 132 168
/**
 * The default CollisionHandlerEvent will throw no events.  Its pattern
 * strings must first be set via a call to add_in_pattern() and/or
 * add_out_pattern().
 */
145
CollisionHandlerEvent::CollisionHandlerEvent(void);
inline CollisionHandlerEvent::CollisionHandlerEvent(CollisionHandlerEvent const &) = default;

412 17 clear_in_patterns 0 4 590 40 CollisionHandlerEvent::clear_in_patterns 0 1 133 80
/**
 * Removes all of the previously-added in patterns.  See add_in_pattern.
 */
59
inline void CollisionHandlerEvent::clear_in_patterns(void);

413 14 add_in_pattern 0 4 590 37 CollisionHandlerEvent::add_in_pattern 0 1 134 1586
/**
 * Adds a pattern string to the list of events that will be generated in
 * response to a collision.  The pattern string describes how the event name
 * will be composed.  It is a string that may contain any of the following:
 *
 * %fn  - the name of the "from" object's node %in  - the name of the "into"
 * object's node %fs  - 't' if "from" is tangible, 'i' if intangible %is  -
 * 't' if "into" is tangible, 'i' if intangible %ig  - 'c' if the collision is
 * into a CollisionNode, 'g' if it is a geom.
 *
 * %(tag)fh - generate event only if "from" node has the indicated net tag.
 * %(tag)fx - generate event only if "from" node does not have the indicated
 * net tag.  %(tag)ih - generate event only if "into" node has the indicated
 * net tag.  %(tag)ix - generate event only if "into" node does not have the
 * indicated net tag.  %(tag)ft - the indicated net tag value of the "from"
 * node.  %(tag)it - the indicated net tag value of the "into" node.
 *
 * Parentheses in the above are literal and should be included in the actual
 * pattern.
 *
 * The event name will be based on the in_pattern string specified here, with
 * all occurrences of the above strings replaced with the corresponding
 * values.
 *
 * In general, the in_pattern event is thrown on the first detection of a
 * collision between two particular nodes.  In subsequent passes, as long as a
 * collision between those two nodes continues to be detected each frame, the
 * again_pattern is thrown.  The first frame in which the collision is no
 * longer detected, the out_pattern event is thrown.
 */
81
inline void CollisionHandlerEvent::add_in_pattern(std::string const &in_pattern);

414 14 set_in_pattern 0 4 590 37 CollisionHandlerEvent::set_in_pattern 0 1 135 141
/**
 * This method is deprecated; it completely replaces all the in patterns that
 * have previously been set with the indicated pattern.
 */
81
inline void CollisionHandlerEvent::set_in_pattern(std::string const &in_pattern);

415 19 get_num_in_patterns 0 4 590 42 CollisionHandlerEvent::get_num_in_patterns 0 1 136 73
/**
 * Returns the number of in pattern strings that have been added.
 */
66
inline int CollisionHandlerEvent::get_num_in_patterns(void) const;

416 14 get_in_pattern 0 4 590 37 CollisionHandlerEvent::get_in_pattern 0 1 137 145
/**
 * Returns the nth pattern string that indicates how the event names are
 * generated for each collision detected.  See add_in_pattern().
 */
70
inline std::string CollisionHandlerEvent::get_in_pattern(int n) const;

417 20 clear_again_patterns 0 4 590 43 CollisionHandlerEvent::clear_again_patterns 0 1 138 83
/**
 * Removes all of the previously-added in patterns.  See add_again_pattern.
 */
62
inline void CollisionHandlerEvent::clear_again_patterns(void);

418 17 add_again_pattern 0 4 590 40 CollisionHandlerEvent::add_again_pattern 0 1 139 649
/**
 * Adds the pattern string that indicates how the event names are generated
 * when a collision between two particular nodes is *still* detected.  This
 * event is thrown each consecutive time a collision between two particular
 * nodes is detected, starting with the second time.
 *
 * In general, the in_pattern event is thrown on the first detection of a
 * collision between two particular nodes.  In subsequent passes, as long as a
 * collision between those two nodes continues to be detected each frame, the
 * again_pattern is thrown.  The first frame in which the collision is no
 * longer detected, the out_pattern event is thrown.
 */
87
inline void CollisionHandlerEvent::add_again_pattern(std::string const &again_pattern);

419 17 set_again_pattern 0 4 590 40 CollisionHandlerEvent::set_again_pattern 0 1 140 141
/**
 * This method is deprecated; it completely replaces all the in patterns that
 * have previously been set with the indicated pattern.
 */
87
inline void CollisionHandlerEvent::set_again_pattern(std::string const &again_pattern);

420 22 get_num_again_patterns 0 4 590 45 CollisionHandlerEvent::get_num_again_patterns 0 1 141 73
/**
 * Returns the number of in pattern strings that have been added.
 */
69
inline int CollisionHandlerEvent::get_num_again_patterns(void) const;

421 17 get_again_pattern 0 4 590 40 CollisionHandlerEvent::get_again_pattern 0 1 142 148
/**
 * Returns the nth pattern string that indicates how the event names are
 * generated for each collision detected.  See add_again_pattern().
 */
73
inline std::string CollisionHandlerEvent::get_again_pattern(int n) const;

422 18 clear_out_patterns 0 4 590 41 CollisionHandlerEvent::clear_out_patterns 0 1 143 81
/**
 * Removes all of the previously-added in patterns.  See add_out_pattern.
 */
60
inline void CollisionHandlerEvent::clear_out_patterns(void);

423 15 add_out_pattern 0 4 590 38 CollisionHandlerEvent::add_out_pattern 0 1 144 518
/**
 * Adds the pattern string that indicates how the event names are generated
 * when a collision between two particular nodes is *no longer* detected.
 *
 * In general, the in_pattern event is thrown on the first detection of a
 * collision between two particular nodes.  In subsequent passes, as long as a
 * collision between those two nodes continues to be detected each frame, the
 * again_pattern is thrown.  The first frame in which the collision is no
 * longer detected, the out_pattern event is thrown.
 */
83
inline void CollisionHandlerEvent::add_out_pattern(std::string const &out_pattern);

424 15 set_out_pattern 0 4 590 38 CollisionHandlerEvent::set_out_pattern 0 1 145 141
/**
 * This method is deprecated; it completely replaces all the in patterns that
 * have previously been set with the indicated pattern.
 */
83
inline void CollisionHandlerEvent::set_out_pattern(std::string const &out_pattern);

425 20 get_num_out_patterns 0 4 590 43 CollisionHandlerEvent::get_num_out_patterns 0 1 146 73
/**
 * Returns the number of in pattern strings that have been added.
 */
67
inline int CollisionHandlerEvent::get_num_out_patterns(void) const;

426 15 get_out_pattern 0 4 590 38 CollisionHandlerEvent::get_out_pattern 0 1 147 146
/**
 * Returns the nth pattern string that indicates how the event names are
 * generated for each collision detected.  See add_out_pattern().
 */
71
inline std::string CollisionHandlerEvent::get_out_pattern(int n) const;

427 0 0 0 0 0 0 0 0
0

428 0 0 0 0 0 0 0 0
0

429 0 0 0 0 0 0 0 0
0

430 5 clear 0 4 590 28 CollisionHandlerEvent::clear 0 1 148 541
/**
 * Empties the list of elements that all colliders are known to be colliding
 * with.  No "out" events will be thrown; if the same collision is detected
 * next frame, a new "in" event will be thrown for each collision.
 *
 * This can be called each frame to defeat the persistent "in" event
 * mechanism, which prevents the same "in" event from being thrown repeatedly.
 * However, also see add_again_pattern(), which can be used to set the event
 * that is thrown when a collision is detected for two or more consecutive
 * frames.
 */
40
void CollisionHandlerEvent::clear(void);

431 5 flush 0 4 590 28 CollisionHandlerEvent::flush 0 1 149 58
/**
 * Same as clear() except "out" events are thrown.
 */
40
void CollisionHandlerEvent::flush(void);

432 14 get_class_type 0 4 590 37 CollisionHandlerEvent::get_class_type 0 1 150 0
62
static TypeHandle CollisionHandlerEvent::get_class_type(void);

433 22 ~CollisionHandlerEvent 0 4 590 45 CollisionHandlerEvent::~CollisionHandlerEvent 0 0 0
52
CollisionHandlerEvent::~CollisionHandlerEvent(void);

434 12 add_collider 0 4 593 38 CollisionHandlerPhysical::add_collider 0 2 151 152 556
/**
 * Adds a new collider to the list with a NodePath that will be updated with
 * the collider's new position, or updates the existing collider with a new
 * NodePath object.
 */

/**
 * Adds a new collider to the list with a NodePath that will be updated with
 * the collider's new position, or updates the existing collider with a new
 * NodePath object.
 *
 * The indicated DriveInterface will also be updated with the target's new
 * transform each frame.  This method should be used when the target is
 * directly controlled by a DriveInterface.
 */
222
void CollisionHandlerPhysical::add_collider(NodePath const &collider, NodePath const &target);
void CollisionHandlerPhysical::add_collider(NodePath const &collider, NodePath const &target, DriveInterface *drive_interface);

435 15 remove_collider 0 4 593 41 CollisionHandlerPhysical::remove_collider 0 1 153 92
/**
 * Removes the collider from the list of colliders that this handler knows
 * about.
 */
73
bool CollisionHandlerPhysical::remove_collider(NodePath const &collider);

436 12 has_collider 0 4 593 38 CollisionHandlerPhysical::has_collider 0 1 154 94
/**
 * Returns true if the handler knows about the indicated collider, false
 * otherwise.
 */
76
bool CollisionHandlerPhysical::has_collider(NodePath const &collider) const;

437 15 clear_colliders 0 4 593 41 CollisionHandlerPhysical::clear_colliders 0 1 155 77
/**
 * Completely empties the list of colliders this handler knows about.
 */
53
void CollisionHandlerPhysical::clear_colliders(void);

438 10 set_center 0 4 593 36 CollisionHandlerPhysical::set_center 0 1 156 269
/**
 * Specifies an arbitrary NodePath that the handler is always considered to be
 * facing.  It does not detect collisions with surfaces that appear to be
 * facing away from this NodePath.  This works best when the collision
 * surfaces in question are polygons.
 */
73
inline void CollisionHandlerPhysical::set_center(NodePath const &center);

439 12 clear_center 0 4 593 38 CollisionHandlerPhysical::clear_center 0 1 157 64
/**
 * Clears the center NodePath specified with set_center.
 */
57
inline void CollisionHandlerPhysical::clear_center(void);

440 10 get_center 0 4 593 36 CollisionHandlerPhysical::get_center 0 1 158 114
/**
 * Returns the NodePath specified with set_center, or the empty NodePath if
 * nothing has been specified.
 */
72
inline NodePath const &CollisionHandlerPhysical::get_center(void) const;

441 10 has_center 0 4 593 36 CollisionHandlerPhysical::has_center 0 1 159 95
/**
 * Returns true if a NodePath has been specified with set_center(), false
 * otherwise.
 */
61
inline bool CollisionHandlerPhysical::has_center(void) const;

442 11 has_contact 0 4 593 37 CollisionHandlerPhysical::has_contact 0 1 160 255
/**
 * Did the handler make any contacts with anything on the last collision pass?
 * Depending on how your world is setup, this can be used to tell if the
 * handler is out of the world (i.e.  out of bounds). That is the original use
 * of this call.
 */
62
inline bool CollisionHandlerPhysical::has_contact(void) const;

443 14 get_class_type 0 4 593 40 CollisionHandlerPhysical::get_class_type 0 1 161 0
65
static TypeHandle CollisionHandlerPhysical::get_class_type(void);

444 21 CollisionHandlerFloor 0 4 595 44 CollisionHandlerFloor::CollisionHandlerFloor 0 1 162 10
/**
 *
 */
51
CollisionHandlerFloor::CollisionHandlerFloor(void);

445 10 set_offset 0 4 595 33 CollisionHandlerFloor::set_offset 0 1 163 166
/**
 * Sets the linear offset to add to (or subtract from) the highest detected
 * collision point to determine the actual height at which to set the
 * collider.
 */
66
inline void CollisionHandlerFloor::set_offset(PN_stdfloat offset);

446 10 get_offset 0 4 595 33 CollisionHandlerFloor::get_offset 0 1 164 169
/**
 * Returns the linear offset to add to (or subtract from) the highest detected
 * collision point to determine the actual height at which to set the
 * collider.
 */
65
inline PN_stdfloat CollisionHandlerFloor::get_offset(void) const;

447 9 set_reach 0 4 595 32 CollisionHandlerFloor::set_reach 0 1 165 82
/**
 * Sets the reach to add to (or subtract from) the highest collision point
 */
64
inline void CollisionHandlerFloor::set_reach(PN_stdfloat reach);

448 9 get_reach 0 4 595 32 CollisionHandlerFloor::get_reach 0 1 166 85
/**
 * Returns the reach to add to (or subtract from) the highest collision point
 */
64
inline PN_stdfloat CollisionHandlerFloor::get_reach(void) const;

449 16 set_max_velocity 0 4 595 39 CollisionHandlerFloor::set_max_velocity 0 1 167 199
/**
 * Sets the maximum speed at which the object will be allowed to descend
 * towards a floor below it, in units per second.  Set this to zero to allow
 * it to instantly teleport any distance.
 */
73
inline void CollisionHandlerFloor::set_max_velocity(PN_stdfloat max_vel);

450 16 get_max_velocity 0 4 595 39 CollisionHandlerFloor::get_max_velocity 0 1 168 160
/**
 * Retrieves the maximum speed at which the object will be allowed to descend
 * towards a floor below it, in units per second.  See set_max_velocity().
 */
71
inline PN_stdfloat CollisionHandlerFloor::get_max_velocity(void) const;

451 14 get_class_type 0 4 595 37 CollisionHandlerFloor::get_class_type 0 1 169 0
62
static TypeHandle CollisionHandlerFloor::get_class_type(void);

452 22 CollisionHandlerPusher 0 4 596 46 CollisionHandlerPusher::CollisionHandlerPusher 0 1 170 10
/**
 *
 */
53
CollisionHandlerPusher::CollisionHandlerPusher(void);

453 14 set_horizontal 0 4 596 38 CollisionHandlerPusher::set_horizontal 0 1 171 10
/**
 *
 */
62
inline void CollisionHandlerPusher::set_horizontal(bool flag);

454 14 get_horizontal 0 4 596 38 CollisionHandlerPusher::get_horizontal 0 1 172 10
/**
 *
 */
63
inline bool CollisionHandlerPusher::get_horizontal(void) const;

455 14 get_class_type 0 4 596 38 CollisionHandlerPusher::get_class_type 0 1 173 0
63
static TypeHandle CollisionHandlerPusher::get_class_type(void);

456 27 CollisionHandlerFluidPusher 0 4 597 56 CollisionHandlerFluidPusher::CollisionHandlerFluidPusher 0 1 174 10
/**
 *
 */
63
CollisionHandlerFluidPusher::CollisionHandlerFluidPusher(void);

457 14 get_class_type 0 4 597 43 CollisionHandlerFluidPusher::get_class_type 0 1 175 0
68
static TypeHandle CollisionHandlerFluidPusher::get_class_type(void);

458 28 ~CollisionHandlerFluidPusher 0 4 597 57 CollisionHandlerFluidPusher::~CollisionHandlerFluidPusher 0 0 0
64
CollisionHandlerFluidPusher::~CollisionHandlerFluidPusher(void);

459 23 CollisionHandlerGravity 0 4 598 48 CollisionHandlerGravity::CollisionHandlerGravity 0 1 176 10
/**
 *
 */
55
CollisionHandlerGravity::CollisionHandlerGravity(void);

460 10 set_offset 0 4 598 35 CollisionHandlerGravity::set_offset 0 1 177 166
/**
 * Sets the linear offset to add to (or subtract from) the highest detected
 * collision point to determine the actual height at which to set the
 * collider.
 */
68
inline void CollisionHandlerGravity::set_offset(PN_stdfloat offset);

461 10 get_offset 0 4 598 35 CollisionHandlerGravity::get_offset 0 1 178 169
/**
 * Returns the linear offset to add to (or subtract from) the highest detected
 * collision point to determine the actual height at which to set the
 * collider.
 */
67
inline PN_stdfloat CollisionHandlerGravity::get_offset(void) const;

462 9 set_reach 0 4 598 34 CollisionHandlerGravity::set_reach 0 1 179 82
/**
 * Sets the reach to add to (or subtract from) the highest collision point
 */
66
inline void CollisionHandlerGravity::set_reach(PN_stdfloat reach);

463 9 get_reach 0 4 598 34 CollisionHandlerGravity::get_reach 0 1 180 85
/**
 * Returns the reach to add to (or subtract from) the highest collision point
 */
66
inline PN_stdfloat CollisionHandlerGravity::get_reach(void) const;

464 19 get_airborne_height 0 4 598 44 CollisionHandlerGravity::get_airborne_height 0 1 181 238
/**
 * Return the height of the object from the ground.
 *
 * The object might not necessarily be at rest.  Use is_on_ground() if you
 * want to know whether the object is on the ground and at rest.
 *
 * See Also: is_in_outer_space()
 */
76
inline PN_stdfloat CollisionHandlerGravity::get_airborne_height(void) const;

465 12 is_on_ground 0 4 598 37 CollisionHandlerGravity::is_on_ground 0 1 182 33
/**
 * Is the object at rest?
 */
62
inline bool CollisionHandlerGravity::is_on_ground(void) const;

466 19 get_impact_velocity 0 4 598 44 CollisionHandlerGravity::get_impact_velocity 0 1 183 282
/**
 * How hard did the object hit the ground.  This value is set on impact with
 * the ground.  You may want to watch (poll) on is_on_groun() and when that is
 * true, call get_impact_velocity(). Normally I avoid polling, but we are
 * calling is_on_ground() frequently anyway.
 */
76
inline PN_stdfloat CollisionHandlerGravity::get_impact_velocity(void) const;

467 18 get_contact_normal 0 4 598 43 CollisionHandlerGravity::get_contact_normal 0 1 184 10
/**
 *
 */
79
inline LVector3 const &CollisionHandlerGravity::get_contact_normal(void) const;

468 12 add_velocity 0 4 598 37 CollisionHandlerGravity::add_velocity 0 1 185 184
/**
 * Adds the sepcified amount to the current velocity.  This is mostly here
 * allow this common operation to be faster for scripting, but it's also more
 * concise even in cpp.
 */
72
inline void CollisionHandlerGravity::add_velocity(PN_stdfloat velocity);

469 12 set_velocity 0 4 598 37 CollisionHandlerGravity::set_velocity 0 1 186 46
/**
 * Sets the current vertical velocity.
 */
72
inline void CollisionHandlerGravity::set_velocity(PN_stdfloat velocity);

470 12 get_velocity 0 4 598 37 CollisionHandlerGravity::get_velocity 0 1 187 354
/**
 * Gets the current vertical velocity.
 *
 * Generally, negative values mean the object is in free fall; while postive
 * values mean the object has vertical thrust.
 *
 * A zero value does not necessarily mean the object on the ground, it may
 * also be weightless and/or at the apex of its jump.
 *
 * See Also: is_on_ground() and get_gravity()
 */
69
inline PN_stdfloat CollisionHandlerGravity::get_velocity(void) const;

471 11 set_gravity 0 4 598 36 CollisionHandlerGravity::set_gravity 0 1 188 56
/**
 * Sets the linear gravity force (always plumb).
 */
70
inline void CollisionHandlerGravity::set_gravity(PN_stdfloat gravity);

472 11 get_gravity 0 4 598 36 CollisionHandlerGravity::get_gravity 0 1 189 56
/**
 * Gets the linear gravity force (always plumb).
 */
68
inline PN_stdfloat CollisionHandlerGravity::get_gravity(void) const;

473 16 set_max_velocity 0 4 598 41 CollisionHandlerGravity::set_max_velocity 0 1 190 199
/**
 * Sets the maximum speed at which the object will be allowed to descend
 * towards a floor below it, in units per second.  Set this to zero to allow
 * it to instantly teleport any distance.
 */
75
inline void CollisionHandlerGravity::set_max_velocity(PN_stdfloat max_vel);

474 16 get_max_velocity 0 4 598 41 CollisionHandlerGravity::get_max_velocity 0 1 191 160
/**
 * Retrieves the maximum speed at which the object will be allowed to descend
 * towards a floor below it, in units per second.  See set_max_velocity().
 */
73
inline PN_stdfloat CollisionHandlerGravity::get_max_velocity(void) const;

475 15 set_legacy_mode 0 4 598 40 CollisionHandlerGravity::set_legacy_mode 0 1 192 229
/**
 * Enables old behavior required by Toontown (Sellbot Factory lava room is
 * good test case, lava and conveyor belt specifically). Behavior is to throw
 * enter/exit events only for floor that the toon is in contact with
 */
71
inline void CollisionHandlerGravity::set_legacy_mode(bool legacy_mode);

476 15 get_legacy_mode 0 4 598 40 CollisionHandlerGravity::get_legacy_mode 0 1 193 49
/**
 * returns true if legacy mode is enabled
 */
65
inline bool CollisionHandlerGravity::get_legacy_mode(void) const;

477 14 get_class_type 0 4 598 39 CollisionHandlerGravity::get_class_type 0 1 194 0
64
static TypeHandle CollisionHandlerGravity::get_class_type(void);

478 28 CollisionHandlerHighestEvent 0 4 600 58 CollisionHandlerHighestEvent::CollisionHandlerHighestEvent 0 2 195 196 168
/**
 * The default CollisionHandlerEvent will throw no events.  Its pattern
 * strings must first be set via a call to add_in_pattern() and/or
 * add_out_pattern().
 */
180
CollisionHandlerHighestEvent::CollisionHandlerHighestEvent(void);
inline CollisionHandlerHighestEvent::CollisionHandlerHighestEvent(CollisionHandlerHighestEvent const &) = default;

479 14 get_class_type 0 4 600 44 CollisionHandlerHighestEvent::get_class_type 0 1 197 0
69
static TypeHandle CollisionHandlerHighestEvent::get_class_type(void);

480 29 ~CollisionHandlerHighestEvent 0 4 600 59 CollisionHandlerHighestEvent::~CollisionHandlerHighestEvent 0 0 0
66
CollisionHandlerHighestEvent::~CollisionHandlerHighestEvent(void);

481 21 CollisionHandlerQueue 0 4 601 44 CollisionHandlerQueue::CollisionHandlerQueue 0 2 198 199 10
/**
 *
 */
145
CollisionHandlerQueue::CollisionHandlerQueue(void);
inline CollisionHandlerQueue::CollisionHandlerQueue(CollisionHandlerQueue const &) = default;

482 12 sort_entries 0 4 601 35 CollisionHandlerQueue::sort_entries 0 1 200 257
/**
 * Sorts all the detected collisions front-to-back by
 * from_intersection_point() so that those intersection points closest to the
 * collider's origin (e.g., the center of the CollisionSphere, or the point_a
 * of a CollisionSegment) appear first.
 */
47
void CollisionHandlerQueue::sort_entries(void);

483 13 clear_entries 0 4 601 36 CollisionHandlerQueue::clear_entries 0 1 201 50
/**
 * Removes all the entries from the queue.
 */
48
void CollisionHandlerQueue::clear_entries(void);

484 15 get_num_entries 0 4 601 38 CollisionHandlerQueue::get_num_entries 0 1 202 69
/**
 * Returns the number of CollisionEntries detected last pass.
 */
55
int CollisionHandlerQueue::get_num_entries(void) const;

485 9 get_entry 0 4 601 32 CollisionHandlerQueue::get_entry 0 1 203 61
/**
 * Returns the nth CollisionEntry detected last pass.
 */
62
CollisionEntry *CollisionHandlerQueue::get_entry(int n) const;

486 0 0 0 0 0 0 0 0
0

487 6 output 0 4 601 29 CollisionHandlerQueue::output 0 1 204 10
/**
 *
 */
55
void CollisionHandlerQueue::output(ostream &out) const;

488 5 write 0 4 601 28 CollisionHandlerQueue::write 0 1 205 10
/**
 *
 */
76
void CollisionHandlerQueue::write(ostream &out, int indent_level = 0) const;

489 14 get_class_type 0 4 601 37 CollisionHandlerQueue::get_class_type 0 1 206 0
62
static TypeHandle CollisionHandlerQueue::get_class_type(void);

490 22 ~CollisionHandlerQueue 0 4 601 45 CollisionHandlerQueue::~CollisionHandlerQueue 0 0 0
52
CollisionHandlerQueue::~CollisionHandlerQueue(void);

491 15 CollisionSphere 0 4 603 32 CollisionSphere::CollisionSphere 0 2 207 208 114
/**
 *
 */

/**
 *
 */

/**
 * Creates an invalid sphere.  Only used when reading from a bam file.
 */

/**
 *
 */
192
inline CollisionSphere::CollisionSphere(LPoint3 const &center, PN_stdfloat radius);
inline CollisionSphere::CollisionSphere(PN_stdfloat cx, PN_stdfloat cy, PN_stdfloat cz, PN_stdfloat radius);

492 10 set_center 0 4 603 27 CollisionSphere::set_center 0 2 209 210 22
/**
 *
 */

/**
 *
 */
149
inline void CollisionSphere::set_center(LPoint3 const &center);
inline void CollisionSphere::set_center(PN_stdfloat x, PN_stdfloat y, PN_stdfloat z);

493 10 get_center 0 4 603 27 CollisionSphere::get_center 0 1 211 10
/**
 *
 */
62
inline LPoint3 const &CollisionSphere::get_center(void) const;

494 10 set_radius 0 4 603 27 CollisionSphere::set_radius 0 1 212 10
/**
 *
 */
60
inline void CollisionSphere::set_radius(PN_stdfloat radius);

495 10 get_radius 0 4 603 27 CollisionSphere::get_radius 0 1 213 10
/**
 *
 */
59
inline PN_stdfloat CollisionSphere::get_radius(void) const;

496 14 get_class_type 0 4 603 31 CollisionSphere::get_class_type 0 1 214 0
56
static TypeHandle CollisionSphere::get_class_type(void);

497 16 ~CollisionSphere 0 4 603 33 CollisionSphere::~CollisionSphere 0 0 0
40
CollisionSphere::~CollisionSphere(void);

498 18 CollisionInvSphere 0 4 604 38 CollisionInvSphere::CollisionInvSphere 0 2 215 216 114
/**
 *
 */

/**
 *
 */

/**
 * Creates an invalid sphere.  Only used when reading from a bam file.
 */

/**
 *
 */
204
inline CollisionInvSphere::CollisionInvSphere(LPoint3 const &center, PN_stdfloat radius);
inline CollisionInvSphere::CollisionInvSphere(PN_stdfloat cx, PN_stdfloat cy, PN_stdfloat cz, PN_stdfloat radius);

499 14 get_class_type 0 4 604 34 CollisionInvSphere::get_class_type 0 1 217 0
59
static TypeHandle CollisionInvSphere::get_class_type(void);

500 19 ~CollisionInvSphere 0 4 604 39 CollisionInvSphere::~CollisionInvSphere 0 0 0
46
CollisionInvSphere::~CollisionInvSphere(void);

501 12 CollisionRay 0 4 605 26 CollisionRay::CollisionRay 0 3 218 219 220 219
/**
 * Creates an invalid ray.  This isn't terribly useful; it's expected that the
 * user will subsequently adjust the ray via set_origin()/set_direction() or
 * set_from_lens().
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */
256
inline CollisionRay::CollisionRay(void);
inline CollisionRay::CollisionRay(LPoint3 const &origin, LVector3 const &direction);
inline CollisionRay::CollisionRay(PN_stdfloat ox, PN_stdfloat oy, PN_stdfloat oz, PN_stdfloat dx, PN_stdfloat dy, PN_stdfloat dz);

502 10 set_origin 0 4 605 24 CollisionRay::set_origin 0 2 221 222 22
/**
 *
 */

/**
 *
 */
143
inline void CollisionRay::set_origin(LPoint3 const &origin);
inline void CollisionRay::set_origin(PN_stdfloat x, PN_stdfloat y, PN_stdfloat z);

503 10 get_origin 0 4 605 24 CollisionRay::get_origin 0 1 223 10
/**
 *
 */
59
inline LPoint3 const &CollisionRay::get_origin(void) const;

504 13 set_direction 0 4 605 27 CollisionRay::set_direction 0 2 224 225 22
/**
 *
 */

/**
 *
 */
153
inline void CollisionRay::set_direction(LVector3 const &direction);
inline void CollisionRay::set_direction(PN_stdfloat x, PN_stdfloat y, PN_stdfloat z);

505 13 get_direction 0 4 605 27 CollisionRay::get_direction 0 1 226 10
/**
 *
 */
63
inline LVector3 const &CollisionRay::get_direction(void) const;

506 13 set_from_lens 0 4 605 27 CollisionRay::set_from_lens 0 2 227 228 591
/**
 * Accepts a LensNode and a 2-d point in the range [-1,1].  Sets the
 * CollisionRay so that it begins at the LensNode's near plane and extends to
 * infinity, making it suitable for picking objects from the screen given a
 * camera and a mouse location.
 */

/**
 * Accepts a LensNode and a 2-d point in the range [-1,1].  Sets the
 * CollisionRay so that it begins at the LensNode's near plane and extends to
 * infinity, making it suitable for picking objects from the screen given a
 * camera and a mouse location.
 *
 * Returns true if the point was acceptable, false otherwise.
 */
164
bool CollisionRay::set_from_lens(LensNode *camera, LPoint2 const &point);
inline bool CollisionRay::set_from_lens(LensNode *camera, PN_stdfloat px, PN_stdfloat py);

507 14 get_class_type 0 4 605 28 CollisionRay::get_class_type 0 1 229 0
53
static TypeHandle CollisionRay::get_class_type(void);

508 13 ~CollisionRay 0 4 605 27 CollisionRay::~CollisionRay 0 0 0
34
CollisionRay::~CollisionRay(void);

509 13 CollisionLine 0 4 606 28 CollisionLine::CollisionLine 0 3 230 231 232 221
/**
 * Creates an invalid line.  This isn't terribly useful; it's expected that
 * the user will subsequently adjust the line via set_origin()/set_direction()
 * or set_from_lens().
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */
262
inline CollisionLine::CollisionLine(void);
inline CollisionLine::CollisionLine(LPoint3 const &origin, LVector3 const &direction);
inline CollisionLine::CollisionLine(PN_stdfloat ox, PN_stdfloat oy, PN_stdfloat oz, PN_stdfloat dx, PN_stdfloat dy, PN_stdfloat dz);

510 14 get_class_type 0 4 606 29 CollisionLine::get_class_type 0 1 233 0
54
static TypeHandle CollisionLine::get_class_type(void);

511 14 ~CollisionLine 0 4 606 29 CollisionLine::~CollisionLine 0 0 0
36
CollisionLine::~CollisionLine(void);

512 17 CollisionParabola 0 4 607 36 CollisionParabola::CollisionParabola 0 2 234 235 163
/**
 * Creates an invalid parabola.
 */

/**
 * Creates a parabola with the endpoints between t1 and t2 in the parametric
 * space of the parabola.
 */

/**
 *
 */
154
inline CollisionParabola::CollisionParabola(void);
inline CollisionParabola::CollisionParabola(LParabola const &parabola, PN_stdfloat t1, PN_stdfloat t2);

513 12 set_parabola 0 4 607 31 CollisionParabola::set_parabola 0 1 236 57
/**
 * Replaces the parabola specified by this solid.
 */
71
inline void CollisionParabola::set_parabola(LParabola const &parabola);

514 12 get_parabola 0 4 607 31 CollisionParabola::get_parabola 0 1 237 56
/**
 * Returns the parabola specified by this solid.
 */
68
inline LParabola const &CollisionParabola::get_parabola(void) const;

515 6 set_t1 0 4 607 25 CollisionParabola::set_t1 0 1 238 54
/**
 * Changes the starting point on the parabola.
 */
54
inline void CollisionParabola::set_t1(PN_stdfloat t1);

516 6 get_t1 0 4 607 25 CollisionParabola::get_t1 0 1 239 54
/**
 * Returns the starting point on the parabola.
 */
57
inline PN_stdfloat CollisionParabola::get_t1(void) const;

517 6 set_t2 0 4 607 25 CollisionParabola::set_t2 0 1 240 52
/**
 * Changes the ending point on the parabola.
 */
54
inline void CollisionParabola::set_t2(PN_stdfloat t2);

518 6 get_t2 0 4 607 25 CollisionParabola::get_t2 0 1 241 52
/**
 * Returns the ending point on the parabola.
 */
57
inline PN_stdfloat CollisionParabola::get_t2(void) const;

519 14 get_class_type 0 4 607 33 CollisionParabola::get_class_type 0 1 242 0
58
static TypeHandle CollisionParabola::get_class_type(void);

520 18 ~CollisionParabola 0 4 607 37 CollisionParabola::~CollisionParabola 0 0 0
44
CollisionParabola::~CollisionParabola(void);

521 16 CollisionSegment 0 4 611 34 CollisionSegment::CollisionSegment 0 3 243 244 245 227
/**
 * Creates an invalid segment.  This isn't terribly useful; it's expected that
 * the user will subsequently adjust the segment via
 * set_origin()/set_direction() or set_from_lens().
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */
267
inline CollisionSegment::CollisionSegment(void);
inline CollisionSegment::CollisionSegment(LPoint3 const &a, LPoint3 const &db);
inline CollisionSegment::CollisionSegment(PN_stdfloat ax, PN_stdfloat ay, PN_stdfloat az, PN_stdfloat bx, PN_stdfloat by, PN_stdfloat bz);

522 11 set_point_a 0 4 611 29 CollisionSegment::set_point_a 0 2 246 247 22
/**
 *
 */

/**
 *
 */
148
inline void CollisionSegment::set_point_a(LPoint3 const &a);
inline void CollisionSegment::set_point_a(PN_stdfloat x, PN_stdfloat y, PN_stdfloat z);

523 11 get_point_a 0 4 611 29 CollisionSegment::get_point_a 0 1 248 10
/**
 *
 */
64
inline LPoint3 const &CollisionSegment::get_point_a(void) const;

524 11 set_point_b 0 4 611 29 CollisionSegment::set_point_b 0 2 249 250 22
/**
 *
 */

/**
 *
 */
148
inline void CollisionSegment::set_point_b(LPoint3 const &b);
inline void CollisionSegment::set_point_b(PN_stdfloat x, PN_stdfloat y, PN_stdfloat z);

525 11 get_point_b 0 4 611 29 CollisionSegment::get_point_b 0 1 251 10
/**
 *
 */
64
inline LPoint3 const &CollisionSegment::get_point_b(void) const;

526 13 set_from_lens 0 4 611 31 CollisionSegment::set_from_lens 0 2 252 253 609
/**
 * Accepts a LensNode and a 2-d point in the range [-1,1].  Sets the
 * CollisionSegment so that it begins at the LensNode's near plane and extends
 * to the far plane, making it suitable for picking objects from the screen
 * given a camera and a mouse location.
 */

/**
 * Accepts a LensNode and a 2-d point in the range [-1,1].  Sets the
 * CollisionSegment so that it begins at the LensNode's near plane and extends
 * to the far plane, making it suitable for picking objects from the screen
 * given a camera and a mouse location.
 *
 * Returns true if the point was acceptable, false otherwise.
 */
172
bool CollisionSegment::set_from_lens(LensNode *camera, LPoint2 const &point);
inline bool CollisionSegment::set_from_lens(LensNode *camera, PN_stdfloat px, PN_stdfloat py);

527 14 get_class_type 0 4 611 32 CollisionSegment::get_class_type 0 1 254 0
57
static TypeHandle CollisionSegment::get_class_type(void);

528 17 ~CollisionSegment 0 4 611 35 CollisionSegment::~CollisionSegment 0 0 0
42
CollisionSegment::~CollisionSegment(void);

529 13 CollisionTube 0 4 612 28 CollisionTube::CollisionTube 0 2 255 256 112
/**
 *
 */

/**
 *
 */

/**
 * Creates an invalid tube.  Only used when reading from a bam file.
 */

/**
 *
 */
246
inline CollisionTube::CollisionTube(LPoint3 const &a, LPoint3 const &db, PN_stdfloat radius);
inline CollisionTube::CollisionTube(PN_stdfloat ax, PN_stdfloat ay, PN_stdfloat az, PN_stdfloat bx, PN_stdfloat by, PN_stdfloat bz, PN_stdfloat radius);

530 11 set_point_a 0 4 612 26 CollisionTube::set_point_a 0 2 257 258 22
/**
 *
 */

/**
 *
 */
142
inline void CollisionTube::set_point_a(LPoint3 const &a);
inline void CollisionTube::set_point_a(PN_stdfloat x, PN_stdfloat y, PN_stdfloat z);

531 11 get_point_a 0 4 612 26 CollisionTube::get_point_a 0 1 259 10
/**
 *
 */
61
inline LPoint3 const &CollisionTube::get_point_a(void) const;

532 11 set_point_b 0 4 612 26 CollisionTube::set_point_b 0 2 260 261 22
/**
 *
 */

/**
 *
 */
142
inline void CollisionTube::set_point_b(LPoint3 const &b);
inline void CollisionTube::set_point_b(PN_stdfloat x, PN_stdfloat y, PN_stdfloat z);

533 11 get_point_b 0 4 612 26 CollisionTube::get_point_b 0 1 262 10
/**
 *
 */
61
inline LPoint3 const &CollisionTube::get_point_b(void) const;

534 10 set_radius 0 4 612 25 CollisionTube::set_radius 0 1 263 10
/**
 *
 */
58
inline void CollisionTube::set_radius(PN_stdfloat radius);

535 10 get_radius 0 4 612 25 CollisionTube::get_radius 0 1 264 10
/**
 *
 */
57
inline PN_stdfloat CollisionTube::get_radius(void) const;

536 14 get_class_type 0 4 612 29 CollisionTube::get_class_type 0 1 265 0
54
static TypeHandle CollisionTube::get_class_type(void);

537 14 ~CollisionTube 0 4 612 29 CollisionTube::~CollisionTube 0 0 0
36
CollisionTube::~CollisionTube(void);

538 19 upcast_to_PandaNode 0 12 613 40 CollisionVisualizer::upcast_to_PandaNode 0 1 273 44
upcast from CollisionVisualizer to PandaNode
58
PandaNode *CollisionVisualizer::upcast_to_PandaNode(void);

539 31 downcast_to_CollisionVisualizer 0 12 563 42 PandaNode::downcast_to_CollisionVisualizer 0 1 274 46
downcast from PandaNode to CollisionVisualizer
70
CollisionVisualizer *PandaNode::downcast_to_CollisionVisualizer(void);

540 27 upcast_to_CollisionRecorder 0 12 613 48 CollisionVisualizer::upcast_to_CollisionRecorder 0 1 275 52
upcast from CollisionVisualizer to CollisionRecorder
74
CollisionRecorder *CollisionVisualizer::upcast_to_CollisionRecorder(void);

541 31 downcast_to_CollisionVisualizer 0 12 573 50 CollisionRecorder::downcast_to_CollisionVisualizer 0 1 276 54
downcast from CollisionRecorder to CollisionVisualizer
78
CollisionVisualizer *CollisionRecorder::downcast_to_CollisionVisualizer(void);

542 19 CollisionVisualizer 0 4 613 40 CollisionVisualizer::CollisionVisualizer 0 1 266 10
/**
 *
 */
66
CollisionVisualizer::CollisionVisualizer(std::string const &name);

543 20 ~CollisionVisualizer 0 6 613 41 CollisionVisualizer::~CollisionVisualizer 0 0 10
/**
 *
 */
56
virtual CollisionVisualizer::~CollisionVisualizer(void);

544 15 set_point_scale 0 4 613 36 CollisionVisualizer::set_point_scale 0 1 267 412
/**
 * Scales the points that are drawn to represent the surface and interior
 * intersection points of the collisions.  By default, these objects are drawn
 * at an arbitrary scale which is appropriate if the window units are the
 * default range -1 .. 1.  Change this scale accordinatly if the window units
 * are measured on some other scale or if you need to observe these objects in
 * a smaller window.
 */
74
inline void CollisionVisualizer::set_point_scale(PN_stdfloat point_scale);

545 15 get_point_scale 0 4 613 36 CollisionVisualizer::get_point_scale 0 1 268 59
/**
 * Returns the value last set by set_point_scale().
 */
68
inline PN_stdfloat CollisionVisualizer::get_point_scale(void) const;

546 16 set_normal_scale 0 4 613 37 CollisionVisualizer::set_normal_scale 0 1 269 370
/**
 * Scales the line segments that are drawn to represent the normals of the
 * collisions.  By default, these objects are drawn at an arbitrary scale
 * which is appropriate if the scene units are measured in feet.  Change this
 * scale accordinatly if the scene units are measured on some other scale or
 * if you need to observe these normals from farther away.
 */
76
inline void CollisionVisualizer::set_normal_scale(PN_stdfloat normal_scale);

547 16 get_normal_scale 0 4 613 37 CollisionVisualizer::get_normal_scale 0 1 270 60
/**
 * Returns the value last set by set_normal_scale().
 */
69
inline PN_stdfloat CollisionVisualizer::get_normal_scale(void) const;

548 5 clear 0 4 613 26 CollisionVisualizer::clear 0 1 271 110
/**
 * Removes all the visualization data from a previous traversal and resets the
 * visualizer to empty.
 */
38
void CollisionVisualizer::clear(void);

549 14 get_class_type 0 4 613 35 CollisionVisualizer::get_class_type 0 1 272 0
60
static TypeHandle CollisionVisualizer::get_class_type(void);

276
1 0 0 7 3 614 0 0 0 1 4 this 3 577  
2 0 0 4 7 616 0 0 295 /**
 * Sets the current state of the 'tangible' flag.  Set this true to make the
 * solid tangible, so that a CollisionHandlerPusher will not allow another
 * object to intersect it, or false to make it intangible, so that a
 * CollisionHandlerPusher will ignore it except to throw an event.
 */ 2 4 this 3 615  8 tangible 1 554  
3 0 0 6 8 554 0 0 266 /**
 * Returns whether the solid is considered 'tangible' or not.  An intangible
 * solid has no effect in a CollisionHandlerPusher (except to throw an event);
 * it's useful for defining 'trigger' planes and spheres, that cause an effect
 * when passed through.
 */ 1 4 this 3 577  
4 0 0 4 11 616 0 0 388 /**
 * Records a false normal for this CollisionSolid that will be reported by the
 * collision system with all collisions into it, instead of its actual normal.
 * This is useful as a workaround for the problem of an avatar wanting to
 * stand on a sloping ground; by storing a false normal, the ground appears to
 * be perfectly level, and the avatar does not tend to slide down it.
 */ 2 4 this 3 615  16 effective_normal 1 617  
5 0 0 4 12 616 0 0 71 /**
 * Removes the normal previously set by set_effective_normal().
 */ 1 4 this 3 615  
6 0 0 6 13 554 0 0 98 /**
 * Returns true if a special normal was set by set_effective_normal(), false
 * otherwise.
 */ 1 4 this 3 577  
7 0 0 6 14 617 0 0 145 /**
 * Returns the normal that was set by set_effective_normal().  It is an error
 * to call this unless has_effective_normal() returns true.
 */ 1 4 this 3 577  
8 0 0 4 15 616 0 0 296 /**
 * This is only meaningful for CollisionSolids that will be added to a
 * traverser as colliders.  It is normally true, but if set false, it means
 * that this particular solid does not care about the "effective" normal of
 * other solids it meets, but rather always uses the true normal.
 */ 2 4 this 3 615  24 respect_effective_normal 1 554  
9 0 0 6 16 554 0 0 46 /**
 * See set_respect_effective_normal().
 */ 1 4 this 3 577  
10 0 0 7 18 620 0 0 47 /**
 * Returns the solid's bounding volume.
 */ 1 4 this 3 577  
11 0 0 4 19 616 0 0 47 /**
 * Returns the solid's bounding volume.
 */ 2 4 this 3 615  15 bounding_volume 1 620  
12 0 0 4 22 616 0 0 10 /**
 *
 */ 2 4 this 3 577  3 out 1 621  
13 0 0 4 23 616 0 0 10 /**
 *
 */ 3 4 this 3 577  3 out 1 621  12 indent_level 1 568  
14 0 0 7 24 624 0 0 0 0 
15 0 0 7 26 626 304 0 59 /**
 * Create the Box by Specifying the Diagonal Points
 */ 2 3 min 1 625  3 max 1 625  
16 0 0 7 26 626 304 0 106 /**
 * Create the Box by giving a Center and distances of each of the sides of
 * box from the Center.
 */ 4 6 center 1 625  1 x 1 581  1 y 1 581  1 z 1 581  
17 0 0 6 27 568 0 0 68 /**
 * Returns 8: the number of vertices of a rectangular solid.
 */ 1 4 this 3 627  
18 0 0 7 28 614 0 0 67 /**
 * Returns the nth vertex of the Axis Aligned Bounding Box.
 */ 2 4 this 3 627  1 n 1 568  
19 0 0 7 29 614 0 0 45 /**
 * Returns the nth vertex of the OBB.
 */ 2 4 this 3 627  1 n 1 568  
20 0 0 6 30 568 0 0 65 /**
 * Returns 6: the number of faces of a rectangular solid.
 */ 1 4 this 3 627  
21 0 0 7 31 629 0 0 57 /**
 * Creates the nth face of the rectangular solid.
 */ 2 4 this 3 627  1 n 1 568  
22 0 0 7 32 629 0 0 57 /**
 * Returns the nth face of the rectangular solid.
 */ 2 4 this 3 627  1 n 1 568  
23 0 0 4 33 616 0 0 10 /**
 *
 */ 2 4 this 3 626  6 center 1 625  
24 0 0 4 33 616 0 0 10 /**
 *
 */ 4 4 this 3 626  1 x 1 581  1 y 1 581  1 z 1 581  
25 0 0 6 34 625 0 0 10 /**
 *
 */ 1 4 this 3 627  
26 0 0 6 35 625 0 0 10 /**
 *
 */ 1 4 this 3 627  
27 0 0 6 36 625 0 0 10 /**
 *
 */ 1 4 this 3 627  
28 0 0 7 37 630 0 0 10 /**
 *
 */ 1 4 this 3 627  
29 0 0 7 45 624 0 0 0 0 
30 0 0 7 50 633 307 0 0 1 6 param0 0 631  
31 0 0 7 49 624 0 0 0 0 
32 0 0 7 54 579 0 0 10 /**
 *
 */ 1 4 name 1 634  
33 0 0 4 55 616 0 0 98 /**
 * Simultaneously sets both the "from" and "into" CollideMask values to the
 * same thing.
 */ 2 4 this 3 579  4 mask 1 635  
34 0 0 4 56 616 0 0 222 /**
 * Sets the "from" CollideMask.  In order for a collision to be detected from
 * this object into another object, the intersection of this object's "from"
 * mask and the other object's "into" mask must be nonzero.
 */ 2 4 this 3 579  4 mask 1 635  
35 0 0 4 57 616 0 0 222 /**
 * Sets the "into" CollideMask.  In order for a collision to be detected from
 * another object into this object, the intersection of the other object's
 * "from" mask and this object's "into" mask must be nonzero.
 */ 2 4 this 3 579  4 mask 1 635  
36 0 0 7 58 635 0 0 233 /**
 * Returns the current "from" CollideMask.  In order for a collision to be
 * detected from this object into another object, the intersection of this
 * object's "from" mask and the other object's "into" mask must be nonzero.
 */ 1 4 this 3 636  
37 0 0 7 59 635 0 0 233 /**
 * Returns the current "into" CollideMask.  In order for a collision to be
 * detected from another object into this object, the intersection of the
 * other object's "from" mask and this object's "into" mask must be nonzero.
 */ 1 4 this 3 636  
38 0 0 4 65 616 0 0 44 /**
 * Removes all solids from the node.
 */ 1 4 this 3 579  
39 0 0 6 66 568 0 0 10 /**
 *
 */ 1 4 this 3 636  
40 0 0 7 67 577 0 0 10 /**
 *
 */ 2 4 this 3 636  1 n 1 568  
41 0 0 7 69 615 0 0 10 /**
 *
 */ 2 4 this 3 579  1 n 1 568  
42 0 0 4 70 616 0 0 55 /**
 * Replaces the solid with the indicated index.
 */ 3 4 this 3 579  1 n 1 568  5 solid 1 615  
43 0 0 4 71 616 0 0 110 /**
 * Removes the solid with the indicated index.  This will shift all subsequent
 * indices down by one.
 */ 2 4 this 3 579  1 n 1 568  
44 0 0 6 72 568 0 0 121 /**
 * Adds the indicated solid to the node.  Returns the index of the new solid
 * within the node's list of solids.
 */ 2 4 this 3 579  5 solid 1 577  
45 0 0 6 76 568 0 0 114 /**
 * Returns the collider_sort value that has been set for this particular node.
 * See set_collider_sort().
 */ 1 4 this 3 636  
46 0 0 4 77 616 0 0 594 /**
 * Sets a particular collider_sort value on this node.  This controls the
 * order in which colliders (that is, "from nodes") are grouped together for
 * the collision traversal.
 *
 * If there are 32 or fewer colliders added to any particular
 * CollisionTraverser, then this value has no meaning.  It is only useful if
 * there are many colliders, which may force the CollisionTraverser to make
 * multiple passes through the data; in that case, it may be a useful
 * optimization to group colliders that have similar bounding volumes together
 * (by giving them similar sort values).
 */ 2 4 this 3 579  4 sort 1 568  
47 0 0 7 80 635 0 0 80 /**
 * Returns the default into_collide_mask assigned to new CollisionNodes.
 */ 0 
48 0 0 7 82 624 0 0 0 0 
49 0 0 7 85 640 327 0 0 1 6 param0 0 638  
50 0 0 7 85 640 327 0 10 /**
 *
 */ 1 4 name 1 634  
51 0 0 4 87 616 0 0 370 /**
 * Sets the flag that indicates whether the prev_transform stored on a node
 * (as updated via set_fluid_pos(), etc.) is respected to calculate
 * collisions.  If this is true, certain types of collision tests will be
 * enhanced by the information about objects in motion.  If this is false,
 * objects are always considered to be static.  The default is false.
 */ 2 4 this 3 640  4 flag 1 554  
52 0 0 6 88 554 0 0 162 /**
 * Returns the flag that indicates whether the prev_transform stored on a node
 * is respected to calculate collisions.  See set_respect_prev_transform().
 */ 1 4 this 3 638  
53 0 0 4 90 616 0 0 437 /**
 * Adds a new CollisionNode, representing an object that will be tested for
 * collisions into other objects, along with the handler that will serve each
 * detected collision.  Each CollisionNode may be served by only one handler
 * at a time, but a given handler may serve many CollisionNodes.
 *
 * The handler that serves a particular node may be changed from time to time
 * by calling add_collider() again on the same node.
 */ 3 4 this 3 640  8 collider 1 641  7 handler 1 633  
54 0 0 6 91 554 0 0 263 /**
 * Removes the collider (and its associated handler) from the set of
 * CollisionNodes that will be tested each frame for collisions into other
 * objects.  Returns true if the definition was found and removed, false if it
 * wasn't present to begin with.
 */ 2 4 this 3 640  8 collider 1 641  
55 0 0 6 92 554 0 0 145 /**
 * Returns true if the indicated node is current in the set of nodes that will
 * be tested each frame for collisions into other objects.
 */ 2 4 this 3 638  8 collider 1 641  
56 0 0 6 93 568 0 0 108 /**
 * Returns the number of CollisionNodes that have been added to the traverser
 * via add_collider().
 */ 1 4 this 3 638  
57 0 0 7 94 642 0 0 100 /**
 * Returns the nth CollisionNode that has been added to the traverser via
 * add_collider().
 */ 2 4 this 3 638  1 n 1 568  
58 0 0 7 96 633 307 0 169 /**
 * Returns the handler that is currently assigned to serve the indicated
 * collision node, or NULL if the node is not on the traverser's set of active
 * nodes.
 */ 2 4 this 3 638  8 collider 1 641  
59 0 0 4 97 616 0 0 90 /**
 * Completely empties the set of collision nodes and their associated
 * handlers.
 */ 1 4 this 3 640  
60 0 0 4 101 616 0 0 10 /**
 *
 */ 2 4 this 3 640  4 root 1 641  
61 0 0 4 102 616 0 0 777 /**
 * Uses the indicated CollisionRecorder object to start recording the
 * intersection tests made by each subsequent call to traverse() on this
 * object.  A particular CollisionRecorder object can only record one
 * traverser at a time; if this object has already been assigned to another
 * traverser, that assignment is broken.
 *
 * This is intended to be used in a debugging mode to try to determine what
 * work is being performed by the collision traversal.  Usually, attaching a
 * recorder will impose significant runtime overhead.
 *
 * This does not transfer ownership of the CollisionRecorder pointer;
 * maintenance of that remains the caller's responsibility.  If the
 * CollisionRecorder is destructed, it will cleanly remove itself from the
 * traverser.
 */ 2 4 this 3 640  8 recorder 1 572  
62 0 0 6 103 554 0 0 120 /**
 * Returns true if the CollisionTraverser has a CollisionRecorder object
 * currently assigned, false otherwise.
 */ 1 4 this 3 638  
63 0 0 6 104 572 0 0 99 /**
 * Returns the CollisionRecorder currently assigned, or NULL if no recorder is
 * assigned.
 */ 1 4 this 3 638  
64 0 0 4 105 616 0 0 107 /**
 * Removes the CollisionRecorder from the traverser and restores normal low-
 * overhead operation.
 */ 1 4 this 3 640  
65 0 0 7 112 643 543 0 300 /**
 * This is a high-level function to create a CollisionVisualizer object to
 * render the collision tests performed by this traverser.  The supplied root
 * should be any node in the scene graph; typically, the top node (e.g.
 * render).  The CollisionVisualizer will be attached to this node.
 */ 2 4 this 3 640  4 root 1 641  
66 0 0 4 113 616 0 0 69 /**
 * Undoes the effect of a previous call to show_collisions().
 */ 1 4 this 3 640  
67 0 0 4 114 616 0 0 10 /**
 *
 */ 2 4 this 3 638  3 out 1 621  
68 0 0 4 115 616 0 0 10 /**
 *
 */ 3 4 this 3 638  3 out 1 621  12 indent_level 1 568  
69 0 0 7 116 624 0 0 0 0 
70 0 0 4 110 616 0 0 10 /**
 *
 */ 2 4 this 3 644  3 out 1 621  
71 0 0 7 111 624 0 0 0 0 
72 0 0 7 119 577 0 0 104 /**
 * Returns the CollisionSolid pointer for the particular solid that triggered
 * this collision.
 */ 1 4 this 3 646  
73 0 0 6 120 554 0 0 288 /**
 * Returns true if the "into" solid is, in fact, a CollisionSolid, and its
 * pointer is known (in which case get_into() may be called to retrieve it).
 * If this returns false, the collision was detected into a GeomNode, and
 * there is no CollisionSolid pointer to be retrieved.
 */ 1 4 this 3 646  
74 0 0 7 121 577 0 0 243 /**
 * Returns the CollisionSolid pointer for the particular solid was collided
 * into.  This pointer might be NULL if the collision was into a piece of
 * visible geometry, instead of a normal CollisionSolid collision; see
 * has_into().
 */ 1 4 this 3 646  
75 0 0 7 122 579 0 0 182 /**
 * Returns the node that contains the CollisionSolid that triggered this
 * collision.  This will be a node that has been added to a CollisionTraverser
 * via add_collider().
 */ 1 4 this 3 646  
76 0 0 7 123 580 0 0 254 /**
 * Returns the node that contains the CollisionSolid that was collided into.
 * This returns a PandaNode pointer instead of something more specific,
 * because it might be either a CollisionNode or a GeomNode.
 *
 * Also see get_into_node_path().
 */ 1 4 this 3 646  
77 0 0 7 124 642 0 0 224 /**
 * Returns the NodePath that represents the CollisionNode that contains the
 * CollisionSolid that triggered this collision.  This will be a NodePath that
 * has been added to a CollisionTraverser via add_collider().
 */ 1 4 this 3 646  
78 0 0 7 125 642 0 0 338 /**
 * Returns the NodePath that represents the specific CollisionNode or GeomNode
 * instance that was collided into.  This is the same node returned by
 * get_into_node(), represented as a NodePath; however, it may be more useful
 * because the NodePath can resolve the particular instance of the node, if
 * there is more than one.
 */ 1 4 this 3 646  
79 0 0 4 126 616 0 0 82 /**
 * Sets a time value for this collision relative to other CollisionEntries
 */ 2 4 this 3 602  1 t 1 581  
80 0 0 6 127 581 0 0 83 /**
 * returns time value for this collision relative to other CollisionEntries
 */ 1 4 this 3 646  
81 0 0 6 128 554 0 0 188 /**
 * returns true if this represents an actual collision as opposed to a
 * potential collision, needed for iterative collision resolution where path
 * of collider changes mid-frame
 */ 1 4 this 3 646  
82 0 0 4 129 616 0 0 45 /**
 * prepare for another collision test
 */ 1 4 this 3 602  
83 0 0 6 130 554 0 0 203 /**
 * Returns true if the collision was detected by a CollisionTraverser whose
 * respect_prev_transform flag was set true, meaning we should consider motion
 * significant in evaluating collisions.
 */ 1 4 this 3 646  
84 0 0 4 131 616 0 0 178 /**
 * Stores the point, on the surface of the "into" object, at which a collision
 * is detected.
 *
 * This point is specified in the coordinate space of the "into" object.
 */ 2 4 this 3 602  5 point 1 625  
85 0 0 4 132 616 0 0 171 /**
 * Stores the surface normal of the "into" object at the point of the
 * intersection.
 *
 * This normal is specified in the coordinate space of the "into" object.
 */ 2 4 this 3 602  6 normal 1 617  
86 0 0 4 133 616 0 0 352 /**
 * Stores the point, within the interior of the "into" object, which
 * represents the depth to which the "from" object has penetrated.  This can
 * also be described as the intersection point on the surface of the "from"
 * object (which is inside the "into" object).
 *
 * This point is specified in the coordinate space of the "into" object.
 */ 2 4 this 3 602  5 point 1 625  
87 0 0 6 134 554 0 0 174 /**
 * Returns true if the surface point has been specified, false otherwise.  See
 * get_surface_point().  Some types of collisions may not compute the surface
 * point.
 */ 1 4 this 3 646  
88 0 0 6 135 554 0 0 176 /**
 * Returns true if the surface normal has been specified, false otherwise.
 * See get_surface_normal().  Some types of collisions may not compute the
 * surface normal.
 */ 1 4 this 3 646  
89 0 0 6 136 554 0 0 176 /**
 * Returns true if the interior point has been specified, false otherwise.
 * See get_interior_point().  Some types of collisions may not compute the
 * interior point.
 */ 1 4 this 3 646  
90 0 0 4 137 616 0 0 190 /**
 * Stores the position of the "from" object at the instant at which the
 * collision is first detected.
 *
 * This position is specified in the coordinate space of the "into" object.
 */ 2 4 this 3 602  3 pos 1 625  
91 0 0 4 138 616 0 0 154 /**
 * Stores the surface normal of the "into" object at the contact pos.
 *
 * This normal is specified in the coordinate space of the "into" object.
 */ 2 4 this 3 602  6 normal 1 617  
92 0 0 6 139 554 0 0 172 /**
 * Returns true if the contact position has been specified, false otherwise.
 * See get_contact_pos().  Some types of collisions may not compute the
 * contact pos.
 */ 1 4 this 3 646  
93 0 0 6 140 554 0 0 176 /**
 * Returns true if the contact normal has been specified, false otherwise.
 * See get_contact_normal().  Some types of collisions may not compute the
 * contact normal.
 */ 1 4 this 3 646  
94 0 0 7 141 614 0 0 330 /**
 * Returns the point, on the surface of the "into" object, at which a
 * collision is detected.  This can be thought of as the first point of
 * intersection.  However the contact point is the actual first point of
 * intersection.
 *
 * The point will be converted into whichever coordinate space the caller
 * specifies.
 */ 2 4 this 3 646  5 space 1 641  
95 0 0 7 142 630 0 0 200 /**
 * Returns the surface normal of the "into" object at the point at which a
 * collision is detected.
 *
 * The normal will be converted into whichever coordinate space the caller
 * specifies.
 */ 2 4 this 3 646  5 space 1 641  
96 0 0 7 143 614 0 0 431 /**
 * Returns the point, within the interior of the "into" object, which
 * represents the depth to which the "from" object has penetrated.  This can
 * also be described as the intersection point on the surface of the "from"
 * object (which is inside the "into" object).  It can be thought of as the
 * deepest point of intersection.
 *
 * The point will be converted into whichever coordinate space the caller
 * specifies.
 */ 2 4 this 3 646  5 space 1 641  
97 0 0 6 144 554 0 0 244 /**
 * Simultaneously transforms the surface point, surface normal, and interior
 * point of the collision into the indicated coordinate space.
 *
 * Returns true if all three properties are available, or false if any one of
 * them is not.
 */ 5 4 this 3 646  5 space 1 641  13 surface_point 1 614  14 surface_normal 1 630  14 interior_point 1 614  
98 0 0 7 145 614 0 0 200 /**
 * Returns the position of the "from" object at the instant that a collision
 * is first detected.
 *
 * The position will be converted into whichever coordinate space the caller
 * specifies.
 */ 2 4 this 3 646  5 space 1 641  
99 0 0 7 146 630 0 0 175 /**
 * Returns the surface normal of the "into" object at the contact position.
 *
 * The normal will be converted into whichever coordinate space the caller
 * specifies.
 */ 2 4 this 3 646  5 space 1 641  
100 0 0 6 147 554 0 0 230 /**
 * Simultaneously transforms the contact position and contact normal of the
 * collision into the indicated coordinate space.
 *
 * Returns true if all three properties are available, or false if any one of
 * them is not.
 */ 4 4 this 3 646  5 space 1 641  11 contact_pos 1 614  14 contact_normal 1 630  
101 0 0 4 148 616 0 0 10 /**
 *
 */ 2 4 this 3 646  3 out 1 621  
102 0 0 4 149 616 0 0 10 /**
 *
 */ 3 4 this 3 646  3 out 1 621  12 indent_level 1 568  
103 0 0 7 164 624 0 0 0 0 
104 0 0 7 167 650 390 0 10 /**
 *
 */ 1 4 copy 1 648  
105 0 0 7 167 650 390 0 10 /**
 *
 */ 1 5 plane 1 651  
106 0 0 7 168 630 0 0 10 /**
 *
 */ 1 4 this 3 648  
107 0 0 6 169 581 0 0 10 /**
 *
 */ 2 4 this 3 648  5 point 1 625  
108 0 0 4 170 616 0 0 10 /**
 *
 */ 2 4 this 3 650  5 plane 1 651  
109 0 0 6 171 651 0 0 10 /**
 *
 */ 1 4 this 3 648  
110 0 0 4 172 616 0 0 57 /**
 * Convenience method to flip the plane in-place.
 */ 1 4 this 3 650  
111 0 0 7 178 624 0 0 0 0 
112 0 0 7 181 652 401 0 144 /**
 * This is only for the convenience of CollisionPolygon.  Normally, you should
 * not attempt to create an uninitialized CollisionPlane.
 */ 0 
113 0 0 4 182 616 0 0 47 /**
 * store away a vertex to index against
 */ 2 4 this 3 652  4 vert 1 625  
114 0 0 4 183 616 0 0 42 /**
 * store a triangle for processing
 */ 4 4 this 3 652  6 pointA 1 653  6 pointB 1 653  6 pointC 1 653  
115 0 0 6 184 653 0 0 0 1 4 this 3 654  
116 0 0 6 185 625 0 0 0 2 4 this 3 654  5 index 1 653  
117 0 0 6 187 653 0 0 0 1 4 this 3 654  
118 0 0 7 188 656 0 0 0 2 4 this 3 654  5 index 1 653  
119 0 0 7 195 624 0 0 0 0 
120 0 0 7 198 657 410 0 10 /**
 *
 */ 2 5 begin 1 625  3 end 1 625  
121 0 0 7 198 657 410 0 10 /**
 *
 */ 3 1 a 1 658  1 b 1 658  1 c 1 658  
122 0 0 7 198 657 410 0 10 /**
 *
 */ 4 1 a 1 658  1 b 1 658  1 c 1 658  1 d 1 658  
123 0 0 6 199 568 0 0 66 /**
 * Returns the number of vertices of the CollisionPolygon.
 */ 1 4 this 3 662  
124 0 0 7 200 614 0 0 82 /**
 * Returns the nth vertex of the CollisionPolygon, expressed in 3-D space.
 */ 2 4 this 3 662  1 n 1 568  
125 0 0 6 202 554 0 0 338 /**
 * Verifies that the indicated set of points will define a valid
 * CollisionPolygon: that is, at least three non-collinear points, with no
 * points repeated.
 *
 * This does not check that the polygon defined is convex; that check is made
 * later, once we have projected the points to 2-d space where the decision is
 * easier.
 */ 2 5 begin 1 625  3 end 1 625  
126 0 0 6 202 554 0 0 167 /**
 * Verifies that the indicated set of points will define a valid
 * CollisionPolygon: that is, at least three non-collinear points, with no
 * points repeated.
 */ 3 1 a 1 625  1 b 1 625  1 c 1 625  
127 0 0 6 202 554 0 0 167 /**
 * Verifies that the indicated set of points will define a valid
 * CollisionPolygon: that is, at least three non-collinear points, with no
 * points repeated.
 */ 4 1 a 1 625  1 b 1 625  1 c 1 625  1 d 1 625  
128 0 0 6 203 554 0 0 122 /**
 * Returns true if the CollisionPolygon is valid (that is, it has at least
 * three vertices), or false otherwise.
 */ 1 4 this 3 662  
129 0 0 6 204 554 0 0 106 /**
 * Returns true if the CollisionPolygon appears to be concave, or false if it
 * is safely convex.
 */ 1 4 this 3 662  
130 0 0 7 209 624 0 0 0 0 
131 0 0 7 212 664 433 0 168 /**
 * The default CollisionHandlerEvent will throw no events.  Its pattern
 * strings must first be set via a call to add_in_pattern() and/or
 * add_out_pattern().
 */ 0 
132 0 0 7 212 664 433 0 0 1 6 param0 0 665  
133 0 0 4 213 616 0 0 80 /**
 * Removes all of the previously-added in patterns.  See add_in_pattern.
 */ 1 4 this 3 664  
134 0 0 4 214 616 0 0 1586 /**
 * Adds a pattern string to the list of events that will be generated in
 * response to a collision.  The pattern string describes how the event name
 * will be composed.  It is a string that may contain any of the following:
 *
 * %fn  - the name of the "from" object's node %in  - the name of the "into"
 * object's node %fs  - 't' if "from" is tangible, 'i' if intangible %is  -
 * 't' if "into" is tangible, 'i' if intangible %ig  - 'c' if the collision is
 * into a CollisionNode, 'g' if it is a geom.
 *
 * %(tag)fh - generate event only if "from" node has the indicated net tag.
 * %(tag)fx - generate event only if "from" node does not have the indicated
 * net tag.  %(tag)ih - generate event only if "into" node has the indicated
 * net tag.  %(tag)ix - generate event only if "into" node does not have the
 * indicated net tag.  %(tag)ft - the indicated net tag value of the "from"
 * node.  %(tag)it - the indicated net tag value of the "into" node.
 *
 * Parentheses in the above are literal and should be included in the actual
 * pattern.
 *
 * The event name will be based on the in_pattern string specified here, with
 * all occurrences of the above strings replaced with the corresponding
 * values.
 *
 * In general, the in_pattern event is thrown on the first detection of a
 * collision between two particular nodes.  In subsequent passes, as long as a
 * collision between those two nodes continues to be detected each frame, the
 * again_pattern is thrown.  The first frame in which the collision is no
 * longer detected, the out_pattern event is thrown.
 */ 2 4 this 3 664  10 in_pattern 1 634  
135 0 0 4 215 616 0 0 141 /**
 * This method is deprecated; it completely replaces all the in patterns that
 * have previously been set with the indicated pattern.
 */ 2 4 this 3 664  10 in_pattern 1 634  
136 0 0 6 216 568 0 0 73 /**
 * Returns the number of in pattern strings that have been added.
 */ 1 4 this 3 665  
137 0 0 6 217 634 0 0 145 /**
 * Returns the nth pattern string that indicates how the event names are
 * generated for each collision detected.  See add_in_pattern().
 */ 2 4 this 3 665  1 n 1 568  
138 0 0 4 219 616 0 0 83 /**
 * Removes all of the previously-added in patterns.  See add_again_pattern.
 */ 1 4 this 3 664  
139 0 0 4 220 616 0 0 649 /**
 * Adds the pattern string that indicates how the event names are generated
 * when a collision between two particular nodes is *still* detected.  This
 * event is thrown each consecutive time a collision between two particular
 * nodes is detected, starting with the second time.
 *
 * In general, the in_pattern event is thrown on the first detection of a
 * collision between two particular nodes.  In subsequent passes, as long as a
 * collision between those two nodes continues to be detected each frame, the
 * again_pattern is thrown.  The first frame in which the collision is no
 * longer detected, the out_pattern event is thrown.
 */ 2 4 this 3 664  13 again_pattern 1 634  
140 0 0 4 221 616 0 0 141 /**
 * This method is deprecated; it completely replaces all the in patterns that
 * have previously been set with the indicated pattern.
 */ 2 4 this 3 664  13 again_pattern 1 634  
141 0 0 6 222 568 0 0 73 /**
 * Returns the number of in pattern strings that have been added.
 */ 1 4 this 3 665  
142 0 0 6 223 634 0 0 148 /**
 * Returns the nth pattern string that indicates how the event names are
 * generated for each collision detected.  See add_again_pattern().
 */ 2 4 this 3 665  1 n 1 568  
143 0 0 4 225 616 0 0 81 /**
 * Removes all of the previously-added in patterns.  See add_out_pattern.
 */ 1 4 this 3 664  
144 0 0 4 226 616 0 0 518 /**
 * Adds the pattern string that indicates how the event names are generated
 * when a collision between two particular nodes is *no longer* detected.
 *
 * In general, the in_pattern event is thrown on the first detection of a
 * collision between two particular nodes.  In subsequent passes, as long as a
 * collision between those two nodes continues to be detected each frame, the
 * again_pattern is thrown.  The first frame in which the collision is no
 * longer detected, the out_pattern event is thrown.
 */ 2 4 this 3 664  11 out_pattern 1 634  
145 0 0 4 227 616 0 0 141 /**
 * This method is deprecated; it completely replaces all the in patterns that
 * have previously been set with the indicated pattern.
 */ 2 4 this 3 664  11 out_pattern 1 634  
146 0 0 6 228 568 0 0 73 /**
 * Returns the number of in pattern strings that have been added.
 */ 1 4 this 3 665  
147 0 0 6 229 634 0 0 146 /**
 * Returns the nth pattern string that indicates how the event names are
 * generated for each collision detected.  See add_out_pattern().
 */ 2 4 this 3 665  1 n 1 568  
148 0 0 4 239 616 0 0 541 /**
 * Empties the list of elements that all colliders are known to be colliding
 * with.  No "out" events will be thrown; if the same collision is detected
 * next frame, a new "in" event will be thrown for each collision.
 *
 * This can be called each frame to defeat the persistent "in" event
 * mechanism, which prevents the same "in" event from being thrown repeatedly.
 * However, also see add_again_pattern(), which can be used to set the event
 * that is thrown when a collision is detected for two or more consecutive
 * frames.
 */ 1 4 this 3 664  
149 0 0 4 240 616 0 0 58 /**
 * Same as clear() except "out" events are thrown.
 */ 1 4 this 3 664  
150 0 0 7 241 624 0 0 0 0 
151 0 0 4 244 616 0 0 180 /**
 * Adds a new collider to the list with a NodePath that will be updated with
 * the collider's new position, or updates the existing collider with a new
 * NodePath object.
 */ 3 4 this 3 667  8 collider 1 641  6 target 1 641  
152 0 0 4 244 616 0 0 374 /**
 * Adds a new collider to the list with a NodePath that will be updated with
 * the collider's new position, or updates the existing collider with a new
 * NodePath object.
 *
 * The indicated DriveInterface will also be updated with the target's new
 * transform each frame.  This method should be used when the target is
 * directly controlled by a DriveInterface.
 */ 4 4 this 3 667  8 collider 1 641  6 target 1 641  15 drive_interface 1 668  
153 0 0 6 245 554 0 0 92 /**
 * Removes the collider from the list of colliders that this handler knows
 * about.
 */ 2 4 this 3 667  8 collider 1 641  
154 0 0 6 246 554 0 0 94 /**
 * Returns true if the handler knows about the indicated collider, false
 * otherwise.
 */ 2 4 this 3 670  8 collider 1 641  
155 0 0 4 247 616 0 0 77 /**
 * Completely empties the list of colliders this handler knows about.
 */ 1 4 this 3 667  
156 0 0 4 248 616 0 0 269 /**
 * Specifies an arbitrary NodePath that the handler is always considered to be
 * facing.  It does not detect collisions with surfaces that appear to be
 * facing away from this NodePath.  This works best when the collision
 * surfaces in question are polygons.
 */ 2 4 this 3 667  6 center 1 641  
157 0 0 4 249 616 0 0 64 /**
 * Clears the center NodePath specified with set_center.
 */ 1 4 this 3 667  
158 0 0 6 250 641 0 0 114 /**
 * Returns the NodePath specified with set_center, or the empty NodePath if
 * nothing has been specified.
 */ 1 4 this 3 670  
159 0 0 6 251 554 0 0 95 /**
 * Returns true if a NodePath has been specified with set_center(), false
 * otherwise.
 */ 1 4 this 3 670  
160 0 0 6 252 554 0 0 255 /**
 * Did the handler make any contacts with anything on the last collision pass?
 * Depending on how your world is setup, this can be used to tell if the
 * handler is out of the world (i.e.  out of bounds). That is the original use
 * of this call.
 */ 1 4 this 3 670  
161 0 0 7 255 624 0 0 0 0 
162 0 0 7 257 672 433 0 10 /**
 *
 */ 0 
163 0 0 4 258 616 0 0 166 /**
 * Sets the linear offset to add to (or subtract from) the highest detected
 * collision point to determine the actual height at which to set the
 * collider.
 */ 2 4 this 3 672  6 offset 1 581  
164 0 0 6 259 581 0 0 169 /**
 * Returns the linear offset to add to (or subtract from) the highest detected
 * collision point to determine the actual height at which to set the
 * collider.
 */ 1 4 this 3 673  
165 0 0 4 260 616 0 0 82 /**
 * Sets the reach to add to (or subtract from) the highest collision point
 */ 2 4 this 3 672  5 reach 1 581  
166 0 0 6 261 581 0 0 85 /**
 * Returns the reach to add to (or subtract from) the highest collision point
 */ 1 4 this 3 673  
167 0 0 4 262 616 0 0 199 /**
 * Sets the maximum speed at which the object will be allowed to descend
 * towards a floor below it, in units per second.  Set this to zero to allow
 * it to instantly teleport any distance.
 */ 2 4 this 3 672  7 max_vel 1 581  
168 0 0 6 263 581 0 0 160 /**
 * Retrieves the maximum speed at which the object will be allowed to descend
 * towards a floor below it, in units per second.  See set_max_velocity().
 */ 1 4 this 3 673  
169 0 0 7 267 624 0 0 0 0 
170 0 0 7 269 675 433 0 10 /**
 *
 */ 0 
171 0 0 4 270 616 0 0 10 /**
 *
 */ 2 4 this 3 675  4 flag 1 554  
172 0 0 6 271 554 0 0 10 /**
 *
 */ 1 4 this 3 676  
173 0 0 7 273 624 0 0 0 0 
174 0 0 7 275 678 458 0 10 /**
 *
 */ 0 
175 0 0 7 276 624 0 0 0 0 
176 0 0 7 279 679 433 0 10 /**
 *
 */ 0 
177 0 0 4 280 616 0 0 166 /**
 * Sets the linear offset to add to (or subtract from) the highest detected
 * collision point to determine the actual height at which to set the
 * collider.
 */ 2 4 this 3 679  6 offset 1 581  
178 0 0 6 281 581 0 0 169 /**
 * Returns the linear offset to add to (or subtract from) the highest detected
 * collision point to determine the actual height at which to set the
 * collider.
 */ 1 4 this 3 680  
179 0 0 4 282 616 0 0 82 /**
 * Sets the reach to add to (or subtract from) the highest collision point
 */ 2 4 this 3 679  5 reach 1 581  
180 0 0 6 283 581 0 0 85 /**
 * Returns the reach to add to (or subtract from) the highest collision point
 */ 1 4 this 3 680  
181 0 0 6 284 581 0 0 238 /**
 * Return the height of the object from the ground.
 *
 * The object might not necessarily be at rest.  Use is_on_ground() if you
 * want to know whether the object is on the ground and at rest.
 *
 * See Also: is_in_outer_space()
 */ 1 4 this 3 680  
182 0 0 6 285 554 0 0 33 /**
 * Is the object at rest?
 */ 1 4 this 3 680  
183 0 0 6 286 581 0 0 282 /**
 * How hard did the object hit the ground.  This value is set on impact with
 * the ground.  You may want to watch (poll) on is_on_groun() and when that is
 * true, call get_impact_velocity(). Normally I avoid polling, but we are
 * calling is_on_ground() frequently anyway.
 */ 1 4 this 3 680  
184 0 0 6 287 617 0 0 10 /**
 *
 */ 1 4 this 3 680  
185 0 0 4 288 616 0 0 184 /**
 * Adds the sepcified amount to the current velocity.  This is mostly here
 * allow this common operation to be faster for scripting, but it's also more
 * concise even in cpp.
 */ 2 4 this 3 679  8 velocity 1 581  
186 0 0 4 289 616 0 0 46 /**
 * Sets the current vertical velocity.
 */ 2 4 this 3 679  8 velocity 1 581  
187 0 0 6 290 581 0 0 354 /**
 * Gets the current vertical velocity.
 *
 * Generally, negative values mean the object is in free fall; while postive
 * values mean the object has vertical thrust.
 *
 * A zero value does not necessarily mean the object on the ground, it may
 * also be weightless and/or at the apex of its jump.
 *
 * See Also: is_on_ground() and get_gravity()
 */ 1 4 this 3 680  
188 0 0 4 291 616 0 0 56 /**
 * Sets the linear gravity force (always plumb).
 */ 2 4 this 3 679  7 gravity 1 581  
189 0 0 6 292 581 0 0 56 /**
 * Gets the linear gravity force (always plumb).
 */ 1 4 this 3 680  
190 0 0 4 293 616 0 0 199 /**
 * Sets the maximum speed at which the object will be allowed to descend
 * towards a floor below it, in units per second.  Set this to zero to allow
 * it to instantly teleport any distance.
 */ 2 4 this 3 679  7 max_vel 1 581  
191 0 0 6 294 581 0 0 160 /**
 * Retrieves the maximum speed at which the object will be allowed to descend
 * towards a floor below it, in units per second.  See set_max_velocity().
 */ 1 4 this 3 680  
192 0 0 4 295 616 0 0 229 /**
 * Enables old behavior required by Toontown (Sellbot Factory lava room is
 * good test case, lava and conveyor belt specifically). Behavior is to throw
 * enter/exit events only for floor that the toon is in contact with
 */ 2 4 this 3 679  11 legacy_mode 1 554  
193 0 0 6 296 554 0 0 49 /**
 * returns true if legacy mode is enabled
 */ 1 4 this 3 680  
194 0 0 7 307 624 0 0 0 0 
195 0 0 7 309 682 480 0 168 /**
 * The default CollisionHandlerEvent will throw no events.  Its pattern
 * strings must first be set via a call to add_in_pattern() and/or
 * add_out_pattern().
 */ 0 
196 0 0 7 309 682 480 0 0 1 6 param0 0 683  
197 0 0 7 310 624 0 0 0 0 
198 0 0 7 313 685 490 0 10 /**
 *
 */ 0 
199 0 0 7 313 685 490 0 0 1 6 param0 0 686  
200 0 0 4 314 616 0 0 257 /**
 * Sorts all the detected collisions front-to-back by
 * from_intersection_point() so that those intersection points closest to the
 * collider's origin (e.g., the center of the CollisionSphere, or the point_a
 * of a CollisionSegment) appear first.
 */ 1 4 this 3 685  
201 0 0 4 315 616 0 0 50 /**
 * Removes all the entries from the queue.
 */ 1 4 this 3 685  
202 0 0 6 316 568 0 0 69 /**
 * Returns the number of CollisionEntries detected last pass.
 */ 1 4 this 3 686  
203 0 0 7 317 602 382 0 61 /**
 * Returns the nth CollisionEntry detected last pass.
 */ 2 4 this 3 686  1 n 1 568  
204 0 0 4 322 616 0 0 10 /**
 *
 */ 2 4 this 3 686  3 out 1 621  
205 0 0 4 323 616 0 0 10 /**
 *
 */ 3 4 this 3 686  3 out 1 621  12 indent_level 1 568  
206 0 0 7 324 624 0 0 0 0 
207 0 0 7 327 688 497 0 10 /**
 *
 */ 2 6 center 1 625  6 radius 1 581  
208 0 0 7 327 688 497 0 10 /**
 *
 */ 4 2 cx 1 581  2 cy 1 581  2 cz 1 581  6 radius 1 581  
209 0 0 4 328 616 0 0 10 /**
 *
 */ 2 4 this 3 688  6 center 1 625  
210 0 0 4 328 616 0 0 10 /**
 *
 */ 4 4 this 3 688  1 x 1 581  1 y 1 581  1 z 1 581  
211 0 0 6 329 625 0 0 10 /**
 *
 */ 1 4 this 3 689  
212 0 0 4 330 616 0 0 10 /**
 *
 */ 2 4 this 3 688  6 radius 1 581  
213 0 0 6 331 581 0 0 10 /**
 *
 */ 1 4 this 3 689  
214 0 0 7 334 624 0 0 0 0 
215 0 0 7 337 691 500 0 10 /**
 *
 */ 2 6 center 1 625  6 radius 1 581  
216 0 0 7 337 691 500 0 10 /**
 *
 */ 4 2 cx 1 581  2 cy 1 581  2 cz 1 581  6 radius 1 581  
217 0 0 7 338 624 0 0 0 0 
218 0 0 7 341 692 508 0 183 /**
 * Creates an invalid ray.  This isn't terribly useful; it's expected that the
 * user will subsequently adjust the ray via set_origin()/set_direction() or
 * set_from_lens().
 */ 0 
219 0 0 7 341 692 508 0 10 /**
 *
 */ 2 6 origin 1 625  9 direction 1 617  
220 0 0 7 341 692 508 0 10 /**
 *
 */ 6 2 ox 1 581  2 oy 1 581  2 oz 1 581  2 dx 1 581  2 dy 1 581  2 dz 1 581  
221 0 0 4 342 616 0 0 10 /**
 *
 */ 2 4 this 3 692  6 origin 1 625  
222 0 0 4 342 616 0 0 10 /**
 *
 */ 4 4 this 3 692  1 x 1 581  1 y 1 581  1 z 1 581  
223 0 0 6 343 625 0 0 10 /**
 *
 */ 1 4 this 3 693  
224 0 0 4 345 616 0 0 10 /**
 *
 */ 2 4 this 3 692  9 direction 1 617  
225 0 0 4 345 616 0 0 10 /**
 *
 */ 4 4 this 3 692  1 x 1 581  1 y 1 581  1 z 1 581  
226 0 0 6 346 617 0 0 10 /**
 *
 */ 1 4 this 3 693  
227 0 0 6 348 554 0 0 327 /**
 * Accepts a LensNode and a 2-d point in the range [-1,1].  Sets the
 * CollisionRay so that it begins at the LensNode's near plane and extends to
 * infinity, making it suitable for picking objects from the screen given a
 * camera and a mouse location.
 *
 * Returns true if the point was acceptable, false otherwise.
 */ 3 4 this 3 692  6 camera 1 695  5 point 1 697  
228 0 0 6 348 554 0 0 262 /**
 * Accepts a LensNode and a 2-d point in the range [-1,1].  Sets the
 * CollisionRay so that it begins at the LensNode's near plane and extends to
 * infinity, making it suitable for picking objects from the screen given a
 * camera and a mouse location.
 */ 4 4 this 3 692  6 camera 1 695  2 px 1 581  2 py 1 581  
229 0 0 7 349 624 0 0 0 0 
230 0 0 7 352 701 511 0 185 /**
 * Creates an invalid line.  This isn't terribly useful; it's expected that
 * the user will subsequently adjust the line via set_origin()/set_direction()
 * or set_from_lens().
 */ 0 
231 0 0 7 352 701 511 0 10 /**
 *
 */ 2 6 origin 1 625  9 direction 1 617  
232 0 0 7 352 701 511 0 10 /**
 *
 */ 6 2 ox 1 581  2 oy 1 581  2 oz 1 581  2 dx 1 581  2 dy 1 581  2 dz 1 581  
233 0 0 7 353 624 0 0 0 0 
234 0 0 7 356 702 520 0 39 /**
 * Creates an invalid parabola.
 */ 0 
235 0 0 7 356 702 520 0 110 /**
 * Creates a parabola with the endpoints between t1 and t2 in the parametric
 * space of the parabola.
 */ 3 8 parabola 1 703  2 t1 1 581  2 t2 1 581  
236 0 0 4 357 616 0 0 57 /**
 * Replaces the parabola specified by this solid.
 */ 2 4 this 3 702  8 parabola 1 703  
237 0 0 6 358 703 0 0 56 /**
 * Returns the parabola specified by this solid.
 */ 1 4 this 3 704  
238 0 0 4 359 616 0 0 54 /**
 * Changes the starting point on the parabola.
 */ 2 4 this 3 702  2 t1 1 581  
239 0 0 6 360 581 0 0 54 /**
 * Returns the starting point on the parabola.
 */ 1 4 this 3 704  
240 0 0 4 361 616 0 0 52 /**
 * Changes the ending point on the parabola.
 */ 2 4 this 3 702  2 t2 1 581  
241 0 0 6 362 581 0 0 52 /**
 * Returns the ending point on the parabola.
 */ 1 4 this 3 704  
242 0 0 7 369 624 0 0 0 0 
243 0 0 7 372 706 528 0 191 /**
 * Creates an invalid segment.  This isn't terribly useful; it's expected that
 * the user will subsequently adjust the segment via
 * set_origin()/set_direction() or set_from_lens().
 */ 0 
244 0 0 7 372 706 528 0 10 /**
 *
 */ 2 1 a 1 625  2 db 1 625  
245 0 0 7 372 706 528 0 10 /**
 *
 */ 6 2 ax 1 581  2 ay 1 581  2 az 1 581  2 bx 1 581  2 by 1 581  2 bz 1 581  
246 0 0 4 373 616 0 0 10 /**
 *
 */ 2 4 this 3 706  1 a 1 625  
247 0 0 4 373 616 0 0 10 /**
 *
 */ 4 4 this 3 706  1 x 1 581  1 y 1 581  1 z 1 581  
248 0 0 6 374 625 0 0 10 /**
 *
 */ 1 4 this 3 707  
249 0 0 4 375 616 0 0 10 /**
 *
 */ 2 4 this 3 706  1 b 1 625  
250 0 0 4 375 616 0 0 10 /**
 *
 */ 4 4 this 3 706  1 x 1 581  1 y 1 581  1 z 1 581  
251 0 0 6 376 625 0 0 10 /**
 *
 */ 1 4 this 3 707  
252 0 0 6 377 554 0 0 336 /**
 * Accepts a LensNode and a 2-d point in the range [-1,1].  Sets the
 * CollisionSegment so that it begins at the LensNode's near plane and extends
 * to the far plane, making it suitable for picking objects from the screen
 * given a camera and a mouse location.
 *
 * Returns true if the point was acceptable, false otherwise.
 */ 3 4 this 3 706  6 camera 1 695  5 point 1 697  
253 0 0 6 377 554 0 0 271 /**
 * Accepts a LensNode and a 2-d point in the range [-1,1].  Sets the
 * CollisionSegment so that it begins at the LensNode's near plane and extends
 * to the far plane, making it suitable for picking objects from the screen
 * given a camera and a mouse location.
 */ 4 4 this 3 706  6 camera 1 695  2 px 1 581  2 py 1 581  
254 0 0 7 380 624 0 0 0 0 
255 0 0 7 383 709 537 0 10 /**
 *
 */ 3 1 a 1 625  2 db 1 625  6 radius 1 581  
256 0 0 7 383 709 537 0 10 /**
 *
 */ 7 2 ax 1 581  2 ay 1 581  2 az 1 581  2 bx 1 581  2 by 1 581  2 bz 1 581  6 radius 1 581  
257 0 0 4 384 616 0 0 10 /**
 *
 */ 2 4 this 3 709  1 a 1 625  
258 0 0 4 384 616 0 0 10 /**
 *
 */ 4 4 this 3 709  1 x 1 581  1 y 1 581  1 z 1 581  
259 0 0 6 385 625 0 0 10 /**
 *
 */ 1 4 this 3 710  
260 0 0 4 386 616 0 0 10 /**
 *
 */ 2 4 this 3 709  1 b 1 625  
261 0 0 4 386 616 0 0 10 /**
 *
 */ 4 4 this 3 709  1 x 1 581  1 y 1 581  1 z 1 581  
262 0 0 6 387 625 0 0 10 /**
 *
 */ 1 4 this 3 710  
263 0 0 4 388 616 0 0 10 /**
 *
 */ 2 4 this 3 709  6 radius 1 581  
264 0 0 6 389 581 0 0 10 /**
 *
 */ 1 4 this 3 710  
265 0 0 7 393 624 0 0 0 0 
266 0 0 7 400 643 543 0 10 /**
 *
 */ 1 4 name 1 634  
267 0 0 4 402 616 0 0 412 /**
 * Scales the points that are drawn to represent the surface and interior
 * intersection points of the collisions.  By default, these objects are drawn
 * at an arbitrary scale which is appropriate if the window units are the
 * default range -1 .. 1.  Change this scale accordinatly if the window units
 * are measured on some other scale or if you need to observe these objects in
 * a smaller window.
 */ 2 4 this 3 643  11 point_scale 1 581  
268 0 0 6 403 581 0 0 59 /**
 * Returns the value last set by set_point_scale().
 */ 1 4 this 3 712  
269 0 0 4 404 616 0 0 370 /**
 * Scales the line segments that are drawn to represent the normals of the
 * collisions.  By default, these objects are drawn at an arbitrary scale
 * which is appropriate if the scene units are measured in feet.  Change this
 * scale accordinatly if the scene units are measured on some other scale or
 * if you need to observe these normals from farther away.
 */ 2 4 this 3 643  12 normal_scale 1 581  
270 0 0 6 405 581 0 0 60 /**
 * Returns the value last set by set_normal_scale().
 */ 1 4 this 3 712  
271 0 0 4 406 616 0 0 110 /**
 * Removes all the visualization data from a previous traversal and resets the
 * visualizer to empty.
 */ 1 4 this 3 643  
272 0 0 7 409 624 0 0 0 0 
273 0 0 7 396 580 0 0 0 1 4 this 3 643  
274 0 0 7 397 643 543 0 0 1 4 this 3 580  
275 0 0 6 398 572 0 0 0 1 4 this 3 643  
276 0 0 7 399 643 543 0 0 1 4 this 3 572  
164
550 14 CollisionSolid 0 75777 14 CollisionSolid 14 CollisionSolid 0 0 0 0 0 4 714 715 716 717 14 277 278 279 280 281 282 283 284 285 286 287 288 289 290 0 0 1 0 551 0 0 0 0 457
/**
 * The abstract base class for all things that can collide with other things
 * in the world, and all the things they can collide with (except geometry).
 *
 * This class and its derivatives really work very similarly to the way
 * BoundingVolume and all of its derivatives work.  There's a different
 * subclass for each basic shape of solid, and double-dispatch function calls
 * handle the subset of the N*N intersection tests that we care about.
 */

551 17 CopyOnWriteObject 0 2049 17 CopyOnWriteObject 17 CopyOnWriteObject 0 0 0 0 0 0 0 0 0 0 0 0 169
/**
 * This base class provides basic reference counting, but also can be used
 * with a CopyOnWritePointer to provide get_read_pointer() and
 * get_write_pointer().
 */

552 7 LPoint3 0 2105344 7 LPoint3 7 LPoint3 0 0 553 0 0 0 0 0 0 0 0 0 0

553 8 LPoint3f 0 2048 8 LPoint3f 8 LPoint3f 0 0 0 0 0 0 0 0 0 0 0 0 337
/**
 * This is a three-component point in space (as opposed to a three-component
 * vector, which represents a direction and a distance).  Some of the methods
 * are slightly different between LPoint3 and LVector3; in particular,
 * subtraction of two points yields a vector, while addition of a vector and a
 * point yields a point.
 */

554 4 bool 0 8194 4 bool 4 bool 0 4 0 0 0 0 0 0 0 0 0 0 0

555 32 ConstPointerTo< BoundingVolume > 0 2048 32 ConstPointerTo< BoundingVolume > 32 ConstPointerTo< BoundingVolume > 0 0 0 0 0 0 0 0 0 0 0 0 0

556 12 CollisionBox 0 141313 12 CollisionBox 12 CollisionBox 0 0 0 1 291 304 4 718 719 720 721 12 292 293 294 295 296 297 298 299 300 301 302 303 0 0 1 0 550 0 0 0 0 47
/**
 * A cuboid collision volume or object.
 */

557 13 LPoint3 const 0 8832 13 LPoint3 const 13 LPoint3 const 0 0 552 0 0 0 0 0 0 0 0 0 0

558 8 LVector3 0 2105344 8 LVector3 8 LVector3 0 0 559 0 0 0 0 0 0 0 0 0 0

559 9 LVector3f 0 2048 9 LVector3f 9 LVector3f 0 0 0 0 0 0 0 0 0 0 0 0 338
/**
 * This is a three-component vector distance (as opposed to a three-component
 * point, which represents a particular point in space).  Some of the methods
 * are slightly different between LPoint3 and LVector3; in particular,
 * subtraction of two points yields a vector, while addition of a vector and a
 * point yields a point.
 */

560 16 CollisionHandler 0 141313 16 CollisionHandler 16 CollisionHandler 0 0 0 1 306 307 0 1 305 0 0 1 0 561 0 0 0 0 262
/**
 * The abstract interface to a number of classes that decide what to do when a
 * collision is detected.  One of these must be assigned to the
 * CollisionTraverser that is processing collisions in order to specify how to
 * dispatch detected collisions.
 */

561 19 TypedReferenceCount 0 2049 19 TypedReferenceCount 19 TypedReferenceCount 0 0 0 0 0 0 0 0 0 0 0 0 410
/**
 * A base class for things which need to inherit from both TypedObject and
 * from ReferenceCount.  It's convenient to define this intermediate base
 * class instead of multiply inheriting from the two classes each time they
 * are needed, so that we can sensibly pass around pointers to things which
 * are both TypedObjects and ReferenceCounters.
 *
 * See also TypedObject for detailed instructions.
 */

562 13 CollisionNode 0 75777 13 CollisionNode 13 CollisionNode 0 0 0 1 308 0 5 722 723 724 725 726 16 309 310 311 312 313 314 315 316 317 318 319 320 322 323 324 325 1 777 0 1 0 563 0 0 0 0 261
/**
 * A node in the scene graph that can hold any number of CollisionSolids.
 * This may either represent a bit of static geometry in the scene that things
 * will collide with, or an animated object twirling around in the world and
 * running into things.
 */

563 9 PandaNode 0 2049 9 PandaNode 9 PandaNode 0 0 0 0 0 0 0 0 0 0 0 0 175
/**
 * A basic node of the scene graph or data graph.  This is the base class of
 * all specialized nodes, and also serves as a generic node with no special
 * properties.
 */

564 11 CollideMask 0 2105344 11 CollideMask 11 CollideMask 0 0 565 0 0 0 0 0 0 0 0 0 0

565 9 BitMask32 0 2105344 9 BitMask32 9 BitMask32 0 0 566 0 0 0 0 0 0 0 0 0 0

566 23 BitMask< uint32_t, 32 > 0 2048 23 BitMask< uint32_t, 32 > 23 BitMask< uint32_t, 32 > 0 0 0 0 0 0 0 0 0 0 0 0 0

567 32 ConstPointerTo< CollisionSolid > 0 2048 32 ConstPointerTo< CollisionSolid > 32 ConstPointerTo< CollisionSolid > 0 0 0 0 0 0 0 0 0 0 0 0 0

568 3 int 0 8194 3 int 3 int 0 1 0 0 0 0 0 0 0 0 0 0 0

569 18 CollisionTraverser 0 26625 18 CollisionTraverser 18 CollisionTraverser 0 0 0 1 326 327 3 727 728 729 19 328 329 330 331 332 333 334 335 336 338 339 340 341 342 345 346 347 348 349 1 778 0 1 0 570 0 0 0 0 467
/**
 * This class manages the traversal through the scene graph to detect
 * collisions.  It holds ownership of a number of collider objects, each of
 * which is a CollisionNode and an associated CollisionHandler.
 *
 * When traverse() is called, it begins at the indicated root and detects all
 * collisions with any of its collider objects against nodes at or below the
 * indicated root, calling the appropriate CollisionHandler for each detected
 * collision.
 */

570 7 Namable 0 2049 7 Namable 7 Namable 0 0 0 0 0 0 0 0 0 0 0 0 125
/**
 * A base class for all things which can have a name.  The name is either
 * empty or nonempty, but it is never NULL.
 */

571 8 NodePath 0 2048 8 NodePath 8 NodePath 0 0 0 0 0 0 0 0 0 0 0 0 762
/**
 * NodePath is the fundamental system for disambiguating instances, and also
 * provides a higher-level interface for manipulating the scene graph.
 *
 * A NodePath is a list of connected nodes from the root of the graph to any
 * sub-node.  Each NodePath therefore uniquely describes one instance of a
 * node.
 *
 * NodePaths themselves are lightweight objects that may easily be copied and
 * passed by value.  Their data is stored as a series of NodePathComponents
 * that are stored on the nodes.  Holding a NodePath will keep a reference
 * count to all the nodes in the path.  However, if any node in the path is
 * removed or reparented (perhaps through a different NodePath), the NodePath
 * will automatically be updated to reflect the changes.
 */

572 19 CollisionRecorder * 0 8576 19 CollisionRecorder * 19 CollisionRecorder * 0 0 573 0 0 0 0 0 0 0 0 0 0

573 17 CollisionRecorder 0 75777 17 CollisionRecorder 17 CollisionRecorder 0 0 0 0 0 0 2 343 344 0 0 1 0 574 0 0 0 0 206
/**
 * This class is used to help debug the work the collisions system is doing.
 * It is a virtual base class that just provides an interface for recording
 * collisions tested and detected each frame.
 */

574 11 TypedObject 0 2049 11 TypedObject 11 TypedObject 0 0 0 0 0 0 0 0 0 0 0 0 2508
/**
 * This is an abstract class that all classes which use TypeHandle, and also
 * provide virtual functions to support polymorphism, should inherit from.
 * Each derived class should define get_type(), which should return the
 * specific type of the derived class.  Inheriting from this automatically
 * provides support for is_of_type() and is_exact_type().
 *
 * All classes that inherit directly or indirectly from TypedObject should
 * redefine get_type() and force_init_type(), as shown below.  Some classes
 * that do not inherit from TypedObject may still declare TypeHandles for
 * themselves by defining methods called get_class_type() and init_type().
 * Classes such as these may serve as base classes, but the dynamic type
 * identification system will be limited.  Classes that do not inherit from
 * TypedObject need not define the virtual functions get_type() and
 * force_init_type() (or any other virtual functions).
 *
 * There is a specific layout for defining the overrides from this class.
 * Keeping the definitions formatted just like these examples will allow
 * someone in the future to use a sed (or similar) script to make global
 * changes, if necessary.  Avoid rearranging the braces or the order of the
 * functions unless you're ready to change them in every file all at once.
 *
 * What follows are some examples that can be used in new classes that you
 * create.
 *
 * @par In the class definition (.h file):
 * @code
 * public:
 *   static TypeHandle get_class_type() {
 *     return _type_handle;
 *   }
 *   static void init_type() {
 *     <<<BaseClassOne>>>::init_type();
 *     <<<BaseClassTwo>>>::init_type();
 *     <<<BaseClassN>>>::init_type();
 *     register_type(_type_handle, "<<<ThisClassStringName>>>",
 *                   <<<BaseClassOne>>>::get_class_type(),
 *                   <<<BaseClassTwo>>>::get_class_type(),
 *                   <<<BaseClassN>>>::get_class_type());
 *   }
 *   virtual TypeHandle get_type() const {
 *     return get_class_type();
 *   }
 *   virtual TypeHandle force_init_type() {init_type(); return get_class_type();}
 *
 * private:
 *   static TypeHandle _type_handle;
 * @endcode
 *
 * @par In the class .cxx file:
 * @code
 * TypeHandle <<<ThisClassStringName>>>::_type_handle;
 * @endcode
 *
 * @par In the class config_<<<PackageName>>>.cxx file:
 * @code
 * ConfigureFn(config_<<<PackageName>>>) {
 *   <<<ClassOne>>>::init_type();
 *   <<<ClassTwo>>>::init_type();
 *   <<<ClassN>>>::init_type();
 * }
 * @endcode
 */

575 14 CollisionEntry 0 141313 14 CollisionEntry 14 CollisionEntry 0 0 0 0 382 8 730 731 732 733 734 735 736 737 32 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 0 0 1 0 576 0 0 0 0 437
/**
 * Defines a single collision event.  One of these is created for each
 * collision detected by a CollisionTraverser, to be dealt with by the
 * CollisionHandler.
 *
 * A CollisionEntry provides slots for a number of data values (such as
 * intersection point and normal) that might or might not be known for each
 * collision.  It is up to the handler to determine what information is known
 * and to do the right thing with it.
 */

576 27 TypedWritableReferenceCount 0 2049 27 TypedWritableReferenceCount 27 TypedWritableReferenceCount 0 0 0 0 0 0 0 0 0 0 0 0 414
/**
 * A base class for things which need to inherit from both TypedWritable and
 * from ReferenceCount.  It's convenient to define this intermediate base
 * class instead of multiply inheriting from the two classes each time they
 * are needed, so that we can sensibly pass around pointers to things which
 * are both TypedWritables and ReferenceCounters.
 *
 * See also TypedObject for detailed instructions.
 */

577 22 CollisionSolid const * 0 8576 22 CollisionSolid const * 22 CollisionSolid const * 0 0 578 0 0 0 0 0 0 0 0 0 0

578 20 CollisionSolid const 0 8832 20 CollisionSolid const 20 CollisionSolid const 0 0 550 0 0 0 0 0 0 0 0 0 0

579 15 CollisionNode * 0 8576 15 CollisionNode * 15 CollisionNode * 0 0 562 0 0 0 0 0 0 0 0 0 0

580 11 PandaNode * 0 8576 11 PandaNode * 11 PandaNode * 0 0 563 0 0 0 0 0 0 0 0 0 0

581 11 PN_stdfloat 0 2105344 11 PN_stdfloat 11 PN_stdfloat 0 0 582 0 0 0 0 0 0 0 0 0 0

582 5 float 0 8194 5 float 5 float 0 2 0 0 0 0 0 0 0 0 0 0 0

583 14 CollisionPlane 0 141313 14 CollisionPlane 14 CollisionPlane 0 0 0 1 383 390 2 738 739 6 384 385 386 387 388 389 0 0 1 0 550 0 0 0 0 10
/**
 *
 */

584 12 LPlane const 0 8832 12 LPlane const 12 LPlane const 0 0 585 0 0 0 0 0 0 0 0 0 0

585 6 LPlane 0 2105344 6 LPlane 6 LPlane 0 0 586 0 0 0 0 0 0 0 0 0 0

586 7 LPlanef 0 2048 7 LPlanef 7 LPlanef 0 0 0 0 0 0 0 0 0 0 0 0 120
/**
 * An abstract mathematical description of a plane.  A plane is defined by the
 * equation Ax + By + Cz + D = 0.
 */

587 18 CollisionFloorMesh 0 141313 18 CollisionFloorMesh 18 CollisionFloorMesh 0 0 0 1 391 401 2 740 741 7 392 393 394 395 396 397 400 2 779 780 0 1 0 550 0 0 0 0 124
/**
 * This object represents a solid made entirely of triangles, which will only
 * be tested again z axis aligned rays
 */

588 8 LPoint3i 0 2048 8 LPoint3i 8 LPoint3i 0 0 0 0 0 0 0 0 0 0 0 0 337
/**
 * This is a three-component point in space (as opposed to a three-component
 * vector, which represents a direction and a distance).  Some of the methods
 * are slightly different between LPoint3 and LVector3; in particular,
 * subtraction of two points yields a vector, while addition of a vector and a
 * point yields a point.
 */

589 16 CollisionPolygon 0 141313 16 CollisionPolygon 16 CollisionPolygon 0 0 0 1 402 410 3 742 743 744 6 403 404 405 406 407 409 1 781 0 1 0 583 0 0 0 0 10
/**
 *
 */

590 21 CollisionHandlerEvent 0 141313 21 CollisionHandlerEvent 21 CollisionHandlerEvent 0 0 0 1 411 433 3 745 746 747 18 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 430 431 432 3 782 783 784 0 1 0 560 0 0 0 0 296
/**
 * A specialized kind of CollisionHandler that throws an event for each
 * collision detected.  The event thrown may be based on the name of the
 * moving object or the struck object, or both.  The first parameter of the
 * event will be a pointer to the CollisionEntry that triggered it.
 */

591 6 string 0 2105344 11 std::string 11 std::string 0 0 592 0 0 0 0 0 0 0 0 0 0

592 20 basic_string< char > 0 2048 25 std::basic_string< char > 25 std::basic_string< char > 0 0 0 0 0 0 0 0 0 0 0 0 0

593 24 CollisionHandlerPhysical 0 75777 24 CollisionHandlerPhysical 24 CollisionHandlerPhysical 0 0 0 0 433 1 748 10 434 435 436 437 438 439 440 441 442 443 0 0 1 0 590 0 0 0 0 209
/**
 * The abstract base class for a number of CollisionHandlers that have some
 * physical effect on their moving bodies: they need to update the nodes'
 * positions based on the effects of the collision.
 */

594 14 NodePath const 0 8832 14 NodePath const 14 NodePath const 0 0 571 0 0 0 0 0 0 0 0 0 0

595 21 CollisionHandlerFloor 0 75777 21 CollisionHandlerFloor 21 CollisionHandlerFloor 0 0 0 1 444 433 3 749 750 751 7 445 446 447 448 449 450 451 0 0 1 0 593 0 0 0 0 294
/**
 * A specialized kind of CollisionHandler that sets the Z height of the
 * collider to a fixed linear offset from the highest detected collision point
 * each frame.  It's intended to implement walking around on a floor of
 * varying height by casting a ray down from the avatar's head.
 */

596 22 CollisionHandlerPusher 0 75777 22 CollisionHandlerPusher 22 CollisionHandlerPusher 0 0 0 1 452 433 1 752 3 453 454 455 0 0 1 0 593 0 0 0 0 197
/**
 * A specialized kind of CollisionHandler that simply pushes back on things
 * that attempt to move into solid walls.  This is the simplest kind of "real-
 * world" collisions you can have.
 */

597 27 CollisionHandlerFluidPusher 0 141313 27 CollisionHandlerFluidPusher 27 CollisionHandlerFluidPusher 0 0 0 1 456 458 0 1 457 0 0 1 0 596 0 0 0 0 139
/**
 * A CollisionHandlerPusher that makes use of timing and spatial information
 * from fluid collisions to improve collision response
 */

598 23 CollisionHandlerGravity 0 75777 23 CollisionHandlerGravity 23 CollisionHandlerGravity 0 0 0 1 459 433 9 753 754 755 756 757 758 759 760 761 18 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 0 0 1 0 593 0 0 0 0 294
/**
 * A specialized kind of CollisionHandler that sets the Z height of the
 * collider to a fixed linear offset from the highest detected collision point
 * each frame.  It's intended to implement walking around on a floor of
 * varying height by casting a ray down from the avatar's head.
 */

599 14 LVector3 const 0 8832 14 LVector3 const 14 LVector3 const 0 0 558 0 0 0 0 0 0 0 0 0 0

600 28 CollisionHandlerHighestEvent 0 141313 28 CollisionHandlerHighestEvent 28 CollisionHandlerHighestEvent 0 0 0 1 478 480 0 1 479 0 0 1 0 590 0 0 0 0 296
/**
 * A specialized kind of CollisionHandler that throws an event for each
 * collision detected.  The event thrown may be based on the name of the
 * moving object or the struck object, or both.  The first parameter of the
 * event will be a pointer to the CollisionEntry that triggered it.
 */

601 21 CollisionHandlerQueue 0 141313 21 CollisionHandlerQueue 21 CollisionHandlerQueue 0 0 0 1 481 490 1 762 7 482 483 484 485 487 488 489 1 785 0 1 0 560 0 0 0 0 313
/**
 * A special kind of CollisionHandler that does nothing except remember the
 * CollisionEntries detected the last pass.  This set of CollisionEntries may
 * then be queried by the calling function.  It's primarily useful when a
 * simple intersection test is being made, e.g.  for picking from the window.
 */

602 16 CollisionEntry * 0 8576 16 CollisionEntry * 16 CollisionEntry * 0 0 575 0 0 0 0 0 0 0 0 0 0

603 15 CollisionSphere 0 141313 15 CollisionSphere 15 CollisionSphere 0 0 0 1 491 497 2 763 764 5 492 493 494 495 496 0 0 1 0 550 0 0 0 0 50
/**
 * A spherical collision volume or object.
 */

604 18 CollisionInvSphere 0 141313 18 CollisionInvSphere 18 CollisionInvSphere 0 0 0 1 498 500 0 1 499 0 0 1 0 603 0 0 0 0 272
/**
 * An inverted sphere: this is a sphere whose collision surface is the inside
 * surface of the sphere.  Everything outside the sphere is solid matter;
 * everything inside is empty space.  Useful for constraining objects to
 * remain within a spherical perimeter.
 */

605 12 CollisionRay 0 141313 12 CollisionRay 12 CollisionRay 0 0 0 1 501 508 2 765 766 6 502 503 504 505 506 507 0 0 1 0 550 0 0 0 0 220
/**
 * An infinite ray, with a specific origin and direction.  It begins at its
 * origin and continues in one direction to infinity, and it has no radius.
 * Useful for picking from a window, or for gravity effects.
 */

606 13 CollisionLine 0 141313 13 CollisionLine 13 CollisionLine 0 0 0 1 509 511 0 1 510 0 0 1 0 605 0 0 0 0 131
/**
 * An infinite line, similar to a CollisionRay, except that it extends in both
 * directions.  It is, however, directional.
 */

607 17 CollisionParabola 0 141313 17 CollisionParabola 17 CollisionParabola 0 0 0 1 512 520 3 767 768 769 7 513 514 515 516 517 518 519 0 0 1 0 550 0 0 0 0 308
/**
 * This defines a parabolic arc, or subset of an arc, similar to the path of a
 * projectile or falling object.  It is finite, having a specific beginning
 * and end, but it is infinitely thin.
 *
 * Think of it as a wire bending from point t1 to point t2 along the path of a
 * pre-defined parabola.
 */

608 15 LParabola const 0 8832 15 LParabola const 15 LParabola const 0 0 609 0 0 0 0 0 0 0 0 0 0

609 9 LParabola 0 2105344 9 LParabola 9 LParabola 0 0 610 0 0 0 0 0 0 0 0 0 0

610 10 LParabolaf 0 2048 10 LParabolaf 10 LParabolaf 0 0 0 0 0 0 0 0 0 0 0 0 200
/**
 * An abstract mathematical description of a parabola, particularly useful for
 * describing arcs of projectiles.
 *
 * The parabolic equation, given parametrically here, is P = At^2 + Bt + C.
 */

611 16 CollisionSegment 0 141313 16 CollisionSegment 16 CollisionSegment 0 0 0 1 521 528 2 770 771 6 522 523 524 525 526 527 0 0 1 0 550 0 0 0 0 371
/**
 * A finite line segment, with two specific endpoints but no thickness.  It's
 * similar to a CollisionRay, except it does not continue to infinity.
 *
 * It does have an ordering, from point A to point B. If more than a single
 * point of the segment is intersecting a solid, the reported intersection
 * point is generally the closest on the segment to point A.
 */

612 13 CollisionTube 0 141313 13 CollisionTube 13 CollisionTube 0 0 0 1 529 537 3 772 773 774 7 530 531 532 533 534 535 536 0 0 1 0 550 0 0 0 0 232
/**
 * This implements a solid roughly in cylindrical shape.  It's not called a
 * CollisionCylinder because it's not a true cylinder; specifically, it has
 * rounded ends instead of flat ends.  It looks more like a Contac pill.
 */

613 19 CollisionVisualizer 0 26625 19 CollisionVisualizer 19 CollisionVisualizer 0 0 0 1 542 543 2 775 776 6 544 545 546 547 548 549 0 0 2 3 563 538 539 3 573 540 541 0 0 304
/**
 * This class is used to help debug the work the collisions system is doing.
 * It shows the polygons that are detected as collisions, as well as those
 * that are simply considered for collisions.
 *
 * It may be parented anywhere in the scene graph where it will be rendered to
 * achieve this.
 */

614 9 LPoint3 * 0 8576 9 LPoint3 * 9 LPoint3 * 0 0 552 0 0 0 0 0 0 0 0 0 0

615 16 CollisionSolid * 0 8576 16 CollisionSolid * 16 CollisionSolid * 0 0 550 0 0 0 0 0 0 0 0 0 0

616 4 void 0 8194 4 void 4 void 0 6 0 0 0 0 0 0 0 0 0 0 0

617 16 LVector3 const * 0 8576 16 LVector3 const * 16 LVector3 const * 0 0 599 0 0 0 0 0 0 0 0 0 0

618 20 BoundingVolume const 0 8832 20 BoundingVolume const 20 BoundingVolume const 0 0 619 0 0 0 0 0 0 0 0 0 0

619 14 BoundingVolume 0 2048 14 BoundingVolume 14 BoundingVolume 0 0 0 0 0 0 0 0 0 0 0 0 330
/**
 * This is an abstract class for any volume in any sense which can be said to
 * define the locality of reference of a node in a graph, along with all of
 * its descendants.  It is not necessarily a geometric volume (although see
 * GeometricBoundingVolume); this is simply an abstract interface for bounds
 * of any sort.
 */

620 22 BoundingVolume const * 0 8576 22 BoundingVolume const * 22 BoundingVolume const * 0 0 618 0 0 0 0 0 0 0 0 0 0

621 9 ostream * 0 8576 9 ostream * 9 ostream * 0 0 622 0 0 0 0 0 0 0 0 0 0

622 7 ostream 0 2048 7 ostream 7 ostream 0 0 0 0 0 0 0 0 0 0 0 0 0

623 10 TypeHandle 0 16779264 10 TypeHandle 10 TypeHandle 0 0 0 0 0 0 0 0 0 0 0 0 732
/**
 * TypeHandle is the identifier used to differentiate C++ class types.  Any
 * C++ classes that inherit from some base class, and must be differentiated
 * at run time, should store a static TypeHandle object that can be queried
 * through a static member function named get_class_type().  Most of the time,
 * it is also desirable to inherit from TypedObject, which provides some
 * virtual functions to return the TypeHandle for a particular instance.
 *
 * At its essence, a TypeHandle is simply a unique identifier that is assigned
 * by the TypeRegistry.  The TypeRegistry stores a tree of TypeHandles, so
 * that ancestry of a particular type may be queried, and the type name may be
 * retrieved for run-time display.
 */

624 12 TypeHandle * 0 8576 12 TypeHandle * 12 TypeHandle * 0 0 623 0 0 0 0 0 0 0 0 0 0

625 15 LPoint3 const * 0 8576 15 LPoint3 const * 15 LPoint3 const * 0 0 557 0 0 0 0 0 0 0 0 0 0

626 14 CollisionBox * 0 8576 14 CollisionBox * 14 CollisionBox * 0 0 556 0 0 0 0 0 0 0 0 0 0

627 20 CollisionBox const * 0 8576 20 CollisionBox const * 20 CollisionBox const * 0 0 628 0 0 0 0 0 0 0 0 0 0

628 18 CollisionBox const 0 8832 18 CollisionBox const 18 CollisionBox const 0 0 556 0 0 0 0 0 0 0 0 0 0

629 8 LPlane * 0 8576 8 LPlane * 8 LPlane * 0 0 585 0 0 0 0 0 0 0 0 0 0

630 10 LVector3 * 0 8576 10 LVector3 * 10 LVector3 * 0 0 558 0 0 0 0 0 0 0 0 0 0

631 24 CollisionHandler const * 0 8576 24 CollisionHandler const * 24 CollisionHandler const * 0 0 632 0 0 0 0 0 0 0 0 0 0

632 22 CollisionHandler const 0 8832 22 CollisionHandler const 22 CollisionHandler const 0 0 560 0 0 0 0 0 0 0 0 0 0

633 18 CollisionHandler * 0 8576 18 CollisionHandler * 18 CollisionHandler * 0 0 560 0 0 0 0 0 0 0 0 0 0

634 13 atomic string 0 2 13 atomic string 13 atomic string 0 7 0 0 0 0 0 0 0 0 0 0 0

635 13 CollideMask * 0 8576 13 CollideMask * 13 CollideMask * 0 0 564 0 0 0 0 0 0 0 0 0 0

636 21 CollisionNode const * 0 8576 21 CollisionNode const * 21 CollisionNode const * 0 0 637 0 0 0 0 0 0 0 0 0 0

637 19 CollisionNode const 0 8832 19 CollisionNode const 19 CollisionNode const 0 0 562 0 0 0 0 0 0 0 0 0 0

638 26 CollisionTraverser const * 0 8576 26 CollisionTraverser const * 26 CollisionTraverser const * 0 0 639 0 0 0 0 0 0 0 0 0 0

639 24 CollisionTraverser const 0 8832 24 CollisionTraverser const 24 CollisionTraverser const 0 0 569 0 0 0 0 0 0 0 0 0 0

640 20 CollisionTraverser * 0 8576 20 CollisionTraverser * 20 CollisionTraverser * 0 0 569 0 0 0 0 0 0 0 0 0 0

641 16 NodePath const * 0 8576 16 NodePath const * 16 NodePath const * 0 0 594 0 0 0 0 0 0 0 0 0 0

642 10 NodePath * 0 8576 10 NodePath * 10 NodePath * 0 0 571 0 0 0 0 0 0 0 0 0 0

643 21 CollisionVisualizer * 0 8576 21 CollisionVisualizer * 21 CollisionVisualizer * 0 0 613 0 0 0 0 0 0 0 0 0 0

644 25 CollisionRecorder const * 0 8576 25 CollisionRecorder const * 25 CollisionRecorder const * 0 0 645 0 0 0 0 0 0 0 0 0 0

645 23 CollisionRecorder const 0 8832 23 CollisionRecorder const 23 CollisionRecorder const 0 0 573 0 0 0 0 0 0 0 0 0 0

646 22 CollisionEntry const * 0 8576 22 CollisionEntry const * 22 CollisionEntry const * 0 0 647 0 0 0 0 0 0 0 0 0 0

647 20 CollisionEntry const 0 8832 20 CollisionEntry const 20 CollisionEntry const 0 0 575 0 0 0 0 0 0 0 0 0 0

648 22 CollisionPlane const * 0 8576 22 CollisionPlane const * 22 CollisionPlane const * 0 0 649 0 0 0 0 0 0 0 0 0 0

649 20 CollisionPlane const 0 8832 20 CollisionPlane const 20 CollisionPlane const 0 0 583 0 0 0 0 0 0 0 0 0 0

650 16 CollisionPlane * 0 8576 16 CollisionPlane * 16 CollisionPlane * 0 0 583 0 0 0 0 0 0 0 0 0 0

651 14 LPlane const * 0 8576 14 LPlane const * 14 LPlane const * 0 0 584 0 0 0 0 0 0 0 0 0 0

652 20 CollisionFloorMesh * 0 8576 20 CollisionFloorMesh * 20 CollisionFloorMesh * 0 0 587 0 0 0 0 0 0 0 0 0 0

653 12 unsigned int 0 8198 12 unsigned int 12 unsigned int 0 1 0 0 0 0 0 0 0 0 0 0 0

654 26 CollisionFloorMesh const * 0 8576 26 CollisionFloorMesh const * 26 CollisionFloorMesh const * 0 0 655 0 0 0 0 0 0 0 0 0 0

655 24 CollisionFloorMesh const 0 8832 24 CollisionFloorMesh const 24 CollisionFloorMesh const 0 0 587 0 0 0 0 0 0 0 0 0 0

656 10 LPoint3i * 0 8576 10 LPoint3i * 10 LPoint3i * 0 0 588 0 0 0 0 0 0 0 0 0 0

657 18 CollisionPolygon * 0 8576 18 CollisionPolygon * 18 CollisionPolygon * 0 0 589 0 0 0 0 0 0 0 0 0 0

658 17 LVecBase3 const * 0 8576 17 LVecBase3 const * 17 LVecBase3 const * 0 0 659 0 0 0 0 0 0 0 0 0 0

659 15 LVecBase3 const 0 8832 15 LVecBase3 const 15 LVecBase3 const 0 0 660 0 0 0 0 0 0 0 0 0 0

660 9 LVecBase3 0 2105344 9 LVecBase3 9 LVecBase3 0 0 661 0 0 0 0 0 0 0 0 0 0

661 10 LVecBase3f 0 2048 10 LVecBase3f 10 LVecBase3f 0 0 0 0 0 0 0 0 0 0 0 0 77
/**
 * This is the base class for all three-component vectors and points.
 */

662 24 CollisionPolygon const * 0 8576 24 CollisionPolygon const * 24 CollisionPolygon const * 0 0 663 0 0 0 0 0 0 0 0 0 0

663 22 CollisionPolygon const 0 8832 22 CollisionPolygon const 22 CollisionPolygon const 0 0 589 0 0 0 0 0 0 0 0 0 0

664 23 CollisionHandlerEvent * 0 8576 23 CollisionHandlerEvent * 23 CollisionHandlerEvent * 0 0 590 0 0 0 0 0 0 0 0 0 0

665 29 CollisionHandlerEvent const * 0 8576 29 CollisionHandlerEvent const * 29 CollisionHandlerEvent const * 0 0 666 0 0 0 0 0 0 0 0 0 0

666 27 CollisionHandlerEvent const 0 8832 27 CollisionHandlerEvent const 27 CollisionHandlerEvent const 0 0 590 0 0 0 0 0 0 0 0 0 0

667 26 CollisionHandlerPhysical * 0 8576 26 CollisionHandlerPhysical * 26 CollisionHandlerPhysical * 0 0 593 0 0 0 0 0 0 0 0 0 0

668 16 DriveInterface * 0 8576 16 DriveInterface * 16 DriveInterface * 0 0 669 0 0 0 0 0 0 0 0 0 0

669 14 DriveInterface 0 2048 14 DriveInterface 14 DriveInterface 0 0 0 0 0 0 0 0 0 0 0 0 191
/**
 * This is a TFormer, similar to Trackball, that moves around a transform
 * matrix in response to mouse input.  The basic motion is on a horizontal
 * plane, as if driving a vehicle.
 */

670 32 CollisionHandlerPhysical const * 0 8576 32 CollisionHandlerPhysical const * 32 CollisionHandlerPhysical const * 0 0 671 0 0 0 0 0 0 0 0 0 0

671 30 CollisionHandlerPhysical const 0 8832 30 CollisionHandlerPhysical const 30 CollisionHandlerPhysical const 0 0 593 0 0 0 0 0 0 0 0 0 0

672 23 CollisionHandlerFloor * 0 8576 23 CollisionHandlerFloor * 23 CollisionHandlerFloor * 0 0 595 0 0 0 0 0 0 0 0 0 0

673 29 CollisionHandlerFloor const * 0 8576 29 CollisionHandlerFloor const * 29 CollisionHandlerFloor const * 0 0 674 0 0 0 0 0 0 0 0 0 0

674 27 CollisionHandlerFloor const 0 8832 27 CollisionHandlerFloor const 27 CollisionHandlerFloor const 0 0 595 0 0 0 0 0 0 0 0 0 0

675 24 CollisionHandlerPusher * 0 8576 24 CollisionHandlerPusher * 24 CollisionHandlerPusher * 0 0 596 0 0 0 0 0 0 0 0 0 0

676 30 CollisionHandlerPusher const * 0 8576 30 CollisionHandlerPusher const * 30 CollisionHandlerPusher const * 0 0 677 0 0 0 0 0 0 0 0 0 0

677 28 CollisionHandlerPusher const 0 8832 28 CollisionHandlerPusher const 28 CollisionHandlerPusher const 0 0 596 0 0 0 0 0 0 0 0 0 0

678 29 CollisionHandlerFluidPusher * 0 8576 29 CollisionHandlerFluidPusher * 29 CollisionHandlerFluidPusher * 0 0 597 0 0 0 0 0 0 0 0 0 0

679 25 CollisionHandlerGravity * 0 8576 25 CollisionHandlerGravity * 25 CollisionHandlerGravity * 0 0 598 0 0 0 0 0 0 0 0 0 0

680 31 CollisionHandlerGravity const * 0 8576 31 CollisionHandlerGravity const * 31 CollisionHandlerGravity const * 0 0 681 0 0 0 0 0 0 0 0 0 0

681 29 CollisionHandlerGravity const 0 8832 29 CollisionHandlerGravity const 29 CollisionHandlerGravity const 0 0 598 0 0 0 0 0 0 0 0 0 0

682 30 CollisionHandlerHighestEvent * 0 8576 30 CollisionHandlerHighestEvent * 30 CollisionHandlerHighestEvent * 0 0 600 0 0 0 0 0 0 0 0 0 0

683 36 CollisionHandlerHighestEvent const * 0 8576 36 CollisionHandlerHighestEvent const * 36 CollisionHandlerHighestEvent const * 0 0 684 0 0 0 0 0 0 0 0 0 0

684 34 CollisionHandlerHighestEvent const 0 8832 34 CollisionHandlerHighestEvent const 34 CollisionHandlerHighestEvent const 0 0 600 0 0 0 0 0 0 0 0 0 0

685 23 CollisionHandlerQueue * 0 8576 23 CollisionHandlerQueue * 23 CollisionHandlerQueue * 0 0 601 0 0 0 0 0 0 0 0 0 0

686 29 CollisionHandlerQueue const * 0 8576 29 CollisionHandlerQueue const * 29 CollisionHandlerQueue const * 0 0 687 0 0 0 0 0 0 0 0 0 0

687 27 CollisionHandlerQueue const 0 8832 27 CollisionHandlerQueue const 27 CollisionHandlerQueue const 0 0 601 0 0 0 0 0 0 0 0 0 0

688 17 CollisionSphere * 0 8576 17 CollisionSphere * 17 CollisionSphere * 0 0 603 0 0 0 0 0 0 0 0 0 0

689 23 CollisionSphere const * 0 8576 23 CollisionSphere const * 23 CollisionSphere const * 0 0 690 0 0 0 0 0 0 0 0 0 0

690 21 CollisionSphere const 0 8832 21 CollisionSphere const 21 CollisionSphere const 0 0 603 0 0 0 0 0 0 0 0 0 0

691 20 CollisionInvSphere * 0 8576 20 CollisionInvSphere * 20 CollisionInvSphere * 0 0 604 0 0 0 0 0 0 0 0 0 0

692 14 CollisionRay * 0 8576 14 CollisionRay * 14 CollisionRay * 0 0 605 0 0 0 0 0 0 0 0 0 0

693 20 CollisionRay const * 0 8576 20 CollisionRay const * 20 CollisionRay const * 0 0 694 0 0 0 0 0 0 0 0 0 0

694 18 CollisionRay const 0 8832 18 CollisionRay const 18 CollisionRay const 0 0 605 0 0 0 0 0 0 0 0 0 0

695 10 LensNode * 0 8576 10 LensNode * 10 LensNode * 0 0 696 0 0 0 0 0 0 0 0 0 0

696 8 LensNode 0 2048 8 LensNode 8 LensNode 0 0 0 0 0 0 0 0 0 0 0 0 181
/**
 * A node that contains a Lens.  The most important example of this kind of
 * node is a Camera, but other kinds of nodes also contain a lens (for
 * instance, a Spotlight).
 */

697 15 LPoint2 const * 0 8576 15 LPoint2 const * 15 LPoint2 const * 0 0 698 0 0 0 0 0 0 0 0 0 0

698 13 LPoint2 const 0 8832 13 LPoint2 const 13 LPoint2 const 0 0 699 0 0 0 0 0 0 0 0 0 0

699 7 LPoint2 0 2105344 7 LPoint2 7 LPoint2 0 0 700 0 0 0 0 0 0 0 0 0 0

700 8 LPoint2f 0 2048 8 LPoint2f 8 LPoint2f 0 0 0 0 0 0 0 0 0 0 0 0 50
/**
 * This is a two-component point in space.
 */

701 15 CollisionLine * 0 8576 15 CollisionLine * 15 CollisionLine * 0 0 606 0 0 0 0 0 0 0 0 0 0

702 19 CollisionParabola * 0 8576 19 CollisionParabola * 19 CollisionParabola * 0 0 607 0 0 0 0 0 0 0 0 0 0

703 17 LParabola const * 0 8576 17 LParabola const * 17 LParabola const * 0 0 608 0 0 0 0 0 0 0 0 0 0

704 25 CollisionParabola const * 0 8576 25 CollisionParabola const * 25 CollisionParabola const * 0 0 705 0 0 0 0 0 0 0 0 0 0

705 23 CollisionParabola const 0 8832 23 CollisionParabola const 23 CollisionParabola const 0 0 607 0 0 0 0 0 0 0 0 0 0

706 18 CollisionSegment * 0 8576 18 CollisionSegment * 18 CollisionSegment * 0 0 611 0 0 0 0 0 0 0 0 0 0

707 24 CollisionSegment const * 0 8576 24 CollisionSegment const * 24 CollisionSegment const * 0 0 708 0 0 0 0 0 0 0 0 0 0

708 22 CollisionSegment const 0 8832 22 CollisionSegment const 22 CollisionSegment const 0 0 611 0 0 0 0 0 0 0 0 0 0

709 15 CollisionTube * 0 8576 15 CollisionTube * 15 CollisionTube * 0 0 612 0 0 0 0 0 0 0 0 0 0

710 21 CollisionTube const * 0 8576 21 CollisionTube const * 21 CollisionTube const * 0 0 711 0 0 0 0 0 0 0 0 0 0

711 19 CollisionTube const 0 8832 19 CollisionTube const 19 CollisionTube const 0 0 612 0 0 0 0 0 0 0 0 0 0

712 27 CollisionVisualizer const * 0 8576 27 CollisionVisualizer const * 27 CollisionVisualizer const * 0 0 713 0 0 0 0 0 0 0 0 0 0

713 25 CollisionVisualizer const 0 8832 25 CollisionVisualizer const 25 CollisionVisualizer const 0 0 613 0 0 0 0 0 0 0 0 0 0

0
63
714 16 collision_origin 0 2 0 277 0 0 0 0 0 32 CollisionSolid::collision_origin 0

715 8 tangible 0 6 0 279 278 0 0 0 0 24 CollisionSolid::tangible 0

716 24 respect_effective_normal 0 6 0 285 284 0 0 0 0 40 CollisionSolid::respect_effective_normal 0

717 6 bounds 0 6 0 286 287 0 0 0 0 22 CollisionSolid::bounds 0

718 6 center 0 2 0 299 0 0 0 0 0 20 CollisionBox::center 0

719 3 min 0 2 0 300 0 0 0 0 0 17 CollisionBox::min 0

720 3 max 0 2 0 301 0 0 0 0 0 17 CollisionBox::max 0

721 10 dimensions 0 2 0 302 0 0 0 0 0 24 CollisionBox::dimensions 0

722 17 from_collide_mask 0 6 0 312 310 0 0 0 0 32 CollisionNode::from_collide_mask 0

723 17 into_collide_mask 0 6 0 313 311 0 0 0 0 32 CollisionNode::into_collide_mask 0

724 6 solids 0 102 0 321 318 0 0 319 315 21 CollisionNode::solids 0

725 13 collider_sort 0 6 0 322 323 0 0 0 0 28 CollisionNode::collider_sort 0

726 20 default_collide_mask 0 2 0 324 0 0 0 0 0 35 CollisionNode::default_collide_mask 0

727 22 respect_preV_transform 0 6 0 329 328 0 0 0 0 42 CollisionTraverser::respect_preV_transform 0

728 9 colliders 0 66 0 337 0 0 0 0 333 29 CollisionTraverser::colliders 0

729 8 recorder 0 30 0 341 339 340 342 0 0 28 CollisionTraverser::recorder 0

730 10 from_solid 0 2 0 350 0 0 0 0 0 26 CollisionEntry::from_solid 0

731 10 into_solid 0 2 0 352 0 0 0 0 0 26 CollisionEntry::into_solid 0

732 9 from_node 0 2 0 353 0 0 0 0 0 25 CollisionEntry::from_node 0

733 9 into_node 0 2 0 354 0 0 0 0 0 25 CollisionEntry::into_node 0

734 14 from_node_path 0 2 0 355 0 0 0 0 0 30 CollisionEntry::from_node_path 0

735 14 into_node_path 0 2 0 356 0 0 0 0 0 30 CollisionEntry::into_node_path 0

736 1 t 0 6 0 358 357 0 0 0 0 17 CollisionEntry::t 0

737 22 respect_prev_transform 0 2 0 361 0 0 0 0 0 38 CollisionEntry::respect_prev_transform 0

738 6 normal 0 2 0 384 0 0 0 0 0 22 CollisionPlane::normal 0

739 5 plane 0 6 0 387 386 0 0 0 0 21 CollisionPlane::plane 0

740 8 vertices 0 66 0 398 0 0 0 0 394 28 CollisionFloorMesh::vertices 0

741 9 triangles 0 66 0 399 0 0 0 0 396 29 CollisionFloorMesh::triangles 0

742 6 points 0 66 0 408 0 0 0 0 403 24 CollisionPolygon::points 0

743 5 valid 0 2 0 406 0 0 0 0 0 23 CollisionPolygon::valid 0

744 7 concave 0 2 0 407 0 0 0 0 0 25 CollisionPolygon::concave 0

745 11 in_patterns 0 66 0 427 0 0 0 0 415 34 CollisionHandlerEvent::in_patterns 0

746 14 again_patterns 0 66 0 428 0 0 0 0 420 37 CollisionHandlerEvent::again_patterns 0

747 12 out_patterns 0 66 0 429 0 0 0 0 425 35 CollisionHandlerEvent::out_patterns 0

748 6 center 0 30 0 440 438 441 439 0 0 32 CollisionHandlerPhysical::center 0

749 6 offset 0 6 0 446 445 0 0 0 0 29 CollisionHandlerFloor::offset 0

750 5 reach 0 6 0 448 447 0 0 0 0 28 CollisionHandlerFloor::reach 0

751 12 max_velocity 0 6 0 450 449 0 0 0 0 35 CollisionHandlerFloor::max_velocity 0

752 10 horizontal 0 6 0 454 453 0 0 0 0 34 CollisionHandlerPusher::horizontal 0

753 6 offset 0 6 0 461 460 0 0 0 0 31 CollisionHandlerGravity::offset 0

754 5 reach 0 6 0 463 462 0 0 0 0 30 CollisionHandlerGravity::reach 0

755 15 airborne_height 0 2 0 464 0 0 0 0 0 40 CollisionHandlerGravity::airborne_height 0

756 9 on_ground 0 2 0 465 0 0 0 0 0 34 CollisionHandlerGravity::on_ground 0

757 15 impact_velocity 0 2 0 466 0 0 0 0 0 40 CollisionHandlerGravity::impact_velocity 0

758 14 contact_normal 0 2 0 467 0 0 0 0 0 39 CollisionHandlerGravity::contact_normal 0

759 8 velocity 0 6 0 470 469 0 0 0 0 33 CollisionHandlerGravity::velocity 0

760 7 gravity 0 6 0 472 471 0 0 0 0 32 CollisionHandlerGravity::gravity 0

761 12 max_velocity 0 6 0 474 473 0 0 0 0 37 CollisionHandlerGravity::max_velocity 0

762 7 entries 0 66 0 486 0 0 0 0 484 30 CollisionHandlerQueue::entries 0

763 6 center 0 6 0 493 492 0 0 0 0 23 CollisionSphere::center 0

764 6 radius 0 6 0 495 494 0 0 0 0 23 CollisionSphere::radius 0

765 6 origin 0 6 0 503 502 0 0 0 0 20 CollisionRay::origin 0

766 9 direction 0 6 0 505 504 0 0 0 0 23 CollisionRay::direction 0

767 8 parabola 0 6 0 514 513 0 0 0 0 27 CollisionParabola::parabola 0

768 2 t1 0 6 0 516 515 0 0 0 0 21 CollisionParabola::t1 0

769 2 t2 0 6 0 518 517 0 0 0 0 21 CollisionParabola::t2 0

770 7 point_a 0 6 0 523 522 0 0 0 0 25 CollisionSegment::point_a 0

771 7 point_b 0 6 0 525 524 0 0 0 0 25 CollisionSegment::point_b 0

772 7 point_a 0 6 0 531 530 0 0 0 0 22 CollisionTube::point_a 0

773 7 point_b 0 6 0 533 532 0 0 0 0 22 CollisionTube::point_b 0

774 6 radius 0 6 0 535 534 0 0 0 0 21 CollisionTube::radius 0

775 11 point_scale 0 6 0 545 544 0 0 0 0 32 CollisionVisualizer::point_scale 0

776 12 normal_scale 0 6 0 547 546 0 0 0 0 33 CollisionVisualizer::normal_scale 0

9
777 10 get_solids 0 315 316 25 CollisionNode::get_solids 0

778 13 get_colliders 0 333 334 33 CollisionTraverser::get_colliders 0

779 12 get_vertices 0 394 395 32 CollisionFloorMesh::get_vertices 0

780 13 get_triangles 0 396 397 33 CollisionFloorMesh::get_triangles 0

781 10 get_points 0 403 404 28 CollisionPolygon::get_points 0

782 15 get_in_patterns 0 415 416 38 CollisionHandlerEvent::get_in_patterns 0

783 18 get_again_patterns 0 420 421 41 CollisionHandlerEvent::get_again_patterns 0

784 16 get_out_patterns 0 425 426 39 CollisionHandlerEvent::get_out_patterns 0

785 11 get_entries 0 484 485 34 CollisionHandlerQueue::get_entries 0

