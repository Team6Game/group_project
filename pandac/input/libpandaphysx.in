1508348226
3 2
13 libpandaphysx 4 l5yH 13 panda3d.physx 
1493
1472 10 PhysxEnums 0 4 2965 22 PhysxEnums::PhysxEnums 0 2 1 2 0
107
inline PhysxEnums::PhysxEnums(void) = default;
inline PhysxEnums::PhysxEnums(PhysxEnums const &) = default;

1473 11 ~PhysxEnums 0 4 2965 23 PhysxEnums::~PhysxEnums 0 0 0
30
PhysxEnums::~PhysxEnums(void);

1474 14 set_python_tag 0 4 2996 27 PhysxObject::set_python_tag 0 1 3 10
/**
 *
 */
81
inline void PhysxObject::set_python_tag(std::string const &key, PyObject *value);

1475 14 get_python_tag 0 4 2996 27 PhysxObject::get_python_tag 0 1 4 10
/**
 *
 */
75
inline PyObject *PhysxObject::get_python_tag(std::string const &key) const;

1476 14 has_python_tag 0 4 2996 27 PhysxObject::has_python_tag 0 1 5 10
/**
 *
 */
70
inline bool PhysxObject::has_python_tag(std::string const &key) const;

1477 16 clear_python_tag 0 4 2996 29 PhysxObject::clear_python_tag 0 1 6 10
/**
 *
 */
66
inline void PhysxObject::clear_python_tag(std::string const &key);

1478 15 has_python_tags 0 4 2996 28 PhysxObject::has_python_tags 0 1 7 10
/**
 *
 */
53
inline bool PhysxObject::has_python_tags(void) const;

1479 2 ls 0 6 2996 15 PhysxObject::ls 0 2 8 9 0
121
virtual void PhysxObject::ls(void) const = 0;
virtual void PhysxObject::ls(ostream &out, int indent_level = 0) const = 0;

1480 14 get_class_type 0 4 2996 27 PhysxObject::get_class_type 0 1 10 0
52
static TypeHandle PhysxObject::get_class_type(void);

1481 21 upcast_to_PhysxObject 0 12 2998 33 PhysxActor::upcast_to_PhysxObject 0 1 105 37
upcast from PhysxActor to PhysxObject
53
PhysxObject *PhysxActor::upcast_to_PhysxObject(void);

1482 22 downcast_to_PhysxActor 0 12 2996 35 PhysxObject::downcast_to_PhysxActor 0 1 106 39
downcast from PhysxObject to PhysxActor
54
PhysxActor *PhysxObject::downcast_to_PhysxActor(void);

1483 20 upcast_to_PhysxEnums 0 12 2998 32 PhysxActor::upcast_to_PhysxEnums 0 1 107 36
upcast from PhysxActor to PhysxEnums
51
PhysxEnums *PhysxActor::upcast_to_PhysxEnums(void);

1484 22 downcast_to_PhysxActor 0 12 2965 34 PhysxEnums::downcast_to_PhysxActor 0 1 108 38
downcast from PhysxEnums to PhysxActor
53
PhysxActor *PhysxEnums::downcast_to_PhysxActor(void);

1485 10 PhysxActor 0 4 2998 22 PhysxActor::PhysxActor 0 1 11 10
/**
 *
 */
36
inline PhysxActor::PhysxActor(void);

1486 11 ~PhysxActor 0 6 2998 23 PhysxActor::~PhysxActor 0 0 10
/**
 *
 */
45
virtual inline PhysxActor::~PhysxActor(void);

1487 17 save_body_to_desc 0 4 2998 29 PhysxActor::save_body_to_desc 0 1 12 90
/**
 * Saves the body information of a dynamic actor to the passed body
 * descriptor.
 */
66
bool PhysxActor::save_body_to_desc(PhysxBodyDesc &bodyDesc) const;

1488 12 save_to_desc 0 4 2998 24 PhysxActor::save_to_desc 0 1 13 65
/**
 * Saves the state of the actor to the passed descriptor.
 */
63
void PhysxActor::save_to_desc(PhysxActorDesc &actorDesc) const;

1489 8 set_name 0 4 2998 20 PhysxActor::set_name 0 1 14 139
/**
 * Sets a name string for the object that can be retrieved with get_name().
 * This is for debugging and is not used by the engine.
 */
44
void PhysxActor::set_name(char const *name);

1490 14 set_global_pos 0 4 2998 26 PhysxActor::set_global_pos 0 1 15 118
/**
 * Method for setting a dynamic actor's position in the world.  Please see
 * set_global_mat for some caveats.
 */
53
void PhysxActor::set_global_pos(LPoint3f const &pos);

1491 14 set_global_mat 0 4 2998 26 PhysxActor::set_global_mat 0 1 16 1191
/**
 * Method for setting a dynamic actor's transform matrix in the world.
 *
 * This method instantaneously changes the actor space to world space
 * transformation.
 *
 * One should exercise restraint in making use of these methods.
 *
 * Static actors should not be moved at all.  There are various internal data
 * structures for static actors which may need to be recomputed when one
 * moves.  Also, moving static actors will not interact correctly with dynamic
 * actors or joints.  If you would like to directly control an actor's
 * position and would like to have it correctly interact with dynamic bodies
 * and joints, you should create a dynamic body with the BF_kinematic flag,
 * and then use the move_global_*() commands to move it along a path!
 *
 * When briefly moving dynamic actors, one should not: - Move actors into
 * other actors, thus causing interpenetration (an invalid physical state). -
 * Move an actor that is connected by a joint to another away from the other
 * (thus causing joint error). - When moving jointed actors the joints' cached
 * transform information is destroyed and recreated next frame; thus this call
 * is expensive for jointed actors.
 */
54
void PhysxActor::set_global_mat(LMatrix4f const &mat);

1492 14 set_global_hpr 0 4 2998 26 PhysxActor::set_global_hpr 0 1 17 121
/**
 * Method for setting a dynamic actor's orientation in the world.  Please see
 * set_global_mat for some caveats.
 */
59
void PhysxActor::set_global_hpr(float h, float p, float r);

1493 13 set_body_flag 0 4 2998 25 PhysxActor::set_body_flag 0 1 18 52
/**
 * Raise or lower individual BodyFlag flags.
 */
75
void PhysxActor::set_body_flag(PhysxEnums::PhysxBodyFlag flag, bool value);

1494 14 set_actor_flag 0 4 2998 26 PhysxActor::set_actor_flag 0 1 19 53
/**
 * Raise or lower individual ActorFlag flags.
 */
77
void PhysxActor::set_actor_flag(PhysxEnums::PhysxActorFlag flag, bool value);

1495 23 set_contact_report_flag 0 4 2998 35 PhysxActor::set_contact_report_flag 0 1 20 478
/**
 * Sets the actor's contact report flags.
 *
 * These flags are used to determine the kind of report that is generated for
 * interactions with other actors.
 *
 * Please note: If the actor is part of an interacting pair for which the
 * contact report generation is controlled already through any other mechanism
 * (for example by use of PhysxScene::set_actor_pair_flags) then the union of
 * all the specified contact report flags will be used to generate the report.
 */
92
void PhysxActor::set_contact_report_flag(PhysxEnums::PhysxContactPairFlag flag, bool value);

1496 28 set_contact_report_threshold 0 4 2998 40 PhysxActor::set_contact_report_threshold 0 1 21 84
/**
 * Sets the force threshold for contact reports.  The actor must be dynamic.
 */
63
void PhysxActor::set_contact_report_threshold(float threshold);

1497 9 set_group 0 4 2998 21 PhysxActor::set_group 0 1 22 406
/**
 * Assigns the actor to a user defined group of actors.  The actor group must
 * be an integer in between 0 and 0x7fff (32767).
 *
 * This is similar to NxShape groups, except those are only five bits and
 * serve a different purpose.
 *
 * The PhysxScene::set_actor_group_pair_flags() lets you set certain behaviors
 * for pairs of actor groups.
 *
 * By default every actor is created in group 0.
 */
47
void PhysxActor::set_group(unsigned int group);

1498 19 set_dominance_group 0 4 2998 31 PhysxActor::set_dominance_group 0 1 23 455
/**
 * Assigns dynamic actors a dominance group identifier.  Dominance groups are
 * integere in the range from 0 to 31.
 *
 * This is similar to shape groups, except those serve a different purpose.
 *
 * The PhysxScene::set_dominance_group_pair() lets you set certain behaviors
 * for pairs of dominance groups.
 *
 * By default every actor is created in group 0. Static actors must stay in
 * group 0; thus you can only call this on dynamic actors.
 */
57
void PhysxActor::set_dominance_group(unsigned int group);

1499 15 set_shape_group 0 4 2998 27 PhysxActor::set_shape_group 0 1 24 96
/**
 * Sets the collision group for all shapes of this actor.  See
 * PhysxShape.setGroup().
 */
53
void PhysxActor::set_shape_group(unsigned int group);

1500 8 get_name 0 4 2998 20 PhysxActor::get_name 0 1 25 37
/**
 * Retrieves the name string.
 */
45
char const *PhysxActor::get_name(void) const;

1501 14 get_global_pos 0 4 2998 26 PhysxActor::get_global_pos 0 1 26 53
/**
 * Retrieves the actors world space position.
 */
48
LPoint3f PhysxActor::get_global_pos(void) const;

1502 14 get_global_mat 0 4 2998 26 PhysxActor::get_global_mat 0 1 27 54
/**
 * Retrieves the actors world space transform.
 */
49
LMatrix4f PhysxActor::get_global_mat(void) const;

1503 15 get_global_quat 0 4 2998 27 PhysxActor::get_global_quat 0 1 28 56
/**
 * Retrieves the actors world space orientation.
 */
53
LQuaternionf PhysxActor::get_global_quat(void) const;

1504 13 get_body_flag 0 4 2998 25 PhysxActor::get_body_flag 0 1 29 46
/**
 * Return the specified BodyFlag flag.
 */
69
bool PhysxActor::get_body_flag(PhysxEnums::PhysxBodyFlag flag) const;

1505 14 get_actor_flag 0 4 2998 26 PhysxActor::get_actor_flag 0 1 30 47
/**
 * Return the specified ActorFlag flag.
 */
71
bool PhysxActor::get_actor_flag(PhysxEnums::PhysxActorFlag flag) const;

1506 9 get_group 0 4 2998 21 PhysxActor::get_group 0 1 31 63
/**
 * Retrieves the actor group this actor is assigned to.
 */
47
unsigned int PhysxActor::get_group(void) const;

1507 19 get_dominance_group 0 4 2998 31 PhysxActor::get_dominance_group 0 1 32 55
/**
 * Retrieves the dominance group of this actor.
 */
57
unsigned int PhysxActor::get_dominance_group(void) const;

1508 10 is_dynamic 0 4 2998 22 PhysxActor::is_dynamic 0 1 33 48
/**
 * Returns true if the actor is dynamic.
 */
40
bool PhysxActor::is_dynamic(void) const;

1509 22 compute_kinetic_energy 0 4 2998 34 PhysxActor::compute_kinetic_energy 0 1 34 121
/**
 * Computes the total kinetic (rotational and translational) energy of the
 * object.  The actor must be dynamic.
 */
53
float PhysxActor::compute_kinetic_energy(void) const;

1510 23 update_mass_from_shapes 0 4 2998 35 PhysxActor::update_mass_from_shapes 0 1 35 1143
/**
 * Recomputes a dynamic actor's mass properties from its shapes.
 *
 * Given a constant density or total mass, the actors mass properties can be
 * recomputed using the shapes attached to the actor.  If the actor has no
 * shapes, then only the totalMass parameter can be used.  If all shapes in
 * the actor are trigger shapes (non-physical), the call will fail.
 *
 * The mass of each shape is either the shape's local density (as specified in
 * the PhysxShapeDesc; default 1.0) multiplied by the shape's volume or a
 * directly specified shape mass.
 *
 * The inertia tensor, mass frame and center of mass will always be
 * recomputed.  If there are no shapes in the actor, the mass will be
 * totalMass, and the mass frame will be set to the center of the actor.
 *
 * If you supply a non-zero total mass, the actor's mass and inertia will
 * first be computed as above and then scaled to fit this total mass.
 *
 * If you supply a non-zero density, the actor's mass and inertia will first
 * be computed as above and then scaled by this factor.
 *
 * Either totalMass or density must be non-zero.
 *
 * The actor must be dynamic.
 */
73
bool PhysxActor::update_mass_from_shapes(float density, float totalMass);

1511 9 get_scene 0 4 2998 21 PhysxActor::get_scene 0 1 36 59
/**
 * Retrieves the scene which this actor belongs to.
 */
46
PhysxScene *PhysxActor::get_scene(void) const;

1512 16 attach_node_path 0 4 2998 28 PhysxActor::attach_node_path 0 1 37 300
// NodePath

/**
 * Attaches a node path to this actor.  The node path's transform will be
 * updated automatically if the actor's transform changes (and only then).
 *
 * Note: any non-uniform scale or shear set on the NodePath's transform will
 * be overwritten at the time of the first update.
 */
54
void PhysxActor::attach_node_path(NodePath const &np);

1513 16 detach_node_path 0 4 2998 28 PhysxActor::detach_node_path 0 1 38 150
/**
 * Detaches a previously assigned NodePath from this actor.  The NodePath's
 * transform will no longer be updated from the actor's transform.
 */
40
void PhysxActor::detach_node_path(void);

1514 13 get_node_path 0 4 2998 25 PhysxActor::get_node_path 0 1 39 139
/**
 * Retrieves a previously attached NodePath.  An empty NodePath will be
 * returned if no NodePath has been attached to this actor.
 */
47
NodePath PhysxActor::get_node_path(void) const;

1515 14 get_num_shapes 0 4 2998 26 PhysxActor::get_num_shapes 0 1 40 84
// Shapes

// Shapes

/**
 * Returns the number of shapes assigned to the actor.
 */
52
unsigned int PhysxActor::get_num_shapes(void) const;

1516 12 create_shape 0 4 2998 24 PhysxActor::create_shape 0 1 41 292
/**
 * Creates a new shape and adds it to the list of shapes of this actor.
 *
 * Mass properties of dynamic actors will not automatically be recomputed to
 * reflect the new mass distribution implied by the shape.  Follow this call
 * with a call to update_mass_from_shapes() to do that.
 */
59
PhysxShape *PhysxActor::create_shape(PhysxShapeDesc &desc);

1517 9 get_shape 0 4 2998 21 PhysxActor::get_shape 0 1 42 146
/**
 * Retrieves an individual shape from the actor's array of shapes.  Index must
 * be in the range from zero to (number-of-shapes minus 1).
 */
58
PhysxShape *PhysxActor::get_shape(unsigned int idx) const;

1518 17 get_shape_by_name 0 4 2998 29 PhysxActor::get_shape_by_name 0 1 43 205
/**
 * Retrieves an individual shape from the actor's array of shapes.  The first
 * shape for which the shape's name matches the specified name is returned, or
 * NULL if no shape has a matching name.
 */
66
PhysxShape *PhysxActor::get_shape_by_name(char const *name) const;

1519 9 add_force 0 4 2998 21 PhysxActor::add_force 0 1 44 340
// Forces

/**
 * Applies a force (or impulse) defined in the global coordinate frame to the
 * actor.
 *
 * This will not induce a torque.
 *
 * Mode determines if the torque is to be conventional or impulsive.
 *
 * The actor must be dynamic.  This call wakes the actor if it is sleeping and
 * the wakeup parameter is true (default).
 */
128
void PhysxActor::add_force(LVector3f const force, PhysxEnums::PhysxForceMode mode = ::PhysxEnums::FM_force, bool wakeup = true);

1520 16 add_force_at_pos 0 4 2998 28 PhysxActor::add_force_at_pos 0 1 45 623
/**
 * Applies a force (or impulse) defined in the global coordinate frame, acting
 * at a particular point in global coordinates, to the actor.
 *
 * Note that if the force does not act along the center of mass of the actor,
 * this will also add the corresponding torque.  Because forces are reset at
 * the end of every timestep, you can maintain a total external force on an
 * object by calling this once every frame.
 *
 * Mode determines if the torque is to be conventional or impulsive.
 *
 * The actor must be dynamic.  This call wakes the actor if it is sleeping and
 * the wakeup parameter is true (default).
 */
156
void PhysxActor::add_force_at_pos(LVector3f const force, LPoint3f const &pos, PhysxEnums::PhysxForceMode mode = ::PhysxEnums::FM_force, bool wakeup = true);

1521 22 add_force_at_local_pos 0 4 2998 34 PhysxActor::add_force_at_local_pos 0 1 46 622
/**
 * Applies a force (or impulse) defined in the global coordinate frame, acting
 * at a particular point in local coordinates, to the actor.
 *
 * Note that if the force does not act along the center of mass of the actor,
 * this will also add the corresponding torque.  Because forces are reset at
 * the end of every timestep, you can maintain a total external force on an
 * object by calling this once every frame.
 *
 * Mode determines if the torque is to be conventional or impulsive.
 *
 * The actor must be dynamic.  This call wakes the actor if it is sleeping and
 * the wakeup parameter is true (default).
 */
162
void PhysxActor::add_force_at_local_pos(LVector3f const force, LPoint3f const &pos, PhysxEnums::PhysxForceMode mode = ::PhysxEnums::FM_force, bool wakeup = true);

1522 10 add_torque 0 4 2998 22 PhysxActor::add_torque 0 1 47 291
/**
 * Applies an impulsive torque defined in the global coordinate frame to the
 * actor.
 *
 * Mode determines if the torque is to be conventional or impulsive.
 *
 * The actor must be dynamic.  This call wakes the actor if it is sleeping and
 * the wakeup parameter is true (default).
 */
130
void PhysxActor::add_torque(LVector3f const torque, PhysxEnums::PhysxForceMode mode = ::PhysxEnums::FM_force, bool wakeup = true);

1523 15 add_local_force 0 4 2998 27 PhysxActor::add_local_force 0 1 48 329
/**
 * Applies a force (or impulse) defined in the actor local coordinate frame to
 * the actor.  This will not induce a torque.
 *
 * Mode determines if the torque is to be conventional or impulsive.
 *
 * The actor must be dynamic.  This call wakes the actor if it is sleeping and
 * the wakeup parameter is true (default).
 */
134
void PhysxActor::add_local_force(LVector3f const force, PhysxEnums::PhysxForceMode mode = ::PhysxEnums::FM_force, bool wakeup = true);

1524 22 add_local_force_at_pos 0 4 2998 34 PhysxActor::add_local_force_at_pos 0 1 49 628
/**
 * Applies a force (or impulse) defined in the actor local coordinate frame,
 * acting at a particular point in global coordinates, to the actor.
 *
 * Note that if the force does not act along the center of mass of the actor,
 * this will also add the corresponding torque.  Because forces are reset at
 * the end of every timestep, you can maintain a total external force on an
 * object by calling this once every frame.
 *
 * Mode determines if the torque is to be conventional or impulsive.
 *
 * The actor must be dynamic.  This call wakes the actor if it is sleeping and
 * the wakeup parameter is true (default).
 */
162
void PhysxActor::add_local_force_at_pos(LVector3f const force, LPoint3f const &pos, PhysxEnums::PhysxForceMode mode = ::PhysxEnums::FM_force, bool wakeup = true);

1525 28 add_local_force_at_local_pos 0 4 2998 40 PhysxActor::add_local_force_at_local_pos 0 1 50 627
/**
 * Applies a force (or impulse) defined in the actor local coordinate frame,
 * acting at a particular point in local coordinates, to the actor.
 *
 * Note that if the force does not act along the center of mass of the actor,
 * this will also add the corresponding torque.  Because forces are reset at
 * the end of every timestep, you can maintain a total external force on an
 * object by calling this once every frame.
 *
 * Mode determines if the torque is to be conventional or impulsive.
 *
 * The actor must be dynamic.  This call wakes the actor if it is sleeping and
 * the wakeup parameter is true (default).
 */
168
void PhysxActor::add_local_force_at_local_pos(LVector3f const force, LPoint3f const &pos, PhysxEnums::PhysxForceMode mode = ::PhysxEnums::FM_force, bool wakeup = true);

1526 16 add_local_torque 0 4 2998 28 PhysxActor::add_local_torque 0 1 51 296
/**
 * Applies an impulsive torque defined in the actor local coordinate frame to
 * the actor.
 *
 * Mode determines if the torque is to be conventional or impulsive.
 *
 * The actor must be dynamic.  This call wakes the actor if it is sleeping and
 * the wakeup parameter is true (default).
 */
136
void PhysxActor::add_local_torque(LVector3f const torque, PhysxEnums::PhysxForceMode mode = ::PhysxEnums::FM_force, bool wakeup = true);

1527 8 set_mass 0 4 2998 20 PhysxActor::set_mass 0 1 52 66
// Mass manipulation

/**
 * Sets the mass of a dynamic actor.
 */
38
void PhysxActor::set_mass(float mass);

1528 27 set_c_mass_offset_local_mat 0 4 2998 39 PhysxActor::set_c_mass_offset_local_mat 0 1 53 71
/**
 * Sets the matrix of the center of mass relative to the actor.
 */
67
void PhysxActor::set_c_mass_offset_local_mat(LMatrix4f const &mat);

1529 27 set_c_mass_offset_local_pos 0 4 2998 39 PhysxActor::set_c_mass_offset_local_pos 0 1 54 73
/**
 * Sets the position of the center of mass relative to the actor.
 */
66
void PhysxActor::set_c_mass_offset_local_pos(LPoint3f const &pos);

1530 35 set_c_mass_offset_local_orientation 0 4 2998 47 PhysxActor::set_c_mass_offset_local_orientation 0 1 55 76
/**
 * Sets the orientation of the center of mass relative to the actor.
 */
75
void PhysxActor::set_c_mass_offset_local_orientation(LMatrix3f const &mat);

1531 28 set_c_mass_offset_global_mat 0 4 2998 40 PhysxActor::set_c_mass_offset_global_mat 0 1 56 73
/**
 * Sets the matrix of the center of mass relative to world space.
 */
68
void PhysxActor::set_c_mass_offset_global_mat(LMatrix4f const &mat);

1532 28 set_c_mass_offset_global_pos 0 4 2998 40 PhysxActor::set_c_mass_offset_global_pos 0 1 57 75
/**
 * Sets the position of the center of mass relative to world space.
 */
67
void PhysxActor::set_c_mass_offset_global_pos(LPoint3f const &pos);

1533 36 set_c_mass_offset_global_orientation 0 4 2998 48 PhysxActor::set_c_mass_offset_global_orientation 0 1 58 78
/**
 * Sets the orientation of the center of mass relative to world space.
 */
76
void PhysxActor::set_c_mass_offset_global_orientation(LMatrix3f const &mat);

1534 21 set_c_mass_global_mat 0 4 2998 33 PhysxActor::set_c_mass_global_mat 0 1 59 74
/**
 * Moves the actor by setting the transform of the center of mass.
 */
61
void PhysxActor::set_c_mass_global_mat(LMatrix4f const &mat);

1535 21 set_c_mass_global_pos 0 4 2998 33 PhysxActor::set_c_mass_global_pos 0 1 60 73
/**
 * Moves the actor by setting the position of the center of mass.
 */
60
void PhysxActor::set_c_mass_global_pos(LPoint3f const &pos);

1536 29 set_c_mass_global_orientation 0 4 2998 41 PhysxActor::set_c_mass_global_orientation 0 1 61 76
/**
 * Moves the actor by setting the orientation of the center of mass.
 */
69
void PhysxActor::set_c_mass_global_orientation(LMatrix3f const &mat);

1537 29 set_mass_space_inertia_tensor 0 4 2998 41 PhysxActor::set_mass_space_inertia_tensor 0 1 62 93
/**
 * Sets the inertia tensor, using a parameter specified in mass space
 * coordinates.
 */
67
void PhysxActor::set_mass_space_inertia_tensor(LVector3f const &m);

1538 8 get_mass 0 4 2998 20 PhysxActor::get_mass 0 1 63 41
/**
 * Returns the mass of the actor.
 */
39
float PhysxActor::get_mass(void) const;

1539 21 get_c_mass_global_mat 0 4 2998 33 PhysxActor::get_c_mass_global_mat 0 1 64 63
/**
 * Returns the center of mass transform in world space.
 */
56
LMatrix4f PhysxActor::get_c_mass_global_mat(void) const;

1540 21 get_c_mass_global_pos 0 4 2998 33 PhysxActor::get_c_mass_global_pos 0 1 65 62
/**
 * Returns the center of mass position in world space.
 */
55
LPoint3f PhysxActor::get_c_mass_global_pos(void) const;

1541 29 get_c_mass_global_orientation 0 4 2998 41 PhysxActor::get_c_mass_global_orientation 0 1 66 65
/**
 * Returns the center of mass orientation in world space.
 */
64
LMatrix3f PhysxActor::get_c_mass_global_orientation(void) const;

1542 20 get_c_mass_local_mat 0 4 2998 32 PhysxActor::get_c_mass_local_mat 0 1 67 70
/**
 * Returns the center of mass transform relative to the actor.
 */
55
LMatrix4f PhysxActor::get_c_mass_local_mat(void) const;

1543 20 get_c_mass_local_pos 0 4 2998 32 PhysxActor::get_c_mass_local_pos 0 1 68 69
/**
 * Returns the center of mass position relative to the actor.
 */
54
LPoint3f PhysxActor::get_c_mass_local_pos(void) const;

1544 28 get_c_mass_local_orientation 0 4 2998 40 PhysxActor::get_c_mass_local_orientation 0 1 69 72
/**
 * Returns the center of mass orientation relative to the actor.
 */
63
LMatrix3f PhysxActor::get_c_mass_local_orientation(void) const;

1545 29 get_mass_space_inertia_tensor 0 4 2998 41 PhysxActor::get_mass_space_inertia_tensor 0 1 70 101
/**
 * Returns the diagonal inertia tensor of the actor relative to the mass
 * coordinate frame.
 */
64
LVector3f PhysxActor::get_mass_space_inertia_tensor(void) const;

1546 25 get_global_inertia_tensor 0 4 2998 37 PhysxActor::get_global_inertia_tensor 0 1 71 93
/**
 * Returns the inertia tensor of the actor relative to the world coordinate
 * frame.
 */
60
LMatrix3f PhysxActor::get_global_inertia_tensor(void) const;

1547 33 get_global_inertia_tensor_inverse 0 4 2998 45 PhysxActor::get_global_inertia_tensor_inverse 0 1 72 108
/**
 * Returns the inverse of the inertia tensor of the actor relative to the
 * world coordinate frame.
 */
68
LMatrix3f PhysxActor::get_global_inertia_tensor_inverse(void) const;

1548 18 set_linear_damping 0 4 2998 30 PhysxActor::set_linear_damping 0 1 73 179
// Damping

/**
 * Sets the linear damping coefficient.  Zero represents no damping.  The
 * damping coefficient must be nonnegative.  The actor must be dynamic.
 * Default: 0
 */
51
void PhysxActor::set_linear_damping(float linDamp);

1549 19 set_angular_damping 0 4 2998 31 PhysxActor::set_angular_damping 0 1 74 180
/**
 * Sets the angular damping coefficient.  Zero represents no damping.  The
 * angular damping coefficient must be nonnegative.  The actor must be
 * dynamic.  Default: 0.05
 */
52
void PhysxActor::set_angular_damping(float angDamp);

1550 18 get_linear_damping 0 4 2998 30 PhysxActor::get_linear_damping 0 1 75 80
/**
 * Retrieves the linear damping coefficient.  The actor must be dynamic.
 */
49
float PhysxActor::get_linear_damping(void) const;

1551 19 get_angular_damping 0 4 2998 31 PhysxActor::get_angular_damping 0 1 76 79
/**
 * Returns the angular damping coefficient.  The actor must be dynamic.
 */
50
float PhysxActor::get_angular_damping(void) const;

1552 19 set_linear_velocity 0 4 2998 31 PhysxActor::set_linear_velocity 0 1 77 326
// Velocity

/**
 * Sets the linear velocity of the actor.
 *
 * Note that if you continuously set the velocity of an actor yourself, forces
 * such as gravity or friction will not be able to manifest themselves,
 * because forces directly influence only the velocity/momentum of an actor.
 *
 * The actor must be dynamic.
 */
62
void PhysxActor::set_linear_velocity(LVector3f const &linVel);

1553 20 set_angular_velocity 0 4 2998 32 PhysxActor::set_angular_velocity 0 1 78 296
/**
 * Sets the angular velocity of the actor.
 *
 * Note that if you continuously set the angular velocity of an actor
 * yourself, forces such as friction will not be able to rotate the actor,
 * because forces directly influence only the velocity/momentum.
 *
 * The actor must be dynamic.
 */
63
void PhysxActor::set_angular_velocity(LVector3f const &angVel);

1554 24 set_max_angular_velocity 0 4 2998 36 PhysxActor::set_max_angular_velocity 0 1 79 863
/**
 * Lets you set the maximum angular velocity permitted for this actor.
 *
 * Because for various internal computations, very quickly rotating actors
 * introduce error into the simulation, which leads to undesired results.
 *
 * With PhysxManager::set_parameter(PP_max_angular_velocity) you can set the
 * default maximum velocity for actors created after the call.  Bodies' high
 * angular velocities are clamped to this value.
 *
 * However, because some actors, such as car wheels, should be able to rotate
 * quickly, you can override the default setting on a per-actor basis with the
 * below call.  Note that objects such as wheels which are approximated with
 * spherical or other smooth collision primitives can be simulated with
 * stability at a much higher angular velocity than, say, a box that has
 * corners.
 *
 * The actor must be dynamic.
 */
59
void PhysxActor::set_max_angular_velocity(float maxAngVel);

1555 19 get_linear_velocity 0 4 2998 31 PhysxActor::get_linear_velocity 0 1 80 79
/**
 * Returns the linear velocity of an actor.  The actor must be dynamic.
 */
54
LVector3f PhysxActor::get_linear_velocity(void) const;

1556 20 get_angular_velocity 0 4 2998 32 PhysxActor::get_angular_velocity 0 1 81 81
/**
 * Returns the angular velocity of the actor.  The actor must be dynamic.
 */
55
LVector3f PhysxActor::get_angular_velocity(void) const;

1557 24 get_max_angular_velocity 0 4 2998 36 PhysxActor::get_max_angular_velocity 0 1 82 73
/**
 * Returns the maximum angular velocity permitted for this actor.
 */
55
float PhysxActor::get_max_angular_velocity(void) const;

1558 18 get_point_velocity 0 4 2998 30 PhysxActor::get_point_velocity 0 1 83 178
// Point Velocity

/**
 * Computes the velocity of a point given in world coordinates if it were
 * attached to the actor and moving with it.
 *
 * The actor must be dynamic.
 */
70
LVector3f PhysxActor::get_point_velocity(LPoint3f const &point) const;

1559 24 get_local_point_velocity 0 4 2998 36 PhysxActor::get_local_point_velocity 0 1 84 167
/**
 * Computes the velocity of a point given in body local coordinates as if it
 * were attached to the actor and moving with it.
 *
 * The actor must be dynamic.
 */
76
LVector3f PhysxActor::get_local_point_velocity(LPoint3f const &point) const;

1560 19 set_linear_momentum 0 4 2998 31 PhysxActor::set_linear_momentum 0 1 85 328
// Momentum

/**
 * Sets the linear momentum of the actor.  Note that if you continuously set
 * the linear momentum of an actor yourself, forces such as gravity or
 * friction will not be able to manifest themselves, because forces directly
 * influence only the velocity/momentum of a actor.  The actor must be
 * dynamic.
 */
64
void PhysxActor::set_linear_momentum(LVector3f const &momentum);

1561 20 set_angular_momentum 0 4 2998 32 PhysxActor::set_angular_momentum 0 1 86 289
/**
 * Sets the angular momentum of the actor.  Note that if you continuously set
 * the angular velocity of an actor yourself, forces such as friction will not
 * be able to rotate the actor, because forces directly influence only the
 * velocity of actor.  The actor must be dynamic.
 */
65
void PhysxActor::set_angular_momentum(LVector3f const &momentum);

1562 19 get_linear_momentum 0 4 2998 31 PhysxActor::get_linear_momentum 0 1 87 139
/**
 * Retrieves the linear momentum of an actor.  The momentum is equal to the
 * velocity times the mass.  The actor must be dynamic.
 */
54
LVector3f PhysxActor::get_linear_momentum(void) const;

1563 20 get_angular_momentum 0 4 2998 32 PhysxActor::get_angular_momentum 0 1 88 182
/**
 * Retrieves the angular momentum of an actor.  The angular momentum is equal
 * to the angular velocity times the global space inertia tensor.  The actor
 * must be dynamic.
 */
55
LVector3f PhysxActor::get_angular_momentum(void) const;

1564 25 set_sleep_linear_velocity 0 4 2998 37 PhysxActor::set_sleep_linear_velocity 0 1 89 312
// Sleeping

/**
 * Sets the linear velocity below which an actor may go to sleep.  Actors
 * whose linear velocity is above this threshold will not be put to sleep.
 *
 * Setting the sleep angular/linear velocity only makes sense when the
 * BF_energy_sleep_test is not set.
 *
 * The actor must be dynamic.
 */
60
void PhysxActor::set_sleep_linear_velocity(float threshold);

1565 26 set_sleep_angular_velocity 0 4 2998 38 PhysxActor::set_sleep_angular_velocity 0 1 90 301
/**
 * Sets the angular velocity below which an actor may go to sleep.  Actors
 * whose angular velocity is above this threshold will not be put to sleep.
 *
 * Setting the sleep angular/linear velocity only makes sense when the
 * BF_energy_sleep_test is not set.
 *
 * The actor must be dynamic.
 */
61
void PhysxActor::set_sleep_angular_velocity(float threshold);

1566 26 set_sleep_energy_threshold 0 4 2998 38 PhysxActor::set_sleep_energy_threshold 0 1 91 409
/**
 * Sets the energy threshold below which an actor may go to sleep.  Actors
 * whose kinematic energy is above this threshold will not be put to sleep.
 *
 * Setting the sleep energy threshold only makes sense when the
 * BF_energy_sleep_test is set.  There are also other types of sleeping that
 * uses the linear and angular velocities directly instead of the energy.
 *
 * The actor must be dynamic.
 */
61
void PhysxActor::set_sleep_energy_threshold(float threshold);

1567 25 get_sleep_linear_velocity 0 4 2998 37 PhysxActor::get_sleep_linear_velocity 0 1 92 189
/**
 * Returns the linear velocity below which an actor may go to sleep.  Actors
 * whose linear velocity is above this threshold will not be put to sleep.
 * The actor must be dynamic.
 */
56
float PhysxActor::get_sleep_linear_velocity(void) const;

1568 26 get_sleep_angular_velocity 0 4 2998 38 PhysxActor::get_sleep_angular_velocity 0 1 93 191
/**
 * Returns the angular velocity below which an actor may go to sleep.  Actors
 * whose angular velocity is above this threshold will not be put to sleep.
 * The actor must be dynamic.
 */
57
float PhysxActor::get_sleep_angular_velocity(void) const;

1569 26 get_sleep_energy_threshold 0 4 2998 38 PhysxActor::get_sleep_energy_threshold 0 1 94 172
/**
 * Returns the energy below which an actor may go to sleep.  Actors whose
 * energy is above this threshold will not be put to sleep.  The actor must be
 * dynamic.
 */
57
float PhysxActor::get_sleep_energy_threshold(void) const;

1570 11 is_sleeping 0 4 2998 23 PhysxActor::is_sleeping 0 1 95 440
/**
 * Returns true if this body is sleeping.
 *
 * When an actor does not move for a period of time, it is no longer simulated
 * in order to save time.  This state is called sleeping.  However, because
 * the object automatically wakes up when it is either touched by an awake
 * object, or one of its properties is changed by the user, the entire sleep
 * mechanism should be transparent to the user.
 *
 * The actor must be dynamic.
 */
41
bool PhysxActor::is_sleeping(void) const;

1571 7 wake_up 0 4 2998 19 PhysxActor::wake_up 0 1 96 272
/**
 * Wakes up the actor if it is sleeping.
 *
 * The wakeCounterValue determines how long until the body is put to sleep, a
 * value of zero means that the body is sleeping.  wake_up(0) is equivalent to
 * PhysxActor::put_to_sleep().
 *
 * The actor must be dynamic.
 */
81
void PhysxActor::wake_up(float wakeCounterValue = (20.0 * 0.020000000000000005));

1572 12 put_to_sleep 0 4 2998 24 PhysxActor::put_to_sleep 0 1 97 299
/**
 * Forces the actor to sleep.
 *
 * The actor will stay asleep until the next call to simulate, and will not
 * wake up until then even when otherwise it would (for example a force is
 * applied to it). It can however wake up during the next do_physics call.
 *
 * The actor must be dynamic.
 */
36
void PhysxActor::put_to_sleep(void);

1573 15 move_global_pos 0 4 2998 27 PhysxActor::move_global_pos 0 1 98 230
// Kinematic

/**
 * The move_global_* calls serve to move kinematically controlled dynamic
 * actors through the game world.
 *
 * See move_global_mat() for more information.
 *
 * This call wakes the actor if it is sleeping.
 */
54
void PhysxActor::move_global_pos(LPoint3f const &pos);

1574 15 move_global_mat 0 4 2998 27 PhysxActor::move_global_mat 0 1 99 881
/**
 * The move_global_* calls serve to move kinematically controlled dynamic
 * actors through the game world.
 *
 * You set a dynamic actor to be kinematic using the BF_KINEMATIC body flag,
 * used either in the PhysBodyDesc or with set_body_flag().
 *
 * The move command will result in a velocity that, when successfully carried
 * out (i.e.  the motion is not blocked due to joints or collisions) inside
 * run*(), will move the body into the desired pose.  After the move is
 * carried out during a single time step, the velocity is returned to zero.
 * Thus, you must continuously call this in every time step for kinematic
 * actors so that they move along a path.
 *
 * These functions simply store the move destination until run*() is called,
 * so consecutive calls will simply overwrite the stored target variable.
 *
 * This call wakes the actor if it is sleeping.
 */
55
void PhysxActor::move_global_mat(LMatrix4f const &mat);

1575 15 move_global_hpr 0 4 2998 27 PhysxActor::move_global_hpr 0 1 100 216
/**
 * The move_global_* calls serve to move kinematically controlled dynamic
 * actors through the game world.
 *
 * See move_global_mat() for more information.
 *
 * This call wakes the actor if it is sleeping.
 */
60
void PhysxActor::move_global_hpr(float h, float p, float r);

1576 2 ls 0 6 2998 14 PhysxActor::ls 0 2 101 102 22
/**
 *
 */

/**
 *
 */
125
virtual inline void PhysxActor::ls(void) const;
virtual inline void PhysxActor::ls(ostream &out, int indent_level = 0) const;

1577 7 release 0 4 2998 19 PhysxActor::release 0 1 103 10
/**
 *
 */
31
void PhysxActor::release(void);

1578 14 get_class_type 0 4 2998 26 PhysxActor::get_class_type 0 1 104 0
51
static TypeHandle PhysxActor::get_class_type(void);

1579 21 upcast_to_PhysxObject 0 12 2999 38 PhysxController::upcast_to_PhysxObject 0 1 129 42
upcast from PhysxController to PhysxObject
58
PhysxObject *PhysxController::upcast_to_PhysxObject(void);

1580 27 downcast_to_PhysxController 0 12 2996 40 PhysxObject::downcast_to_PhysxController 0 1 130 44
downcast from PhysxObject to PhysxController
64
PhysxController *PhysxObject::downcast_to_PhysxController(void);

1581 20 upcast_to_PhysxEnums 0 12 2999 37 PhysxController::upcast_to_PhysxEnums 0 1 131 41
upcast from PhysxController to PhysxEnums
56
PhysxEnums *PhysxController::upcast_to_PhysxEnums(void);

1582 27 downcast_to_PhysxController 0 12 2965 39 PhysxEnums::downcast_to_PhysxController 0 1 132 43
downcast from PhysxEnums to PhysxController
63
PhysxController *PhysxEnums::downcast_to_PhysxController(void);

1583 7 release 0 4 2999 24 PhysxController::release 0 1 109 10
/**
 *
 */
36
void PhysxController::release(void);

1584 9 get_actor 0 4 2999 26 PhysxController::get_actor 0 1 110 72
/**
 * Retrieves the actor which this controller is associated with.
 */
51
PhysxActor *PhysxController::get_actor(void) const;

1585 7 set_pos 0 4 2999 24 PhysxController::set_pos 0 1 111 140
/**
 * Sets the position of the controller is global space.  This can be used for
 * initial placement or for teleporting the character.
 */
51
void PhysxController::set_pos(LPoint3f const &pos);

1586 13 set_sharpness 0 4 2999 30 PhysxController::set_sharpness 0 1 112 279
/**
 * Sharpness is used to smooth motion with a feedback filter, having a value
 * between 0 (so smooth it doesn't move) and 1 (no smoothing = unfiltered
 * motion). Sharpness can ease the motion curve when the auto-step feature is
 * used with boxes.  Default value is 1.0.
 */
53
void PhysxController::set_sharpness(float sharpness);

1587 13 set_collision 0 4 2999 30 PhysxController::set_collision 0 1 113 67
/**
 * Enable/Disable collisions for this controller and actor.
 */
49
void PhysxController::set_collision(bool enable);

1588 16 set_min_distance 0 4 2999 33 PhysxController::set_min_distance 0 1 114 288
/**
 * Sets the the minimum travelled distance to consider when moving the
 * controller.  If travelled distance is smaller, the character doesn't move.
 * This is used to stop the recursive motion algorithm when remaining distance
 * to travel is small.  The default value is 0.0001.
 */
55
void PhysxController::set_min_distance(float min_dist);

1589 15 set_step_offset 0 4 2999 32 PhysxController::set_step_offset 0 1 115 58
/**
 * Sets the step height/offset for the controller.
 */
52
void PhysxController::set_step_offset(float offset);

1590 7 get_pos 0 4 2999 24 PhysxController::get_pos 0 1 116 66
/**
 * Retruns the position of the controller is global space.
 */
46
LPoint3f PhysxController::get_pos(void) const;

1591 13 get_sharpness 0 4 2999 30 PhysxController::get_sharpness 0 1 117 124
/**
 * Returns the sharpness used to ease the motion curve when the auto-step
 * feature is used.  Default value is 1.0.
 */
49
float PhysxController::get_sharpness(void) const;

1592 16 set_global_speed 0 4 2999 33 PhysxController::set_global_speed 0 1 118 67
/**
 * Sets the linear speed of the controller in global space.
 */
63
void PhysxController::set_global_speed(LVector3f const &speed);

1593 15 set_local_speed 0 4 2999 32 PhysxController::set_local_speed 0 1 119 72
/**
 * Sets the linear speed of the controller in local coordinates.
 */
62
void PhysxController::set_local_speed(LVector3f const &speed);

1594 9 set_omega 0 4 2999 26 PhysxController::set_omega 0 1 120 169
/**
 * Sets the angular velocity (degrees per second) of the controller.  The
 * angular velocity is used to compute the new heading when updating the
 * controller.
 */
45
void PhysxController::set_omega(float omega);

1595 5 set_h 0 4 2999 22 PhysxController::set_h 0 1 121 191
/**
 * Sets the heading of the controller is global space.  Note: only heading is
 * supported.  Pitch and roll are constrained by PhysX in order to alyways
 * keep the character upright.
 */
43
void PhysxController::set_h(float heading);

1596 5 get_h 0 4 2999 22 PhysxController::get_h 0 1 122 65
/**
 * Returns the heading of the controller in global space.
 */
41
float PhysxController::get_h(void) const;

1597 20 report_scene_changed 0 4 2999 37 PhysxController::report_scene_changed 0 1 123 233
/**
 * The character controller uses caching in order to speed up collision
 * testing, this caching can not detect when static objects have changed in
 * the scene.  You need to call this method when such changes have been made.
 */
49
void PhysxController::report_scene_changed(void);

1598 10 start_jump 0 4 2999 27 PhysxController::start_jump 0 1 124 98
/**
 * Enters the jump mode.  The parameter is the intial upward velocity of the
 * character.
 */
43
void PhysxController::start_jump(float v0);

1599 9 stop_jump 0 4 2999 26 PhysxController::stop_jump 0 1 125 149
/**
 * Leaves the jump mode.  This method is automatically called if a ground
 * collision is detected.  Usually users need not call this method.
 */
38
void PhysxController::stop_jump(void);

1600 2 ls 0 6 2999 19 PhysxController::ls 0 2 126 127 22
/**
 *
 */

/**
 *
 */
135
virtual inline void PhysxController::ls(void) const;
virtual inline void PhysxController::ls(ostream &out, int indent_level = 0) const;

1601 14 get_class_type 0 4 2999 31 PhysxController::get_class_type 0 1 128 0
56
static TypeHandle PhysxController::get_class_type(void);

1602 16 ~PhysxController 0 4 2999 33 PhysxController::~PhysxController 0 0 0
40
PhysxController::~PhysxController(void);

1603 18 PhysxBoxController 0 4 3000 38 PhysxBoxController::PhysxBoxController 0 1 133 10
/**
 *
 */
52
inline PhysxBoxController::PhysxBoxController(void);

1604 11 set_extents 0 4 3000 31 PhysxBoxController::set_extents 0 1 134 37
/**
 * Sets controller's extents.
 */
63
void PhysxBoxController::set_extents(LVector3f const &extents);

1605 11 get_extents 0 4 3000 31 PhysxBoxController::get_extents 0 1 135 40
/**
 * Returns controller's extents.
 */
54
LVector3f PhysxBoxController::get_extents(void) const;

1606 14 get_class_type 0 4 3000 34 PhysxBoxController::get_class_type 0 1 136 0
59
static TypeHandle PhysxBoxController::get_class_type(void);

1607 21 upcast_to_PhysxObject 0 12 3001 43 PhysxForceFieldShape::upcast_to_PhysxObject 0 1 149 47
upcast from PhysxForceFieldShape to PhysxObject
63
PhysxObject *PhysxForceFieldShape::upcast_to_PhysxObject(void);

1608 32 downcast_to_PhysxForceFieldShape 0 12 2996 45 PhysxObject::downcast_to_PhysxForceFieldShape 0 1 150 49
downcast from PhysxObject to PhysxForceFieldShape
74
PhysxForceFieldShape *PhysxObject::downcast_to_PhysxForceFieldShape(void);

1609 20 upcast_to_PhysxEnums 0 12 3001 42 PhysxForceFieldShape::upcast_to_PhysxEnums 0 1 151 46
upcast from PhysxForceFieldShape to PhysxEnums
61
PhysxEnums *PhysxForceFieldShape::upcast_to_PhysxEnums(void);

1610 32 downcast_to_PhysxForceFieldShape 0 12 2965 44 PhysxEnums::downcast_to_PhysxForceFieldShape 0 1 152 48
downcast from PhysxEnums to PhysxForceFieldShape
73
PhysxForceFieldShape *PhysxEnums::downcast_to_PhysxForceFieldShape(void);

1611 7 release 0 4 3001 29 PhysxForceFieldShape::release 0 1 137 10
/**
 *
 */
41
void PhysxForceFieldShape::release(void);

1612 15 get_force_field 0 4 3001 37 PhysxForceFieldShape::get_force_field 0 1 138 112
/**
 * Returns the owning force field if this is a shape of an include group, else
 * NULL will be returned.
 */
67
PhysxForceField *PhysxForceFieldShape::get_force_field(void) const;

1613 15 get_shape_group 0 4 3001 37 PhysxForceFieldShape::get_shape_group 0 1 139 54
/**
 * Returns the owning force field shape group.
 */
77
PhysxForceFieldShapeGroup *PhysxForceFieldShape::get_shape_group(void) const;

1614 8 set_name 0 4 3001 30 PhysxForceFieldShape::set_name 0 1 140 99
/**
 * Sets a name string for this object.  The name can be retrieved again with
 * get_name().
 */
54
void PhysxForceFieldShape::set_name(char const *name);

1615 7 set_mat 0 4 3001 29 PhysxForceFieldShape::set_mat 0 1 141 50
/**
 * Sets the force field shape's transform.
 */
57
void PhysxForceFieldShape::set_mat(LMatrix4f const &mat);

1616 7 set_pos 0 4 3001 29 PhysxForceFieldShape::set_pos 0 1 142 52
/**
 * Sets the force field shape's translation.
 */
56
void PhysxForceFieldShape::set_pos(LPoint3f const &pos);

1617 8 get_name 0 4 3001 30 PhysxForceFieldShape::get_name 0 1 143 35
/**
 * Returns the name string.
 */
55
char const *PhysxForceFieldShape::get_name(void) const;

1618 7 get_mat 0 4 3001 29 PhysxForceFieldShape::get_mat 0 1 144 53
/**
 * Returns the force field shape's transform.
 */
52
LMatrix4f PhysxForceFieldShape::get_mat(void) const;

1619 7 get_pos 0 4 3001 29 PhysxForceFieldShape::get_pos 0 1 145 55
/**
 * Returns the force field shape's translation.
 */
51
LPoint3f PhysxForceFieldShape::get_pos(void) const;

1620 2 ls 0 6 3001 24 PhysxForceFieldShape::ls 0 2 146 147 22
/**
 *
 */

/**
 *
 */
145
virtual inline void PhysxForceFieldShape::ls(void) const;
virtual inline void PhysxForceFieldShape::ls(ostream &out, int indent_level = 0) const;

1621 14 get_class_type 0 4 3001 36 PhysxForceFieldShape::get_class_type 0 1 148 0
61
static TypeHandle PhysxForceFieldShape::get_class_type(void);

1622 21 ~PhysxForceFieldShape 0 4 3001 43 PhysxForceFieldShape::~PhysxForceFieldShape 0 0 0
50
PhysxForceFieldShape::~PhysxForceFieldShape(void);

1623 23 PhysxBoxForceFieldShape 0 4 3002 48 PhysxBoxForceFieldShape::PhysxBoxForceFieldShape 0 1 153 10
/**
 *
 */
62
inline PhysxBoxForceFieldShape::PhysxBoxForceFieldShape(void);

1624 12 save_to_desc 0 4 3002 37 PhysxBoxForceFieldShape::save_to_desc 0 1 154 63
/**
 * Saves the state of the shape object to a descriptor.
 */
89
void PhysxBoxForceFieldShape::save_to_desc(PhysxBoxForceFieldShapeDesc &shapeDesc) const;

1625 14 set_dimensions 0 4 3002 39 PhysxBoxForceFieldShape::set_dimensions 0 1 155 179
/**
 * Sets the box dimensions.
 *
 * The dimensions are the 'radii' of the box, meaning 1/2 extents in x
 * dimension, 1/2 extents in y dimension, 1/2 extents in z dimension.
 */
74
void PhysxBoxForceFieldShape::set_dimensions(LVector3f const &dimensions);

1626 14 get_dimensions 0 4 3002 39 PhysxBoxForceFieldShape::get_dimensions 0 1 156 191
/**
 * Retrieves the dimensions of the box.
 *
 * The dimensions are the 'radii' of the box, meaning 1/2 extents in x
 * dimension, 1/2 extents in y dimension, 1/2 extents in z dimension.
 */
62
LVector3f PhysxBoxForceFieldShape::get_dimensions(void) const;

1627 14 get_class_type 0 4 3002 39 PhysxBoxForceFieldShape::get_class_type 0 1 157 0
64
static TypeHandle PhysxBoxForceFieldShape::get_class_type(void);

1628 21 upcast_to_PhysxObject 0 12 3003 33 PhysxShape::upcast_to_PhysxObject 0 1 188 37
upcast from PhysxShape to PhysxObject
53
PhysxObject *PhysxShape::upcast_to_PhysxObject(void);

1629 22 downcast_to_PhysxShape 0 12 2996 35 PhysxObject::downcast_to_PhysxShape 0 1 189 39
downcast from PhysxObject to PhysxShape
54
PhysxShape *PhysxObject::downcast_to_PhysxShape(void);

1630 20 upcast_to_PhysxEnums 0 12 3003 32 PhysxShape::upcast_to_PhysxEnums 0 1 190 36
upcast from PhysxShape to PhysxEnums
51
PhysxEnums *PhysxShape::upcast_to_PhysxEnums(void);

1631 22 downcast_to_PhysxShape 0 12 2965 34 PhysxEnums::downcast_to_PhysxShape 0 1 191 38
downcast from PhysxEnums to PhysxShape
53
PhysxShape *PhysxEnums::downcast_to_PhysxShape(void);

1632 7 release 0 4 3003 19 PhysxShape::release 0 1 158 10
/**
 *
 */
31
void PhysxShape::release(void);

1633 9 get_actor 0 4 3003 21 PhysxShape::get_actor 0 1 159 67
/**
 * Retrieves the actor which this shape is associated with.
 */
46
PhysxActor *PhysxShape::get_actor(void) const;

1634 8 set_name 0 4 3003 20 PhysxShape::set_name 0 1 160 160
/**
 * Sets a name string for this object.  The name can be retrieved again with
 * get_name(). This is for debugging and is not used by the physics engine.
 */
44
void PhysxShape::set_name(char const *name);

1635 8 set_flag 0 4 3003 20 PhysxShape::set_flag 0 1 161 449
/**
 * Sets the specified shape flag.
 *
 * The shape may be turned into a trigger by setting one or more of the
 * TriggerFlags to true.  A trigger shape will not collide with other shapes.
 * Instead, if a shape enters the trigger's volume, a trigger event will be
 * sent.  Trigger events can be listened to by DirectObjects.
 *
 * The following trigger events can be sent: - physx-trigger-enter - physx-
 * trigger-stay - physx-trigger-leave
 */
77
void PhysxShape::set_flag(PhysxEnums::PhysxShapeFlag const flag, bool value);

1636 14 set_skin_width 0 4 3003 26 PhysxShape::set_skin_width 0 1 162 69
/**
 * Sets the skin width.  The skin width must be non-negative.
 */
49
void PhysxShape::set_skin_width(float skinWidth);

1637 9 set_group 0 4 3003 21 PhysxShape::set_group 0 1 163 285
/**
 * Sets which collision group this shape is part of.
 *
 * Default group is 0. Maximum possible group is 31. Collision groups are sets
 * of shapes which may or may not be set to collision detect with each other;
 * this can be set using PhysxScene::set_group_collision_flag().
 */
53
void PhysxShape::set_group(unsigned short int group);

1638 13 set_local_pos 0 4 3003 25 PhysxShape::set_local_pos 0 1 164 358
/**
 * Set the position of the shape in actor space, i.e.  relative to the actor
 * it is owned by.
 *
 * Calling this method does NOT wake the associated actor up automatically.
 *
 * Calling this method does not automatically update the inertia properties of
 * the owning actor (if applicable); use PhysxActor::update_mass_from_shapes()
 * to do this.
 */
52
void PhysxShape::set_local_pos(LPoint3f const &pos);

1639 13 set_local_mat 0 4 3003 25 PhysxShape::set_local_mat 0 1 165 359
/**
 * Set the transform of the shape in actor space, i.e.  relative to the actor
 * it is owned by.
 *
 * Calling this method does NOT wake the associated actor up automatically.
 *
 * Calling this method does not automatically update the inertia properties of
 * the owning actor (if applicable); use PhysxActor::update_mass_from_shapes()
 * to do this.
 */
53
void PhysxShape::set_local_mat(LMatrix4f const &mat);

1640 12 set_material 0 4 3003 24 PhysxShape::set_material 0 1 166 43
/**
 * Assigns a material to the shape.
 */
61
void PhysxShape::set_material(PhysxMaterial const &material);

1641 18 set_material_index 0 4 3003 30 PhysxShape::set_material_index 0 1 167 288
/**
 * Assigns a material index to the shape.
 *
 * The material index can be retrieved by calling
 * PhysxMaterial::get_material_index(). If the material index is invalid, it
 * will still be recorded, but the default material (at index 0) will
 * effectively be used for simulation.
 */
60
void PhysxShape::set_material_index(unsigned short int idx);

1642 15 set_groups_mask 0 4 3003 27 PhysxShape::set_groups_mask 0 1 168 115
/**
 * Sets 128-bit mask used for collision filtering.  Does NOT wake the
 * associated actor up automatically.
 */
62
void PhysxShape::set_groups_mask(PhysxGroupsMask const &mask);

1643 16 set_ccd_skeleton 0 4 3003 28 PhysxShape::set_ccd_skeleton 0 1 169 10
/**
 *
 */
58
void PhysxShape::set_ccd_skeleton(PhysxCcdSkeleton *skel);

1644 8 get_name 0 4 3003 20 PhysxShape::get_name 0 1 170 35
/**
 * Returns the name string.
 */
45
char const *PhysxShape::get_name(void) const;

1645 8 get_flag 0 4 3003 20 PhysxShape::get_flag 0 1 171 44
/**
 * Returns the specified shape flag.
 */
71
bool PhysxShape::get_flag(PhysxEnums::PhysxShapeFlag const flag) const;

1646 14 get_skin_width 0 4 3003 26 PhysxShape::get_skin_width 0 1 172 34
/**
 * Returns the skin width.
 */
45
float PhysxShape::get_skin_width(void) const;

1647 9 get_group 0 4 3003 21 PhysxShape::get_group 0 1 173 116
/**
 * Retrieves the collision group set for this shape.  The collision group is
 * an integer between 0 and 31.
 */
53
unsigned short int PhysxShape::get_group(void) const;

1648 13 get_local_pos 0 4 3003 25 PhysxShape::get_local_pos 0 1 174 108
/**
 * Retrieve the position of the shape in actor space, i.e.  relative to the
 * actor it is owned by.
 */
47
LPoint3f PhysxShape::get_local_pos(void) const;

1649 13 get_local_mat 0 4 3003 25 PhysxShape::get_local_mat 0 1 175 109
/**
 * Retrieve the transform of the shape in actor space, i.e.  relative to the
 * actor it is owned by.
 */
48
LMatrix4f PhysxShape::get_local_mat(void) const;

1650 18 get_material_index 0 4 3003 30 PhysxShape::get_material_index 0 1 176 70
/**
 * Returns the material index currently assigned to the shape.
 */
62
unsigned short int PhysxShape::get_material_index(void) const;

1651 15 get_groups_mask 0 4 3003 27 PhysxShape::get_groups_mask 0 1 177 58
/**
 * Gets 128-bit mask used for collision filtering.
 */
56
PhysxGroupsMask PhysxShape::get_groups_mask(void) const;

1652 16 get_world_bounds 0 4 3003 28 PhysxShape::get_world_bounds 0 1 178 59
/**
 * Returns a world space AABB enclosing this shape.
 */
54
PhysxBounds3 PhysxShape::get_world_bounds(void) const;

1653 16 get_ccd_skeleton 0 4 3003 28 PhysxShape::get_ccd_skeleton 0 1 179 10
/**
 *
 */
59
PhysxCcdSkeleton *PhysxShape::get_ccd_skeleton(void) const;

1654 18 check_overlap_aabb 0 4 3003 30 PhysxShape::check_overlap_aabb 0 1 180 71
/**
 * Checks whether the shape overlaps a world-space AABB or not.
 */
76
bool PhysxShape::check_overlap_aabb(PhysxBounds3 const &world_bounds) const;

1655 21 check_overlap_capsule 0 4 3003 33 PhysxShape::check_overlap_capsule 0 1 181 74
/**
 * Checks whether the shape overlaps a world-space capsule or not.
 */
80
bool PhysxShape::check_overlap_capsule(PhysxCapsule const &world_capsule) const;

1656 17 check_overlap_obb 0 4 3003 29 PhysxShape::check_overlap_obb 0 1 182 70
/**
 * Checks whether the shape overlaps a world-space OBB or not.
 */
68
bool PhysxShape::check_overlap_obb(PhysxBox const &world_box) const;

1657 20 check_overlap_sphere 0 4 3003 32 PhysxShape::check_overlap_sphere 0 1 183 73
/**
 * Checks whether the shape overlaps a world-space sphere or not.
 */
77
bool PhysxShape::check_overlap_sphere(PhysxSphere const &world_sphere) const;

1658 7 raycast 0 4 3003 19 PhysxShape::raycast 0 1 184 10
/**
 *
 */
102
PhysxRaycastHit PhysxShape::raycast(PhysxRay const &worldRay, bool firstHit, bool smoothNormal) const;

1659 2 ls 0 6 3003 14 PhysxShape::ls 0 2 185 186 22
/**
 *
 */

/**
 *
 */
125
virtual inline void PhysxShape::ls(void) const;
virtual inline void PhysxShape::ls(ostream &out, int indent_level = 0) const;

1660 14 get_class_type 0 4 3003 26 PhysxShape::get_class_type 0 1 187 0
51
static TypeHandle PhysxShape::get_class_type(void);

1661 11 ~PhysxShape 0 4 3003 23 PhysxShape::~PhysxShape 0 0 0
30
PhysxShape::~PhysxShape(void);

1662 13 PhysxBoxShape 0 4 3004 28 PhysxBoxShape::PhysxBoxShape 0 1 192 10
/**
 *
 */
42
inline PhysxBoxShape::PhysxBoxShape(void);

1663 12 save_to_desc 0 4 3004 27 PhysxBoxShape::save_to_desc 0 1 193 63
/**
 * Saves the state of the shape object to a descriptor.
 */
69
void PhysxBoxShape::save_to_desc(PhysxBoxShapeDesc &shapeDesc) const;

1664 14 set_dimensions 0 4 3004 29 PhysxBoxShape::set_dimensions 0 1 194 179
/**
 * Sets the box dimensions.
 *
 * The dimensions are the 'radii' of the box, meaning 1/2 extents in x
 * dimension, 1/2 extents in y dimension, 1/2 extents in z dimension.
 */
64
void PhysxBoxShape::set_dimensions(LVector3f const &dimensions);

1665 14 get_dimensions 0 4 3004 29 PhysxBoxShape::get_dimensions 0 1 195 191
/**
 * Retrieves the dimensions of the box.
 *
 * The dimensions are the 'radii' of the box, meaning 1/2 extents in x
 * dimension, 1/2 extents in y dimension, 1/2 extents in z dimension.
 */
52
LVector3f PhysxBoxShape::get_dimensions(void) const;

1666 14 get_class_type 0 4 3004 29 PhysxBoxShape::get_class_type 0 1 196 0
54
static TypeHandle PhysxBoxShape::get_class_type(void);

1667 22 PhysxCapsuleController 0 4 3005 46 PhysxCapsuleController::PhysxCapsuleController 0 1 197 10
/**
 *
 */
60
inline PhysxCapsuleController::PhysxCapsuleController(void);

1668 10 set_radius 0 4 3005 34 PhysxCapsuleController::set_radius 0 1 198 42
/**
 * Resets the controller's radius.
 */
54
void PhysxCapsuleController::set_radius(float radius);

1669 10 set_height 0 4 3005 34 PhysxCapsuleController::set_height 0 1 199 42
/**
 * Resets the controller's height.
 */
54
void PhysxCapsuleController::set_height(float height);

1670 10 get_radius 0 4 3005 34 PhysxCapsuleController::get_radius 0 1 200 43
/**
 * Returns the controller's radius.
 */
53
float PhysxCapsuleController::get_radius(void) const;

1671 10 get_height 0 4 3005 34 PhysxCapsuleController::get_height 0 1 201 43
/**
 * Returns the controller's height.
 */
53
float PhysxCapsuleController::get_height(void) const;

1672 14 get_class_type 0 4 3005 38 PhysxCapsuleController::get_class_type 0 1 202 0
63
static TypeHandle PhysxCapsuleController::get_class_type(void);

1673 27 PhysxCapsuleForceFieldShape 0 4 3006 56 PhysxCapsuleForceFieldShape::PhysxCapsuleForceFieldShape 0 1 203 10
/**
 *
 */
70
inline PhysxCapsuleForceFieldShape::PhysxCapsuleForceFieldShape(void);

1674 12 save_to_desc 0 4 3006 41 PhysxCapsuleForceFieldShape::save_to_desc 0 1 204 63
/**
 * Saves the state of the shape object to a descriptor.
 */
97
void PhysxCapsuleForceFieldShape::save_to_desc(PhysxCapsuleForceFieldShapeDesc &shapeDesc) const;

1675 10 set_radius 0 4 3006 39 PhysxCapsuleForceFieldShape::set_radius 0 1 205 44
/**
 * Alters the radius of the capsule.
 */
59
void PhysxCapsuleForceFieldShape::set_radius(float radius);

1676 10 set_height 0 4 3006 39 PhysxCapsuleForceFieldShape::set_height 0 1 206 44
/**
 * Alters the height of the capsule.
 */
59
void PhysxCapsuleForceFieldShape::set_height(float height);

1677 10 get_radius 0 4 3006 39 PhysxCapsuleForceFieldShape::get_radius 0 1 207 47
/**
 * Retrieves the radius of the capsule.
 */
58
float PhysxCapsuleForceFieldShape::get_radius(void) const;

1678 10 get_height 0 4 3006 39 PhysxCapsuleForceFieldShape::get_height 0 1 208 47
/**
 * Retrieves the height of the capsule.
 */
58
float PhysxCapsuleForceFieldShape::get_height(void) const;

1679 14 get_class_type 0 4 3006 43 PhysxCapsuleForceFieldShape::get_class_type 0 1 209 0
68
static TypeHandle PhysxCapsuleForceFieldShape::get_class_type(void);

1680 17 PhysxCapsuleShape 0 4 3007 36 PhysxCapsuleShape::PhysxCapsuleShape 0 1 210 10
/**
 *
 */
50
inline PhysxCapsuleShape::PhysxCapsuleShape(void);

1681 12 save_to_desc 0 4 3007 31 PhysxCapsuleShape::save_to_desc 0 1 211 63
/**
 * Saves the state of the shape object to a descriptor.
 */
77
void PhysxCapsuleShape::save_to_desc(PhysxCapsuleShapeDesc &shapeDesc) const;

1682 10 set_radius 0 4 3007 29 PhysxCapsuleShape::set_radius 0 1 212 44
/**
 * Alters the radius of the capsule.
 */
49
void PhysxCapsuleShape::set_radius(float radius);

1683 10 set_height 0 4 3007 29 PhysxCapsuleShape::set_height 0 1 213 44
/**
 * Alters the height of the capsule.
 */
49
void PhysxCapsuleShape::set_height(float height);

1684 10 get_radius 0 4 3007 29 PhysxCapsuleShape::get_radius 0 1 214 47
/**
 * Retrieves the radius of the capsule.
 */
48
float PhysxCapsuleShape::get_radius(void) const;

1685 10 get_height 0 4 3007 29 PhysxCapsuleShape::get_height 0 1 215 47
/**
 * Retrieves the height of the capsule.
 */
48
float PhysxCapsuleShape::get_height(void) const;

1686 14 get_class_type 0 4 3007 33 PhysxCapsuleShape::get_class_type 0 1 216 0
58
static TypeHandle PhysxCapsuleShape::get_class_type(void);

1687 19 get_reference_count 0 4 3008 37 PhysxCcdSkeleton::get_reference_count 0 1 217 57
/**
 * Returns the reference count for shared meshes.
 */
63
unsigned int PhysxCcdSkeleton::get_reference_count(void) const;

1688 7 release 0 4 3008 25 PhysxCcdSkeleton::release 0 1 218 10
/**
 *
 */
37
void PhysxCcdSkeleton::release(void);

1689 14 get_class_type 0 4 3008 32 PhysxCcdSkeleton::get_class_type 0 1 219 0
57
static TypeHandle PhysxCcdSkeleton::get_class_type(void);

1690 21 upcast_to_PhysxObject 0 12 3009 33 PhysxCloth::upcast_to_PhysxObject 0 1 262 37
upcast from PhysxCloth to PhysxObject
53
PhysxObject *PhysxCloth::upcast_to_PhysxObject(void);

1691 22 downcast_to_PhysxCloth 0 12 2996 35 PhysxObject::downcast_to_PhysxCloth 0 1 263 39
downcast from PhysxObject to PhysxCloth
54
PhysxCloth *PhysxObject::downcast_to_PhysxCloth(void);

1692 20 upcast_to_PhysxEnums 0 12 3009 32 PhysxCloth::upcast_to_PhysxEnums 0 1 264 36
upcast from PhysxCloth to PhysxEnums
51
PhysxEnums *PhysxCloth::upcast_to_PhysxEnums(void);

1693 22 downcast_to_PhysxCloth 0 12 2965 34 PhysxEnums::downcast_to_PhysxCloth 0 1 265 38
downcast from PhysxEnums to PhysxCloth
53
PhysxCloth *PhysxEnums::downcast_to_PhysxCloth(void);

1694 10 PhysxCloth 0 4 3009 22 PhysxCloth::PhysxCloth 0 1 220 10
/**
 *
 */
36
inline PhysxCloth::PhysxCloth(void);

1695 11 ~PhysxCloth 0 6 3009 23 PhysxCloth::~PhysxCloth 0 0 10
/**
 *
 */
45
virtual inline PhysxCloth::~PhysxCloth(void);

1696 9 get_scene 0 4 3009 21 PhysxCloth::get_scene 0 1 221 57
/**
 * Returns the scene which this cloth belongs to.
 */
46
PhysxScene *PhysxCloth::get_scene(void) const;

1697 14 get_cloth_node 0 4 3009 26 PhysxCloth::get_cloth_node 0 1 222 10
/**
 *
 */
55
PhysxClothNode *PhysxCloth::get_cloth_node(void) const;

1698 17 create_cloth_node 0 4 3009 29 PhysxCloth::create_cloth_node 0 1 223 10
/**
 *
 */
64
PhysxClothNode *PhysxCloth::create_cloth_node(char const *name);

1699 8 set_name 0 4 3009 20 PhysxCloth::set_name 0 1 224 139
/**
 * Sets a name string for the object that can be retrieved with get_name().
 * This is for debugging and is not used by the engine.
 */
44
void PhysxCloth::set_name(char const *name);

1700 9 set_group 0 4 3009 21 PhysxCloth::set_group 0 1 225 106
/**
 * Sets which collision group this cloth is part of.  Collision group must be
 * between 0 and 31.
 */
47
void PhysxCloth::set_group(unsigned int group);

1701 15 set_groups_mask 0 4 3009 27 PhysxCloth::set_groups_mask 0 1 226 58
/**
 * Sets 128-bit mask used for collision filtering.
 */
62
void PhysxCloth::set_groups_mask(PhysxGroupsMask const &mask);

1702 8 set_flag 0 4 3009 20 PhysxCloth::set_flag 0 1 227 43
/**
 * Sets the value of a single flag.
 */
71
void PhysxCloth::set_flag(PhysxEnums::PhysxClothFlag flag, bool value);

1703 13 set_thickness 0 4 3009 25 PhysxCloth::set_thickness 0 1 228 55
/**
 * Sets the cloth thickness (must be positive).
 */
48
void PhysxCloth::set_thickness(float thickness);

1704 8 get_name 0 4 3009 20 PhysxCloth::get_name 0 1 229 37
/**
 * Retrieves the name string.
 */
45
char const *PhysxCloth::get_name(void) const;

1705 17 get_num_particles 0 4 3009 29 PhysxCloth::get_num_particles 0 1 230 46
/**
 * Gets the number of cloth particles.
 */
49
unsigned int PhysxCloth::get_num_particles(void);

1706 9 get_group 0 4 3009 21 PhysxCloth::get_group 0 1 231 63
/**
 * Retrieves the collision group this cloth is part of.
 */
47
unsigned int PhysxCloth::get_group(void) const;

1707 15 get_groups_mask 0 4 3009 27 PhysxCloth::get_groups_mask 0 1 232 69
/**
 * Gets the 128-bit groups mask used for collision filtering.
 */
56
PhysxGroupsMask PhysxCloth::get_groups_mask(void) const;

1708 8 get_flag 0 4 3009 20 PhysxCloth::get_flag 0 1 233 48
/**
 * Retrieves the value of a single flag.
 */
65
bool PhysxCloth::get_flag(PhysxEnums::PhysxClothFlag flag) const;

1709 13 get_thickness 0 4 3009 25 PhysxCloth::get_thickness 0 1 234 36
/**
 * Gets the cloth thickness.
 */
44
float PhysxCloth::get_thickness(void) const;

1710 11 get_density 0 4 3009 23 PhysxCloth::get_density 0 1 235 34
/**
 * Gets the cloth density.
 */
42
float PhysxCloth::get_density(void) const;

1711 25 get_relative_grid_spacing 0 4 3009 37 PhysxCloth::get_relative_grid_spacing 0 1 236 296
/**
 * Gets the relative grid spacing for the broad phase.  The cloth is
 * represented by a set of world aligned cubical cells in broad phase.  The
 * size of these cells is determined by multiplying the length of the diagonal
 * of the AABB of the initial soft body size with this constant.
 */
56
float PhysxCloth::get_relative_grid_spacing(void) const;

1712 27 attach_vertex_to_global_pos 0 4 3009 39 PhysxCloth::attach_vertex_to_global_pos 0 1 237 79
// Attachment

/**
 * Attaches a cloth vertex to a position in world space.
 */
89
void PhysxCloth::attach_vertex_to_global_pos(unsigned int vertexId, LPoint3f const &pos);

1713 11 free_vertex 0 4 3009 23 PhysxCloth::free_vertex 0 1 238 51
/**
 * Frees a previously attached cloth point.
 */
52
void PhysxCloth::free_vertex(unsigned int vertexId);

1714 15 attach_to_shape 0 4 3009 27 PhysxCloth::attach_to_shape 0 1 239 238
/**
 * Attaches the cloth to a shape.  All cloth points currently inside the shape
 * are attached.
 *
 * This method only works with primitive and convex shapes.  Since the inside
 * of a general triangle mesh is not clearly defined.
 */
52
void PhysxCloth::attach_to_shape(PhysxShape *shape);

1715 26 attach_to_colliding_shapes 0 4 3009 38 PhysxCloth::attach_to_colliding_shapes 0 1 240 200
/**
 * Attaches the cloth to all shapes, currently colliding.
 *
 * This method only works with primitive and convex shapes.  Since the inside
 * of a general triangle mesh is not clearly defined.
 */
50
void PhysxCloth::attach_to_colliding_shapes(void);

1716 17 detach_from_shape 0 4 3009 29 PhysxCloth::detach_from_shape 0 1 241 163
/**
 * Detaches the cloth from a shape it has been attached to before.
 *
 * If the cloth has not been attached to the shape before, the call has no
 * effect.
 */
54
void PhysxCloth::detach_from_shape(PhysxShape *shape);

1717 22 attach_vertex_to_shape 0 4 3009 34 PhysxCloth::attach_vertex_to_shape 0 1 242 70
/**
 * Attaches a cloth vertex to a local position within a shape.
 */
108
void PhysxCloth::attach_vertex_to_shape(unsigned int vertexId, PhysxShape *shape, LPoint3f const &localPos);

1718 28 get_vertex_attachment_status 0 4 3009 40 PhysxCloth::get_vertex_attachment_status 0 1 243 60
/**
 * Return the attachment status of the given vertex.
 */
110
PhysxEnums::PhysxVertexAttachmentStatus PhysxCloth::get_vertex_attachment_status(unsigned int vertexId) const;

1719 27 get_vertex_attachment_shape 0 4 3009 39 PhysxCloth::get_vertex_attachment_shape 0 1 244 169
/**
 * Returns the pointer to an attached shape pointer of the given vertex.  If
 * the vertex is not attached or attached to a global position, NULL is
 * returned.
 */
81
PhysxShape *PhysxCloth::get_vertex_attachment_shape(unsigned int vertexId) const;

1720 25 get_vertex_attachment_pos 0 4 3009 37 PhysxCloth::get_vertex_attachment_pos 0 1 245 221
/**
 * Returns the attachment position of the given vertex.  If the vertex is
 * attached to shape, the position local to the shape's pose is returned.  If
 * the vertex is not attached, the return value is undefined.
 */
76
LPoint3f PhysxCloth::get_vertex_attachment_pos(unsigned int vertexId) const;

1721 11 is_sleeping 0 4 3009 23 PhysxCloth::is_sleeping 0 1 246 420
// Sleeping

/**
 * Returns true if this cloth is sleeping.
 *
 * When a cloth does not move for a period of time, it is no longer simulated
 * in order to save time.  This state is called sleeping.  However, because
 * the object automatically wakes up when it is either touched by an awake
 * object, or one of its properties is changed by the user, the entire sleep
 * mechanism should be transparent to the user.
 */
41
bool PhysxCloth::is_sleeping(void) const;

1722 7 wake_up 0 4 3009 19 PhysxCloth::wake_up 0 1 247 239
/**
 * Wakes up the cloth if it is sleeping.
 *
 * The wakeCounterValue determines how long until the body is put to sleep, a
 * value of zero means that the body is sleeping.  wake_up(0) is equivalent to
 * PhysxCloth::put_to_sleep().
 */
81
void PhysxCloth::wake_up(float wakeCounterValue = (20.0 * 0.020000000000000005));

1723 12 put_to_sleep 0 4 3009 24 PhysxCloth::put_to_sleep 0 1 248 267
/**
 * Forces the cloth to sleep.
 *
 * The cloth  will stay asleep until the next call to simulate, and will not
 * wake up until then even when otherwise it would (for example a force is
 * applied to it). It can however wake up during the next do_physics call.
 */
36
void PhysxCloth::put_to_sleep(void);

1724 25 set_sleep_linear_velocity 0 4 3009 37 PhysxCloth::set_sleep_linear_velocity 0 1 249 266
/**
 * Sets the linear velocity below which an cloth may go to sleep.  Cloths
 * whose linear velocity is above this threshold will not be put to sleep.
 *
 * Setting the sleep angular/linear velocity only makes sense when the
 * BF_energy_sleep_test is not set.
 */
60
void PhysxCloth::set_sleep_linear_velocity(float threshold);

1725 25 get_sleep_linear_velocity 0 4 3009 37 PhysxCloth::get_sleep_linear_velocity 0 1 250 165
/**
 * Returns the linear velocity below which an soft body may go to sleep.
 * cloths whose linear velocity is above this threshold will not be put to
 * sleep.
 */
56
float PhysxCloth::get_sleep_linear_velocity(void) const;

1726 25 set_external_acceleration 0 4 3009 37 PhysxCloth::set_external_acceleration 0 1 251 109
// Forces

/**
 * Sets an external acceleration which affects all non attached particles of
 * the cloth.
 */
74
void PhysxCloth::set_external_acceleration(LVector3f const &acceleration);

1727 25 get_external_acceleration 0 4 3009 37 PhysxCloth::get_external_acceleration 0 1 252 104
/**
 * Retrieves the external acceleration which affects all non attached
 * particles of the cloth.
 */
60
LVector3f PhysxCloth::get_external_acceleration(void) const;

1728 21 set_wind_acceleration 0 4 3009 33 PhysxCloth::set_wind_acceleration 0 1 253 82
/**
 * Sets an acceleration acting normal to the cloth surface at each vertex.
 */
70
void PhysxCloth::set_wind_acceleration(LVector3f const &acceleration);

1729 21 get_wind_acceleration 0 4 3009 33 PhysxCloth::get_wind_acceleration 0 1 254 90
/**
 * Retrieves the acceleration acting normal to the cloth surface at each
 * vertex
 */
56
LVector3f PhysxCloth::get_wind_acceleration(void) const;

1730 19 add_force_at_vertex 0 4 3009 31 PhysxCloth::add_force_at_vertex 0 1 255 119
/**
 * Applies a force (or impulse) defined in the global coordinate frame, to a
 * particular vertex of the cloth.
 */
133
void PhysxCloth::add_force_at_vertex(LVector3f const &force, int vertexId, PhysxEnums::PhysxForceMode mode = ::PhysxEnums::FM_force);

1731 16 add_force_at_pos 0 4 3009 28 PhysxCloth::add_force_at_pos 0 1 256 147
/**
 * Applies a radial force (or impulse) at a particular position.  All vertices
 * within radius will be affected with a quadratic drop-off.
 */
144
void PhysxCloth::add_force_at_pos(LPoint3f const &pos, float magnitude, float radius, PhysxEnums::PhysxForceMode mode = ::PhysxEnums::FM_force);

1732 25 add_directed_force_at_pos 0 4 3009 37 PhysxCloth::add_directed_force_at_pos 0 1 257 149
/**
 * Applies a directed force (or impulse) at a particular position.  All
 * vertices within radius will be affected with a quadratic drop-off.
 */
160
void PhysxCloth::add_directed_force_at_pos(LPoint3f const &pos, LVector3f const &force, float radius, PhysxEnums::PhysxForceMode mode = ::PhysxEnums::FM_force);

1733 2 ls 0 6 3009 14 PhysxCloth::ls 0 2 258 259 22
/**
 *
 */

/**
 *
 */
125
virtual inline void PhysxCloth::ls(void) const;
virtual inline void PhysxCloth::ls(ostream &out, int indent_level = 0) const;

1734 7 release 0 4 3009 19 PhysxCloth::release 0 1 260 10
/**
 *
 */
31
void PhysxCloth::release(void);

1735 14 get_class_type 0 4 3009 26 PhysxCloth::get_class_type 0 1 261 0
51
static TypeHandle PhysxCloth::get_class_type(void);

1736 19 get_reference_count 0 4 3010 35 PhysxClothMesh::get_reference_count 0 1 266 57
/**
 * Returns the reference count for shared meshes.
 */
61
unsigned int PhysxClothMesh::get_reference_count(void) const;

1737 7 release 0 4 3010 23 PhysxClothMesh::release 0 1 267 10
/**
 *
 */
35
void PhysxClothMesh::release(void);

1738 14 get_class_type 0 4 3010 30 PhysxClothMesh::get_class_type 0 1 268 0
55
static TypeHandle PhysxClothMesh::get_class_type(void);

1739 14 PhysxClothNode 0 4 3011 30 PhysxClothNode::PhysxClothNode 0 1 269 10
/**
 *
 */
56
inline PhysxClothNode::PhysxClothNode(char const *name);

1740 13 set_texcoords 0 4 3011 29 PhysxClothNode::set_texcoords 0 1 270 10
/**
 *
 */
61
bool PhysxClothNode::set_texcoords(Filename const &filename);

1741 14 get_class_type 0 4 3011 30 PhysxClothNode::get_class_type 0 1 271 0
55
static TypeHandle PhysxClothNode::get_class_type(void);

1742 12 is_deleted_a 0 4 3013 30 PhysxContactPair::is_deleted_a 0 1 272 66
/**
 * Returns true if the first of the two actors is deleted.
 */
48
bool PhysxContactPair::is_deleted_a(void) const;

1743 12 is_deleted_b 0 4 3013 30 PhysxContactPair::is_deleted_b 0 1 273 67
/**
 * Returns true if the second of the two actors is deleted.
 */
48
bool PhysxContactPair::is_deleted_b(void) const;

1744 11 get_actor_a 0 4 3013 29 PhysxContactPair::get_actor_a 0 1 274 71
/**
 * Returns the first of the two actors that makes up this pair.
 */
54
PhysxActor *PhysxContactPair::get_actor_a(void) const;

1745 11 get_actor_b 0 4 3013 29 PhysxContactPair::get_actor_b 0 1 275 70
/**
 * Returns the second of the two actors that make up his pair.
 */
54
PhysxActor *PhysxContactPair::get_actor_b(void) const;

1746 20 get_sum_normal_force 0 4 3013 38 PhysxContactPair::get_sum_normal_force 0 1 276 307
/**
 * Returns the total contact normal force that was applied for this pair, to
 * maintain nonpenetration constraints.
 *
 * You should set the ContactPairFlag CPF_notify_forces in order to receive
 * this value.
 *
 * @see PhysxScene::set_actor_pair_flag @see
 * PhysxScene::set_actor_group_pair_flag
 */
61
LVector3f PhysxContactPair::get_sum_normal_force(void) const;

1747 22 get_sum_friction_force 0 4 3013 40 PhysxContactPair::get_sum_friction_force 0 1 277 260
/**
 * Returns the total tangential force that was applied for this pair.
 *
 * You should set the ContactPairFlag CPF_notify_forces in order to receive
 * this value.
 *
 * @see PhysxScene::set_actor_pair_flag @see
 * PhysxScene::set_actor_group_pair_flag
 */
63
LVector3f PhysxContactPair::get_sum_friction_force(void) const;

1748 22 get_num_contact_points 0 4 3013 40 PhysxContactPair::get_num_contact_points 0 1 278 172
/**
 * Returns the total number of contact points reported in this pair's contact
 * stream.
 *
 * This method is a helper for iterating over the pair's contact stream.
 */
60
unsigned int PhysxContactPair::get_num_contact_points(void);

1749 17 get_contact_point 0 4 3013 35 PhysxContactPair::get_contact_point 0 1 279 194
/**
 * Returns an instance of PhysxContactPoint, which represents a single entry
 * of this pair's contact stream.
 *
 * This method is a helper for iterating over the pair's contact stream.
 */
78
PhysxContactPoint PhysxContactPair::get_contact_point(unsigned int idx) const;

1750 14 get_class_type 0 4 3013 32 PhysxContactPair::get_class_type 0 1 280 0
57
static TypeHandle PhysxContactPair::get_class_type(void);

1751 17 PhysxContactPoint 0 4 3014 36 PhysxContactPoint::PhysxContactPoint 0 1 281 10
/**
 *
 */
50
inline PhysxContactPoint::PhysxContactPoint(void);

1752 9 get_point 0 4 3014 28 PhysxContactPoint::get_point 0 1 282 46
/**
 * Returns the contact point position.
 */
50
LPoint3f PhysxContactPoint::get_point(void) const;

1753 10 get_normal 0 4 3014 29 PhysxContactPoint::get_normal 0 1 283 38
/**
 * Retrieves the patch normal.
 */
52
LVector3f PhysxContactPoint::get_normal(void) const;

1754 16 get_normal_force 0 4 3014 35 PhysxContactPoint::get_normal_force 0 1 284 44
/**
 * Retrieves the point normal force.
 */
54
float PhysxContactPoint::get_normal_force(void) const;

1755 14 get_separation 0 4 3014 33 PhysxContactPoint::get_separation 0 1 285 55
/**
 * Return the separation for the contact point.
 */
52
float PhysxContactPoint::get_separation(void) const;

1756 18 get_feature_index0 0 4 3014 37 PhysxContactPoint::get_feature_index0 0 1 286 39
/**
 * Retrieves the feature index.
 */
63
unsigned int PhysxContactPoint::get_feature_index0(void) const;

1757 18 get_feature_index1 0 4 3014 37 PhysxContactPoint::get_feature_index1 0 1 287 39
/**
 * Retrieves the feature index.
 */
63
unsigned int PhysxContactPoint::get_feature_index1(void) const;

1758 14 get_class_type 0 4 3014 33 PhysxContactPoint::get_class_type 0 1 288 0
58
static TypeHandle PhysxContactPoint::get_class_type(void);

1759 13 ~PhysxManager 0 4 3016 27 PhysxManager::~PhysxManager 0 0 10
/**
 *
 */
34
PhysxManager::~PhysxManager(void);

1760 14 get_global_ptr 0 4 3016 28 PhysxManager::get_global_ptr 0 1 290 63
/**
 * Returns a pointer to the global PhysxManager object.
 */
56
static PhysxManager *PhysxManager::get_global_ptr(void);

1761 13 set_parameter 0 4 3016 27 PhysxManager::set_parameter 0 1 291 10
/**
 *
 */
80
void PhysxManager::set_parameter(PhysxEnums::PhysxParameter param, float value);

1762 13 get_parameter 0 4 3016 27 PhysxManager::get_parameter 0 1 292 10
/**
 *
 */
68
float PhysxManager::get_parameter(PhysxEnums::PhysxParameter param);

1763 21 is_hardware_available 0 4 3016 35 PhysxManager::is_hardware_available 0 1 293 78
/**
 * Returns TRUE if a physcis hardware is available on the host system.
 */
47
bool PhysxManager::is_hardware_available(void);

1764 12 get_num_ppus 0 4 3016 26 PhysxManager::get_num_ppus 0 1 294 67
/**
 * Reports the number of PPUs installed in the host system.
 */
46
unsigned int PhysxManager::get_num_ppus(void);

1765 14 get_hw_version 0 4 3016 28 PhysxManager::get_hw_version 0 1 295 171
/**
 * Reports the available revision of the PhysX Hardware.  Returns 0 if there
 * is no hardware present in the machine, 1 for the PhysX Athena revision 1.0
 * card.
 */
48
unsigned int PhysxManager::get_hw_version(void);

1766 20 get_internal_version 0 4 3016 34 PhysxManager::get_internal_version 0 1 296 62
/**
 * Reports the internal API version number of the SDK.
 */
53
char const *PhysxManager::get_internal_version(void);

1767 14 get_num_scenes 0 4 3016 28 PhysxManager::get_num_scenes 0 1 297 10
/**
 *
 */
54
unsigned int PhysxManager::get_num_scenes(void) const;

1768 12 create_scene 0 4 3016 26 PhysxManager::create_scene 0 1 298 10
/**
 *
 */
61
PhysxScene *PhysxManager::create_scene(PhysxSceneDesc &desc);

1769 9 get_scene 0 4 3016 23 PhysxManager::get_scene 0 1 299 10
/**
 *
 */
60
PhysxScene *PhysxManager::get_scene(unsigned int idx) const;

1770 21 get_num_height_fields 0 4 3016 35 PhysxManager::get_num_height_fields 0 1 300 10
/**
 *
 */
55
unsigned int PhysxManager::get_num_height_fields(void);

1771 19 create_height_field 0 4 3016 33 PhysxManager::create_height_field 0 1 301 10
/**
 *
 */
80
PhysxHeightField *PhysxManager::create_height_field(PhysxHeightFieldDesc &desc);

1772 16 get_height_field 0 4 3016 30 PhysxManager::get_height_field 0 1 302 10
/**
 *
 */
67
PhysxHeightField *PhysxManager::get_height_field(unsigned int idx);

1773 21 get_num_convex_meshes 0 4 3016 35 PhysxManager::get_num_convex_meshes 0 1 303 10
/**
 *
 */
55
unsigned int PhysxManager::get_num_convex_meshes(void);

1774 15 get_convex_mesh 0 4 3016 29 PhysxManager::get_convex_mesh 0 1 304 10
/**
 *
 */
65
PhysxConvexMesh *PhysxManager::get_convex_mesh(unsigned int idx);

1775 23 get_num_triangle_meshes 0 4 3016 37 PhysxManager::get_num_triangle_meshes 0 1 305 10
/**
 *
 */
57
unsigned int PhysxManager::get_num_triangle_meshes(void);

1776 17 get_triangle_mesh 0 4 3016 31 PhysxManager::get_triangle_mesh 0 1 306 10
/**
 *
 */
69
PhysxTriangleMesh *PhysxManager::get_triangle_mesh(unsigned int idx);

1777 20 get_num_cloth_meshes 0 4 3016 34 PhysxManager::get_num_cloth_meshes 0 1 307 10
/**
 *
 */
54
unsigned int PhysxManager::get_num_cloth_meshes(void);

1778 14 get_cloth_mesh 0 4 3016 28 PhysxManager::get_cloth_mesh 0 1 308 10
/**
 *
 */
63
PhysxClothMesh *PhysxManager::get_cloth_mesh(unsigned int idx);

1779 24 get_num_soft_body_meshes 0 4 3016 38 PhysxManager::get_num_soft_body_meshes 0 1 309 10
/**
 *
 */
58
unsigned int PhysxManager::get_num_soft_body_meshes(void);

1780 18 get_soft_body_mesh 0 4 3016 32 PhysxManager::get_soft_body_mesh 0 1 310 10
/**
 *
 */
70
PhysxSoftBodyMesh *PhysxManager::get_soft_body_mesh(unsigned int idx);

1781 21 get_num_ccd_skeletons 0 4 3016 35 PhysxManager::get_num_ccd_skeletons 0 1 311 10
/**
 *
 */
55
unsigned int PhysxManager::get_num_ccd_skeletons(void);

1782 19 create_ccd_skeleton 0 4 3016 33 PhysxManager::create_ccd_skeleton 0 1 312 10
/**
 *
 */
80
PhysxCcdSkeleton *PhysxManager::create_ccd_skeleton(PhysxCcdSkeletonDesc &desc);

1783 16 get_ccd_skeleton 0 4 3016 30 PhysxManager::get_ccd_skeleton 0 1 313 10
/**
 *
 */
67
PhysxCcdSkeleton *PhysxManager::get_ccd_skeleton(unsigned int idx);

1784 2 ls 0 4 3016 16 PhysxManager::ls 0 2 314 315 22
/**
 *
 */

/**
 *
 */
113
inline void PhysxManager::ls(void) const;
inline void PhysxManager::ls(ostream &out, int indent_level = 0) const;

1785 12 PhysxManager 0 4 3016 26 PhysxManager::PhysxManager 0 1 289 10
/**
 *
 */
66
inline PhysxManager::PhysxManager(PhysxManager const &) = default;

1786 23 PhysxControllerShapeHit 0 4 3017 48 PhysxControllerShapeHit::PhysxControllerShapeHit 0 1 316 10
/**
 *
 */
89
inline PhysxControllerShapeHit::PhysxControllerShapeHit(NxControllerShapeHit const &hit);

1787 14 get_controller 0 4 3017 39 PhysxControllerShapeHit::get_controller 0 1 317 10
/**
 *
 */
76
inline PhysxController *PhysxControllerShapeHit::get_controller(void) const;

1788 9 get_shape 0 4 3017 34 PhysxControllerShapeHit::get_shape 0 1 318 10
/**
 *
 */
66
inline PhysxShape *PhysxControllerShapeHit::get_shape(void) const;

1789 13 get_world_pos 0 4 3017 38 PhysxControllerShapeHit::get_world_pos 0 1 319 10
/**
 *
 */
66
inline LPoint3 PhysxControllerShapeHit::get_world_pos(void) const;

1790 16 get_world_normal 0 4 3017 41 PhysxControllerShapeHit::get_world_normal 0 1 320 10
/**
 *
 */
70
inline LVector3 PhysxControllerShapeHit::get_world_normal(void) const;

1791 7 get_dir 0 4 3017 32 PhysxControllerShapeHit::get_dir 0 1 321 10
/**
 *
 */
61
inline LVector3 PhysxControllerShapeHit::get_dir(void) const;

1792 10 get_length 0 4 3017 35 PhysxControllerShapeHit::get_length 0 1 322 10
/**
 *
 */
67
inline PN_stdfloat PhysxControllerShapeHit::get_length(void) const;

1793 14 get_class_type 0 4 3017 39 PhysxControllerShapeHit::get_class_type 0 1 323 0
64
static TypeHandle PhysxControllerShapeHit::get_class_type(void);

1794 19 PhysxControllersHit 0 4 3019 40 PhysxControllersHit::PhysxControllersHit 0 1 324 10
/**
 *
 */
77
inline PhysxControllersHit::PhysxControllersHit(NxControllersHit const &hit);

1795 14 get_controller 0 4 3019 35 PhysxControllersHit::get_controller 0 1 325 10
/**
 *
 */
72
inline PhysxController *PhysxControllersHit::get_controller(void) const;

1796 9 get_other 0 4 3019 30 PhysxControllersHit::get_other 0 1 326 10
/**
 *
 */
67
inline PhysxController *PhysxControllersHit::get_other(void) const;

1797 14 get_class_type 0 4 3019 35 PhysxControllersHit::get_class_type 0 1 327 0
60
static TypeHandle PhysxControllersHit::get_class_type(void);

1798 19 get_reference_count 0 4 3020 36 PhysxConvexMesh::get_reference_count 0 1 328 57
/**
 * Returns the reference count for shared meshes.
 */
62
unsigned int PhysxConvexMesh::get_reference_count(void) const;

1799 7 release 0 4 3020 24 PhysxConvexMesh::release 0 1 329 10
/**
 *
 */
36
void PhysxConvexMesh::release(void);

1800 14 get_class_type 0 4 3020 31 PhysxConvexMesh::get_class_type 0 1 330 0
56
static TypeHandle PhysxConvexMesh::get_class_type(void);

1801 26 PhysxConvexForceFieldShape 0 4 3021 54 PhysxConvexForceFieldShape::PhysxConvexForceFieldShape 0 1 331 10
/**
 *
 */
68
inline PhysxConvexForceFieldShape::PhysxConvexForceFieldShape(void);

1802 12 save_to_desc 0 4 3021 40 PhysxConvexForceFieldShape::save_to_desc 0 1 332 63
/**
 * Saves the state of the shape object to a descriptor.
 */
95
void PhysxConvexForceFieldShape::save_to_desc(PhysxConvexForceFieldShapeDesc &shapeDesc) const;

1803 14 get_class_type 0 4 3021 42 PhysxConvexForceFieldShape::get_class_type 0 1 333 0
67
static TypeHandle PhysxConvexForceFieldShape::get_class_type(void);

1804 16 PhysxConvexShape 0 4 3022 34 PhysxConvexShape::PhysxConvexShape 0 1 334 10
/**
 *
 */
48
inline PhysxConvexShape::PhysxConvexShape(void);

1805 12 save_to_desc 0 4 3022 30 PhysxConvexShape::save_to_desc 0 1 335 63
/**
 * Saves the state of the shape object to a descriptor.
 */
75
void PhysxConvexShape::save_to_desc(PhysxConvexShapeDesc &shapeDesc) const;

1806 14 get_class_type 0 4 3022 32 PhysxConvexShape::get_class_type 0 1 336 0
57
static TypeHandle PhysxConvexShape::get_class_type(void);

1807 21 upcast_to_PhysxObject 0 12 3023 33 PhysxJoint::upcast_to_PhysxObject 0 1 357 37
upcast from PhysxJoint to PhysxObject
53
PhysxObject *PhysxJoint::upcast_to_PhysxObject(void);

1808 22 downcast_to_PhysxJoint 0 12 2996 35 PhysxObject::downcast_to_PhysxJoint 0 1 358 39
downcast from PhysxObject to PhysxJoint
54
PhysxJoint *PhysxObject::downcast_to_PhysxJoint(void);

1809 20 upcast_to_PhysxEnums 0 12 3023 32 PhysxJoint::upcast_to_PhysxEnums 0 1 359 36
upcast from PhysxJoint to PhysxEnums
51
PhysxEnums *PhysxJoint::upcast_to_PhysxEnums(void);

1810 22 downcast_to_PhysxJoint 0 12 2965 34 PhysxEnums::downcast_to_PhysxJoint 0 1 360 38
downcast from PhysxEnums to PhysxJoint
53
PhysxJoint *PhysxEnums::downcast_to_PhysxJoint(void);

1811 7 release 0 4 3023 19 PhysxJoint::release 0 1 337 10
/**
 *
 */
31
void PhysxJoint::release(void);

1812 9 get_actor 0 4 3023 21 PhysxJoint::get_actor 0 1 338 67
/**
 * Retrieves the actor which this joint is associated with.
 */
58
PhysxActor *PhysxJoint::get_actor(unsigned int idx) const;

1813 9 get_scene 0 4 3023 21 PhysxJoint::get_scene 0 1 339 67
/**
 * Retrieves the scene which this joint is associated with.
 */
46
PhysxScene *PhysxJoint::get_scene(void) const;

1814 18 purge_limit_planes 0 4 3023 30 PhysxJoint::purge_limit_planes 0 1 340 55
/**
 * Deletes all limit planes added to the joint.
 */
42
void PhysxJoint::purge_limit_planes(void);

1815 8 set_name 0 4 3023 20 PhysxJoint::set_name 0 1 341 160
/**
 * Sets a name string for this object.  The name can be retrieved again with
 * get_name(). This is for debugging and is not used by the physics engine.
 */
44
void PhysxJoint::set_name(char const *name);

1816 17 set_global_anchor 0 4 3023 29 PhysxJoint::set_global_anchor 0 1 342 96
/**
 * Sets the point where the two actors are attached, specified in global
 * coordinates.
 */
59
void PhysxJoint::set_global_anchor(LPoint3f const &anchor);

1817 15 set_global_axis 0 4 3023 27 PhysxJoint::set_global_axis 0 1 343 94
/**
 * Sets the direction of the joint's primary axis, specified in global
 * coordinates.
 */
56
void PhysxJoint::set_global_axis(LVector3f const &axis);

1818 13 set_breakable 0 4 3023 25 PhysxJoint::set_breakable 0 1 344 888
/**
 * Sets the maximum force magnitude that the joint is able to withstand
 * without breaking.
 *
 * If the joint force rises above this threshold, the joint breaks, and
 * becomes disabled.
 *
 * There are two values, one for linear forces, and one for angular forces.
 * Both values are used directly as a value for the maximum impulse tolerated
 * by the joint constraints.
 *
 * Both force values are NX_MAX_REAL by default.  This setting makes the joint
 * unbreakable.  The values should always be nonnegative.
 *
 * The distinction between maxForce and maxTorque is dependent on how the
 * joint is implemented internally, which may not be obvious.  For example
 * what appears to be an angular degree of freedom may be constrained
 * indirectly by a linear constraint.
 *
 * So in most practical applications the user should set both maxTorque and
 * maxForce to low values.
 */
64
void PhysxJoint::set_breakable(float maxForce, float maxTorque);

1819 31 set_solver_extrapolation_factor 0 4 3023 43 PhysxJoint::set_solver_extrapolation_factor 0 1 345 48
/**
 * Sets the solver extrapolation factor.
 */
63
void PhysxJoint::set_solver_extrapolation_factor(float factor);

1820 27 set_use_acceleration_spring 0 4 3023 39 PhysxJoint::set_use_acceleration_spring 0 1 346 62
/**
 * Switch between acceleration and force based spring.
 */
57
void PhysxJoint::set_use_acceleration_spring(bool value);

1821 15 set_limit_point 0 4 3023 27 PhysxJoint::set_limit_point 0 1 347 684
/**
 * Sets the limit point.  The point is specified in the global coordinate
 * frame.
 *
 * All types of joints may be limited with the same system: You may elect a
 * point attached to one of the two actors to act as the limit point.  You may
 * also specify several planes attached to the other actor.
 *
 * The points and planes move together with the actor they are attached to.
 *
 * The simulation then makes certain that the pair of actors only move
 * relative to each other so that the limit point stays on the positive side
 * of all limit planes.
 *
 * The default limit point is (0,0,0) in the local frame of actor2. Calling
 * this deletes all existing limit planes
 */
78
void PhysxJoint::set_limit_point(LPoint3f const &pos, bool isOnActor2 = true);

1822 15 add_limit_plane 0 4 3023 27 PhysxJoint::add_limit_plane 0 1 348 402
/**
 * Adds a limit plane.  The parameters are given in global coordinates.  The
 * plane is affixed to the actor that does not have the limit point.
 *
 * The normal of the plane points toward the positive side of the plane, and
 * thus toward the limit point.  If the normal points away from the limit
 * point at the time of this call, the method returns false and the limit
 * plane is ignored.
 */
113
void PhysxJoint::add_limit_plane(LVector3f const &normal, LPoint3f const &pointInPlane, float restitution = 0.0);

1823 8 get_name 0 4 3023 20 PhysxJoint::get_name 0 1 349 35
/**
 * Returns the name string.
 */
45
char const *PhysxJoint::get_name(void) const;

1824 17 get_global_anchor 0 4 3023 29 PhysxJoint::get_global_anchor 0 1 350 38
/**
 * Retrieves the joint anchor.
 */
51
LPoint3f PhysxJoint::get_global_anchor(void) const;

1825 15 get_global_axis 0 4 3023 27 PhysxJoint::get_global_axis 0 1 351 36
/**
 * Retrieves the joint axis.
 */
50
LVector3f PhysxJoint::get_global_axis(void) const;

1826 31 get_solver_extrapolation_factor 0 4 3023 43 PhysxJoint::get_solver_extrapolation_factor 0 1 352 53
/**
 * Retrieves the solver extrapolation factor.
 */
62
float PhysxJoint::get_solver_extrapolation_factor(void) const;

1827 27 get_use_acceleration_spring 0 4 3023 39 PhysxJoint::get_use_acceleration_spring 0 1 353 54
/**
 * Checks whether acceleration spring is used.
 */
57
bool PhysxJoint::get_use_acceleration_spring(void) const;

1828 2 ls 0 6 3023 14 PhysxJoint::ls 0 2 354 355 22
/**
 *
 */

/**
 *
 */
125
virtual inline void PhysxJoint::ls(void) const;
virtual inline void PhysxJoint::ls(ostream &out, int indent_level = 0) const;

1829 14 get_class_type 0 4 3023 26 PhysxJoint::get_class_type 0 1 356 0
51
static TypeHandle PhysxJoint::get_class_type(void);

1830 11 ~PhysxJoint 0 4 3023 23 PhysxJoint::~PhysxJoint 0 0 0
30
PhysxJoint::~PhysxJoint(void);

1831 21 PhysxCylindricalJoint 0 4 3024 44 PhysxCylindricalJoint::PhysxCylindricalJoint 0 1 361 10
/**
 *
 */
58
inline PhysxCylindricalJoint::PhysxCylindricalJoint(void);

1832 12 save_to_desc 0 4 3024 35 PhysxCylindricalJoint::save_to_desc 0 1 362 63
/**
 * Saves the state of the joint object to a descriptor.
 */
85
void PhysxCylindricalJoint::save_to_desc(PhysxCylindricalJointDesc &jointDesc) const;

1833 14 load_from_desc 0 4 3024 37 PhysxCylindricalJoint::load_from_desc 0 1 363 84
/**
 * Loads the entire state of the joint from a descriptor with a single call.
 */
87
void PhysxCylindricalJoint::load_from_desc(PhysxCylindricalJointDesc const &jointDesc);

1834 14 get_class_type 0 4 3024 37 PhysxCylindricalJoint::get_class_type 0 1 364 0
62
static TypeHandle PhysxCylindricalJoint::get_class_type(void);

1835 12 PhysxD6Joint 0 4 3025 26 PhysxD6Joint::PhysxD6Joint 0 1 365 10
/**
 *
 */
40
inline PhysxD6Joint::PhysxD6Joint(void);

1836 12 save_to_desc 0 4 3025 26 PhysxD6Joint::save_to_desc 0 1 366 63
/**
 * Saves the state of the joint object to a descriptor.
 */
67
void PhysxD6Joint::save_to_desc(PhysxD6JointDesc &jointDesc) const;

1837 14 load_from_desc 0 4 3025 28 PhysxD6Joint::load_from_desc 0 1 367 84
/**
 * Loads the entire state of the joint from a descriptor with a single call.
 */
69
void PhysxD6Joint::load_from_desc(PhysxD6JointDesc const &jointDesc);

1838 26 set_drive_angular_velocity 0 4 3025 40 PhysxD6Joint::set_drive_angular_velocity 0 1 368 10
/**
 *
 */
66
void PhysxD6Joint::set_drive_angular_velocity(LVector3f const &v);

1839 25 set_drive_linear_velocity 0 4 3025 39 PhysxD6Joint::set_drive_linear_velocity 0 1 369 10
/**
 *
 */
65
void PhysxD6Joint::set_drive_linear_velocity(LVector3f const &v);

1840 21 set_drive_orientation 0 4 3025 35 PhysxD6Joint::set_drive_orientation 0 1 370 10
/**
 *
 */
67
void PhysxD6Joint::set_drive_orientation(LQuaternionf const &quat);

1841 18 set_drive_position 0 4 3025 32 PhysxD6Joint::set_drive_position 0 1 371 10
/**
 *
 */
59
void PhysxD6Joint::set_drive_position(LPoint3f const &pos);

1842 14 get_class_type 0 4 3025 28 PhysxD6Joint::get_class_type 0 1 372 0
53
static TypeHandle PhysxD6Joint::get_class_type(void);

1843 18 PhysxDebugGeomNode 0 4 3026 38 PhysxDebugGeomNode::PhysxDebugGeomNode 0 2 373 374 10
/**
 *
 */
137
inline PhysxDebugGeomNode::PhysxDebugGeomNode(void);
inline PhysxDebugGeomNode::PhysxDebugGeomNode(PhysxDebugGeomNode const &) = default;

1844 2 on 0 4 3026 22 PhysxDebugGeomNode::on 0 1 375 10
/**
 *
 */
34
void PhysxDebugGeomNode::on(void);

1845 3 off 0 4 3026 23 PhysxDebugGeomNode::off 0 1 376 10
/**
 *
 */
35
void PhysxDebugGeomNode::off(void);

1846 6 toggle 0 4 3026 26 PhysxDebugGeomNode::toggle 0 1 377 10
/**
 *
 */
38
void PhysxDebugGeomNode::toggle(void);

1847 20 visualize_world_axes 0 4 3026 40 PhysxDebugGeomNode::visualize_world_axes 0 1 378 10
/**
 *
 */
65
inline void PhysxDebugGeomNode::visualize_world_axes(bool value);

1848 19 visualize_body_axes 0 4 3026 39 PhysxDebugGeomNode::visualize_body_axes 0 1 379 10
/**
 *
 */
64
inline void PhysxDebugGeomNode::visualize_body_axes(bool value);

1849 24 visualize_body_mass_axes 0 4 3026 44 PhysxDebugGeomNode::visualize_body_mass_axes 0 1 380 10
/**
 *
 */
69
inline void PhysxDebugGeomNode::visualize_body_mass_axes(bool value);

1850 27 visualize_body_lin_velocity 0 4 3026 47 PhysxDebugGeomNode::visualize_body_lin_velocity 0 1 381 10
/**
 *
 */
72
inline void PhysxDebugGeomNode::visualize_body_lin_velocity(bool value);

1851 27 visualize_body_ang_velocity 0 4 3026 47 PhysxDebugGeomNode::visualize_body_ang_velocity 0 1 382 10
/**
 *
 */
72
inline void PhysxDebugGeomNode::visualize_body_ang_velocity(bool value);

1852 27 visualize_body_joint_groups 0 4 3026 47 PhysxDebugGeomNode::visualize_body_joint_groups 0 1 383 10
/**
 *
 */
72
inline void PhysxDebugGeomNode::visualize_body_joint_groups(bool value);

1853 26 visualize_joint_local_axes 0 4 3026 46 PhysxDebugGeomNode::visualize_joint_local_axes 0 1 384 10
/**
 *
 */
71
inline void PhysxDebugGeomNode::visualize_joint_local_axes(bool value);

1854 26 visualize_joint_world_axes 0 4 3026 46 PhysxDebugGeomNode::visualize_joint_world_axes 0 1 385 10
/**
 *
 */
71
inline void PhysxDebugGeomNode::visualize_joint_world_axes(bool value);

1855 22 visualize_joint_limits 0 4 3026 42 PhysxDebugGeomNode::visualize_joint_limits 0 1 386 10
/**
 *
 */
67
inline void PhysxDebugGeomNode::visualize_joint_limits(bool value);

1856 23 visualize_contact_point 0 4 3026 43 PhysxDebugGeomNode::visualize_contact_point 0 1 387 10
/**
 *
 */
68
inline void PhysxDebugGeomNode::visualize_contact_point(bool value);

1857 24 visualize_contact_normal 0 4 3026 44 PhysxDebugGeomNode::visualize_contact_normal 0 1 388 10
/**
 *
 */
69
inline void PhysxDebugGeomNode::visualize_contact_normal(bool value);

1858 23 visualize_contact_error 0 4 3026 43 PhysxDebugGeomNode::visualize_contact_error 0 1 389 10
/**
 *
 */
68
inline void PhysxDebugGeomNode::visualize_contact_error(bool value);

1859 23 visualize_contact_force 0 4 3026 43 PhysxDebugGeomNode::visualize_contact_force 0 1 390 10
/**
 *
 */
68
inline void PhysxDebugGeomNode::visualize_contact_force(bool value);

1860 20 visualize_actor_axes 0 4 3026 40 PhysxDebugGeomNode::visualize_actor_axes 0 1 391 10
/**
 *
 */
65
inline void PhysxDebugGeomNode::visualize_actor_axes(bool value);

1861 25 visualize_collision_aabbs 0 4 3026 45 PhysxDebugGeomNode::visualize_collision_aabbs 0 1 392 10
/**
 *
 */
70
inline void PhysxDebugGeomNode::visualize_collision_aabbs(bool value);

1862 26 visualize_collision_shapes 0 4 3026 46 PhysxDebugGeomNode::visualize_collision_shapes 0 1 393 10
/**
 *
 */
71
inline void PhysxDebugGeomNode::visualize_collision_shapes(bool value);

1863 24 visualize_collision_axes 0 4 3026 44 PhysxDebugGeomNode::visualize_collision_axes 0 1 394 10
/**
 *
 */
69
inline void PhysxDebugGeomNode::visualize_collision_axes(bool value);

1864 29 visualize_collision_compounds 0 4 3026 49 PhysxDebugGeomNode::visualize_collision_compounds 0 1 395 10
/**
 *
 */
74
inline void PhysxDebugGeomNode::visualize_collision_compounds(bool value);

1865 28 visualize_collision_vnormals 0 4 3026 48 PhysxDebugGeomNode::visualize_collision_vnormals 0 1 396 10
/**
 *
 */
73
inline void PhysxDebugGeomNode::visualize_collision_vnormals(bool value);

1866 28 visualize_collision_fnormals 0 4 3026 48 PhysxDebugGeomNode::visualize_collision_fnormals 0 1 397 10
/**
 *
 */
73
inline void PhysxDebugGeomNode::visualize_collision_fnormals(bool value);

1867 25 visualize_collision_edges 0 4 3026 45 PhysxDebugGeomNode::visualize_collision_edges 0 1 398 10
/**
 *
 */
70
inline void PhysxDebugGeomNode::visualize_collision_edges(bool value);

1868 27 visualize_collision_spheres 0 4 3026 47 PhysxDebugGeomNode::visualize_collision_spheres 0 1 399 10
/**
 *
 */
72
inline void PhysxDebugGeomNode::visualize_collision_spheres(bool value);

1869 26 visualize_collision_static 0 4 3026 46 PhysxDebugGeomNode::visualize_collision_static 0 1 400 10
/**
 *
 */
71
inline void PhysxDebugGeomNode::visualize_collision_static(bool value);

1870 27 visualize_collision_dynamic 0 4 3026 47 PhysxDebugGeomNode::visualize_collision_dynamic 0 1 401 10
/**
 *
 */
72
inline void PhysxDebugGeomNode::visualize_collision_dynamic(bool value);

1871 24 visualize_collision_free 0 4 3026 44 PhysxDebugGeomNode::visualize_collision_free 0 1 402 10
/**
 *
 */
69
inline void PhysxDebugGeomNode::visualize_collision_free(bool value);

1872 23 visualize_collision_ccd 0 4 3026 43 PhysxDebugGeomNode::visualize_collision_ccd 0 1 403 10
/**
 *
 */
68
inline void PhysxDebugGeomNode::visualize_collision_ccd(bool value);

1873 29 visualize_collision_skeletons 0 4 3026 49 PhysxDebugGeomNode::visualize_collision_skeletons 0 1 404 10
/**
 *
 */
74
inline void PhysxDebugGeomNode::visualize_collision_skeletons(bool value);

1874 20 visualize_cloth_mesh 0 4 3026 40 PhysxDebugGeomNode::visualize_cloth_mesh 0 1 405 10
/**
 *
 */
65
inline void PhysxDebugGeomNode::visualize_cloth_mesh(bool value);

1875 27 visualize_cloth_validbounds 0 4 3026 47 PhysxDebugGeomNode::visualize_cloth_validbounds 0 1 406 10
/**
 *
 */
72
inline void PhysxDebugGeomNode::visualize_cloth_validbounds(bool value);

1876 23 visualize_softbody_mesh 0 4 3026 43 PhysxDebugGeomNode::visualize_softbody_mesh 0 1 407 10
/**
 *
 */
68
inline void PhysxDebugGeomNode::visualize_softbody_mesh(bool value);

1877 30 visualize_softbody_validbounds 0 4 3026 50 PhysxDebugGeomNode::visualize_softbody_validbounds 0 1 408 10
/**
 *
 */
75
inline void PhysxDebugGeomNode::visualize_softbody_validbounds(bool value);

1878 22 visualize_force_fields 0 4 3026 42 PhysxDebugGeomNode::visualize_force_fields 0 1 409 10
/**
 *
 */
67
inline void PhysxDebugGeomNode::visualize_force_fields(bool value);

1879 14 get_class_type 0 4 3026 34 PhysxDebugGeomNode::get_class_type 0 1 410 0
59
static TypeHandle PhysxDebugGeomNode::get_class_type(void);

1880 18 PhysxDistanceJoint 0 4 3027 38 PhysxDistanceJoint::PhysxDistanceJoint 0 1 411 10
/**
 *
 */
52
inline PhysxDistanceJoint::PhysxDistanceJoint(void);

1881 12 save_to_desc 0 4 3027 32 PhysxDistanceJoint::save_to_desc 0 1 412 63
/**
 * Saves the state of the joint object to a descriptor.
 */
79
void PhysxDistanceJoint::save_to_desc(PhysxDistanceJointDesc &jointDesc) const;

1882 14 load_from_desc 0 4 3027 34 PhysxDistanceJoint::load_from_desc 0 1 413 84
/**
 * Loads the entire state of the joint from a descriptor with a single call.
 */
81
void PhysxDistanceJoint::load_from_desc(PhysxDistanceJointDesc const &jointDesc);

1883 14 get_class_type 0 4 3027 34 PhysxDistanceJoint::get_class_type 0 1 414 0
59
static TypeHandle PhysxDistanceJoint::get_class_type(void);

1884 15 PhysxFixedJoint 0 4 3028 32 PhysxFixedJoint::PhysxFixedJoint 0 1 415 10
/**
 *
 */
46
inline PhysxFixedJoint::PhysxFixedJoint(void);

1885 12 save_to_desc 0 4 3028 29 PhysxFixedJoint::save_to_desc 0 1 416 63
/**
 * Saves the state of the joint object to a descriptor.
 */
73
void PhysxFixedJoint::save_to_desc(PhysxFixedJointDesc &jointDesc) const;

1886 14 load_from_desc 0 4 3028 31 PhysxFixedJoint::load_from_desc 0 1 417 84
/**
 * Loads the entire state of the joint from a descriptor with a single call.
 */
75
void PhysxFixedJoint::load_from_desc(PhysxFixedJointDesc const &jointDesc);

1887 14 get_class_type 0 4 3028 31 PhysxFixedJoint::get_class_type 0 1 418 0
56
static TypeHandle PhysxFixedJoint::get_class_type(void);

1888 15 PhysxForceField 0 4 3029 32 PhysxForceField::PhysxForceField 0 1 419 10
/**
 *
 */
46
inline PhysxForceField::PhysxForceField(void);

1889 8 set_name 0 4 3029 25 PhysxForceField::set_name 0 1 420 10
/**
 *
 */
49
void PhysxForceField::set_name(char const *name);

1890 8 get_name 0 4 3029 25 PhysxForceField::get_name 0 1 421 10
/**
 *
 */
50
char const *PhysxForceField::get_name(void) const;

1891 9 get_scene 0 4 3029 26 PhysxForceField::get_scene 0 1 422 10
/**
 *
 */
51
PhysxScene *PhysxForceField::get_scene(void) const;

1892 23 get_include_shape_group 0 4 3029 40 PhysxForceField::get_include_shape_group 0 1 423 10
/**
 *
 */
80
PhysxForceFieldShapeGroup *PhysxForceField::get_include_shape_group(void) const;

1893 20 get_num_shape_groups 0 4 3029 37 PhysxForceField::get_num_shape_groups 0 1 424 10
/**
 *
 */
63
unsigned int PhysxForceField::get_num_shape_groups(void) const;

1894 15 get_shape_group 0 4 3029 32 PhysxForceField::get_shape_group 0 1 425 10
/**
 *
 */
84
PhysxForceFieldShapeGroup *PhysxForceField::get_shape_group(unsigned int idx) const;

1895 7 release 0 4 3029 24 PhysxForceField::release 0 1 426 10
/**
 *
 */
36
void PhysxForceField::release(void);

1896 14 get_class_type 0 4 3029 31 PhysxForceField::get_class_type 0 1 427 0
56
static TypeHandle PhysxForceField::get_class_type(void);

1897 21 upcast_to_PhysxObject 0 12 3030 48 PhysxForceFieldShapeGroup::upcast_to_PhysxObject 0 1 441 52
upcast from PhysxForceFieldShapeGroup to PhysxObject
68
PhysxObject *PhysxForceFieldShapeGroup::upcast_to_PhysxObject(void);

1898 37 downcast_to_PhysxForceFieldShapeGroup 0 12 2996 50 PhysxObject::downcast_to_PhysxForceFieldShapeGroup 0 1 442 54
downcast from PhysxObject to PhysxForceFieldShapeGroup
84
PhysxForceFieldShapeGroup *PhysxObject::downcast_to_PhysxForceFieldShapeGroup(void);

1899 20 upcast_to_PhysxEnums 0 12 3030 47 PhysxForceFieldShapeGroup::upcast_to_PhysxEnums 0 1 443 51
upcast from PhysxForceFieldShapeGroup to PhysxEnums
66
PhysxEnums *PhysxForceFieldShapeGroup::upcast_to_PhysxEnums(void);

1900 37 downcast_to_PhysxForceFieldShapeGroup 0 12 2965 49 PhysxEnums::downcast_to_PhysxForceFieldShapeGroup 0 1 444 53
downcast from PhysxEnums to PhysxForceFieldShapeGroup
83
PhysxForceFieldShapeGroup *PhysxEnums::downcast_to_PhysxForceFieldShapeGroup(void);

1901 25 PhysxForceFieldShapeGroup 0 4 3030 52 PhysxForceFieldShapeGroup::PhysxForceFieldShapeGroup 0 1 428 10
/**
 *
 */
66
inline PhysxForceFieldShapeGroup::PhysxForceFieldShapeGroup(void);

1902 26 ~PhysxForceFieldShapeGroup 0 6 3030 53 PhysxForceFieldShapeGroup::~PhysxForceFieldShapeGroup 0 0 10
/**
 *
 */
75
virtual inline PhysxForceFieldShapeGroup::~PhysxForceFieldShapeGroup(void);

1903 12 save_to_desc 0 4 3030 39 PhysxForceFieldShapeGroup::save_to_desc 0 1 429 82
/**
 * Saves the state of the force field shape group object to a  descriptor.
 */
93
void PhysxForceFieldShapeGroup::save_to_desc(PhysxForceFieldShapeGroupDesc &groupDesc) const;

1904 9 get_scene 0 4 3030 36 PhysxForceFieldShapeGroup::get_scene 0 1 430 68
/**
 * Returns the scene that owns this force field shape group.
 */
61
PhysxScene *PhysxForceFieldShapeGroup::get_scene(void) const;

1905 15 get_force_field 0 4 3030 42 PhysxForceFieldShapeGroup::get_force_field 0 1 431 111
/**
 * Returns the force field of this group if this is an include group.  If not
 * NULL will be returned.
 */
72
PhysxForceField *PhysxForceFieldShapeGroup::get_force_field(void) const;

1906 8 get_name 0 4 3030 35 PhysxForceFieldShapeGroup::get_name 0 1 432 35
/**
 * Returns the name string.
 */
60
char const *PhysxForceFieldShapeGroup::get_name(void) const;

1907 8 set_name 0 4 3030 35 PhysxForceFieldShapeGroup::set_name 0 1 433 139
/**
 * Sets a name string for the object that can be retrieved with get_name().
 * This is for debugging and is not used by the engine.
 */
59
void PhysxForceFieldShapeGroup::set_name(char const *name);

1908 14 get_num_shapes 0 4 3030 41 PhysxForceFieldShapeGroup::get_num_shapes 0 1 434 102
// Shapes

// Shapes

/**
 * Returns the number of shapes assigned to the force field shape group.
 */
67
unsigned int PhysxForceFieldShapeGroup::get_num_shapes(void) const;

1909 12 create_shape 0 4 3030 39 PhysxForceFieldShapeGroup::create_shape 0 1 435 64
/**
 * Creates a force field shape and adds it to the group.
 */
94
PhysxForceFieldShape *PhysxForceFieldShapeGroup::create_shape(PhysxForceFieldShapeDesc &desc);

1910 9 get_shape 0 4 3030 36 PhysxForceFieldShapeGroup::get_shape 0 1 436 59
/**
 * Returns the i-th shape in the force field group.
 */
83
PhysxForceFieldShape *PhysxForceFieldShapeGroup::get_shape(unsigned int idx) const;

1911 7 release 0 4 3030 34 PhysxForceFieldShapeGroup::release 0 1 437 42
/**
 * Releases the force field shape.
 */
46
void PhysxForceFieldShapeGroup::release(void);

1912 2 ls 0 6 3030 29 PhysxForceFieldShapeGroup::ls 0 2 438 439 22
/**
 *
 */

/**
 *
 */
155
virtual inline void PhysxForceFieldShapeGroup::ls(void) const;
virtual inline void PhysxForceFieldShapeGroup::ls(ostream &out, int indent_level = 0) const;

1913 14 get_class_type 0 4 3030 41 PhysxForceFieldShapeGroup::get_class_type 0 1 440 0
66
static TypeHandle PhysxForceFieldShapeGroup::get_class_type(void);

1914 7 release 0 4 3031 25 PhysxHeightField::release 0 1 445 10
/**
 *
 */
37
void PhysxHeightField::release(void);

1915 19 get_reference_count 0 4 3031 37 PhysxHeightField::get_reference_count 0 1 446 57
/**
 * Returns the reference count for shared meshes.
 */
63
unsigned int PhysxHeightField::get_reference_count(void) const;

1916 10 get_height 0 4 3031 28 PhysxHeightField::get_height 0 1 447 10
/**
 *
 */
59
float PhysxHeightField::get_height(float x, float y) const;

1917 14 get_class_type 0 4 3031 32 PhysxHeightField::get_class_type 0 1 448 0
57
static TypeHandle PhysxHeightField::get_class_type(void);

1918 21 PhysxHeightFieldShape 0 4 3032 44 PhysxHeightFieldShape::PhysxHeightFieldShape 0 1 449 10
/**
 *
 */
58
inline PhysxHeightFieldShape::PhysxHeightFieldShape(void);

1919 12 save_to_desc 0 4 3032 35 PhysxHeightFieldShape::save_to_desc 0 1 450 63
/**
 * Saves the state of the shape object to a descriptor.
 */
85
void PhysxHeightFieldShape::save_to_desc(PhysxHeightFieldShapeDesc &shapeDesc) const;

1920 14 get_class_type 0 4 3032 37 PhysxHeightFieldShape::get_class_type 0 1 451 0
62
static TypeHandle PhysxHeightFieldShape::get_class_type(void);

1921 21 upcast_to_PhysxObject 0 12 3033 36 PhysxMaterial::upcast_to_PhysxObject 0 1 479 40
upcast from PhysxMaterial to PhysxObject
56
PhysxObject *PhysxMaterial::upcast_to_PhysxObject(void);

1922 25 downcast_to_PhysxMaterial 0 12 2996 38 PhysxObject::downcast_to_PhysxMaterial 0 1 480 42
downcast from PhysxObject to PhysxMaterial
60
PhysxMaterial *PhysxObject::downcast_to_PhysxMaterial(void);

1923 20 upcast_to_PhysxEnums 0 12 3033 35 PhysxMaterial::upcast_to_PhysxEnums 0 1 481 39
upcast from PhysxMaterial to PhysxEnums
54
PhysxEnums *PhysxMaterial::upcast_to_PhysxEnums(void);

1924 25 downcast_to_PhysxMaterial 0 12 2965 37 PhysxEnums::downcast_to_PhysxMaterial 0 1 482 41
downcast from PhysxEnums to PhysxMaterial
59
PhysxMaterial *PhysxEnums::downcast_to_PhysxMaterial(void);

1925 13 PhysxMaterial 0 4 3033 28 PhysxMaterial::PhysxMaterial 0 1 452 10
/**
 *
 */
42
inline PhysxMaterial::PhysxMaterial(void);

1926 14 ~PhysxMaterial 0 6 3033 29 PhysxMaterial::~PhysxMaterial 0 0 10
/**
 *
 */
51
virtual inline PhysxMaterial::~PhysxMaterial(void);

1927 9 get_scene 0 4 3033 24 PhysxMaterial::get_scene 0 1 453 53
/**
 * Returns the scene that owns this material.
 */
49
PhysxScene *PhysxMaterial::get_scene(void) const;

1928 18 get_material_index 0 4 3033 33 PhysxMaterial::get_material_index 0 1 454 342
/**
 * Returns the material index for this material.
 *
 * Materials are associated with mesh faces and shapes using material index
 * identifiers.
 *
 * If you release a material while its material index is still in use by
 * shapes or meshes, the material usage of these objects becomes undefined as
 * the material index gets recycled.
 */
65
unsigned short int PhysxMaterial::get_material_index(void) const;

1929 14 load_from_desc 0 4 3033 29 PhysxMaterial::load_from_desc 0 1 455 90
/**
 * Loads the entire state of the material from a descriptor with a single
 * call.
 */
74
void PhysxMaterial::load_from_desc(PhysxMaterialDesc const &materialDesc);

1930 12 save_to_desc 0 4 3033 27 PhysxMaterial::save_to_desc 0 1 456 66
/**
 * Saves the state of the material object to a descriptor.
 */
72
void PhysxMaterial::save_to_desc(PhysxMaterialDesc &materialDesc) const;

1931 20 set_dynamic_friction 0 4 3033 35 PhysxMaterial::set_dynamic_friction 0 1 457 340
/**
 * Sets the coefficient of dynamic friction.  The coefficient of dynamic
 * friction should be in [0, +inf]. If set to greater than staticFriction, the
 * effective value of staticFriction will be increased to match.  If the flag
 * MF_anisotropic is set, then this value is used for the primary direction of
 * anisotropy (U axis).
 */
53
void PhysxMaterial::set_dynamic_friction(float coef);

1932 19 set_static_friction 0 4 3033 34 PhysxMaterial::set_static_friction 0 1 458 239
/**
 * Sets the coefficient of static friction.  The coefficient of static
 * friction should be in the range [0, +inf]. If the flag MF_anisotropic is
 * set, then this value is used for the primary direction of anisotropy (U
 * axis).
 */
52
void PhysxMaterial::set_static_friction(float coef);

1933 15 set_restitution 0 4 3033 30 PhysxMaterial::set_restitution 0 1 459 167
/**
 * Sets the coefficient of restitution.  A coefficient of 0 makes the object
 * bounce as little as possible, higher values up to 1.0 result in more
 * bounce.
 */
48
void PhysxMaterial::set_restitution(float rest);

1934 22 set_dynamic_friction_v 0 4 3033 37 PhysxMaterial::set_dynamic_friction_v 0 1 460 181
/**
 * Sets the dynamic friction coefficient along the secondary (V) axis.  This
 * is used when anisotropic friction is being applied.  I.e.  the flag
 * MF_anisotropic is set.
 */
55
void PhysxMaterial::set_dynamic_friction_v(float coef);

1935 21 set_static_friction_v 0 4 3033 36 PhysxMaterial::set_static_friction_v 0 1 461 180
/**
 * Sets the static friction coefficient along the secondary (V) axis.  This is
 * used when anisotropic friction is being applied.  I.e.  the flag
 * MF_anisotropic is set.
 */
54
void PhysxMaterial::set_static_friction_v(float coef);

1936 21 set_dir_of_anisotropy 0 4 3033 36 PhysxMaterial::set_dir_of_anisotropy 0 1 462 127
/**
 * Sets the shape space direction (unit vector) of anisotropy.  This is only
 * used if the flag MF_anisotropic is set.
 */
63
void PhysxMaterial::set_dir_of_anisotropy(LVector3f const dir);

1937 8 set_flag 0 4 3033 23 PhysxMaterial::set_flag 0 1 463 43
/**
 * Sets the value of a single flag.
 */
77
void PhysxMaterial::set_flag(PhysxEnums::PhysxMaterialFlag flag, bool value);

1938 25 set_friction_combine_mode 0 4 3033 40 PhysxMaterial::set_friction_combine_mode 0 1 464 176
/**
 * Sets the friction combine mode.  - CM_average : Average: (a + b)/2. -
 * CM_min : Minimum: min(a,b). - CM_multiply : Multiply: a*b.  - CM_max :
 * Maximum: max(a,b).
 */
81
void PhysxMaterial::set_friction_combine_mode(PhysxEnums::PhysxCombineMode mode);

1939 28 set_restitution_combine_mode 0 4 3033 43 PhysxMaterial::set_restitution_combine_mode 0 1 465 179
/**
 * Sets the restitution combine mode.  - CM_average : Average: (a + b)/2. -
 * CM_min : Minimum: min(a,b). - CM_multiply : Multiply: a*b.  - CM_max :
 * Maximum: max(a,b).
 */
84
void PhysxMaterial::set_restitution_combine_mode(PhysxEnums::PhysxCombineMode mode);

1940 20 get_dynamic_friction 0 4 3033 35 PhysxMaterial::get_dynamic_friction 0 1 466 45
/**
 * Returns the DynamicFriction value.
 */
54
float PhysxMaterial::get_dynamic_friction(void) const;

1941 19 get_static_friction 0 4 3033 34 PhysxMaterial::get_static_friction 0 1 467 54
/**
 * Returns the coefficient of static friction.
 */
53
float PhysxMaterial::get_static_friction(void) const;

1942 15 get_restitution 0 4 3033 30 PhysxMaterial::get_restitution 0 1 468 50
/**
 * Returns the coefficient of restitution.
 */
49
float PhysxMaterial::get_restitution(void) const;

1943 22 get_dynamic_friction_v 0 4 3033 37 PhysxMaterial::get_dynamic_friction_v 0 1 469 72
/**
 * Returns the dynamic friction coefficient for the V direction.
 */
56
float PhysxMaterial::get_dynamic_friction_v(void) const;

1944 21 get_static_friction_v 0 4 3033 36 PhysxMaterial::get_static_friction_v 0 1 470 71
/**
 * Returns the static friction coefficient for the V direction.
 */
55
float PhysxMaterial::get_static_friction_v(void) const;

1945 21 get_dir_of_anisotropy 0 4 3033 36 PhysxMaterial::get_dir_of_anisotropy 0 1 471 53
/**
 * Returns the direction of anisotropy value.
 */
59
LVector3f PhysxMaterial::get_dir_of_anisotropy(void) const;

1946 8 get_flag 0 4 3033 23 PhysxMaterial::get_flag 0 1 472 46
/**
 * Returns the value of a single flag.
 */
71
bool PhysxMaterial::get_flag(PhysxEnums::PhysxMaterialFlag flag) const;

1947 25 get_friction_combine_mode 0 4 3033 40 PhysxMaterial::get_friction_combine_mode 0 1 473 45
/**
 * Returns the friction combine mode.
 */
82
PhysxEnums::PhysxCombineMode PhysxMaterial::get_friction_combine_mode(void) const;

1948 28 get_restitution_combine_mode 0 4 3033 43 PhysxMaterial::get_restitution_combine_mode 0 1 474 48
/**
 * Returns the restitution combine mode.
 */
85
PhysxEnums::PhysxCombineMode PhysxMaterial::get_restitution_combine_mode(void) const;

1949 2 ls 0 6 3033 17 PhysxMaterial::ls 0 2 475 476 22
/**
 *
 */

/**
 *
 */
131
virtual inline void PhysxMaterial::ls(void) const;
virtual inline void PhysxMaterial::ls(ostream &out, int indent_level = 0) const;

1950 7 release 0 4 3033 22 PhysxMaterial::release 0 1 477 10
/**
 *
 */
34
void PhysxMaterial::release(void);

1951 14 get_class_type 0 4 3033 29 PhysxMaterial::get_class_type 0 1 478 0
54
static TypeHandle PhysxMaterial::get_class_type(void);

1952 15 PhysxPlaneShape 0 4 3034 32 PhysxPlaneShape::PhysxPlaneShape 0 1 483 10
/**
 *
 */
46
inline PhysxPlaneShape::PhysxPlaneShape(void);

1953 12 save_to_desc 0 4 3034 29 PhysxPlaneShape::save_to_desc 0 1 484 63
/**
 * Saves the state of the shape object to a descriptor.
 */
73
void PhysxPlaneShape::save_to_desc(PhysxPlaneShapeDesc &shapeDesc) const;

1954 9 set_plane 0 4 3034 26 PhysxPlaneShape::set_plane 0 1 485 189
/**
 * Sets the plane equation.  - normal:  Normal for the plane, in the global
 * frame.  Range: direction vector - d: Distance coefficient of the plane
 * equation.  Range: (-inf,inf)
 */
66
void PhysxPlaneShape::set_plane(LVector3f const &normal, float d);

1955 14 get_class_type 0 4 3034 31 PhysxPlaneShape::get_class_type 0 1 486 0
56
static TypeHandle PhysxPlaneShape::get_class_type(void);

1956 22 PhysxPointInPlaneJoint 0 4 3035 46 PhysxPointInPlaneJoint::PhysxPointInPlaneJoint 0 1 487 10
/**
 *
 */
60
inline PhysxPointInPlaneJoint::PhysxPointInPlaneJoint(void);

1957 12 save_to_desc 0 4 3035 36 PhysxPointInPlaneJoint::save_to_desc 0 1 488 63
/**
 * Saves the state of the joint object to a descriptor.
 */
87
void PhysxPointInPlaneJoint::save_to_desc(PhysxPointInPlaneJointDesc &jointDesc) const;

1958 14 load_from_desc 0 4 3035 38 PhysxPointInPlaneJoint::load_from_desc 0 1 489 84
/**
 * Loads the entire state of the joint from a descriptor with a single call.
 */
89
void PhysxPointInPlaneJoint::load_from_desc(PhysxPointInPlaneJointDesc const &jointDesc);

1959 14 get_class_type 0 4 3035 38 PhysxPointInPlaneJoint::get_class_type 0 1 490 0
63
static TypeHandle PhysxPointInPlaneJoint::get_class_type(void);

1960 21 PhysxPointOnLineJoint 0 4 3036 44 PhysxPointOnLineJoint::PhysxPointOnLineJoint 0 1 491 10
/**
 *
 */
58
inline PhysxPointOnLineJoint::PhysxPointOnLineJoint(void);

1961 12 save_to_desc 0 4 3036 35 PhysxPointOnLineJoint::save_to_desc 0 1 492 63
/**
 * Saves the state of the joint object to a descriptor.
 */
85
void PhysxPointOnLineJoint::save_to_desc(PhysxPointOnLineJointDesc &jointDesc) const;

1962 14 load_from_desc 0 4 3036 37 PhysxPointOnLineJoint::load_from_desc 0 1 493 84
/**
 * Loads the entire state of the joint from a descriptor with a single call.
 */
87
void PhysxPointOnLineJoint::load_from_desc(PhysxPointOnLineJointDesc const &jointDesc);

1963 14 get_class_type 0 4 3036 37 PhysxPointOnLineJoint::get_class_type 0 1 494 0
62
static TypeHandle PhysxPointOnLineJoint::get_class_type(void);

1964 19 PhysxPrismaticJoint 0 4 3037 40 PhysxPrismaticJoint::PhysxPrismaticJoint 0 1 495 10
/**
 *
 */
54
inline PhysxPrismaticJoint::PhysxPrismaticJoint(void);

1965 12 save_to_desc 0 4 3037 33 PhysxPrismaticJoint::save_to_desc 0 1 496 63
/**
 * Saves the state of the joint object to a descriptor.
 */
81
void PhysxPrismaticJoint::save_to_desc(PhysxPrismaticJointDesc &jointDesc) const;

1966 14 load_from_desc 0 4 3037 35 PhysxPrismaticJoint::load_from_desc 0 1 497 84
/**
 * Loads the entire state of the joint from a descriptor with a single call.
 */
83
void PhysxPrismaticJoint::load_from_desc(PhysxPrismaticJointDesc const &jointDesc);

1967 14 get_class_type 0 4 3037 35 PhysxPrismaticJoint::get_class_type 0 1 498 0
60
static TypeHandle PhysxPrismaticJoint::get_class_type(void);

1968 16 PhysxPulleyJoint 0 4 3038 34 PhysxPulleyJoint::PhysxPulleyJoint 0 1 499 10
/**
 *
 */
48
inline PhysxPulleyJoint::PhysxPulleyJoint(void);

1969 12 save_to_desc 0 4 3038 30 PhysxPulleyJoint::save_to_desc 0 1 500 63
/**
 * Saves the state of the joint object to a descriptor.
 */
75
void PhysxPulleyJoint::save_to_desc(PhysxPulleyJointDesc &jointDesc) const;

1970 14 load_from_desc 0 4 3038 32 PhysxPulleyJoint::load_from_desc 0 1 501 84
/**
 * Loads the entire state of the joint from a descriptor with a single call.
 */
77
void PhysxPulleyJoint::load_from_desc(PhysxPulleyJointDesc const &jointDesc);

1971 9 set_motor 0 4 3038 27 PhysxPulleyJoint::set_motor 0 1 502 1037
/**
 * Sets motor parameters for the joint.
 *
 * For a positive velTarget, the motor pulls the first body towards its
 * pulley, for a negative velTarget, the motor pulls the second body towards
 * its pulley.
 *
 * velTarget - the relative velocity the motor is trying to achieve.  The
 * motor will only be able to reach this velocity if the maxForce is
 * sufficiently large.  If the joint is moving faster than this velocity, the
 * motor will actually try to brake.  If you set this to infinity then the
 * motor will keep speeding up, unless there is some sort of resistance on the
 * attached bodies.
 *
 * maxForce - the maximum force the motor can exert.  Zero disables the motor.
 * Default is 0, should be >= 0. Setting this to a very large value if
 * velTarget is also very large may not be a good idea.
 *
 * freeSpin - if this flag is set, and if the joint is moving faster than
 * velTarget, then neither braking nor additional acceleration will result.
 * default: false.
 *
 * This automatically enables the motor.
 */
62
void PhysxPulleyJoint::set_motor(PhysxMotorDesc const &motor);

1972 8 set_flag 0 4 3038 26 PhysxPulleyJoint::set_flag 0 1 503 52
/**
 * Sets or clear a single pulley joint flag.
 */
83
void PhysxPulleyJoint::set_flag(PhysxEnums::PhysxPulleyJointFlag flag, bool value);

1973 8 get_flag 0 4 3038 26 PhysxPulleyJoint::get_flag 0 1 504 59
/**
 * Retrieves the value of a single PulleyJointFlag.
 */
77
bool PhysxPulleyJoint::get_flag(PhysxEnums::PhysxPulleyJointFlag flag) const;

1974 9 get_motor 0 4 3038 27 PhysxPulleyJoint::get_motor 0 1 505 10
/**
 *
 */
55
PhysxMotorDesc PhysxPulleyJoint::get_motor(void) const;

1975 14 get_class_type 0 4 3038 32 PhysxPulleyJoint::get_class_type 0 1 506 0
57
static TypeHandle PhysxPulleyJoint::get_class_type(void);

1976 18 PhysxRevoluteJoint 0 4 3039 38 PhysxRevoluteJoint::PhysxRevoluteJoint 0 1 507 10
/**
 *
 */
52
inline PhysxRevoluteJoint::PhysxRevoluteJoint(void);

1977 12 save_to_desc 0 4 3039 32 PhysxRevoluteJoint::save_to_desc 0 1 508 63
/**
 * Saves the state of the joint object to a descriptor.
 */
79
void PhysxRevoluteJoint::save_to_desc(PhysxRevoluteJointDesc &jointDesc) const;

1978 14 load_from_desc 0 4 3039 34 PhysxRevoluteJoint::load_from_desc 0 1 509 84
/**
 * Loads the entire state of the joint from a descriptor with a single call.
 */
81
void PhysxRevoluteJoint::load_from_desc(PhysxRevoluteJointDesc const &jointDesc);

1979 10 set_spring 0 4 3039 30 PhysxRevoluteJoint::set_spring 0 1 510 886
/**
 * Sets spring parameters.
 *
 * The spring is implicitly integrated so no instability should result for
 * arbitrary spring and damping constants.  Using these settings together with
 * a motor is not possible -- the motor will have priority and the spring
 * settings are ignored.  If you would like to simulate your motor's internal
 * friction, do this by altering the motor parameters directly.
 *
 * spring - The rotational spring acts along the hinge axis and tries to force
 * the joint angle to zero.  A setting of zero disables the spring.  Default
 * is 0, should be >= 0.
 *
 * damper - Damping coefficient; acts against the hinge's angular velocity.  A
 * setting of zero disables the damping.  The default is 0, should be >= 0.
 *
 * targetValue - The angle at which the spring is relaxed.  In [-Pi,Pi].
 * Default is 0.
 *
 * This automatically enables the spring
 */
67
void PhysxRevoluteJoint::set_spring(PhysxSpringDesc const &spring);

1980 9 set_motor 0 4 3039 29 PhysxRevoluteJoint::set_motor 0 1 511 1037
/**
 * Sets motor parameters for the joint.
 *
 * For a positive velTarget, the motor pulls the first body towards its
 * pulley, for a negative velTarget, the motor pulls the second body towards
 * its pulley.
 *
 * velTarget - the relative velocity the motor is trying to achieve.  The
 * motor will only be able to reach this velocity if the maxForce is
 * sufficiently large.  If the joint is moving faster than this velocity, the
 * motor will actually try to brake.  If you set this to infinity then the
 * motor will keep speeding up, unless there is some sort of resistance on the
 * attached bodies.
 *
 * maxForce - the maximum force the motor can exert.  Zero disables the motor.
 * Default is 0, should be >= 0. Setting this to a very large value if
 * velTarget is also very large may not be a good idea.
 *
 * freeSpin - if this flag is set, and if the joint is moving faster than
 * velTarget, then neither braking nor additional acceleration will result.
 * default: false.
 *
 * This automatically enables the motor.
 */
64
void PhysxRevoluteJoint::set_motor(PhysxMotorDesc const &motor);

1981 10 set_limits 0 4 3039 30 PhysxRevoluteJoint::set_limits 0 1 512 916
/**
 * Sets angular joint limits.
 *
 * If either of these limits are set, any planar limits in PhysxJoint are
 * ignored.  The limits are angles defined the same way as the values that
 * get_angle() returns.
 *
 * The following has to hold:
 *
 * Pi < lowAngle < highAngle < Pi Both limits are disabled by default.  Also
 * sets coefficients of restitutions for the low and high angular limits.
 * These settings are only used if valid limits are set using set_limits().
 * These restitution coefficients work the same way as for contacts.
 *
 * The coefficient of restitution determines whether a collision with the
 * joint limit is completely elastic (like pool balls, restitution = 1, no
 * energy is lost in the collision), completely inelastic (like putty,
 * restitution = 0, no rebound after collision) or somewhere in between.  The
 * default is 0 for both.
 *
 * This automatically enables the limit.
 */
101
void PhysxRevoluteJoint::set_limits(PhysxJointLimitDesc const &low, PhysxJointLimitDesc const &high);

1982 8 set_flag 0 4 3039 28 PhysxRevoluteJoint::set_flag 0 1 513 53
/**
 * Sets or clears a single RevoluteJointFlag.
 */
87
void PhysxRevoluteJoint::set_flag(PhysxEnums::PhysxRevoluteJointFlag flag, bool value);

1983 19 set_projection_mode 0 4 3039 39 PhysxRevoluteJoint::set_projection_mode 0 1 514 42
/**
 * Sets the joint projection mode.
 */
83
void PhysxRevoluteJoint::set_projection_mode(PhysxEnums::PhysxProjectionMode mode);

1984 9 get_angle 0 4 3039 29 PhysxRevoluteJoint::get_angle 0 1 515 411
/**
 * Retrieves the current revolute joint angle.
 *
 * The relative orientation of the bodies is stored when the joint is created,
 * or when set_axis() or set_anchor() is called.  This initial orientation
 * returns an angle of zero, and joint angles are measured relative to this
 * pose.  The angle is in the range [-180, 180], with positive angles CCW
 * around the axis, measured from body2 to body1.
 */
48
float PhysxRevoluteJoint::get_angle(void) const;

1985 12 get_velocity 0 4 3039 32 PhysxRevoluteJoint::get_velocity 0 1 516 159
/**
 * Retrieves the revolute joint angle's rate of change (angular velocity). It
 * is the angular velocity of body1 minus body2 projected along the axis.
 */
51
float PhysxRevoluteJoint::get_velocity(void) const;

1986 8 get_flag 0 4 3039 28 PhysxRevoluteJoint::get_flag 0 1 517 59
/**
 * Returns the value of a single RevoluteJointFlag.
 */
81
bool PhysxRevoluteJoint::get_flag(PhysxEnums::PhysxRevoluteJointFlag flag) const;

1987 19 get_projection_mode 0 4 3039 39 PhysxRevoluteJoint::get_projection_mode 0 1 518 48
/**
 * Retrieves the joints projection mode.
 */
84
PhysxEnums::PhysxProjectionMode PhysxRevoluteJoint::get_projection_mode(void) const;

1988 9 get_motor 0 4 3039 29 PhysxRevoluteJoint::get_motor 0 1 519 10
/**
 *
 */
57
PhysxMotorDesc PhysxRevoluteJoint::get_motor(void) const;

1989 10 get_spring 0 4 3039 30 PhysxRevoluteJoint::get_spring 0 1 520 10
/**
 *
 */
59
PhysxSpringDesc PhysxRevoluteJoint::get_spring(void) const;

1990 14 get_class_type 0 4 3039 34 PhysxRevoluteJoint::get_class_type 0 1 521 0
59
static TypeHandle PhysxRevoluteJoint::get_class_type(void);

1991 31 upcast_to_PhysxUserEntityReport 0 12 3040 51 PhysxOverlapReport::upcast_to_PhysxUserEntityReport 0 0 55
upcast from PhysxOverlapReport to PhysxUserEntityReport
81
PhysxUserEntityReport *PhysxOverlapReport::upcast_to_PhysxUserEntityReport(void);

1992 30 downcast_to_PhysxOverlapReport 0 12 3041 53 PhysxUserEntityReport::downcast_to_PhysxOverlapReport 0 0 57
downcast from PhysxUserEntityReport to PhysxOverlapReport
80
PhysxOverlapReport *PhysxUserEntityReport::downcast_to_PhysxOverlapReport(void);

1993 16 get_num_overlaps 0 4 3040 36 PhysxOverlapReport::get_num_overlaps 0 1 523 10
/**
 *
 */
62
unsigned int PhysxOverlapReport::get_num_overlaps(void) const;

1994 17 get_first_overlap 0 4 3040 37 PhysxOverlapReport::get_first_overlap 0 1 524 10
/**
 *
 */
56
PhysxShape *PhysxOverlapReport::get_first_overlap(void);

1995 16 get_next_overlap 0 4 3040 36 PhysxOverlapReport::get_next_overlap 0 1 525 10
/**
 *
 */
55
PhysxShape *PhysxOverlapReport::get_next_overlap(void);

1996 11 get_overlap 0 4 3040 31 PhysxOverlapReport::get_overlap 0 1 526 10
/**
 *
 */
62
PhysxShape *PhysxOverlapReport::get_overlap(unsigned int idx);

1997 19 ~PhysxOverlapReport 0 4 3040 39 PhysxOverlapReport::~PhysxOverlapReport 0 0 10
/**
 *
 */
53
inline PhysxOverlapReport::~PhysxOverlapReport(void);

1998 18 PhysxOverlapReport 0 4 3040 38 PhysxOverlapReport::PhysxOverlapReport 0 1 522 10
/**
 *
 */
84
inline PhysxOverlapReport::PhysxOverlapReport(PhysxOverlapReport const &) = default;

1999 9 PhysxMask 0 4 3042 20 PhysxMask::PhysxMask 0 2 527 528 10
/**
 *
 */
92
inline PhysxMask::PhysxMask(void);
inline PhysxMask::PhysxMask(PhysxMask const &) = default;

2000 10 ~PhysxMask 0 4 3042 21 PhysxMask::~PhysxMask 0 0 10
/**
 *
 */
35
inline PhysxMask::~PhysxMask(void);

2001 7 set_bit 0 4 3042 18 PhysxMask::set_bit 0 1 529 68
/**
 * Sets the nth bit on.  Index must be in the range [0, 31].
 */
42
void PhysxMask::set_bit(unsigned int idx);

2002 9 clear_bit 0 4 3042 20 PhysxMask::clear_bit 0 1 530 69
/**
 * Sets the nth bit off.  Index must be in the range [0, 31].
 */
44
void PhysxMask::clear_bit(unsigned int idx);

2003 7 get_bit 0 4 3042 18 PhysxMask::get_bit 0 1 531 110
/**
 * Returns true if the nth bit is set, false if it is cleared.  Index must be
 * in the range [0, 31].
 */
48
bool PhysxMask::get_bit(unsigned int idx) const;

2004 6 output 0 4 3042 17 PhysxMask::output 0 1 532 64
/**
 * Writes the PhysxMask out as a list of ones and zeros.
 */
43
void PhysxMask::output(ostream &out) const;

2005 6 all_on 0 4 3042 17 PhysxMask::all_on 0 1 533 53
/**
 * Returns a PhysxMask whose bits are all on.
 */
41
static PhysxMask PhysxMask::all_on(void);

2006 7 all_off 0 4 3042 18 PhysxMask::all_off 0 1 534 54
/**
 * Returns a PhysxMask whose bits are all off.
 */
42
static PhysxMask PhysxMask::all_off(void);

2007 15 PhysxGroupsMask 0 4 3043 32 PhysxGroupsMask::PhysxGroupsMask 0 3 535 536 537 22
/**
 *
 */

/**
 *
 */
182
inline PhysxGroupsMask::PhysxGroupsMask(void);
inline PhysxGroupsMask::PhysxGroupsMask(NxGroupsMask mask);
inline PhysxGroupsMask::PhysxGroupsMask(PhysxGroupsMask const &) = default;

2008 16 ~PhysxGroupsMask 0 4 3043 33 PhysxGroupsMask::~PhysxGroupsMask 0 0 10
/**
 *
 */
47
inline PhysxGroupsMask::~PhysxGroupsMask(void);

2009 7 set_bit 0 4 3043 24 PhysxGroupsMask::set_bit 0 1 538 69
/**
 * Sets the nth bit on.  Index must be in the range [0, 127].
 */
48
void PhysxGroupsMask::set_bit(unsigned int idx);

2010 9 clear_bit 0 4 3043 26 PhysxGroupsMask::clear_bit 0 1 539 70
/**
 * Sets the nth bit off.  Index must be in the range [0, 127].
 */
50
void PhysxGroupsMask::clear_bit(unsigned int idx);

2011 7 get_bit 0 4 3043 24 PhysxGroupsMask::get_bit 0 1 540 111
/**
 * Returns true if the nth bit is set, false if it is cleared.  Index must be
 * in the range [0, 127].
 */
54
bool PhysxGroupsMask::get_bit(unsigned int idx) const;

2012 6 output 0 4 3043 23 PhysxGroupsMask::output 0 1 541 70
/**
 * Writes the PhysxGroupsMask out as a list of ones and zeros.
 */
49
void PhysxGroupsMask::output(ostream &out) const;

2013 6 all_on 0 4 3043 23 PhysxGroupsMask::all_on 0 1 542 59
/**
 * Returns a PhysxGroupsMask whose bits are all on.
 */
53
static PhysxGroupsMask PhysxGroupsMask::all_on(void);

2014 7 all_off 0 4 3043 24 PhysxGroupsMask::all_off 0 1 543 60
/**
 * Returns a PhysxGroupsMask whose bits are all off.
 */
54
static PhysxGroupsMask PhysxGroupsMask::all_off(void);

2015 9 get_bits0 0 4 3043 26 PhysxGroupsMask::get_bits0 0 1 544 10
/**
 *
 */
59
inline unsigned int PhysxGroupsMask::get_bits0(void) const;

2016 9 get_bits1 0 4 3043 26 PhysxGroupsMask::get_bits1 0 1 545 10
/**
 *
 */
59
inline unsigned int PhysxGroupsMask::get_bits1(void) const;

2017 9 get_bits2 0 4 3043 26 PhysxGroupsMask::get_bits2 0 1 546 10
/**
 *
 */
59
inline unsigned int PhysxGroupsMask::get_bits2(void) const;

2018 9 get_bits3 0 4 3043 26 PhysxGroupsMask::get_bits3 0 1 547 10
/**
 *
 */
59
inline unsigned int PhysxGroupsMask::get_bits3(void) const;

2019 9 set_bits0 0 4 3043 26 PhysxGroupsMask::set_bits0 0 1 548 10
/**
 *
 */
58
inline void PhysxGroupsMask::set_bits0(unsigned int bits);

2020 9 set_bits1 0 4 3043 26 PhysxGroupsMask::set_bits1 0 1 549 10
/**
 *
 */
58
inline void PhysxGroupsMask::set_bits1(unsigned int bits);

2021 9 set_bits2 0 4 3043 26 PhysxGroupsMask::set_bits2 0 1 550 10
/**
 *
 */
58
inline void PhysxGroupsMask::set_bits2(unsigned int bits);

2022 9 set_bits3 0 4 3043 26 PhysxGroupsMask::set_bits3 0 1 551 10
/**
 *
 */
58
inline void PhysxGroupsMask::set_bits3(unsigned int bits);

2023 21 upcast_to_PhysxObject 0 12 3044 33 PhysxScene::upcast_to_PhysxObject 0 1 633 37
upcast from PhysxScene to PhysxObject
53
PhysxObject *PhysxScene::upcast_to_PhysxObject(void);

2024 22 downcast_to_PhysxScene 0 12 2996 35 PhysxObject::downcast_to_PhysxScene 0 1 634 39
downcast from PhysxObject to PhysxScene
54
PhysxScene *PhysxObject::downcast_to_PhysxScene(void);

2025 20 upcast_to_PhysxEnums 0 12 3044 32 PhysxScene::upcast_to_PhysxEnums 0 1 635 36
upcast from PhysxScene to PhysxEnums
51
PhysxEnums *PhysxScene::upcast_to_PhysxEnums(void);

2026 22 downcast_to_PhysxScene 0 12 2965 34 PhysxEnums::downcast_to_PhysxScene 0 1 636 38
downcast from PhysxEnums to PhysxScene
53
PhysxScene *PhysxEnums::downcast_to_PhysxScene(void);

2027 10 PhysxScene 0 4 3044 22 PhysxScene::PhysxScene 0 1 552 10
/**
 *
 */
36
inline PhysxScene::PhysxScene(void);

2028 11 ~PhysxScene 0 6 3044 23 PhysxScene::~PhysxScene 0 0 10
/**
 *
 */
45
virtual inline PhysxScene::~PhysxScene(void);

2029 8 simulate 0 4 3044 20 PhysxScene::simulate 0 1 553 337
/**
 * Advances the simulation by an elapsedTime time.  The elapsed time has to be
 * in the range (0, inf).
 *
 * It is not allowed to modify the physics scene in between the simulate(dt)
 * and the fetch_results calls!  But it is allowed to read from the scene and
 * do additional computations, e.  g.  AI, in between these calls.
 */
36
void PhysxScene::simulate(float dt);

2030 13 fetch_results 0 4 3044 25 PhysxScene::fetch_results 0 1 554 342
/**
 * Waits until the simulation has finished, and then updates the scene graph
 * with with simulation results.
 *
 * It is not allowed to modify the physics scene in between the simulate(dt)
 * and the fetch_results calls!  But it is allowed to read from the scene and
 * do additional computations, e.  g.  AI, in between these calls.
 */
37
void PhysxScene::fetch_results(void);

2031 19 set_timing_variable 0 4 3044 31 PhysxScene::set_timing_variable 0 1 555 62
/**
 * Sets simulation timing parameters used in simulate.
 */
43
void PhysxScene::set_timing_variable(void);

2032 16 set_timing_fixed 0 4 3044 28 PhysxScene::set_timing_fixed 0 1 556 611
/**
 * Sets simulation timing parameters used in simulate.  The elapsed time
 * (parameter "dt" in simulate()) is internally subdivided into up to maxIter
 * substeps no larger than maxTimestep.  If the elapsed time is not a multiple
 * of maxTimestep then any remaining time is accumulated to be added onto the
 * elapsed time for the next time step.  If more sub steps than maxIter are
 * needed to advance the simulation by elapsed time, then the remaining time
 * is also accumulated for the next call to simulate().
 *
 * This timing method is strongly preferred for stable, reproducible
 * simulation.
 */
94
void PhysxScene::set_timing_fixed(float maxTimestep = (1.0 / 60.0), unsigned int maxIter = 8);

2033 19 get_debug_geom_node 0 4 3044 31 PhysxScene::get_debug_geom_node 0 1 557 407
/**
 * Retrieves the debug geom node for this scene.  The debug geom node is used
 * to visualize information about the physical scene which can be useful for
 * debugging an application.
 *
 * The debug geom node geometry is generated in global coordinates.  In order
 * to see correct information it is important not to dislocate the debug node.
 * Reparent it to render and leave position at (0,0,0).
 */
58
PhysxDebugGeomNode *PhysxScene::get_debug_geom_node(void);

2034 24 enable_contact_reporting 0 4 3044 36 PhysxScene::enable_contact_reporting 0 1 558 10
/**
 *
 */
56
void PhysxScene::enable_contact_reporting(bool enabled);

2035 28 is_contact_reporting_enabled 0 4 3044 40 PhysxScene::is_contact_reporting_enabled 0 1 559 10
/**
 *
 */
58
bool PhysxScene::is_contact_reporting_enabled(void) const;

2036 24 enable_trigger_reporting 0 4 3044 36 PhysxScene::enable_trigger_reporting 0 1 560 10
/**
 *
 */
56
void PhysxScene::enable_trigger_reporting(bool enabled);

2037 28 is_trigger_reporting_enabled 0 4 3044 40 PhysxScene::is_trigger_reporting_enabled 0 1 561 10
/**
 *
 */
58
bool PhysxScene::is_trigger_reporting_enabled(void) const;

2038 27 enable_controller_reporting 0 4 3044 39 PhysxScene::enable_controller_reporting 0 1 562 10
/**
 *
 */
59
void PhysxScene::enable_controller_reporting(bool enabled);

2039 31 is_controller_reporting_enabled 0 4 3044 43 PhysxScene::is_controller_reporting_enabled 0 1 563 10
/**
 *
 */
61
bool PhysxScene::is_controller_reporting_enabled(void) const;

2040 33 set_controller_shape_hit_callback 0 4 3044 45 PhysxScene::set_controller_shape_hit_callback 0 1 564 10
/**
 *
 */
93
inline void PhysxScene::set_controller_shape_hit_callback(PointerTo< CallbackObject > cbobj);

2041 38 set_controller_controller_hit_callback 0 4 3044 50 PhysxScene::set_controller_controller_hit_callback 0 1 565 10
/**
 *
 */
98
inline void PhysxScene::set_controller_controller_hit_callback(PointerTo< CallbackObject > cbobj);

2042 11 set_gravity 0 4 3044 23 PhysxScene::set_gravity 0 1 566 56
/**
 * Sets a constant gravity for the entire scene.
 */
55
void PhysxScene::set_gravity(LVector3f const &gravity);

2043 11 get_gravity 0 4 3044 23 PhysxScene::get_gravity 0 1 567 49
/**
 * Retrieves the current gravity setting.
 */
46
LVector3f PhysxScene::get_gravity(void) const;

2044 10 get_stats2 0 4 3044 22 PhysxScene::get_stats2 0 1 568 10
/**
 *
 */
52
PhysxSceneStats2 PhysxScene::get_stats2(void) const;

2045 8 get_flag 0 4 3044 20 PhysxScene::get_flag 0 1 569 48
/**
 * Return the specified scene flag flag.
 */
65
bool PhysxScene::get_flag(PhysxEnums::PhysxSceneFlag flag) const;

2046 17 is_hardware_scene 0 4 3044 29 PhysxScene::is_hardware_scene 0 1 570 115
/**
 * Returns TRUE if the the scene is simulated in hardware.  FALSE if the scene
 * is simulated in software.
 */
47
bool PhysxScene::is_hardware_scene(void) const;

2047 14 get_num_actors 0 4 3044 26 PhysxScene::get_num_actors 0 1 571 32
// Actors

// Actors

/**
 *
 */
52
unsigned int PhysxScene::get_num_actors(void) const;

2048 12 create_actor 0 4 3044 24 PhysxScene::create_actor 0 1 572 10
/**
 *
 */
59
PhysxActor *PhysxScene::create_actor(PhysxActorDesc &desc);

2049 9 get_actor 0 4 3044 21 PhysxScene::get_actor 0 1 573 10
/**
 *
 */
58
PhysxActor *PhysxScene::get_actor(unsigned int idx) const;

2050 14 get_num_joints 0 4 3044 26 PhysxScene::get_num_joints 0 1 574 142
// Joints

// Joints

/**
 * Returns the number of joints in the scene (excluding "dead" joints). Note
 * that this includes compartments.
 */
52
unsigned int PhysxScene::get_num_joints(void) const;

2051 12 create_joint 0 4 3044 24 PhysxScene::create_joint 0 1 575 41
/**
 * Creates a joint in this scene.
 */
59
PhysxJoint *PhysxScene::create_joint(PhysxJointDesc &desc);

2052 9 get_joint 0 4 3044 21 PhysxScene::get_joint 0 1 576 81
/**
 * Retrieve the n-th joint from the array of all the joints in the scene.
 */
58
PhysxJoint *PhysxScene::get_joint(unsigned int idx) const;

2053 17 get_num_materials 0 4 3044 29 PhysxScene::get_num_materials 0 1 577 347
// Materials

// Materials

/**
 * Return the number of materials in the scene.
 *
 * Note that the returned value is not related to material indices.  Those may
 * not be allocated continuously, and its values may be higher than
 * get_num_materials(). This will also include the default material which
 * exists without having to be created.
 */
55
unsigned int PhysxScene::get_num_materials(void) const;

2054 27 get_hightest_material_index 0 4 3044 39 PhysxScene::get_hightest_material_index 0 1 578 167
/**
 * Returns current highest valid material index.
 *
 * Note that not all indices below this are valid if some of them belong to
 * meshes that have beed freed.
 */
65
unsigned int PhysxScene::get_hightest_material_index(void) const;

2055 15 create_material 0 4 3044 27 PhysxScene::create_material 0 2 579 580 381
/**
 * Creates a new PhysxMaterial.
 *
 * The material library consists of an array of material objects.  Each
 * material has a well defined index that can be used to refer to it.  If an
 * object references an undefined material, the default material with index 0
 * is used instead.
 */

/**
 * Creates a new PhysxMaterial using the default settings of
 * PhysxMaterialDesc.
 */
118
PhysxMaterial *PhysxScene::create_material(PhysxMaterialDesc &desc);
PhysxMaterial *PhysxScene::create_material(void);

2056 12 get_material 0 4 3044 24 PhysxScene::get_material 0 1 581 156
/**
 * Retrieves the n-th material from the array of materials.  See also
 * get_material_from_index, which retrieves a material by it's material index.
 */
64
PhysxMaterial *PhysxScene::get_material(unsigned int idx) const;

2057 23 get_material_from_index 0 4 3044 35 PhysxScene::get_material_from_index 0 1 582 367
/**
 * Retrieves the material with the given material index.
 *
 * There is always at least one material in the Scene, the default material
 * (index 0). If the specified material index is out of range (larger than
 * get_hightest_material_index) or belongs to a material that has been
 * released, then the default material is returned, but no error is reported.
 */
75
PhysxMaterial *PhysxScene::get_material_from_index(unsigned int idx) const;

2058 19 get_num_controllers 0 4 3044 31 PhysxScene::get_num_controllers 0 1 583 89
// Controllers

// Controllers

/**
 * Return the number of controllers in the scene.
 */
57
unsigned int PhysxScene::get_num_controllers(void) const;

2059 17 create_controller 0 4 3044 29 PhysxScene::create_controller 0 1 584 46
/**
 * Creates a new character controller.
 */
84
PhysxController *PhysxScene::create_controller(PhysxControllerDesc &controllerDesc);

2060 14 get_controller 0 4 3044 26 PhysxScene::get_controller 0 1 585 58
/**
 * Retrieves the n-th controller within the scene.
 */
68
PhysxController *PhysxScene::get_controller(unsigned int idx) const;

2061 20 get_num_force_fields 0 4 3044 32 PhysxScene::get_num_force_fields 0 1 586 90
// Force fields

// Force fields

/**
 * Gets the number of force fields in the scene.
 */
58
unsigned int PhysxScene::get_num_force_fields(void) const;

2062 18 create_force_field 0 4 3044 30 PhysxScene::create_force_field 0 1 587 47
/**
 * Creates a force field in this scene.
 */
75
PhysxForceField *PhysxScene::create_force_field(PhysxForceFieldDesc &desc);

2063 15 get_force_field 0 4 3044 27 PhysxScene::get_force_field 0 1 588 95
/**
 * Returns the n-th force field from the array of all the force fields in the
 * scene.
 */
69
PhysxForceField *PhysxScene::get_force_field(unsigned int idx) const;

2064 32 get_num_force_field_shape_groups 0 4 3044 44 PhysxScene::get_num_force_field_shape_groups 0 1 589 126
// Force field shape groups

// Force field shape groups

/**
 * Gets the number of force field shape groups in the scene.
 */
70
unsigned int PhysxScene::get_num_force_field_shape_groups(void) const;

2065 30 create_force_field_shape_group 0 4 3044 42 PhysxScene::create_force_field_shape_group 0 1 590 63
/**
 * Creates a new force field shape group in this scene.
 */
107
PhysxForceFieldShapeGroup *PhysxScene::create_force_field_shape_group(PhysxForceFieldShapeGroupDesc &desc);

2066 27 get_force_field_shape_group 0 4 3044 39 PhysxScene::get_force_field_shape_group 0 1 591 65
/**
 * Returns the n-th force field shape group in this scene
 */
91
PhysxForceFieldShapeGroup *PhysxScene::get_force_field_shape_group(unsigned int idx) const;

2067 14 get_num_cloths 0 4 3044 26 PhysxScene::get_num_cloths 0 1 592 72
// Cloths

// Cloths

/**
 * Gets the number of cloths in the scene.
 */
52
unsigned int PhysxScene::get_num_cloths(void) const;

2068 12 create_cloth 0 4 3044 24 PhysxScene::create_cloth 0 1 593 41
/**
 * Creates a cloth in this scene.
 */
59
PhysxCloth *PhysxScene::create_cloth(PhysxClothDesc &desc);

2069 9 get_cloth 0 4 3044 21 PhysxScene::get_cloth 0 1 594 80
/**
 * Returns the n-th cloth from the array of all the cloths in the scene.
 */
58
PhysxCloth *PhysxScene::get_cloth(unsigned int idx) const;

2070 19 get_num_soft_bodies 0 4 3044 31 PhysxScene::get_num_soft_bodies 0 1 595 87
// Soft bodies

// Soft bodies

/**
 * Gets the number of soft bodies in the scene.
 */
57
unsigned int PhysxScene::get_num_soft_bodies(void) const;

2071 16 create_soft_body 0 4 3044 28 PhysxScene::create_soft_body 0 1 596 45
/**
 * Creates a soft body in this scene.
 */
69
PhysxSoftBody *PhysxScene::create_soft_body(PhysxSoftBodyDesc &desc);

2072 13 get_soft_body 0 4 3044 25 PhysxScene::get_soft_body 0 1 597 92
/**
 * Returns the n-th soft body from the array of all the soft bodies in the
 * scene.
 */
65
PhysxSoftBody *PhysxScene::get_soft_body(unsigned int idx) const;

2073 16 get_num_vehicles 0 4 3044 28 PhysxScene::get_num_vehicles 0 1 598 81
// Vehicles

// Vehicles

/**
 * Returns the number of vehicles in the scene.
 */
54
unsigned int PhysxScene::get_num_vehicles(void) const;

2074 14 create_vehicle 0 4 3044 26 PhysxScene::create_vehicle 0 1 599 43
/**
 * Creates a vehicle in this scene.
 */
65
PhysxVehicle *PhysxScene::create_vehicle(PhysxVehicleDesc &desc);

2075 11 get_vehicle 0 4 3044 23 PhysxScene::get_vehicle 0 1 600 84
/**
 * Returns the n-th vehicle from the array of all the vehicles in the scene.
 */
62
PhysxVehicle *PhysxScene::get_vehicle(unsigned int idx) const;

2076 17 raycast_any_shape 0 4 3044 29 PhysxScene::raycast_any_shape 0 1 601 83
// Raycast queries

/**
 * Returns true if any shape is intersected by the ray.
 */
197
bool PhysxScene::raycast_any_shape(PhysxRay const &ray, PhysxEnums::PhysxShapesType shapesType = ::PhysxEnums::ST_all, PhysxMask mask = ::PhysxMask::all_on(), PhysxGroupsMask *groups = NULL) const;

2077 21 raycast_closest_shape 0 4 3044 33 PhysxScene::raycast_closest_shape 0 1 602 145
/**
 * Returns the first shape that is hit along the ray.  If not shape is hit
 * then an empty raycast hit is returned (is_empty() == true).
 */
238
PhysxRaycastHit PhysxScene::raycast_closest_shape(PhysxRay const &ray, PhysxEnums::PhysxShapesType shapesType = ::PhysxEnums::ST_all, PhysxMask mask = ::PhysxMask::all_on(), PhysxGroupsMask *groups = NULL, bool smoothNormal = true) const;

2078 18 raycast_all_shapes 0 4 3044 30 PhysxScene::raycast_all_shapes 0 1 603 125
/**
 * Returns a PhysxRaycastReport object which can be used to iterate over all
 * shapes that have been hit by the ray.
 */
238
PhysxRaycastReport PhysxScene::raycast_all_shapes(PhysxRay const &ray, PhysxEnums::PhysxShapesType shapesType = ::PhysxEnums::ST_all, PhysxMask mask = ::PhysxMask::all_on(), PhysxGroupsMask *groups = NULL, bool smoothNormal = true) const;

2079 18 raycast_any_bounds 0 4 3044 30 PhysxScene::raycast_any_bounds 0 1 604 104
/**
 * Returns true if any axis aligned bounding box enclosing a shape is
 * intersected by the ray.
 */
198
bool PhysxScene::raycast_any_bounds(PhysxRay const &ray, PhysxEnums::PhysxShapesType shapesType = ::PhysxEnums::ST_all, PhysxMask mask = ::PhysxMask::all_on(), PhysxGroupsMask *groups = NULL) const;

2080 22 raycast_closest_bounds 0 4 3044 34 PhysxScene::raycast_closest_bounds 0 1 605 186
/**
 * Returns the first axis aligned bounding box enclosing a shape that is hit
 * along the ray.  If not shape is hit then an empty raycast hit is returned
 * (is_empty() == true).
 */
239
PhysxRaycastHit PhysxScene::raycast_closest_bounds(PhysxRay const &ray, PhysxEnums::PhysxShapesType shapesType = ::PhysxEnums::ST_all, PhysxMask mask = ::PhysxMask::all_on(), PhysxGroupsMask *groups = NULL, bool smoothNormal = true) const;

2081 18 raycast_all_bounds 0 4 3044 30 PhysxScene::raycast_all_bounds 0 1 606 168
/**
 * Returns a PhysxRaycastReport object which can be used to iterate over all
 * shapes that have been enclosed by axis aligned bounding boxes hit by the
 * ray.
 */
238
PhysxRaycastReport PhysxScene::raycast_all_bounds(PhysxRay const &ray, PhysxEnums::PhysxShapesType shapesType = ::PhysxEnums::ST_all, PhysxMask mask = ::PhysxMask::all_on(), PhysxGroupsMask *groups = NULL, bool smoothNormal = true) const;

2082 21 overlap_sphere_shapes 0 4 3044 33 PhysxScene::overlap_sphere_shapes 0 1 607 175
// Overlap queries

/**
 * Returns the set of shapes overlapped by the world-space sphere.  You can
 * test against static and/or dynamic objects by adjusting 'shapeType'.
 */
231
PhysxOverlapReport PhysxScene::overlap_sphere_shapes(LPoint3f const &center, float radius, PhysxEnums::PhysxShapesType shapesType = ::PhysxEnums::ST_all, PhysxMask mask = ::PhysxMask::all_on(), bool accurateCollision = true) const;

2083 22 overlap_capsule_shapes 0 4 3044 34 PhysxScene::overlap_capsule_shapes 0 1 608 156
/**
 * Returns the set of shapes overlapped by the world-space capsule.  You can
 * test against static and/or dynamic objects by adjusting 'shapeType'.
 */
248
PhysxOverlapReport PhysxScene::overlap_capsule_shapes(LPoint3f const &p0, LPoint3f const &p1, float radius, PhysxEnums::PhysxShapesType shapesType = ::PhysxEnums::ST_all, PhysxMask mask = ::PhysxMask::all_on(), bool accurateCollision = true) const;

2084 19 set_actor_pair_flag 0 4 3044 31 PhysxScene::set_actor_pair_flag 0 1 609 428
// Filters

/**
 * Sets the pair flags for the given pair of actors.
 *
 * Calling this on an actor that has no shape(s) has no effect.  The two actor
 * references must not reference the same actor.
 *
 * It is important to note that the engine stores pair flags per shape, even
 * for actor pair flags.  This means that shapes should be created before
 * actor pair flags are set, otherwise the pair flags will be ignored.
 */
128
void PhysxScene::set_actor_pair_flag(PhysxActor &actorA, PhysxActor &actorB, PhysxEnums::PhysxContactPairFlag flag, bool value);

2085 19 set_shape_pair_flag 0 4 3044 31 PhysxScene::set_shape_pair_flag 0 1 610 137
/**
 * Disables or enables contact generation for a pair of shapes.
 *
 * The two shape references must not reference the same shape.
 */
89
void PhysxScene::set_shape_pair_flag(PhysxShape &shapeA, PhysxShape &shapeB, bool value);

2086 25 set_actor_group_pair_flag 0 4 3044 37 PhysxScene::set_actor_group_pair_flag 0 1 611 730
/**
 * With this method one can set contact reporting flags between actors
 * belonging to a pair of groups.
 *
 * It is possible to assign each actor to a group using
 * PhysxActor::set_group(). This is a different set of groups from the shape
 * groups despite the similar name.  Here up to 0xffff different groups are
 * permitted, With this method one can set contact reporting flags between
 * actors belonging to a pair of groups.
 *
 * The following flags are permitted: - CPF_start_touch - CPF_end_touch -
 * CPF_touch - CPF_start_touch_treshold - CPF_end_touch_treshold -
 * CPF_touch_treshold
 *
 * Note that finer grain control of pairwise flags is possible using the
 * function PhysxScene::set_actor_pair_flags().
 */
128
void PhysxScene::set_actor_group_pair_flag(unsigned int g1, unsigned int g2, PhysxEnums::PhysxContactPairFlag flag, bool value);

2087 24 set_group_collision_flag 0 4 3044 36 PhysxScene::set_group_collision_flag 0 1 612 448
/**
 * Specifies if collision should be performed by a pair of shape groups.
 *
 * It is possible to assign each shape to a collision groups using
 * PhysxShape::set_group(). With this method one can set whether collisions
 * should be detected between shapes belonging to a given pair of groups.
 * Initially all pairs are enabled.
 *
 * Fluids can be assigned to collision groups as well.
 *
 * Collision groups are integers between 0 and 31.
 */
89
void PhysxScene::set_group_collision_flag(unsigned int g1, unsigned int g2, bool enable);

2088 14 set_filter_ops 0 4 3044 26 PhysxScene::set_filter_ops 0 1 613 39
/**
 * Setups filtering operations.
 */
125
void PhysxScene::set_filter_ops(PhysxEnums::PhysxFilterOp op0, PhysxEnums::PhysxFilterOp op1, PhysxEnums::PhysxFilterOp op2);

2089 15 set_filter_bool 0 4 3044 27 PhysxScene::set_filter_bool 0 1 614 44
/**
 * Setups filtering's boolean value.
 */
44
void PhysxScene::set_filter_bool(bool flag);

2090 20 set_filter_constant0 0 4 3044 32 PhysxScene::set_filter_constant0 0 1 615 39
/**
 * Setups filtering's K0 value.
 */
67
void PhysxScene::set_filter_constant0(PhysxGroupsMask const &mask);

2091 20 set_filter_constant1 0 4 3044 32 PhysxScene::set_filter_constant1 0 1 616 39
/**
 * Setups filtering's K1 value.
 */
67
void PhysxScene::set_filter_constant1(PhysxGroupsMask const &mask);

2092 24 set_dominance_group_pair 0 4 3044 36 PhysxScene::set_dominance_group_pair 0 1 617 1934
/**
 * Specifies the dominance behavior of constraints between two actors with two
 * certain dominance groups.
 *
 * It is possible to assign each actor to a dominance groups using
 * PhysxActor::set_dominance_group().
 *
 * With dominance groups one can have all constraints (contacts and joints)
 * created between actors act in one direction only.  This is useful if you
 * want to make sure that the movement of the rider of a vehicle or the pony
 * tail of a character doesn't influence the object it is attached to, while
 * keeping the motion of both inherently physical.
 *
 * Whenever a constraint (i.e.  joint or contact) between two actors (a0, a1)
 * needs to be solved, the groups (g0, g1) of both actors are retrieved.  Then
 * the constraint dominance setting for this group pair is retrieved.
 *
 * In the constraint, PhysxConstraintDominance::get_0() becomes the dominance
 * setting for a0, and PhysxConstraintDominance::get_1() becomes the dominance
 * setting for a1. A dominance setting of 1.0f, the default, will permit the
 * actor to be pushed or pulled by the other actor.  A dominance setting of
 * 0.0f will however prevent the actor to be pushed or pulled by the other
 * actor.  Thus, a PhysxConstraintDominance of (1.0f, 0.0f) makes the
 * interaction one-way.
 *
 * The dominance matrix is initialised by default such that: - if g1 == g2,
 * then (1.0f, 1.0f) is returned - if g1 < g2, then (0.0f, 1.0f) is returned -
 * if g1 > g2, then (1.0f, 0.0f) is returned
 *
 * In other words, actors in higher groups can be pushed around by actors in
 * lower groups by default.
 *
 * These settings should cover most applications, and in fact not overriding
 * these settings may likely result in higher performance.
 *
 * Dominance settings are currently specified as floats 0.0f or 1.0f because
 * in the future PhysX may permit arbitrary fractional settings to express
 * 'partly-one-way' interactions.
 */
112
void PhysxScene::set_dominance_group_pair(unsigned int g1, unsigned int g2, PhysxConstraintDominance dominance);

2093 19 get_actor_pair_flag 0 4 3044 31 PhysxScene::get_actor_pair_flag 0 1 618 130
/**
 * Retrieves a single flag for the given pair of actors.
 *
 * The two actor references must not reference the same actor.
 */
116
bool PhysxScene::get_actor_pair_flag(PhysxActor &actorA, PhysxActor &actorB, PhysxEnums::PhysxContactPairFlag flag);

2094 19 get_shape_pair_flag 0 4 3044 31 PhysxScene::get_shape_pair_flag 0 1 619 200
/**
 * Returns /true/ if contact generation between a pair of shapes is enabled,
 * and /false/ if contact generation is disables.
 *
 * The two shape references must not reference the same shape.
 */
77
bool PhysxScene::get_shape_pair_flag(PhysxShape &shapeA, PhysxShape &shapeB);

2095 25 get_actor_group_pair_flag 0 4 3044 37 PhysxScene::get_actor_group_pair_flag 0 1 620 83
/**
 * Retrieves a single flag set with PhysxScene::set_actor_group_pair_flag()
 */
116
bool PhysxScene::get_actor_group_pair_flag(unsigned int g1, unsigned int g2, PhysxEnums::PhysxContactPairFlag flag);

2096 24 get_group_collision_flag 0 4 3044 36 PhysxScene::get_group_collision_flag 0 1 621 134
/**
 * Determines if collision detection is performed between a pair of groups.
 * Collision groups are integers between 0 and 31.
 */
76
bool PhysxScene::get_group_collision_flag(unsigned int g1, unsigned int g2);

2097 15 get_filter_bool 0 4 3044 27 PhysxScene::get_filter_bool 0 1 622 47
/**
 * Retrieves filtering's boolean value.
 */
45
bool PhysxScene::get_filter_bool(void) const;

2098 20 get_filter_constant0 0 4 3044 32 PhysxScene::get_filter_constant0 0 1 623 38
/**
 * Gets filtering constant K0.
 */
61
PhysxGroupsMask PhysxScene::get_filter_constant0(void) const;

2099 20 get_filter_constant1 0 4 3044 32 PhysxScene::get_filter_constant1 0 1 624 38
/**
 * Gets filtering constant K1.
 */
61
PhysxGroupsMask PhysxScene::get_filter_constant1(void) const;

2100 14 get_filter_op0 0 4 3044 26 PhysxScene::get_filter_op0 0 1 625 49
/**
 * Retrieves the op0 filtering operation.
 */
65
PhysxEnums::PhysxFilterOp PhysxScene::get_filter_op0(void) const;

2101 14 get_filter_op1 0 4 3044 26 PhysxScene::get_filter_op1 0 1 626 49
/**
 * Retrieves the op1 filtering operation.
 */
65
PhysxEnums::PhysxFilterOp PhysxScene::get_filter_op1(void) const;

2102 14 get_filter_op2 0 4 3044 26 PhysxScene::get_filter_op2 0 1 627 49
/**
 * Retrieves the op2 filtering operation.
 */
65
PhysxEnums::PhysxFilterOp PhysxScene::get_filter_op2(void) const;

2103 24 get_dominance_group_pair 0 4 3044 36 PhysxScene::get_dominance_group_pair 0 1 628 40
/**
 * Samples the dominance matrix.
 */
96
PhysxConstraintDominance PhysxScene::get_dominance_group_pair(unsigned int g1, unsigned int g2);

2104 7 release 0 4 3044 19 PhysxScene::release 0 1 629 10
/**
 *
 */
31
void PhysxScene::release(void);

2105 2 ls 0 6 3044 14 PhysxScene::ls 0 2 630 631 22
/**
 *
 */

/**
 *
 */
125
virtual inline void PhysxScene::ls(void) const;
virtual inline void PhysxScene::ls(ostream &out, int indent_level = 0) const;

2106 14 get_class_type 0 4 3044 26 PhysxScene::get_class_type 0 1 632 0
51
static TypeHandle PhysxScene::get_class_type(void);

2107 21 upcast_to_PhysxObject 0 12 3045 36 PhysxSoftBody::upcast_to_PhysxObject 0 1 681 40
upcast from PhysxSoftBody to PhysxObject
56
PhysxObject *PhysxSoftBody::upcast_to_PhysxObject(void);

2108 25 downcast_to_PhysxSoftBody 0 12 2996 38 PhysxObject::downcast_to_PhysxSoftBody 0 1 682 42
downcast from PhysxObject to PhysxSoftBody
60
PhysxSoftBody *PhysxObject::downcast_to_PhysxSoftBody(void);

2109 20 upcast_to_PhysxEnums 0 12 3045 35 PhysxSoftBody::upcast_to_PhysxEnums 0 1 683 39
upcast from PhysxSoftBody to PhysxEnums
54
PhysxEnums *PhysxSoftBody::upcast_to_PhysxEnums(void);

2110 25 downcast_to_PhysxSoftBody 0 12 2965 37 PhysxEnums::downcast_to_PhysxSoftBody 0 1 684 41
downcast from PhysxEnums to PhysxSoftBody
59
PhysxSoftBody *PhysxEnums::downcast_to_PhysxSoftBody(void);

2111 13 PhysxSoftBody 0 4 3045 28 PhysxSoftBody::PhysxSoftBody 0 1 637 10
/**
 *
 */
42
inline PhysxSoftBody::PhysxSoftBody(void);

2112 14 ~PhysxSoftBody 0 6 3045 29 PhysxSoftBody::~PhysxSoftBody 0 0 10
/**
 *
 */
51
virtual inline PhysxSoftBody::~PhysxSoftBody(void);

2113 9 get_scene 0 4 3045 24 PhysxSoftBody::get_scene 0 1 638 61
/**
 * Returns the scene which this soft body belongs to.
 */
49
PhysxScene *PhysxSoftBody::get_scene(void) const;

2114 18 get_soft_body_node 0 4 3045 33 PhysxSoftBody::get_soft_body_node 0 1 639 10
/**
 *
 */
65
PhysxSoftBodyNode *PhysxSoftBody::get_soft_body_node(void) const;

2115 21 create_soft_body_node 0 4 3045 36 PhysxSoftBody::create_soft_body_node 0 1 640 10
/**
 *
 */
74
PhysxSoftBodyNode *PhysxSoftBody::create_soft_body_node(char const *name);

2116 8 set_name 0 4 3045 23 PhysxSoftBody::set_name 0 1 641 139
/**
 * Sets a name string for the object that can be retrieved with get_name().
 * This is for debugging and is not used by the engine.
 */
47
void PhysxSoftBody::set_name(char const *name);

2117 8 set_flag 0 4 3045 23 PhysxSoftBody::set_flag 0 1 642 43
/**
 * Sets the value of a single flag.
 */
77
void PhysxSoftBody::set_flag(PhysxEnums::PhysxSoftBodyFlag flag, bool value);

2118 15 set_groups_mask 0 4 3045 30 PhysxSoftBody::set_groups_mask 0 1 643 58
/**
 * Sets 128-bit mask used for collision filtering.
 */
65
void PhysxSoftBody::set_groups_mask(PhysxGroupsMask const &mask);

2119 9 set_group 0 4 3045 24 PhysxSoftBody::set_group 0 1 644 110
/**
 * Sets which collision group this soft body is part of.  Collision group must
 * be between 0 and 31.
 */
50
void PhysxSoftBody::set_group(unsigned int group);

2120 21 set_solver_iterations 0 4 3045 36 PhysxSoftBody::set_solver_iterations 0 1 645 48
/**
 * Sets the soft body solver iterations.
 */
67
void PhysxSoftBody::set_solver_iterations(unsigned int iterations);

2121 19 set_particle_radius 0 4 3045 34 PhysxSoftBody::set_particle_radius 0 1 646 65
/**
 * Sets the soft body particle radius (must be positive).
 */
54
void PhysxSoftBody::set_particle_radius(float radius);

2122 28 set_self_collision_thickness 0 4 3045 43 PhysxSoftBody::set_self_collision_thickness 0 1 647 74
/**
 * Sets the soft body self collision thickness (must be positive).
 */
66
void PhysxSoftBody::set_self_collision_thickness(float thickness);

2123 34 set_hard_stretch_limitation_factor 0 4 3045 49 PhysxSoftBody::set_hard_stretch_limitation_factor 0 1 648 60
/**
 * Sets the soft body hard stretch elongation limit.
 */
69
void PhysxSoftBody::set_hard_stretch_limitation_factor(float factor);

2124 20 set_volume_stiffness 0 4 3045 35 PhysxSoftBody::set_volume_stiffness 0 1 649 72
/**
 * Sets the soft body volume stiffness in the range from 0 to 1.
 */
58
void PhysxSoftBody::set_volume_stiffness(float stiffness);

2125 24 set_stretching_stiffness 0 4 3045 39 PhysxSoftBody::set_stretching_stiffness 0 1 650 76
/**
 * Sets the soft body stretching stiffness in the range from 0 to 1.
 */
62
void PhysxSoftBody::set_stretching_stiffness(float stiffness);

2126 23 set_damping_coefficient 0 4 3045 38 PhysxSoftBody::set_damping_coefficient 0 1 651 65
/**
 * Sets the damping coefficient in the range from 0 to 1.
 */
56
void PhysxSoftBody::set_damping_coefficient(float coef);

2127 12 set_friction 0 4 3045 27 PhysxSoftBody::set_friction 0 1 652 76
/**
 * Sets the soft body friction coefficient in the range from 0 to 1.
 */
49
void PhysxSoftBody::set_friction(float friction);

2128 15 set_tear_factor 0 4 3045 30 PhysxSoftBody::set_tear_factor 0 1 653 68
/**
 * Sets the soft body tear factor (must be larger than one).
 */
50
void PhysxSoftBody::set_tear_factor(float factor);

2129 26 set_attachment_tear_factor 0 4 3045 41 PhysxSoftBody::set_attachment_tear_factor 0 1 654 79
/**
 * Sets the soft body attachment tear factor (must be larger than one).
 */
61
void PhysxSoftBody::set_attachment_tear_factor(float factor);

2130 8 get_name 0 4 3045 23 PhysxSoftBody::get_name 0 1 655 37
/**
 * Retrieves the name string.
 */
48
char const *PhysxSoftBody::get_name(void) const;

2131 8 get_flag 0 4 3045 23 PhysxSoftBody::get_flag 0 1 656 48
/**
 * Retrieves the value of a single flag.
 */
71
bool PhysxSoftBody::get_flag(PhysxEnums::PhysxSoftBodyFlag flag) const;

2132 15 get_groups_mask 0 4 3045 30 PhysxSoftBody::get_groups_mask 0 1 657 69
/**
 * Gets the 128-bit groups mask used for collision filtering.
 */
59
PhysxGroupsMask PhysxSoftBody::get_groups_mask(void) const;

2133 9 get_group 0 4 3045 24 PhysxSoftBody::get_group 0 1 658 67
/**
 * Retrieves the collision group this soft body is part of.
 */
50
unsigned int PhysxSoftBody::get_group(void) const;

2134 17 get_num_particles 0 4 3045 32 PhysxSoftBody::get_num_particles 0 1 659 46
/**
 * Gets the number of cloth particles.
 */
52
unsigned int PhysxSoftBody::get_num_particles(void);

2135 21 get_solver_iterations 0 4 3045 36 PhysxSoftBody::get_solver_iterations 0 1 660 53
/**
 * Retrieves the soft body solver iterations.
 */
62
unsigned int PhysxSoftBody::get_solver_iterations(void) const;

2136 19 get_particle_radius 0 4 3045 34 PhysxSoftBody::get_particle_radius 0 1 661 46
/**
 * Gets the soft body particle radius.
 */
53
float PhysxSoftBody::get_particle_radius(void) const;

2137 11 get_density 0 4 3045 26 PhysxSoftBody::get_density 0 1 662 38
/**
 * Gets the soft body density.
 */
45
float PhysxSoftBody::get_density(void) const;

2138 25 get_relative_grid_spacing 0 4 3045 40 PhysxSoftBody::get_relative_grid_spacing 0 1 663 296
/**
 * Gets the relative grid spacing for the broad phase.  The cloth is
 * represented by a set of world aligned cubical cells in broad phase.  The
 * size of these cells is determined by multiplying the length of the diagonal
 * of the AABB of the initial soft body size with this constant.
 */
59
float PhysxSoftBody::get_relative_grid_spacing(void) const;

2139 28 get_self_collision_thickness 0 4 3045 43 PhysxSoftBody::get_self_collision_thickness 0 1 664 55
/**
 * Gets the soft body self collision thickness.
 */
62
float PhysxSoftBody::get_self_collision_thickness(void) const;

2140 34 get_hard_stretch_limitation_factor 0 4 3045 49 PhysxSoftBody::get_hard_stretch_limitation_factor 0 1 665 65
/**
 * Retrieves the soft body hard stretch elongation limit.
 */
68
float PhysxSoftBody::get_hard_stretch_limitation_factor(void) const;

2141 20 get_volume_stiffness 0 4 3045 35 PhysxSoftBody::get_volume_stiffness 0 1 666 52
/**
 * Retrieves the soft body volume stiffness.
 */
54
float PhysxSoftBody::get_volume_stiffness(void) const;

2142 24 get_stretching_stiffness 0 4 3045 39 PhysxSoftBody::get_stretching_stiffness 0 1 667 56
/**
 * Retrieves the soft body stretching stiffness.
 */
58
float PhysxSoftBody::get_stretching_stiffness(void) const;

2143 23 get_damping_coefficient 0 4 3045 38 PhysxSoftBody::get_damping_coefficient 0 1 668 45
/**
 * Retrieves the damping coefficient.
 */
57
float PhysxSoftBody::get_damping_coefficient(void) const;

2144 12 get_friction 0 4 3045 27 PhysxSoftBody::get_friction 0 1 669 56
/**
 * Retrieves the soft body friction coefficient.
 */
46
float PhysxSoftBody::get_friction(void) const;

2145 15 get_tear_factor 0 4 3045 30 PhysxSoftBody::get_tear_factor 0 1 670 47
/**
 * Retrieves the soft body tear factor.
 */
49
float PhysxSoftBody::get_tear_factor(void) const;

2146 26 get_attachment_tear_factor 0 4 3045 41 PhysxSoftBody::get_attachment_tear_factor 0 1 671 58
/**
 * Retrieves the attachment soft body tear factor.
 */
60
float PhysxSoftBody::get_attachment_tear_factor(void) const;

2147 11 is_sleeping 0 4 3045 26 PhysxSoftBody::is_sleeping 0 1 672 428
// Sleeping

/**
 * Returns true if this soft body is sleeping.
 *
 * When a soft body does not move for a period of time, it is no longer
 * simulated in order to save time.  This state is called sleeping.  However,
 * because the object automatically wakes up when it is either touched by an
 * awake object, or one of its properties is changed by the user, the entire
 * sleep mechanism should be transparent to the user.
 */
44
bool PhysxSoftBody::is_sleeping(void) const;

2148 7 wake_up 0 4 3045 22 PhysxSoftBody::wake_up 0 1 673 246
/**
 * Wakes up the soft body if it is sleeping.
 *
 * The wakeCounterValue determines how long until the body is put to sleep, a
 * value of zero means that the body is sleeping.  wake_up(0) is equivalent to
 * PhysxSoftBody::put_to_sleep().
 */
84
void PhysxSoftBody::wake_up(float wakeCounterValue = (20.0 * 0.020000000000000005));

2149 12 put_to_sleep 0 4 3045 27 PhysxSoftBody::put_to_sleep 0 1 674 275
/**
 * Forces the soft body to sleep.
 *
 * The soft body  will stay asleep until the next call to simulate, and will
 * not wake up until then even when otherwise it would (for example a force is
 * applied to it). It can however wake up during the next do_physics call.
 */
39
void PhysxSoftBody::put_to_sleep(void);

2150 25 set_sleep_linear_velocity 0 4 3045 40 PhysxSoftBody::set_sleep_linear_velocity 0 1 675 275
/**
 * Sets the linear velocity below which an soft body may go to sleep.
 * SoftBodys whose linear velocity is above this threshold will not be put to
 * sleep.
 *
 * Setting the sleep angular/linear velocity only makes sense when the
 * BF_energy_sleep_test is not set.
 */
63
void PhysxSoftBody::set_sleep_linear_velocity(float threshold);

2151 25 get_sleep_linear_velocity 0 4 3045 40 PhysxSoftBody::get_sleep_linear_velocity 0 1 676 171
/**
 * Returns the linear velocity below which an soft body may go to sleep.  Soft
 * bodies whose linear velocity is above this threshold will not be put to
 * sleep.
 */
59
float PhysxSoftBody::get_sleep_linear_velocity(void) const;

2152 2 ls 0 6 3045 17 PhysxSoftBody::ls 0 2 677 678 22
/**
 *
 */

/**
 *
 */
131
virtual inline void PhysxSoftBody::ls(void) const;
virtual inline void PhysxSoftBody::ls(ostream &out, int indent_level = 0) const;

2153 7 release 0 4 3045 22 PhysxSoftBody::release 0 1 679 10
/**
 *
 */
34
void PhysxSoftBody::release(void);

2154 14 get_class_type 0 4 3045 29 PhysxSoftBody::get_class_type 0 1 680 0
54
static TypeHandle PhysxSoftBody::get_class_type(void);

2155 19 get_reference_count 0 4 3046 38 PhysxSoftBodyMesh::get_reference_count 0 1 685 57
/**
 * Returns the reference count for shared meshes.
 */
64
unsigned int PhysxSoftBodyMesh::get_reference_count(void) const;

2156 7 release 0 4 3046 26 PhysxSoftBodyMesh::release 0 1 686 10
/**
 *
 */
38
void PhysxSoftBodyMesh::release(void);

2157 14 get_class_type 0 4 3046 33 PhysxSoftBodyMesh::get_class_type 0 1 687 0
58
static TypeHandle PhysxSoftBodyMesh::get_class_type(void);

2158 17 PhysxSoftBodyNode 0 4 3047 36 PhysxSoftBodyNode::PhysxSoftBodyNode 0 1 688 10
/**
 *
 */
62
inline PhysxSoftBodyNode::PhysxSoftBodyNode(char const *name);

2159 13 set_from_geom 0 4 3047 32 PhysxSoftBodyNode::set_from_geom 0 1 689 243
/**
 * Reads the vertices and indices from an existing Geom and makes a decomposed
 * copy of the data.  Then computes links between the owning soft body
 * tetrahedron mesh in order to render an updated geometry every simulation
 * frame.
 */
56
void PhysxSoftBodyNode::set_from_geom(Geom const *geom);

2160 14 get_class_type 0 4 3047 33 PhysxSoftBodyNode::get_class_type 0 1 690 0
58
static TypeHandle PhysxSoftBodyNode::get_class_type(void);

2161 26 PhysxSphereForceFieldShape 0 4 3048 54 PhysxSphereForceFieldShape::PhysxSphereForceFieldShape 0 1 691 10
/**
 *
 */
68
inline PhysxSphereForceFieldShape::PhysxSphereForceFieldShape(void);

2162 12 save_to_desc 0 4 3048 40 PhysxSphereForceFieldShape::save_to_desc 0 1 692 63
/**
 * Saves the state of the shape object to a descriptor.
 */
95
void PhysxSphereForceFieldShape::save_to_desc(PhysxSphereForceFieldShapeDesc &shapeDesc) const;

2163 10 set_radius 0 4 3048 38 PhysxSphereForceFieldShape::set_radius 0 1 693 34
/**
 * Sets the sphere radius.
 */
58
void PhysxSphereForceFieldShape::set_radius(float radius);

2164 10 get_radius 0 4 3048 38 PhysxSphereForceFieldShape::get_radius 0 1 694 44
/**
 * Returns the radius of the sphere.
 */
57
float PhysxSphereForceFieldShape::get_radius(void) const;

2165 14 get_class_type 0 4 3048 42 PhysxSphereForceFieldShape::get_class_type 0 1 695 0
67
static TypeHandle PhysxSphereForceFieldShape::get_class_type(void);

2166 16 PhysxSphereShape 0 4 3049 34 PhysxSphereShape::PhysxSphereShape 0 1 696 10
/**
 *
 */
48
inline PhysxSphereShape::PhysxSphereShape(void);

2167 12 save_to_desc 0 4 3049 30 PhysxSphereShape::save_to_desc 0 1 697 63
/**
 * Saves the state of the shape object to a descriptor.
 */
75
void PhysxSphereShape::save_to_desc(PhysxSphereShapeDesc &shapeDesc) const;

2168 10 set_radius 0 4 3049 28 PhysxSphereShape::set_radius 0 1 698 34
/**
 * Sets the sphere radius.
 */
48
void PhysxSphereShape::set_radius(float radius);

2169 10 get_radius 0 4 3049 28 PhysxSphereShape::get_radius 0 1 699 44
/**
 * Returns the radius of the sphere.
 */
47
float PhysxSphereShape::get_radius(void) const;

2170 14 get_class_type 0 4 3049 32 PhysxSphereShape::get_class_type 0 1 700 0
57
static TypeHandle PhysxSphereShape::get_class_type(void);

2171 19 PhysxSphericalJoint 0 4 3050 40 PhysxSphericalJoint::PhysxSphericalJoint 0 1 701 10
/**
 *
 */
54
inline PhysxSphericalJoint::PhysxSphericalJoint(void);

2172 12 save_to_desc 0 4 3050 33 PhysxSphericalJoint::save_to_desc 0 1 702 63
/**
 * Saves the state of the joint object to a descriptor.
 */
81
void PhysxSphericalJoint::save_to_desc(PhysxSphericalJointDesc &jointDesc) const;

2173 14 load_from_desc 0 4 3050 35 PhysxSphericalJoint::load_from_desc 0 1 703 84
/**
 * Loads the entire state of the joint from a descriptor with a single call.
 */
83
void PhysxSphericalJoint::load_from_desc(PhysxSphericalJointDesc const &jointDesc);

2174 8 set_flag 0 4 3050 29 PhysxSphericalJoint::set_flag 0 1 704 54
/**
 * Sets or clears a single SphericalJointFlag.
 */
89
void PhysxSphericalJoint::set_flag(PhysxEnums::PhysxSphericalJointFlag flag, bool value);

2175 19 set_projection_mode 0 4 3050 40 PhysxSphericalJoint::set_projection_mode 0 1 705 42
/**
 * Sets the joint projection mode.
 */
84
void PhysxSphericalJoint::set_projection_mode(PhysxEnums::PhysxProjectionMode mode);

2176 8 get_flag 0 4 3050 29 PhysxSphericalJoint::get_flag 0 1 706 60
/**
 * Returns the value of a single SphericalJointFlag.
 */
83
bool PhysxSphericalJoint::get_flag(PhysxEnums::PhysxSphericalJointFlag flag) const;

2177 19 get_projection_mode 0 4 3050 40 PhysxSphericalJoint::get_projection_mode 0 1 707 56
/**
 * Returns the current projection mode settings.
 */
85
PhysxEnums::PhysxProjectionMode PhysxSphericalJoint::get_projection_mode(void) const;

2178 14 get_class_type 0 4 3050 35 PhysxSphericalJoint::get_class_type 0 1 708 0
60
static TypeHandle PhysxSphericalJoint::get_class_type(void);

2179 19 get_reference_count 0 4 3051 38 PhysxTriangleMesh::get_reference_count 0 1 709 57
/**
 * Returns the reference count for shared meshes.
 */
64
unsigned int PhysxTriangleMesh::get_reference_count(void) const;

2180 7 release 0 4 3051 26 PhysxTriangleMesh::release 0 1 710 10
/**
 *
 */
38
void PhysxTriangleMesh::release(void);

2181 14 get_class_type 0 4 3051 33 PhysxTriangleMesh::get_class_type 0 1 711 0
58
static TypeHandle PhysxTriangleMesh::get_class_type(void);

2182 22 PhysxTriangleMeshShape 0 4 3052 46 PhysxTriangleMeshShape::PhysxTriangleMeshShape 0 1 712 10
/**
 *
 */
60
inline PhysxTriangleMeshShape::PhysxTriangleMeshShape(void);

2183 12 save_to_desc 0 4 3052 36 PhysxTriangleMeshShape::save_to_desc 0 1 713 63
/**
 * Saves the state of the shape object to a descriptor.
 */
87
void PhysxTriangleMeshShape::save_to_desc(PhysxTriangleMeshShapeDesc &shapeDesc) const;

2184 14 get_class_type 0 4 3052 38 PhysxTriangleMeshShape::get_class_type 0 1 714 0
63
static TypeHandle PhysxTriangleMeshShape::get_class_type(void);

2185 12 PhysxVehicle 0 4 3053 26 PhysxVehicle::PhysxVehicle 0 1 715 10
/**
 *
 */
40
inline PhysxVehicle::PhysxVehicle(void);

2186 7 release 0 4 3053 21 PhysxVehicle::release 0 1 716 33
/**
 * Destroys this vehicle.
 */
33
void PhysxVehicle::release(void);

2187 14 get_class_type 0 4 3053 28 PhysxVehicle::get_class_type 0 1 717 0
53
static TypeHandle PhysxVehicle::get_class_type(void);

2188 10 PhysxWheel 0 4 3054 22 PhysxWheel::PhysxWheel 0 1 718 10
/**
 *
 */
36
inline PhysxWheel::PhysxWheel(void);

2189 14 get_class_type 0 4 3054 26 PhysxWheel::get_class_type 0 1 719 0
51
static TypeHandle PhysxWheel::get_class_type(void);

2190 15 PhysxWheelShape 0 4 3055 32 PhysxWheelShape::PhysxWheelShape 0 1 720 10
/**
 *
 */
46
inline PhysxWheelShape::PhysxWheelShape(void);

2191 12 save_to_desc 0 4 3055 29 PhysxWheelShape::save_to_desc 0 1 721 63
/**
 * Saves the state of the shape object to a descriptor.
 */
73
void PhysxWheelShape::save_to_desc(PhysxWheelShapeDesc &shapeDesc) const;

2192 10 set_radius 0 4 3055 27 PhysxWheelShape::set_radius 0 1 722 34
/**
 * Sets the sphere radius.
 */
47
void PhysxWheelShape::set_radius(float radius);

2193 21 set_suspension_travel 0 4 3055 38 PhysxWheelShape::set_suspension_travel 0 1 723 120
/**
 * Set the maximum extension distance of suspension along shape's -Y axis.
 * The minimum extension is always 0.
 */
58
void PhysxWheelShape::set_suspension_travel(float travel);

2194 22 set_inverse_wheel_mass 0 4 3055 39 PhysxWheelShape::set_inverse_wheel_mass 0 1 724 111
/**
 * Set the inverse mass of the wheel.  Determines the wheel velocity that
 * wheel torques can achieve.
 */
60
void PhysxWheelShape::set_inverse_wheel_mass(float invMass);

2195 16 set_motor_torque 0 4 3055 33 PhysxWheelShape::set_motor_torque 0 1 725 103
/**
 * Set the sum engine torque on the wheel axle.  Positive or negative
 * depending on direction
 */
53
void PhysxWheelShape::set_motor_torque(float torque);

2196 16 set_brake_torque 0 4 3055 33 PhysxWheelShape::set_brake_torque 0 1 726 93
/**
 * Must be nonnegative.  Very large values should lock wheel but should be
 * stable.
 */
53
void PhysxWheelShape::set_brake_torque(float torque);

2197 15 set_steer_angle 0 4 3055 32 PhysxWheelShape::set_steer_angle 0 1 727 102
/**
 * Set the steering angle, around shape Y axis.  The steering angle is
 * measured in degrees.
 */
51
void PhysxWheelShape::set_steer_angle(float angle);

2198 19 set_steer_angle_rad 0 4 3055 36 PhysxWheelShape::set_steer_angle_rad 0 1 728 102
/**
 * Set the steering angle, around shape Y axis.  The steering angle is
 * measured in radians.
 */
55
void PhysxWheelShape::set_steer_angle_rad(float angle);

2199 14 set_axle_speed 0 4 3055 31 PhysxWheelShape::set_axle_speed 0 1 729 126
/**
 * Set the current axle rotation speed.  Note: WSF_axle_speed_override flag
 * must be raised for this to have effect!
 */
50
void PhysxWheelShape::set_axle_speed(float speed);

2200 14 set_wheel_flag 0 4 3055 31 PhysxWheelShape::set_wheel_flag 0 1 730 58
/**
 * Turns the specified wheel shape flag on or off.
 */
87
void PhysxWheelShape::set_wheel_flag(PhysxEnums::PhysxWheelShapeFlag flag, bool value);

2201 14 set_suspension 0 4 3055 31 PhysxWheelShape::set_suspension 0 1 731 66
/**
 * Set the data intended for car wheel suspension effects.
 */
68
void PhysxWheelShape::set_suspension(PhysxSpringDesc const &spring);

2202 10 get_radius 0 4 3055 27 PhysxWheelShape::get_radius 0 1 732 44
/**
 * Returns the radius of the sphere.
 */
46
float PhysxWheelShape::get_radius(void) const;

2203 21 get_suspension_travel 0 4 3055 38 PhysxWheelShape::get_suspension_travel 0 1 733 40
/**
 * Returns the suspension travel
 */
57
float PhysxWheelShape::get_suspension_travel(void) const;

2204 22 get_inverse_wheel_mass 0 4 3055 39 PhysxWheelShape::get_inverse_wheel_mass 0 1 734 115
/**
 * Returns the inverse mass of the wheel.  Determines the wheel velocity that
 * wheel torques can achieve.
 */
58
float PhysxWheelShape::get_inverse_wheel_mass(void) const;

2205 16 get_motor_torque 0 4 3055 33 PhysxWheelShape::get_motor_torque 0 1 735 109
/**
 * Retrieves the sum engine torque on the wheel axle.  Positive or negative
 * depending on direction
 */
52
float PhysxWheelShape::get_motor_torque(void) const;

2206 16 get_brake_torque 0 4 3055 33 PhysxWheelShape::get_brake_torque 0 1 736 93
/**
 * Must be nonnegative.  Very large values should lock wheel but should be
 * stable.
 */
52
float PhysxWheelShape::get_brake_torque(void) const;

2207 15 get_steer_angle 0 4 3055 32 PhysxWheelShape::get_steer_angle 0 1 737 108
/**
 * Retrieves the steering angle, around shape Y axis.  The steering angle is
 * measured in degrees.
 */
51
float PhysxWheelShape::get_steer_angle(void) const;

2208 19 get_steer_angle_rad 0 4 3055 36 PhysxWheelShape::get_steer_angle_rad 0 1 738 108
/**
 * Retrieves the steering angle, around shape Y axis.  The steering angle is
 * measured in radians.
 */
55
float PhysxWheelShape::get_steer_angle_rad(void) const;

2209 14 get_axle_speed 0 4 3055 31 PhysxWheelShape::get_axle_speed 0 1 739 53
/**
 * Retrieves the current axle rotation speed.
 */
50
float PhysxWheelShape::get_axle_speed(void) const;

2210 14 get_wheel_flag 0 4 3055 31 PhysxWheelShape::get_wheel_flag 0 1 740 63
/**
 * Returns the value of the specified wheel shape flag.
 */
81
bool PhysxWheelShape::get_wheel_flag(PhysxEnums::PhysxWheelShapeFlag flag) const;

2211 14 get_class_type 0 4 3055 31 PhysxWheelShape::get_class_type 0 1 741 0
56
static TypeHandle PhysxWheelShape::get_class_type(void);

2212 14 PhysxActorDesc 0 4 3056 30 PhysxActorDesc::PhysxActorDesc 0 1 742 10
/**
 *
 */
44
inline PhysxActorDesc::PhysxActorDesc(void);

2213 15 ~PhysxActorDesc 0 4 3056 31 PhysxActorDesc::~PhysxActorDesc 0 0 10
/**
 *
 */
45
inline PhysxActorDesc::~PhysxActorDesc(void);

2214 14 set_to_default 0 4 3056 30 PhysxActorDesc::set_to_default 0 1 743 49
/**
 * (re)sets the structure to the default.
 */
49
inline void PhysxActorDesc::set_to_default(void);

2215 8 is_valid 0 4 3056 24 PhysxActorDesc::is_valid 0 1 744 51
/**
 * Returns true if the descriptor is valid.
 */
49
inline bool PhysxActorDesc::is_valid(void) const;

2216 9 add_shape 0 4 3056 25 PhysxActorDesc::add_shape 0 1 745 77
/**
 * Adds a shape to the list of collision shapes composing this actor.
 */
53
void PhysxActorDesc::add_shape(PhysxShapeDesc &desc);

2217 8 set_name 0 4 3056 24 PhysxActorDesc::set_name 0 1 746 54
/**
 * Sets the optional debug name for the actor.
 */
48
void PhysxActorDesc::set_name(char const *name);

2218 11 set_density 0 4 3056 27 PhysxActorDesc::set_density 0 1 747 138
/**
 * Set the density used during mass/intertia computation.  This value is used
 * if the actor's shapes do not have a mass asigned.
 */
48
void PhysxActorDesc::set_density(float density);

2219 14 set_global_pos 0 4 3056 30 PhysxActorDesc::set_global_pos 0 1 748 57
/**
 * Set the position of the actor in global space.
 */
57
void PhysxActorDesc::set_global_pos(LPoint3f const &pos);

2220 14 set_global_mat 0 4 3056 30 PhysxActorDesc::set_global_mat 0 1 749 159
/**
 * Set the position and orientation of the actor in global space.  Scaling and
 * shear arenot supported, even if the matrix contains a scale or shear.
 */
58
void PhysxActorDesc::set_global_mat(LMatrix4f const &mat);

2221 14 set_global_hpr 0 4 3056 30 PhysxActorDesc::set_global_hpr 0 1 750 112
/**
 * Sets the orientation of the actor in global space by providing angles for
 * heading, pitch and roll.
 */
63
void PhysxActorDesc::set_global_hpr(float h, float p, float r);

2222 8 set_body 0 4 3056 24 PhysxActorDesc::set_body 0 1 751 151
/**
 * Sets the body descriptor for this actor.  The actor will be dynmaic if a
 * body descriptor is set, and static if no body descriptor is set.
 */
51
void PhysxActorDesc::set_body(PhysxBodyDesc &desc);

2223 8 get_name 0 4 3056 24 PhysxActorDesc::get_name 0 1 752 58
/**
 * Returns the optional debug name for this actor.
 */
49
char const *PhysxActorDesc::get_name(void) const;

2224 11 get_density 0 4 3056 27 PhysxActorDesc::get_density 0 1 753 39
/**
 * Returns the actor's density.
 */
46
float PhysxActorDesc::get_density(void) const;

2225 14 get_global_pos 0 4 3056 30 PhysxActorDesc::get_global_pos 0 1 754 56
/**
 * Returns the actor's position in global space.
 */
52
LPoint3f PhysxActorDesc::get_global_pos(void) const;

2226 14 get_global_mat 0 4 3056 30 PhysxActorDesc::get_global_mat 0 1 755 57
/**
 * Returns the actor's transform in global space.
 */
53
LMatrix4f PhysxActorDesc::get_global_mat(void) const;

2227 8 get_body 0 4 3056 24 PhysxActorDesc::get_body 0 1 756 51
/**
 * Gets the body descriptor for this actor.
 */
51
PhysxBodyDesc PhysxActorDesc::get_body(void) const;

2228 13 PhysxBodyDesc 0 4 3057 28 PhysxBodyDesc::PhysxBodyDesc 0 1 757 10
/**
 *
 */
42
inline PhysxBodyDesc::PhysxBodyDesc(void);

2229 14 ~PhysxBodyDesc 0 4 3057 29 PhysxBodyDesc::~PhysxBodyDesc 0 0 10
/**
 *
 */
43
inline PhysxBodyDesc::~PhysxBodyDesc(void);

2230 14 set_to_default 0 4 3057 29 PhysxBodyDesc::set_to_default 0 1 758 49
/**
 * (re)sets the structure to the default.
 */
48
inline void PhysxBodyDesc::set_to_default(void);

2231 8 is_valid 0 4 3057 23 PhysxBodyDesc::is_valid 0 1 759 51
/**
 * Returns true if the descriptor is valid.
 */
48
inline bool PhysxBodyDesc::is_valid(void) const;

2232 8 set_mass 0 4 3057 23 PhysxBodyDesc::set_mass 0 1 760 32
/**
 * Set the mass of body.
 */
41
void PhysxBodyDesc::set_mass(float mass);

2233 18 set_linear_damping 0 4 3057 33 PhysxBodyDesc::set_linear_damping 0 1 761 54
/**
 * Set the linear damping applied to the body.
 */
54
void PhysxBodyDesc::set_linear_damping(float damping);

2234 19 set_angular_damping 0 4 3057 34 PhysxBodyDesc::set_angular_damping 0 1 762 55
/**
 * Set the angular damping applied to the body.
 */
55
void PhysxBodyDesc::set_angular_damping(float damping);

2235 19 set_linear_velocity 0 4 3057 34 PhysxBodyDesc::set_linear_velocity 0 1 763 47
/**
 * Set the linear Velocity of the body.
 */
67
void PhysxBodyDesc::set_linear_velocity(LVector3f const &velocity);

2236 20 set_angular_velocity 0 4 3057 35 PhysxBodyDesc::set_angular_velocity 0 1 764 48
/**
 * Set the angular velocity of the body.
 */
68
void PhysxBodyDesc::set_angular_velocity(LVector3f const &velocity);

2237 24 set_max_angular_velocity 0 4 3057 39 PhysxBodyDesc::set_max_angular_velocity 0 1 765 66
/**
 * Set the maximum allowed angular velocity for this body.
 */
60
void PhysxBodyDesc::set_max_angular_velocity(float maximum);

2238 25 set_sleep_linear_velocity 0 4 3057 40 PhysxBodyDesc::set_sleep_linear_velocity 0 1 766 77
/**
 * Set the maximum linear velocity at which the body can go to sleep.
 */
62
void PhysxBodyDesc::set_sleep_linear_velocity(float velocity);

2239 26 set_sleep_angular_velocity 0 4 3057 41 PhysxBodyDesc::set_sleep_angular_velocity 0 1 767 74
/**
 * Set the maximum angular velocity at which body can go to sleep.
 */
63
void PhysxBodyDesc::set_sleep_angular_velocity(float velocity);

2240 26 set_solver_iteration_count 0 4 3057 41 PhysxBodyDesc::set_solver_iteration_count 0 1 768 114
/**
 * Set the number of solver iterations performed when processing
 * joint/contacts connected to this body.
 */
67
void PhysxBodyDesc::set_solver_iteration_count(unsigned int count);

2241 26 set_sleep_energy_threshold 0 4 3057 41 PhysxBodyDesc::set_sleep_energy_threshold 0 1 769 126
/**
 * Set the threshold for the energy-based sleeping algorithm.  Only used when
 * the BF_energy_sleep_test flag is set.
 */
64
void PhysxBodyDesc::set_sleep_energy_threshold(float threshold);

2242 17 set_sleep_damping 0 4 3057 32 PhysxBodyDesc::set_sleep_damping 0 1 770 69
/**
 * Set the damping factor for bodies that are about to sleep.
 */
53
void PhysxBodyDesc::set_sleep_damping(float damping);

2243 18 set_mass_local_mat 0 4 3057 33 PhysxBodyDesc::set_mass_local_mat 0 1 771 66
/**
 * Set the position and orientation of the center of mass.
 */
61
void PhysxBodyDesc::set_mass_local_mat(LMatrix4f const &mat);

2244 22 set_mass_space_inertia 0 4 3057 37 PhysxBodyDesc::set_mass_space_inertia 0 1 772 75
/**
 * Set the diagonal mass space inertia tensor in bodies mass frame.
 */
69
void PhysxBodyDesc::set_mass_space_inertia(LVector3f const &inertia);

2245 8 set_flag 0 4 3057 23 PhysxBodyDesc::set_flag 0 1 773 48
/**
 * Raise or lower individual body flags.
 */
73
void PhysxBodyDesc::set_flag(PhysxEnums::PhysxBodyFlag flag, bool value);

2246 24 set_ccd_motion_threshold 0 4 3057 39 PhysxBodyDesc::set_ccd_motion_threshold 0 1 774 143
/**
 * When CCD is globally enabled, it is still not performed if the motion
 * distance of all points on the body is below this threshold.
 */
62
void PhysxBodyDesc::set_ccd_motion_threshold(float threshold);

2247 19 set_wake_up_counter 0 4 3057 34 PhysxBodyDesc::set_wake_up_counter 0 1 775 50
/**
 * Set the body's initial wake up counter.
 */
53
void PhysxBodyDesc::set_wake_up_counter(float value);

2248 28 set_contact_report_threshold 0 4 3057 43 PhysxBodyDesc::set_contact_report_threshold 0 1 776 55
/**
 * Set The force threshold for contact reports.
 */
66
void PhysxBodyDesc::set_contact_report_threshold(float threshold);

2249 8 get_mass 0 4 3057 23 PhysxBodyDesc::get_mass 0 1 777 32
/**
 * Get the mass of body.
 */
42
float PhysxBodyDesc::get_mass(void) const;

2250 18 get_linear_damping 0 4 3057 33 PhysxBodyDesc::get_linear_damping 0 1 778 54
/**
 * Get the linear damping applied to the body.
 */
52
float PhysxBodyDesc::get_linear_damping(void) const;

2251 19 get_angular_damping 0 4 3057 34 PhysxBodyDesc::get_angular_damping 0 1 779 55
/**
 * Get the angular damping applied to the body.
 */
53
float PhysxBodyDesc::get_angular_damping(void) const;

2252 19 get_linear_velocity 0 4 3057 34 PhysxBodyDesc::get_linear_velocity 0 1 780 47
/**
 * Get the linear Velocity of the body.
 */
57
LVector3f PhysxBodyDesc::get_linear_velocity(void) const;

2253 20 get_angular_velocity 0 4 3057 35 PhysxBodyDesc::get_angular_velocity 0 1 781 48
/**
 * Get the angular velocity of the body.
 */
58
LVector3f PhysxBodyDesc::get_angular_velocity(void) const;

2254 24 get_max_angular_velocity 0 4 3057 39 PhysxBodyDesc::get_max_angular_velocity 0 1 782 66
/**
 * Get the maximum allowed angular velocity for this body.
 */
58
float PhysxBodyDesc::get_max_angular_velocity(void) const;

2255 25 get_sleep_linear_velocity 0 4 3057 40 PhysxBodyDesc::get_sleep_linear_velocity 0 1 783 77
/**
 * Get the maximum linear velocity at which the body can go to sleep.
 */
59
float PhysxBodyDesc::get_sleep_linear_velocity(void) const;

2256 26 get_sleep_angular_velocity 0 4 3057 41 PhysxBodyDesc::get_sleep_angular_velocity 0 1 784 74
/**
 * Get the maximum angular velocity at which body can go to sleep.
 */
60
float PhysxBodyDesc::get_sleep_angular_velocity(void) const;

2257 26 get_solver_iteration_count 0 4 3057 41 PhysxBodyDesc::get_solver_iteration_count 0 1 785 114
/**
 * Get the number of solver iterations performed when processing
 * joint/contacts connected to this body.
 */
67
unsigned int PhysxBodyDesc::get_solver_iteration_count(void) const;

2258 26 get_sleep_energy_threshold 0 4 3057 41 PhysxBodyDesc::get_sleep_energy_threshold 0 1 786 126
/**
 * Get the threshold for the energy-based sleeping algorithm.  Only used when
 * the BF_energy_sleep_test flag is set.
 */
60
float PhysxBodyDesc::get_sleep_energy_threshold(void) const;

2259 17 get_sleep_damping 0 4 3057 32 PhysxBodyDesc::get_sleep_damping 0 1 787 69
/**
 * Get the damping factor for bodies that are about to sleep.
 */
51
float PhysxBodyDesc::get_sleep_damping(void) const;

2260 18 get_mass_local_mat 0 4 3057 33 PhysxBodyDesc::get_mass_local_mat 0 1 788 66
/**
 * Get the position and orientation of the center of mass.
 */
56
LMatrix4f PhysxBodyDesc::get_mass_local_mat(void) const;

2261 22 get_mass_space_inertia 0 4 3057 37 PhysxBodyDesc::get_mass_space_inertia 0 1 789 75
/**
 * Get the diagonal mass space inertia tensor in bodies mass frame.
 */
60
LVector3f PhysxBodyDesc::get_mass_space_inertia(void) const;

2262 8 get_flag 0 4 3057 23 PhysxBodyDesc::get_flag 0 1 790 43
/**
 * Returns the specified body flag.
 */
67
bool PhysxBodyDesc::get_flag(PhysxEnums::PhysxBodyFlag flag) const;

2263 24 get_ccd_motion_threshold 0 4 3057 39 PhysxBodyDesc::get_ccd_motion_threshold 0 1 791 10
/**
 *
 */
58
float PhysxBodyDesc::get_ccd_motion_threshold(void) const;

2264 19 get_wake_up_counter 0 4 3057 34 PhysxBodyDesc::get_wake_up_counter 0 1 792 10
/**
 *
 */
53
float PhysxBodyDesc::get_wake_up_counter(void) const;

2265 28 get_contact_report_threshold 0 4 3057 43 PhysxBodyDesc::get_contact_report_threshold 0 1 793 10
/**
 *
 */
62
float PhysxBodyDesc::get_contact_report_threshold(void) const;

2266 20 upcast_to_PhysxEnums 0 12 3058 36 PhysxShapeDesc::upcast_to_PhysxEnums 0 1 817 40
upcast from PhysxShapeDesc to PhysxEnums
55
PhysxEnums *PhysxShapeDesc::upcast_to_PhysxEnums(void);

2267 26 downcast_to_PhysxShapeDesc 0 12 2965 38 PhysxEnums::downcast_to_PhysxShapeDesc 0 1 818 42
downcast from PhysxEnums to PhysxShapeDesc
61
PhysxShapeDesc *PhysxEnums::downcast_to_PhysxShapeDesc(void);

2268 24 upcast_to_ReferenceCount 0 12 3058 40 PhysxShapeDesc::upcast_to_ReferenceCount 0 1 819 44
upcast from PhysxShapeDesc to ReferenceCount
63
ReferenceCount *PhysxShapeDesc::upcast_to_ReferenceCount(void);

2269 26 downcast_to_PhysxShapeDesc 0 12 3059 42 ReferenceCount::downcast_to_PhysxShapeDesc 0 1 820 46
downcast from ReferenceCount to PhysxShapeDesc
65
PhysxShapeDesc *ReferenceCount::downcast_to_PhysxShapeDesc(void);

2270 14 set_to_default 0 6 3058 30 PhysxShapeDesc::set_to_default 0 1 794 0
54
virtual void PhysxShapeDesc::set_to_default(void) = 0;

2271 8 is_valid 0 6 3058 24 PhysxShapeDesc::is_valid 0 1 795 0
54
virtual bool PhysxShapeDesc::is_valid(void) const = 0;

2272 8 set_name 0 4 3058 24 PhysxShapeDesc::set_name 0 1 796 38
/**
 * Sets a possible debug name.
 */
48
void PhysxShapeDesc::set_name(char const *name);

2273 11 set_trigger 0 4 3058 27 PhysxShapeDesc::set_trigger 0 1 797 181
/**
 * This shape will become a trigger shape if this parameter is set to TRUE. It
 * won't take part in collisions, but trigger events if some other shape
 * passes through it.
 */
45
void PhysxShapeDesc::set_trigger(bool value);

2274 13 set_local_pos 0 4 3058 29 PhysxShapeDesc::set_local_pos 0 1 798 10
/**
 *
 */
56
void PhysxShapeDesc::set_local_pos(LPoint3f const &pos);

2275 13 set_local_mat 0 4 3058 29 PhysxShapeDesc::set_local_mat 0 1 799 10
/**
 *
 */
57
void PhysxShapeDesc::set_local_mat(LMatrix4f const &mat);

2276 13 set_local_hpr 0 4 3058 29 PhysxShapeDesc::set_local_hpr 0 1 800 10
/**
 *
 */
62
void PhysxShapeDesc::set_local_hpr(float h, float p, float r);

2277 14 set_skin_width 0 4 3058 30 PhysxShapeDesc::set_skin_width 0 1 801 619
/**
 * Specifies by how much shapes can interpenetrate.
 *
 * Two shapes will interpenetrate by the sum of their skin widths.  This means
 * that their graphical representations should be adjusted so that they just
 * touch when the shapes are interpenetrating.
 *
 * The default skin width is the 'physx-skin-width' parameter.
 *
 * A skin width sum of zero for two bodies is not permitted because it will
 * lead to an unstable simulation.
 *
 * If your simulation jitters because resting bodies occasionally lose
 * contact, increasing the size of your collision volumes and the skin width
 * may improve things.
 */
53
void PhysxShapeDesc::set_skin_width(float skinWidth);

2278 14 set_shape_flag 0 4 3058 30 PhysxShapeDesc::set_shape_flag 0 1 802 10
/**
 *
 */
87
void PhysxShapeDesc::set_shape_flag(PhysxEnums::PhysxShapeFlag const flag, bool value);

2279 8 set_mass 0 4 3058 24 PhysxShapeDesc::set_mass 0 1 803 314
/**
 * Sets the mass of this individual shape when computing mass inertial
 * properties for a rigidbody.  When mass<=0.0 then density and volume
 * determine the mass.  Note that this will only be used if the body has a
 * zero inertia tensor, or if you call PhysxActor::update_mass_from_shapes
 * explicitly.
 */
42
void PhysxShapeDesc::set_mass(float mass);

2280 11 set_density 0 4 3058 27 PhysxShapeDesc::set_density 0 1 804 292
/**
 * Sets the density of this individual shape when computing mass inertial
 * properties for a rigidbody (unless a valid mass >0.0 is provided). Note
 * that this will only be used if the body has a zero inertia tensor, or if
 * you call PhysxActor::update_mass_from_shapes explicitly.
 */
48
void PhysxShapeDesc::set_density(float density);

2281 9 set_group 0 4 3058 25 PhysxShapeDesc::set_group 0 1 805 10
/**
 *
 */
57
void PhysxShapeDesc::set_group(unsigned short int group);

2282 12 set_material 0 4 3058 28 PhysxShapeDesc::set_material 0 1 806 10
/**
 *
 */
65
void PhysxShapeDesc::set_material(PhysxMaterial const &material);

2283 18 set_material_index 0 4 3058 34 PhysxShapeDesc::set_material_index 0 1 807 10
/**
 *
 */
66
void PhysxShapeDesc::set_material_index(unsigned short int index);

2284 8 get_name 0 4 3058 24 PhysxShapeDesc::get_name 0 1 808 10
/**
 *
 */
49
char const *PhysxShapeDesc::get_name(void) const;

2285 13 get_local_pos 0 4 3058 29 PhysxShapeDesc::get_local_pos 0 1 809 10
/**
 *
 */
51
LPoint3f PhysxShapeDesc::get_local_pos(void) const;

2286 13 get_local_mat 0 4 3058 29 PhysxShapeDesc::get_local_mat 0 1 810 10
/**
 *
 */
52
LMatrix4f PhysxShapeDesc::get_local_mat(void) const;

2287 14 get_skin_width 0 4 3058 30 PhysxShapeDesc::get_skin_width 0 1 811 10
/**
 *
 */
49
float PhysxShapeDesc::get_skin_width(void) const;

2288 14 get_shape_flag 0 4 3058 30 PhysxShapeDesc::get_shape_flag 0 1 812 10
/**
 *
 */
81
bool PhysxShapeDesc::get_shape_flag(PhysxEnums::PhysxShapeFlag const flag) const;

2289 8 get_mass 0 4 3058 24 PhysxShapeDesc::get_mass 0 1 813 10
/**
 *
 */
43
float PhysxShapeDesc::get_mass(void) const;

2290 11 get_density 0 4 3058 27 PhysxShapeDesc::get_density 0 1 814 10
/**
 *
 */
46
float PhysxShapeDesc::get_density(void) const;

2291 9 get_group 0 4 3058 25 PhysxShapeDesc::get_group 0 1 815 10
/**
 *
 */
57
unsigned short int PhysxShapeDesc::get_group(void) const;

2292 18 get_material_index 0 4 3058 34 PhysxShapeDesc::get_material_index 0 1 816 10
/**
 *
 */
66
unsigned short int PhysxShapeDesc::get_material_index(void) const;

2293 12 PhysxBounds3 0 4 3060 26 PhysxBounds3::PhysxBounds3 0 1 821 10
/**
 *
 */
40
inline PhysxBounds3::PhysxBounds3(void);

2294 13 ~PhysxBounds3 0 4 3060 27 PhysxBounds3::~PhysxBounds3 0 0 10
/**
 *
 */
41
inline PhysxBounds3::~PhysxBounds3(void);

2295 13 bounds_of_obb 0 4 3060 27 PhysxBounds3::bounds_of_obb 0 1 822 171
/**
 * Sets this to the AABB (axis ligned bounding box) of the OBB (oriented
 * bounding box). The OBB is described by orientation, translation and half
 * dimensions.
 */
120
void PhysxBounds3::bounds_of_obb(LMatrix3f const &orientation, LPoint3f const &translation, LVector3f const &half_dims);

2296 7 combine 0 4 3060 21 PhysxBounds3::combine 0 1 823 49
/**
 * Sets this to the union of this and b2.
 */
51
void PhysxBounds3::combine(PhysxBounds3 const &b2);

2297 7 contain 0 4 3060 21 PhysxBounds3::contain 0 1 824 60
/**
 * Returns TRUE if these bounds contain the point v.
 */
52
bool PhysxBounds3::contain(LPoint3f const &p) const;

2298 6 fatten 0 4 3060 20 PhysxBounds3::fatten 0 1 825 74
/**
 * Fattens the AABB in all three dimensions by the given distance.
 */
42
void PhysxBounds3::fatten(float distance);

2299 7 include 0 4 3060 21 PhysxBounds3::include 0 1 826 53
/**
 * Expands the volume to include the point v.
 */
46
void PhysxBounds3::include(LPoint3f const &v);

2300 10 intersects 0 4 3060 24 PhysxBounds3::intersects 0 1 827 74
/**
 * Returns TRUE if the intersection of this and b is is not empty.
 */
59
bool PhysxBounds3::intersects(PhysxBounds3 const &b) const;

2301 12 intersects2d 0 4 3060 26 PhysxBounds3::intersects2d 0 1 828 146
/**
 * Indicates whether the intersection of this and b is empty or not in the
 * plane orthogonal to the axis passed (X = 0, Y = 1 or Z = 2).
 */
90
bool PhysxBounds3::intersects2d(PhysxBounds3 const &b, unsigned int axis_to_ignore) const;

2302 8 is_empty 0 4 3060 22 PhysxBounds3::is_empty 0 1 829 53
/**
 * Returns TRUE if the bounding box is empty.
 */
40
bool PhysxBounds3::is_empty(void) const;

2303 5 scale 0 4 3060 19 PhysxBounds3::scale 0 1 830 47
/**
 * Scales the AABB by the given factor.
 */
38
void PhysxBounds3::scale(float scale);

2304 3 set 0 4 3060 17 PhysxBounds3::set 0 1 831 66
/**
 * Setup this AABB from minimum corner and maximum corner.
 */
65
void PhysxBounds3::set(LPoint3f const &min, LPoint3f const &max);

2305 18 set_center_extents 0 4 3060 32 PhysxBounds3::set_center_extents 0 1 832 64
/**
 * Setup this AABB from center point and extents vector.
 */
88
void PhysxBounds3::set_center_extents(LPoint3f const &center, LVector3f const &extents);

2306 9 set_empty 0 4 3060 23 PhysxBounds3::set_empty 0 1 833 30
/**
 * Sets empty to TRUE.
 */
35
void PhysxBounds3::set_empty(void);

2307 12 set_infinite 0 4 3060 26 PhysxBounds3::set_infinite 0 1 834 32
/**
 * Sets infinite bounds.
 */
38
void PhysxBounds3::set_infinite(void);

2308 9 transform 0 4 3060 23 PhysxBounds3::transform 0 1 835 185
/**
 * Transforms this volume as if it was an axis aligned bounding box, and then
 * assigns the results' bounds to this.  The orientation is applied first,
 * then the translation.
 */
88
void PhysxBounds3::transform(LMatrix3f const &orientation, LPoint3f const &translation);

2309 7 get_max 0 4 3060 21 PhysxBounds3::get_max 0 1 836 58
/**
 * Returns the minimum corner of the bounding box.
 */
43
LPoint3f PhysxBounds3::get_max(void) const;

2310 7 get_min 0 4 3060 21 PhysxBounds3::get_min 0 1 837 58
/**
 * Returns the maximum corner of the bounding box.
 */
43
LPoint3f PhysxBounds3::get_min(void) const;

2311 10 get_center 0 4 3060 24 PhysxBounds3::get_center 0 1 838 50
/**
 * Returns the center of the bounding box.
 */
46
LPoint3f PhysxBounds3::get_center(void) const;

2312 14 get_dimensions 0 4 3060 28 PhysxBounds3::get_dimensions 0 1 839 51
/**
 * Returns the extents of the bounding box.
 */
51
LVector3f PhysxBounds3::get_dimensions(void) const;

2313 7 set_max 0 4 3060 21 PhysxBounds3::set_max 0 1 840 55
/**
 * Sets the maximum corner of the bounding box.
 */
43
void PhysxBounds3::set_max(LPoint3f value);

2314 7 set_min 0 4 3060 21 PhysxBounds3::set_min 0 1 841 55
/**
 * Sets the minimum corner of the bounding box.
 */
43
void PhysxBounds3::set_min(LPoint3f value);

2315 8 PhysxBox 0 4 3061 18 PhysxBox::PhysxBox 0 2 842 843 22
/**
 *
 */

/**
 *
 */
124
inline PhysxBox::PhysxBox(void);
PhysxBox::PhysxBox(LPoint3f const &center, LVector3f const &extents, LMatrix3f const &rot);

2316 9 ~PhysxBox 0 4 3061 19 PhysxBox::~PhysxBox 0 0 10
/**
 *
 */
33
inline PhysxBox::~PhysxBox(void);

2317 8 is_valid 0 4 3061 18 PhysxBox::is_valid 0 1 844 44
/**
 * Returns TRUE if the box is valid.
 */
36
bool PhysxBox::is_valid(void) const;

2318 6 rotate 0 4 3061 16 PhysxBox::rotate 0 1 845 75
/**
 * Recomputes the box after an arbitrary transform by a 4x4 matrix.
 */
63
void PhysxBox::rotate(LMatrix4f const &m, PhysxBox &obb) const;

2319 9 set_empty 0 4 3061 19 PhysxBox::set_empty 0 1 846 31
/**
 * Setups an empty box.
 */
31
void PhysxBox::set_empty(void);

2320 10 get_center 0 4 3061 20 PhysxBox::get_center 0 1 847 36
/**
 * Return center of the box.
 */
42
LPoint3f PhysxBox::get_center(void) const;

2321 11 get_extents 0 4 3061 21 PhysxBox::get_extents 0 1 848 50
/**
 * Returns the extents (radii) of the box.
 */
44
LVector3f PhysxBox::get_extents(void) const;

2322 7 get_rot 0 4 3061 17 PhysxBox::get_rot 0 1 849 42
/**
 * Return the rotation of the box.
 */
40
LMatrix3f PhysxBox::get_rot(void) const;

2323 10 set_center 0 4 3061 20 PhysxBox::set_center 0 1 850 38
/**
 * Sets the center of the box.
 */
43
void PhysxBox::set_center(LPoint3f center);

2324 11 set_extents 0 4 3061 21 PhysxBox::set_extents 0 1 851 39
/**
 * Sets the extents of the box.
 */
46
void PhysxBox::set_extents(LVector3f extents);

2325 7 set_rot 0 4 3061 17 PhysxBox::set_rot 0 1 852 40
/**
 * Sets the rotation of the box.
 */
38
void PhysxBox::set_rot(LMatrix3f rot);

2326 20 ~PhysxControllerDesc 0 6 3062 41 PhysxControllerDesc::~PhysxControllerDesc 0 0 0
56
virtual PhysxControllerDesc::~PhysxControllerDesc(void);

2327 14 set_to_default 0 6 3062 35 PhysxControllerDesc::set_to_default 0 1 853 0
59
virtual void PhysxControllerDesc::set_to_default(void) = 0;

2328 8 is_valid 0 6 3062 29 PhysxControllerDesc::is_valid 0 1 854 0
59
virtual bool PhysxControllerDesc::is_valid(void) const = 0;

2329 7 set_pos 0 4 3062 28 PhysxControllerDesc::set_pos 0 1 855 45
/**
 * Set the position of the character.
 */
55
void PhysxControllerDesc::set_pos(LPoint3f const &pos);

2330 15 set_slope_limit 0 4 3062 36 PhysxControllerDesc::set_slope_limit 0 1 856 289
/**
 * Sets the maximum slope which the character can walk up.  In general it is
 * desirable to limit where the character can walk, in particular it is
 * unrealistic for the character to be able to climb arbitary slopes.  The
 * value is expressed in degrees.  Default: 45.0 degrees.
 */
60
void PhysxControllerDesc::set_slope_limit(float slopeLimit);

2331 14 set_skin_width 0 4 3062 35 PhysxControllerDesc::set_skin_width 0 1 857 258
/**
 * Sets the skin width used by the controller.  A "skin" around the controller
 * is necessary to avoid numerical precision issues.  This is dependant on the
 * scale of the users world, but should be a small, positive non zero value.
 * Default: 0.1
 */
58
void PhysxControllerDesc::set_skin_width(float skinWidth);

2332 15 set_step_offset 0 4 3062 36 PhysxControllerDesc::set_step_offset 0 1 858 295
/**
 * Defines the maximum height of an obstacle which the character can climb.  A
 * small value will mean that the character gets stuck and cannot walk up
 * stairs etc, a value which is too large will mean that the character can
 * climb over unrealistically high obstacles.  Default: 0.5
 */
60
void PhysxControllerDesc::set_step_offset(float setpOffset);

2333 20 set_interaction_flag 0 4 3062 41 PhysxControllerDesc::set_interaction_flag 0 1 859 153
/**
 * The interaction flag controls if a character controller collides with other
 * controllers.  The default is to collide with other controllers.
 */
69
void PhysxControllerDesc::set_interaction_flag(bool interactionFlag);

2334 7 get_pos 0 4 3062 28 PhysxControllerDesc::get_pos 0 1 860 49
/**
 * Returns the position of the character.
 */
50
LPoint3f PhysxControllerDesc::get_pos(void) const;

2335 15 get_slope_limit 0 4 3062 36 PhysxControllerDesc::get_slope_limit 0 1 861 69
/**
 * Returns the maximum slope which the character can walk up.
 */
55
float PhysxControllerDesc::get_slope_limit(void) const;

2336 14 get_skin_width 0 4 3062 35 PhysxControllerDesc::get_skin_width 0 1 862 57
/**
 * Returns the skin width used by the controller.
 */
54
float PhysxControllerDesc::get_skin_width(void) const;

2337 15 get_step_offset 0 4 3062 36 PhysxControllerDesc::get_step_offset 0 1 863 83
/**
 * Returns the maximum height of an obstacle which the character can climb.
 */
55
float PhysxControllerDesc::get_step_offset(void) const;

2338 20 get_interaction_flag 0 4 3062 41 PhysxControllerDesc::get_interaction_flag 0 1 864 40
/**
 * Returns the interaction flag.
 */
59
bool PhysxControllerDesc::get_interaction_flag(void) const;

2339 22 PhysxBoxControllerDesc 0 4 3063 46 PhysxBoxControllerDesc::PhysxBoxControllerDesc 0 1 865 10
/**
 *
 */
60
inline PhysxBoxControllerDesc::PhysxBoxControllerDesc(void);

2340 11 set_extents 0 4 3063 35 PhysxBoxControllerDesc::set_extents 0 1 866 186
/**
 * Sets the dimensions of the box.
 *
 * The dimensions are the 'radii' of the box, meaning 1/2 extents in x
 * dimension, 1/2 extents in y dimension, 1/2 extents in z dimension.
 */
67
void PhysxBoxControllerDesc::set_extents(LVector3f const &extents);

2341 11 get_extents 0 4 3063 35 PhysxBoxControllerDesc::get_extents 0 1 867 45
/**
 * Returns the dimensions of the box.
 */
58
LVector3f PhysxBoxControllerDesc::get_extents(void) const;

2342 14 set_to_default 0 6 3064 40 PhysxForceFieldShapeDesc::set_to_default 0 1 868 0
64
virtual void PhysxForceFieldShapeDesc::set_to_default(void) = 0;

2343 8 is_valid 0 6 3064 34 PhysxForceFieldShapeDesc::is_valid 0 1 869 0
64
virtual bool PhysxForceFieldShapeDesc::is_valid(void) const = 0;

2344 8 set_name 0 4 3064 34 PhysxForceFieldShapeDesc::set_name 0 1 870 38
/**
 * Sets a possible debug name.
 */
58
void PhysxForceFieldShapeDesc::set_name(char const *name);

2345 7 set_pos 0 4 3064 33 PhysxForceFieldShapeDesc::set_pos 0 1 871 10
/**
 *
 */
60
void PhysxForceFieldShapeDesc::set_pos(LPoint3f const &pos);

2346 7 set_mat 0 4 3064 33 PhysxForceFieldShapeDesc::set_mat 0 1 872 10
/**
 *
 */
61
void PhysxForceFieldShapeDesc::set_mat(LMatrix4f const &mat);

2347 7 set_hpr 0 4 3064 33 PhysxForceFieldShapeDesc::set_hpr 0 1 873 10
/**
 *
 */
66
void PhysxForceFieldShapeDesc::set_hpr(float h, float p, float r);

2348 8 get_name 0 4 3064 34 PhysxForceFieldShapeDesc::get_name 0 1 874 10
/**
 *
 */
59
char const *PhysxForceFieldShapeDesc::get_name(void) const;

2349 7 get_pos 0 4 3064 33 PhysxForceFieldShapeDesc::get_pos 0 1 875 10
/**
 *
 */
55
LPoint3f PhysxForceFieldShapeDesc::get_pos(void) const;

2350 7 get_mat 0 4 3064 33 PhysxForceFieldShapeDesc::get_mat 0 1 876 10
/**
 *
 */
56
LMatrix4f PhysxForceFieldShapeDesc::get_mat(void) const;

2351 27 PhysxBoxForceFieldShapeDesc 0 4 3065 56 PhysxBoxForceFieldShapeDesc::PhysxBoxForceFieldShapeDesc 0 1 877 10
/**
 *
 */
70
inline PhysxBoxForceFieldShapeDesc::PhysxBoxForceFieldShapeDesc(void);

2352 28 ~PhysxBoxForceFieldShapeDesc 0 4 3065 57 PhysxBoxForceFieldShapeDesc::~PhysxBoxForceFieldShapeDesc 0 0 10
/**
 *
 */
71
inline PhysxBoxForceFieldShapeDesc::~PhysxBoxForceFieldShapeDesc(void);

2353 14 set_dimensions 0 4 3065 43 PhysxBoxForceFieldShapeDesc::set_dimensions 0 1 878 186
/**
 * Sets the dimensions of the box.
 *
 * The dimensions are the 'radii' of the box, meaning 1/2 extents in x
 * dimension, 1/2 extents in y dimension, 1/2 extents in z dimension.
 */
78
void PhysxBoxForceFieldShapeDesc::set_dimensions(LVector3f const &dimensions);

2354 14 get_dimensions 0 4 3065 43 PhysxBoxForceFieldShapeDesc::get_dimensions 0 1 879 45
/**
 * Returns the dimensions of the box.
 */
66
LVector3f PhysxBoxForceFieldShapeDesc::get_dimensions(void) const;

2355 17 PhysxBoxShapeDesc 0 4 3066 36 PhysxBoxShapeDesc::PhysxBoxShapeDesc 0 1 880 10
/**
 *
 */
50
inline PhysxBoxShapeDesc::PhysxBoxShapeDesc(void);

2356 14 set_dimensions 0 4 3066 33 PhysxBoxShapeDesc::set_dimensions 0 1 881 186
/**
 * Sets the dimensions of the box.
 *
 * The dimensions are the 'radii' of the box, meaning 1/2 extents in x
 * dimension, 1/2 extents in y dimension, 1/2 extents in z dimension.
 */
68
void PhysxBoxShapeDesc::set_dimensions(LVector3f const &dimensions);

2357 14 get_dimensions 0 4 3066 33 PhysxBoxShapeDesc::get_dimensions 0 1 882 45
/**
 * Returns the dimensions of the box.
 */
56
LVector3f PhysxBoxShapeDesc::get_dimensions(void) const;

2358 12 PhysxSegment 0 4 3067 26 PhysxSegment::PhysxSegment 0 3 883 884 885 34
/**
 *
 */

/**
 *
 */

/**
 *
 */
172
inline PhysxSegment::PhysxSegment(void);
inline PhysxSegment::PhysxSegment(PhysxSegment const &segment);
PhysxSegment::PhysxSegment(LPoint3f const &p0, LPoint3f const &p1);

2359 13 ~PhysxSegment 0 4 3067 27 PhysxSegment::~PhysxSegment 0 0 10
/**
 *
 */
41
inline PhysxSegment::~PhysxSegment(void);

2360 17 compute_direction 0 4 3067 31 PhysxSegment::compute_direction 0 1 886 92
/**
 * Returns the direction vector from the segment's start point to it's end
 * point.
 */
58
void PhysxSegment::compute_direction(LPoint3f &dir) const;

2361 14 compute_length 0 4 3067 28 PhysxSegment::compute_length 0 1 887 81
/**
 * Returns the distance from the segment's start point to it's end point.
 */
47
float PhysxSegment::compute_length(void) const;

2362 13 compute_point 0 4 3067 27 PhysxSegment::compute_point 0 1 888 43
/**
 * Computes a point on the segment.
 */
61
void PhysxSegment::compute_point(LPoint3f &p, float t) const;

2363 21 compute_square_length 0 4 3067 35 PhysxSegment::compute_square_length 0 1 889 91
/**
 * Returns the square distance from the segment's start point to it's end
 * point.
 */
54
float PhysxSegment::compute_square_length(void) const;

2364 10 get_origin 0 4 3067 24 PhysxSegment::get_origin 0 1 890 50
/**
 * Returns the start point of the segment.
 */
46
LPoint3f PhysxSegment::get_origin(void) const;

2365 20 set_origin_direction 0 4 3067 34 PhysxSegment::set_origin_direction 0 1 891 77
/**
 * Setup this segment from origin (start point) and direction vector.
 */
92
void PhysxSegment::set_origin_direction(LPoint3f const &origin, LVector3f const &direction);

2366 6 get_p0 0 4 3067 20 PhysxSegment::get_p0 0 1 892 50
/**
 * Returns the start point of the segment.
 */
42
LPoint3f PhysxSegment::get_p0(void) const;

2367 6 get_p1 0 4 3067 20 PhysxSegment::get_p1 0 1 893 48
/**
 * Returns the end point of the segment.
 */
42
LPoint3f PhysxSegment::get_p1(void) const;

2368 6 set_p0 0 4 3067 20 PhysxSegment::set_p0 0 1 894 47
/**
 * Sets the start point of the segment.
 */
38
void PhysxSegment::set_p0(LPoint3f p);

2369 6 set_p1 0 4 3067 20 PhysxSegment::set_p1 0 1 895 45
/**
 * Sets the end point of the segment.
 */
38
void PhysxSegment::set_p1(LPoint3f p);

2370 12 PhysxCapsule 0 4 3068 26 PhysxCapsule::PhysxCapsule 0 2 896 897 22
/**
 *
 */

/**
 *
 */
118
inline PhysxCapsule::PhysxCapsule(void);
inline PhysxCapsule::PhysxCapsule(PhysxSegment const &segment, float radius);

2371 13 ~PhysxCapsule 0 4 3068 27 PhysxCapsule::~PhysxCapsule 0 0 10
/**
 *
 */
41
inline PhysxCapsule::~PhysxCapsule(void);

2372 17 compute_direction 0 4 3068 31 PhysxCapsule::compute_direction 0 1 898 92
/**
 * Returns the direction vector from the segment's start point to it's end
 * point.
 */
58
void PhysxCapsule::compute_direction(LPoint3f &dir) const;

2373 14 compute_length 0 4 3068 28 PhysxCapsule::compute_length 0 1 899 81
/**
 * Returns the distance from the segment's start point to it's end point.
 */
47
float PhysxCapsule::compute_length(void) const;

2374 13 compute_point 0 4 3068 27 PhysxCapsule::compute_point 0 1 900 43
/**
 * Computes a point on the segment.
 */
61
void PhysxCapsule::compute_point(LPoint3f &p, float t) const;

2375 21 compute_square_length 0 4 3068 35 PhysxCapsule::compute_square_length 0 1 901 91
/**
 * Returns the square distance from the segment's start point to it's end
 * point.
 */
54
float PhysxCapsule::compute_square_length(void) const;

2376 10 get_origin 0 4 3068 24 PhysxCapsule::get_origin 0 1 902 50
/**
 * Returns the start point of the segment.
 */
46
LPoint3f PhysxCapsule::get_origin(void) const;

2377 20 set_origin_direction 0 4 3068 34 PhysxCapsule::set_origin_direction 0 1 903 77
/**
 * Setup this capsule from origin (start point) and direction vector.
 */
92
void PhysxCapsule::set_origin_direction(LPoint3f const &origin, LVector3f const &direction);

2378 10 get_radius 0 4 3068 24 PhysxCapsule::get_radius 0 1 904 40
/**
 * Returns the capsule's radius.
 */
43
float PhysxCapsule::get_radius(void) const;

2379 6 get_p0 0 4 3068 20 PhysxCapsule::get_p0 0 1 905 50
/**
 * Returns the start point of the segment.
 */
42
LPoint3f PhysxCapsule::get_p0(void) const;

2380 6 get_p1 0 4 3068 20 PhysxCapsule::get_p1 0 1 906 48
/**
 * Returns the end point of the segment.
 */
42
LPoint3f PhysxCapsule::get_p1(void) const;

2381 10 set_radius 0 4 3068 24 PhysxCapsule::set_radius 0 1 907 37
/**
 * Sets the capsule's radius.
 */
43
void PhysxCapsule::set_radius(float value);

2382 6 set_p0 0 4 3068 20 PhysxCapsule::set_p0 0 1 908 47
/**
 * Sets the start point of the segment.
 */
38
void PhysxCapsule::set_p0(LPoint3f p);

2383 6 set_p1 0 4 3068 20 PhysxCapsule::set_p1 0 1 909 45
/**
 * Sets the end point of the segment.
 */
38
void PhysxCapsule::set_p1(LPoint3f p);

2384 26 PhysxCapsuleControllerDesc 0 4 3069 54 PhysxCapsuleControllerDesc::PhysxCapsuleControllerDesc 0 1 910 10
/**
 *
 */
68
inline PhysxCapsuleControllerDesc::PhysxCapsuleControllerDesc(void);

2385 10 set_radius 0 4 3069 38 PhysxCapsuleControllerDesc::set_radius 0 1 911 77
/**
 * Sets the radius of the capsule's hemispherical ends and its trunk.
 */
58
void PhysxCapsuleControllerDesc::set_radius(float radius);

2386 10 set_height 0 4 3069 38 PhysxCapsuleControllerDesc::set_height 0 1 912 79
/**
 * Sets the distance between the two hemispherical ends of the capsule.
 */
58
void PhysxCapsuleControllerDesc::set_height(float height);

2387 10 get_radius 0 4 3069 38 PhysxCapsuleControllerDesc::get_radius 0 1 913 72
/**
 * The radius of the capsule's hemispherical ends and its trunk.
 */
57
float PhysxCapsuleControllerDesc::get_radius(void) const;

2388 10 get_height 0 4 3069 38 PhysxCapsuleControllerDesc::get_height 0 1 914 74
/**
 * The distance between the two hemispherical ends of the capsule.
 */
57
float PhysxCapsuleControllerDesc::get_height(void) const;

2389 31 PhysxCapsuleForceFieldShapeDesc 0 4 3070 64 PhysxCapsuleForceFieldShapeDesc::PhysxCapsuleForceFieldShapeDesc 0 1 915 10
/**
 *
 */
78
inline PhysxCapsuleForceFieldShapeDesc::PhysxCapsuleForceFieldShapeDesc(void);

2390 32 ~PhysxCapsuleForceFieldShapeDesc 0 4 3070 65 PhysxCapsuleForceFieldShapeDesc::~PhysxCapsuleForceFieldShapeDesc 0 0 10
/**
 *
 */
79
inline PhysxCapsuleForceFieldShapeDesc::~PhysxCapsuleForceFieldShapeDesc(void);

2391 10 set_radius 0 4 3070 43 PhysxCapsuleForceFieldShapeDesc::set_radius 0 1 916 77
/**
 * Sets the radius of the capsule's hemispherical ends and its trunk.
 */
63
void PhysxCapsuleForceFieldShapeDesc::set_radius(float radius);

2392 10 set_height 0 4 3070 43 PhysxCapsuleForceFieldShapeDesc::set_height 0 1 917 79
/**
 * Sets the distance between the two hemispherical ends of the capsule.
 */
63
void PhysxCapsuleForceFieldShapeDesc::set_height(float height);

2393 10 get_radius 0 4 3070 43 PhysxCapsuleForceFieldShapeDesc::get_radius 0 1 918 72
/**
 * The radius of the capsule's hemispherical ends and its trunk.
 */
62
float PhysxCapsuleForceFieldShapeDesc::get_radius(void) const;

2394 10 get_height 0 4 3070 43 PhysxCapsuleForceFieldShapeDesc::get_height 0 1 919 74
/**
 * The distance between the two hemispherical ends of the capsule.
 */
62
float PhysxCapsuleForceFieldShapeDesc::get_height(void) const;

2395 21 PhysxCapsuleShapeDesc 0 4 3071 44 PhysxCapsuleShapeDesc::PhysxCapsuleShapeDesc 0 1 920 10
/**
 *
 */
58
inline PhysxCapsuleShapeDesc::PhysxCapsuleShapeDesc(void);

2396 10 set_radius 0 4 3071 33 PhysxCapsuleShapeDesc::set_radius 0 1 921 77
/**
 * Sets the radius of the capsule's hemispherical ends and its trunk.
 */
53
void PhysxCapsuleShapeDesc::set_radius(float radius);

2397 10 set_height 0 4 3071 33 PhysxCapsuleShapeDesc::set_height 0 1 922 79
/**
 * Sets the distance between the two hemispherical ends of the capsule.
 */
53
void PhysxCapsuleShapeDesc::set_height(float height);

2398 10 get_radius 0 4 3071 33 PhysxCapsuleShapeDesc::get_radius 0 1 923 72
/**
 * The radius of the capsule's hemispherical ends and its trunk.
 */
52
float PhysxCapsuleShapeDesc::get_radius(void) const;

2399 10 get_height 0 4 3071 33 PhysxCapsuleShapeDesc::get_height 0 1 924 74
/**
 * The distance between the two hemispherical ends of the capsule.
 */
52
float PhysxCapsuleShapeDesc::get_height(void) const;

2400 13 PhysxMeshPool 0 4 3072 28 PhysxMeshPool::PhysxMeshPool 0 2 925 926 10
/**
 *
 */
112
inline PhysxMeshPool::PhysxMeshPool(void);
inline PhysxMeshPool::PhysxMeshPool(PhysxMeshPool const &) = default;

2401 14 ~PhysxMeshPool 0 4 3072 29 PhysxMeshPool::~PhysxMeshPool 0 0 10
/**
 *
 */
43
inline PhysxMeshPool::~PhysxMeshPool(void);

2402 16 load_convex_mesh 0 4 3072 31 PhysxMeshPool::load_convex_mesh 0 1 927 10
/**
 *
 */
82
static PhysxConvexMesh *PhysxMeshPool::load_convex_mesh(Filename const &filename);

2403 18 load_triangle_mesh 0 4 3072 33 PhysxMeshPool::load_triangle_mesh 0 1 928 10
/**
 *
 */
86
static PhysxTriangleMesh *PhysxMeshPool::load_triangle_mesh(Filename const &filename);

2404 15 load_cloth_mesh 0 4 3072 30 PhysxMeshPool::load_cloth_mesh 0 1 929 10
/**
 *
 */
80
static PhysxClothMesh *PhysxMeshPool::load_cloth_mesh(Filename const &filename);

2405 19 load_soft_body_mesh 0 4 3072 34 PhysxMeshPool::load_soft_body_mesh 0 1 930 10
/**
 *
 */
87
static PhysxSoftBodyMesh *PhysxMeshPool::load_soft_body_mesh(Filename const &filename);

2406 19 release_convex_mesh 0 4 3072 34 PhysxMeshPool::release_convex_mesh 0 1 931 10
/**
 *
 */
70
static bool PhysxMeshPool::release_convex_mesh(PhysxConvexMesh *mesh);

2407 21 release_triangle_mesh 0 4 3072 36 PhysxMeshPool::release_triangle_mesh 0 1 932 10
/**
 *
 */
74
static bool PhysxMeshPool::release_triangle_mesh(PhysxTriangleMesh *mesh);

2408 18 release_cloth_mesh 0 4 3072 33 PhysxMeshPool::release_cloth_mesh 0 1 933 10
/**
 *
 */
68
static bool PhysxMeshPool::release_cloth_mesh(PhysxClothMesh *mesh);

2409 22 release_soft_body_mesh 0 4 3072 37 PhysxMeshPool::release_soft_body_mesh 0 1 934 10
/**
 *
 */
75
static bool PhysxMeshPool::release_soft_body_mesh(PhysxSoftBodyMesh *mesh);

2410 13 list_contents 0 4 3072 28 PhysxMeshPool::list_contents 0 2 935 936 22
/**
 *
 */

/**
 *
 */
103
static void PhysxMeshPool::list_contents(void);
static void PhysxMeshPool::list_contents(ostream &out);

2411 20 PhysxCcdSkeletonDesc 0 4 3073 42 PhysxCcdSkeletonDesc::PhysxCcdSkeletonDesc 0 1 937 10
/**
 *
 */
56
inline PhysxCcdSkeletonDesc::PhysxCcdSkeletonDesc(void);

2412 21 ~PhysxCcdSkeletonDesc 0 4 3073 43 PhysxCcdSkeletonDesc::~PhysxCcdSkeletonDesc 0 0 10
/**
 *
 */
57
inline PhysxCcdSkeletonDesc::~PhysxCcdSkeletonDesc(void);

2413 8 is_valid 0 4 3073 30 PhysxCcdSkeletonDesc::is_valid 0 1 938 51
/**
 * Returns true if the descriptor is valid.
 */
55
inline bool PhysxCcdSkeletonDesc::is_valid(void) const;

2414 16 set_num_vertices 0 4 3073 38 PhysxCcdSkeletonDesc::set_num_vertices 0 1 939 241
/**
 * Sets the number of vertices to be stored within this triangle mesh.  The
 * function allocates memory for the vertices, but it does not set any
 * vertices.
 *
 * This method must be called before any calls to set_vertex are done!
 */
60
void PhysxCcdSkeletonDesc::set_num_vertices(unsigned int n);

2415 10 set_vertex 0 4 3073 32 PhysxCcdSkeletonDesc::set_vertex 0 1 940 118
/**
 * Sets a single vertex.  You have to call the function set_num_vertices
 * before you can call this function.
 */
78
void PhysxCcdSkeletonDesc::set_vertex(unsigned int idx, LPoint3f const &vert);

2416 17 set_num_triangles 0 4 3073 39 PhysxCcdSkeletonDesc::set_num_triangles 0 1 941 151
/**
 * Sets the number of triangles to be stored in this triangle mesh.
 *
 * This method must be called before any calls to set_triangle are done!
 */
61
void PhysxCcdSkeletonDesc::set_num_triangles(unsigned int n);

2417 12 set_triangle 0 4 3073 34 PhysxCcdSkeletonDesc::set_triangle 0 1 942 77
/**
 * Sets a single triangle, by providing the three indices i1, i2, i3.
 */
109
void PhysxCcdSkeletonDesc::set_triangle(unsigned int idx, unsigned int i1, unsigned int i2, unsigned int i3);

2418 18 set_from_node_path 0 4 3073 40 PhysxCcdSkeletonDesc::set_from_node_path 0 1 943 308
/**
 * A convenience method to set the mesh data from a NodePath in a single call.
 * The method iterates over the NodePath geoms and collects data for the
 * triangle mesh.
 *
 * Do not use the following function when using this one: - set_num_vertices -
 * set_vertex - set_num_triangles - set_triangle
 */
66
void PhysxCcdSkeletonDesc::set_from_node_path(NodePath const &np);

2419 14 PhysxClothDesc 0 4 3074 30 PhysxClothDesc::PhysxClothDesc 0 1 944 10
/**
 *
 */
44
inline PhysxClothDesc::PhysxClothDesc(void);

2420 15 ~PhysxClothDesc 0 4 3074 31 PhysxClothDesc::~PhysxClothDesc 0 0 10
/**
 *
 */
45
inline PhysxClothDesc::~PhysxClothDesc(void);

2421 14 set_to_default 0 4 3074 30 PhysxClothDesc::set_to_default 0 1 945 49
/**
 * (re)sets the structure to the default.
 */
49
inline void PhysxClothDesc::set_to_default(void);

2422 8 is_valid 0 4 3074 24 PhysxClothDesc::is_valid 0 1 946 51
/**
 * Returns true if the descriptor is valid.
 */
49
inline bool PhysxClothDesc::is_valid(void) const;

2423 14 set_cloth_mesh 0 4 3074 30 PhysxClothDesc::set_cloth_mesh 0 1 947 10
/**
 *
 */
58
void PhysxClothDesc::set_cloth_mesh(PhysxClothMesh *mesh);

2424 8 set_name 0 4 3074 24 PhysxClothDesc::set_name 0 1 948 10
/**
 *
 */
48
void PhysxClothDesc::set_name(char const *name);

2425 14 set_global_pos 0 4 3074 30 PhysxClothDesc::set_global_pos 0 1 949 10
/**
 *
 */
57
void PhysxClothDesc::set_global_pos(LPoint3f const &pos);

2426 14 set_global_mat 0 4 3074 30 PhysxClothDesc::set_global_mat 0 1 950 10
/**
 *
 */
58
void PhysxClothDesc::set_global_mat(LMatrix4f const &mat);

2427 14 set_global_hpr 0 4 3074 30 PhysxClothDesc::set_global_hpr 0 1 951 10
/**
 *
 */
63
void PhysxClothDesc::set_global_hpr(float h, float p, float r);

2428 13 set_thickness 0 4 3074 29 PhysxClothDesc::set_thickness 0 1 952 10
/**
 *
 */
52
void PhysxClothDesc::set_thickness(float thickness);

2429 11 set_density 0 4 3074 27 PhysxClothDesc::set_density 0 1 953 10
/**
 *
 */
48
void PhysxClothDesc::set_density(float density);

2430 21 set_bending_stiffness 0 4 3074 37 PhysxClothDesc::set_bending_stiffness 0 1 954 10
/**
 *
 */
60
void PhysxClothDesc::set_bending_stiffness(float stiffness);

2431 24 set_stretching_stiffness 0 4 3074 40 PhysxClothDesc::set_stretching_stiffness 0 1 955 10
/**
 *
 */
63
void PhysxClothDesc::set_stretching_stiffness(float stiffness);

2432 23 set_damping_coefficient 0 4 3074 39 PhysxClothDesc::set_damping_coefficient 0 1 956 10
/**
 *
 */
60
void PhysxClothDesc::set_damping_coefficient(float damping);

2433 12 set_friction 0 4 3074 28 PhysxClothDesc::set_friction 0 1 957 10
/**
 *
 */
50
void PhysxClothDesc::set_friction(float friction);

2434 12 set_pressure 0 4 3074 28 PhysxClothDesc::set_pressure 0 1 958 10
/**
 *
 */
50
void PhysxClothDesc::set_pressure(float pressure);

2435 15 set_tear_factor 0 4 3074 31 PhysxClothDesc::set_tear_factor 0 1 959 10
/**
 *
 */
55
void PhysxClothDesc::set_tear_factor(float tearFactor);

2436 21 set_solver_iterations 0 4 3074 37 PhysxClothDesc::set_solver_iterations 0 1 960 117
/**
 * Number of solver iterations.  Small numbers make the simulation faster
 * while the cloth gets less stiff.
 */
69
void PhysxClothDesc::set_solver_iterations(unsigned int interations);

2437 8 set_flag 0 4 3074 24 PhysxClothDesc::set_flag 0 1 961 53
/**
 * Raise or lower individual ClothFlag flags.
 */
75
void PhysxClothDesc::set_flag(PhysxEnums::PhysxClothFlag flag, bool value);

2438 8 get_name 0 4 3074 24 PhysxClothDesc::get_name 0 1 962 10
/**
 *
 */
49
char const *PhysxClothDesc::get_name(void) const;

2439 14 get_global_pos 0 4 3074 30 PhysxClothDesc::get_global_pos 0 1 963 10
/**
 *
 */
52
LPoint3f PhysxClothDesc::get_global_pos(void) const;

2440 14 get_global_mat 0 4 3074 30 PhysxClothDesc::get_global_mat 0 1 964 10
/**
 *
 */
53
LMatrix4f PhysxClothDesc::get_global_mat(void) const;

2441 13 get_thickness 0 4 3074 29 PhysxClothDesc::get_thickness 0 1 965 10
/**
 *
 */
48
float PhysxClothDesc::get_thickness(void) const;

2442 11 get_density 0 4 3074 27 PhysxClothDesc::get_density 0 1 966 10
/**
 *
 */
46
float PhysxClothDesc::get_density(void) const;

2443 21 get_bending_stiffness 0 4 3074 37 PhysxClothDesc::get_bending_stiffness 0 1 967 10
/**
 *
 */
56
float PhysxClothDesc::get_bending_stiffness(void) const;

2444 24 get_stretching_stiffness 0 4 3074 40 PhysxClothDesc::get_stretching_stiffness 0 1 968 10
/**
 *
 */
59
float PhysxClothDesc::get_stretching_stiffness(void) const;

2445 23 get_damping_coefficient 0 4 3074 39 PhysxClothDesc::get_damping_coefficient 0 1 969 10
/**
 *
 */
58
float PhysxClothDesc::get_damping_coefficient(void) const;

2446 12 get_friction 0 4 3074 28 PhysxClothDesc::get_friction 0 1 970 10
/**
 *
 */
47
float PhysxClothDesc::get_friction(void) const;

2447 12 get_pressure 0 4 3074 28 PhysxClothDesc::get_pressure 0 1 971 10
/**
 *
 */
47
float PhysxClothDesc::get_pressure(void) const;

2448 15 get_tear_factor 0 4 3074 31 PhysxClothDesc::get_tear_factor 0 1 972 10
/**
 *
 */
50
float PhysxClothDesc::get_tear_factor(void) const;

2449 21 get_solver_iterations 0 4 3074 37 PhysxClothDesc::get_solver_iterations 0 1 973 10
/**
 *
 */
63
unsigned int PhysxClothDesc::get_solver_iterations(void) const;

2450 8 get_flag 0 4 3074 24 PhysxClothDesc::get_flag 0 1 974 10
/**
 *
 */
69
bool PhysxClothDesc::get_flag(PhysxEnums::PhysxClothFlag flag) const;

2451 18 PhysxClothMeshDesc 0 4 3075 38 PhysxClothMeshDesc::PhysxClothMeshDesc 0 1 975 10
/**
 *
 */
52
inline PhysxClothMeshDesc::PhysxClothMeshDesc(void);

2452 19 ~PhysxClothMeshDesc 0 4 3075 39 PhysxClothMeshDesc::~PhysxClothMeshDesc 0 0 10
/**
 *
 */
53
inline PhysxClothMeshDesc::~PhysxClothMeshDesc(void);

2453 8 is_valid 0 4 3075 28 PhysxClothMeshDesc::is_valid 0 1 976 51
/**
 * Returns true if the descriptor is valid.
 */
53
inline bool PhysxClothMeshDesc::is_valid(void) const;

2454 16 set_num_vertices 0 4 3075 36 PhysxClothMeshDesc::set_num_vertices 0 1 977 241
/**
 * Sets the number of vertices to be stored within this triangle mesh.  The
 * function allocates memory for the vertices, but it does not set any
 * vertices.
 *
 * This method must be called before any calls to set_vertex are done!
 */
58
void PhysxClothMeshDesc::set_num_vertices(unsigned int n);

2455 10 set_vertex 0 4 3075 30 PhysxClothMeshDesc::set_vertex 0 1 978 118
/**
 * Sets a single vertex.  You have to call the function set_num_vertices
 * before you can call this function.
 */
102
void PhysxClothMeshDesc::set_vertex(unsigned int idx, LPoint3f const &vert, LPoint2f const &texcoord);

2456 17 set_num_triangles 0 4 3075 37 PhysxClothMeshDesc::set_num_triangles 0 1 979 151
/**
 * Sets the number of triangles to be stored in this triangle mesh.
 *
 * This method must be called before any calls to set_triangle are done!
 */
59
void PhysxClothMeshDesc::set_num_triangles(unsigned int n);

2457 12 set_triangle 0 4 3075 32 PhysxClothMeshDesc::set_triangle 0 1 980 77
/**
 * Sets a single triangle, by providing the three indices i1, i2, i3.
 */
107
void PhysxClothMeshDesc::set_triangle(unsigned int idx, unsigned int i1, unsigned int i2, unsigned int i3);

2458 18 set_from_node_path 0 4 3075 38 PhysxClothMeshDesc::set_from_node_path 0 1 981 308
/**
 * A convenience method to set the mesh data from a NodePath in a single call.
 * The method iterates over the NodePath geoms and collects data for the
 * triangle mesh.
 *
 * Do not use the following function when using this one: - set_num_vertices -
 * set_vertex - set_num_triangles - set_triangle
 */
64
void PhysxClothMeshDesc::set_from_node_path(NodePath const &np);

2459 24 PhysxConstraintDominance 0 4 3076 50 PhysxConstraintDominance::PhysxConstraintDominance 0 2 982 983 10
/**
 *
 */
181
inline PhysxConstraintDominance::PhysxConstraintDominance(float d0, float d1);
inline PhysxConstraintDominance::PhysxConstraintDominance(PhysxConstraintDominance const &) = default;

2460 25 ~PhysxConstraintDominance 0 4 3076 51 PhysxConstraintDominance::~PhysxConstraintDominance 0 0 10
/**
 *
 */
65
inline PhysxConstraintDominance::~PhysxConstraintDominance(void);

2461 5 get_0 0 4 3076 31 PhysxConstraintDominance::get_0 0 1 984 46
/**
 * Retruns the first dominance factor.
 */
50
float PhysxConstraintDominance::get_0(void) const;

2462 5 get_1 0 4 3076 31 PhysxConstraintDominance::get_1 0 1 985 47
/**
 * Returns the second dominance factor.
 */
50
float PhysxConstraintDominance::get_1(void) const;

2463 5 set_0 0 4 3076 31 PhysxConstraintDominance::set_0 0 1 986 43
/**
 * Sets the first dominance factor.
 */
47
void PhysxConstraintDominance::set_0(float d0);

2464 5 set_1 0 4 3076 31 PhysxConstraintDominance::set_1 0 1 987 44
/**
 * Sets the second dominance factor.
 */
47
void PhysxConstraintDominance::set_1(float d1);

2465 30 PhysxConvexForceFieldShapeDesc 0 4 3077 62 PhysxConvexForceFieldShapeDesc::PhysxConvexForceFieldShapeDesc 0 1 988 10
/**
 *
 */
76
inline PhysxConvexForceFieldShapeDesc::PhysxConvexForceFieldShapeDesc(void);

2466 31 ~PhysxConvexForceFieldShapeDesc 0 4 3077 63 PhysxConvexForceFieldShapeDesc::~PhysxConvexForceFieldShapeDesc 0 0 10
/**
 *
 */
77
inline PhysxConvexForceFieldShapeDesc::~PhysxConvexForceFieldShapeDesc(void);

2467 8 set_mesh 0 4 3077 40 PhysxConvexForceFieldShapeDesc::set_mesh 0 1 989 59
/**
 * Sets the convex mesh for this force field shape.
 */
69
void PhysxConvexForceFieldShapeDesc::set_mesh(PhysxConvexMesh *mesh);

2468 19 PhysxConvexMeshDesc 0 4 3078 40 PhysxConvexMeshDesc::PhysxConvexMeshDesc 0 1 990 10
/**
 *
 */
54
inline PhysxConvexMeshDesc::PhysxConvexMeshDesc(void);

2469 20 ~PhysxConvexMeshDesc 0 4 3078 41 PhysxConvexMeshDesc::~PhysxConvexMeshDesc 0 0 10
/**
 *
 */
55
inline PhysxConvexMeshDesc::~PhysxConvexMeshDesc(void);

2470 8 is_valid 0 4 3078 29 PhysxConvexMeshDesc::is_valid 0 1 991 51
/**
 * Returns true if the descriptor is valid.
 */
54
inline bool PhysxConvexMeshDesc::is_valid(void) const;

2471 16 set_num_vertices 0 4 3078 37 PhysxConvexMeshDesc::set_num_vertices 0 1 992 320
/**
 * Sets the number of vertices to be stored within this convex mesh.  The
 * function allocates memory for the vertices, but it does not set any
 * vertices.
 *
 * This method must be called before any calls to set_vertex are done!
 *
 * The number of vertices in a single convex mesh has to be smaller than 256.
 */
59
void PhysxConvexMeshDesc::set_num_vertices(unsigned int n);

2472 10 set_vertex 0 4 3078 31 PhysxConvexMeshDesc::set_vertex 0 1 993 118
/**
 * Sets a single vertex.  You have to call the function set_num_vertices
 * before you can call this function.
 */
77
void PhysxConvexMeshDesc::set_vertex(unsigned int idx, LPoint3f const &vert);

2473 18 set_from_node_path 0 4 3078 39 PhysxConvexMeshDesc::set_from_node_path 0 1 994 271
/**
 * A convenience method to set the mesh data from a NodePath in a single call.
 * The method iterates over the NodePath geoms and collects data for the
 * convex mesh.
 *
 * Do not use the following function when using this one: - set_num_vertices -
 * set_vertex
 */
65
void PhysxConvexMeshDesc::set_from_node_path(NodePath const &np);

2474 20 PhysxConvexShapeDesc 0 4 3079 42 PhysxConvexShapeDesc::PhysxConvexShapeDesc 0 1 995 10
/**
 *
 */
56
inline PhysxConvexShapeDesc::PhysxConvexShapeDesc(void);

2475 8 set_mesh 0 4 3079 30 PhysxConvexShapeDesc::set_mesh 0 1 996 10
/**
 *
 */
59
void PhysxConvexShapeDesc::set_mesh(PhysxConvexMesh *mesh);

2476 20 upcast_to_PhysxEnums 0 12 3080 36 PhysxJointDesc::upcast_to_PhysxEnums 0 1 1019 40
upcast from PhysxJointDesc to PhysxEnums
55
PhysxEnums *PhysxJointDesc::upcast_to_PhysxEnums(void);

2477 26 downcast_to_PhysxJointDesc 0 12 2965 38 PhysxEnums::downcast_to_PhysxJointDesc 0 1 1020 42
downcast from PhysxEnums to PhysxJointDesc
61
PhysxJointDesc *PhysxEnums::downcast_to_PhysxJointDesc(void);

2478 14 set_to_default 0 6 3080 30 PhysxJointDesc::set_to_default 0 1 997 0
54
virtual void PhysxJointDesc::set_to_default(void) = 0;

2479 8 is_valid 0 6 3080 24 PhysxJointDesc::is_valid 0 1 998 0
54
virtual bool PhysxJointDesc::is_valid(void) const = 0;

2480 8 set_name 0 4 3080 24 PhysxJointDesc::set_name 0 1 999 38
/**
 * Sets a possible debug name.
 */
48
void PhysxJointDesc::set_name(char const *name);

2481 14 set_joint_flag 0 4 3080 30 PhysxJointDesc::set_joint_flag 0 1 1000 43
/**
 * Set or clear a single JointFlag.
 */
81
void PhysxJointDesc::set_joint_flag(PhysxEnums::PhysxJointFlag flag, bool value);

2482 13 set_max_force 0 4 3080 29 PhysxJointDesc::set_max_force 0 1 1001 37
/**
 * Set a possible debug name.
 */
48
void PhysxJointDesc::set_max_force(float force);

2483 14 set_max_torque 0 4 3080 30 PhysxJointDesc::set_max_torque 0 1 1002 116
/**
 * Set the maximum angular force (torque) that the joint can withstand before
 * breaking, must be positive.
 */
50
void PhysxJointDesc::set_max_torque(float torque);

2484 31 set_solver_extrapolation_factor 0 4 3080 47 PhysxJointDesc::set_solver_extrapolation_factor 0 1 1003 70
/**
 * Set the extrapolation factor for solving joint constraints.
 */
67
void PhysxJointDesc::set_solver_extrapolation_factor(float factor);

2485 15 set_global_axis 0 4 3080 31 PhysxJointDesc::set_global_axis 0 1 1004 62
/**
 * Set the local axis/normal using a world space axis.
 */
60
void PhysxJointDesc::set_global_axis(LVector3f const &axis);

2486 17 set_global_anchor 0 4 3080 33 PhysxJointDesc::set_global_anchor 0 1 1005 52
/**
 * Set the anchor using a world space point.
 */
63
void PhysxJointDesc::set_global_anchor(LPoint3f const &anchor);

2487 16 set_local_normal 0 4 3080 32 PhysxJointDesc::set_local_normal 0 1 1006 120
/**
 * Set the X axis of joint space, in actor[i]'s space, orthogonal to
 * localAxis[i]. idx must be either 0 or 1.
 */
81
void PhysxJointDesc::set_local_normal(unsigned int idx, LVector3f const &normal);

2488 14 set_local_axis 0 4 3080 30 PhysxJointDesc::set_local_axis 0 1 1007 133
/**
 * Set the Z axis of joint space, in actor[i]'s space.  This is the primary
 * axis of the joint.  idx must be either 0 or 1.
 */
77
void PhysxJointDesc::set_local_axis(unsigned int idx, LVector3f const &axis);

2489 16 set_local_anchor 0 4 3080 32 PhysxJointDesc::set_local_anchor 0 1 1008 96
/**
 * Set the attachment point of joint in actor[i]'s space.  idx must be either
 * 0 or 1.
 */
80
void PhysxJointDesc::set_local_anchor(unsigned int idx, LPoint3f const &anchor);

2490 9 set_actor 0 4 3080 25 PhysxJointDesc::set_actor 0 1 1009 81
/**
 * Set the two actors connected by the joint.  idx must be either 0 or 1.
 */
74
void PhysxJointDesc::set_actor(unsigned int idx, PhysxActor const &actor);

2491 8 get_name 0 4 3080 24 PhysxJointDesc::get_name 0 1 1010 10
/**
 *
 */
49
char const *PhysxJointDesc::get_name(void) const;

2492 14 get_joint_flag 0 4 3080 30 PhysxJointDesc::get_joint_flag 0 1 1011 10
/**
 *
 */
75
bool PhysxJointDesc::get_joint_flag(PhysxEnums::PhysxJointFlag flag) const;

2493 13 get_max_force 0 4 3080 29 PhysxJointDesc::get_max_force 0 1 1012 10
/**
 *
 */
48
float PhysxJointDesc::get_max_force(void) const;

2494 14 get_max_torque 0 4 3080 30 PhysxJointDesc::get_max_torque 0 1 1013 10
/**
 *
 */
49
float PhysxJointDesc::get_max_torque(void) const;

2495 31 get_solver_extrapolation_factor 0 4 3080 47 PhysxJointDesc::get_solver_extrapolation_factor 0 1 1014 10
/**
 *
 */
66
float PhysxJointDesc::get_solver_extrapolation_factor(void) const;

2496 16 get_local_normal 0 4 3080 32 PhysxJointDesc::get_local_normal 0 1 1015 10
/**
 *
 */
67
LVector3f PhysxJointDesc::get_local_normal(unsigned int idx) const;

2497 14 get_local_axis 0 4 3080 30 PhysxJointDesc::get_local_axis 0 1 1016 10
/**
 *
 */
65
LVector3f PhysxJointDesc::get_local_axis(unsigned int idx) const;

2498 16 get_local_anchor 0 4 3080 32 PhysxJointDesc::get_local_anchor 0 1 1017 10
/**
 *
 */
66
LPoint3f PhysxJointDesc::get_local_anchor(unsigned int idx) const;

2499 9 get_actor 0 4 3080 25 PhysxJointDesc::get_actor 0 1 1018 10
/**
 *
 */
62
PhysxActor *PhysxJointDesc::get_actor(unsigned int idx) const;

2500 25 PhysxCylindricalJointDesc 0 4 3081 52 PhysxCylindricalJointDesc::PhysxCylindricalJointDesc 0 1 1021 10
/**
 *
 */
66
inline PhysxCylindricalJointDesc::PhysxCylindricalJointDesc(void);

2501 26 ~PhysxCylindricalJointDesc 0 4 3081 53 PhysxCylindricalJointDesc::~PhysxCylindricalJointDesc 0 0 10
/**
 *
 */
67
inline PhysxCylindricalJointDesc::~PhysxCylindricalJointDesc(void);

2502 16 PhysxD6JointDesc 0 4 3082 34 PhysxD6JointDesc::PhysxD6JointDesc 0 1 1022 10
/**
 *
 */
48
inline PhysxD6JointDesc::PhysxD6JointDesc(void);

2503 17 ~PhysxD6JointDesc 0 4 3082 35 PhysxD6JointDesc::~PhysxD6JointDesc 0 0 10
/**
 *
 */
49
inline PhysxD6JointDesc::~PhysxD6JointDesc(void);

2504 8 set_flag 0 4 3082 26 PhysxD6JointDesc::set_flag 0 1 1023 52
/**
 * Sets or clears a single D6JointFlag flag.
 */
79
void PhysxD6JointDesc::set_flag(PhysxEnums::PhysxD6JointFlag flag, bool value);

2505 23 set_projection_distance 0 4 3082 41 PhysxD6JointDesc::set_projection_distance 0 1 1024 10
/**
 *
 */
63
void PhysxD6JointDesc::set_projection_distance(float distance);

2506 20 set_projection_angle 0 4 3082 38 PhysxD6JointDesc::set_projection_angle 0 1 1025 10
/**
 *
 */
57
void PhysxD6JointDesc::set_projection_angle(float angle);

2507 14 set_gear_ratio 0 4 3082 32 PhysxD6JointDesc::set_gear_ratio 0 1 1026 10
/**
 *
 */
51
void PhysxD6JointDesc::set_gear_ratio(float ratio);

2508 18 set_drive_position 0 4 3082 36 PhysxD6JointDesc::set_drive_position 0 1 1027 10
/**
 *
 */
63
void PhysxD6JointDesc::set_drive_position(LPoint3f const &pos);

2509 25 set_drive_linear_velocity 0 4 3082 43 PhysxD6JointDesc::set_drive_linear_velocity 0 1 1028 10
/**
 *
 */
69
void PhysxD6JointDesc::set_drive_linear_velocity(LVector3f const &v);

2510 26 set_drive_angular_velocity 0 4 3082 44 PhysxD6JointDesc::set_drive_angular_velocity 0 1 1029 10
/**
 *
 */
70
void PhysxD6JointDesc::set_drive_angular_velocity(LVector3f const &v);

2511 21 set_drive_orientation 0 4 3082 39 PhysxD6JointDesc::set_drive_orientation 0 1 1030 10
/**
 *
 */
71
void PhysxD6JointDesc::set_drive_orientation(LQuaternionf const &quat);

2512 19 set_projection_mode 0 4 3082 37 PhysxD6JointDesc::set_projection_mode 0 1 1031 68
/**
 * Use this to enable joint projection.  Default is PM_none.
 */
81
void PhysxD6JointDesc::set_projection_mode(PhysxEnums::PhysxProjectionMode mode);

2513 12 set_x_motion 0 4 3082 30 PhysxD6JointDesc::set_x_motion 0 1 1032 10
/**
 *
 */
76
void PhysxD6JointDesc::set_x_motion(PhysxEnums::PhysxD6JointMotion xMotion);

2514 12 set_y_motion 0 4 3082 30 PhysxD6JointDesc::set_y_motion 0 1 1033 10
/**
 *
 */
76
void PhysxD6JointDesc::set_y_motion(PhysxEnums::PhysxD6JointMotion yMotion);

2515 12 set_z_motion 0 4 3082 30 PhysxD6JointDesc::set_z_motion 0 1 1034 10
/**
 *
 */
76
void PhysxD6JointDesc::set_z_motion(PhysxEnums::PhysxD6JointMotion zMotion);

2516 17 set_swing1_motion 0 4 3082 35 PhysxD6JointDesc::set_swing1_motion 0 1 1035 10
/**
 *
 */
81
void PhysxD6JointDesc::set_swing1_motion(PhysxEnums::PhysxD6JointMotion xMotion);

2517 17 set_swing2_motion 0 4 3082 35 PhysxD6JointDesc::set_swing2_motion 0 1 1036 10
/**
 *
 */
81
void PhysxD6JointDesc::set_swing2_motion(PhysxEnums::PhysxD6JointMotion yMotion);

2518 16 set_twist_motion 0 4 3082 34 PhysxD6JointDesc::set_twist_motion 0 1 1037 10
/**
 *
 */
80
void PhysxD6JointDesc::set_twist_motion(PhysxEnums::PhysxD6JointMotion zMotion);

2519 11 set_x_drive 0 4 3082 29 PhysxD6JointDesc::set_x_drive 0 1 1038 10
/**
 *
 */
69
void PhysxD6JointDesc::set_x_drive(PhysxJointDriveDesc const &drive);

2520 11 set_y_drive 0 4 3082 29 PhysxD6JointDesc::set_y_drive 0 1 1039 10
/**
 *
 */
69
void PhysxD6JointDesc::set_y_drive(PhysxJointDriveDesc const &drive);

2521 11 set_z_drive 0 4 3082 29 PhysxD6JointDesc::set_z_drive 0 1 1040 10
/**
 *
 */
69
void PhysxD6JointDesc::set_z_drive(PhysxJointDriveDesc const &drive);

2522 15 set_swing_drive 0 4 3082 33 PhysxD6JointDesc::set_swing_drive 0 1 1041 10
/**
 *
 */
73
void PhysxD6JointDesc::set_swing_drive(PhysxJointDriveDesc const &drive);

2523 15 set_twist_drive 0 4 3082 33 PhysxD6JointDesc::set_twist_drive 0 1 1042 10
/**
 *
 */
73
void PhysxD6JointDesc::set_twist_drive(PhysxJointDriveDesc const &drive);

2524 15 set_slerp_drive 0 4 3082 33 PhysxD6JointDesc::set_slerp_drive 0 1 1043 10
/**
 *
 */
73
void PhysxD6JointDesc::set_slerp_drive(PhysxJointDriveDesc const &drive);

2525 16 set_linear_limit 0 4 3082 34 PhysxD6JointDesc::set_linear_limit 0 1 1044 10
/**
 *
 */
78
void PhysxD6JointDesc::set_linear_limit(PhysxJointLimitSoftDesc const &limit);

2526 16 set_swing1_limit 0 4 3082 34 PhysxD6JointDesc::set_swing1_limit 0 1 1045 10
/**
 *
 */
78
void PhysxD6JointDesc::set_swing1_limit(PhysxJointLimitSoftDesc const &limit);

2527 16 set_swing2_limit 0 4 3082 34 PhysxD6JointDesc::set_swing2_limit 0 1 1046 10
/**
 *
 */
78
void PhysxD6JointDesc::set_swing2_limit(PhysxJointLimitSoftDesc const &limit);

2528 19 set_twist_limit_low 0 4 3082 37 PhysxD6JointDesc::set_twist_limit_low 0 1 1047 10
/**
 *
 */
81
void PhysxD6JointDesc::set_twist_limit_low(PhysxJointLimitSoftDesc const &limit);

2529 20 set_twist_limit_high 0 4 3082 38 PhysxD6JointDesc::set_twist_limit_high 0 1 1048 10
/**
 *
 */
82
void PhysxD6JointDesc::set_twist_limit_high(PhysxJointLimitSoftDesc const &limit);

2530 8 get_flag 0 4 3082 26 PhysxD6JointDesc::get_flag 0 1 1049 10
/**
 *
 */
73
bool PhysxD6JointDesc::get_flag(PhysxEnums::PhysxD6JointFlag flag) const;

2531 23 get_projection_distance 0 4 3082 41 PhysxD6JointDesc::get_projection_distance 0 1 1050 10
/**
 *
 */
60
float PhysxD6JointDesc::get_projection_distance(void) const;

2532 20 get_projection_angle 0 4 3082 38 PhysxD6JointDesc::get_projection_angle 0 1 1051 10
/**
 *
 */
57
float PhysxD6JointDesc::get_projection_angle(void) const;

2533 14 get_gear_ratio 0 4 3082 32 PhysxD6JointDesc::get_gear_ratio 0 1 1052 10
/**
 *
 */
51
float PhysxD6JointDesc::get_gear_ratio(void) const;

2534 18 get_drive_position 0 4 3082 36 PhysxD6JointDesc::get_drive_position 0 1 1053 10
/**
 *
 */
58
LPoint3f PhysxD6JointDesc::get_drive_position(void) const;

2535 25 get_drive_linear_velocity 0 4 3082 43 PhysxD6JointDesc::get_drive_linear_velocity 0 1 1054 10
/**
 *
 */
66
LVector3f PhysxD6JointDesc::get_drive_linear_velocity(void) const;

2536 26 get_drive_angular_velocity 0 4 3082 44 PhysxD6JointDesc::get_drive_angular_velocity 0 1 1055 10
/**
 *
 */
67
LVector3f PhysxD6JointDesc::get_drive_angular_velocity(void) const;

2537 21 get_drive_orientation 0 4 3082 39 PhysxD6JointDesc::get_drive_orientation 0 1 1056 10
/**
 *
 */
65
LQuaternionf PhysxD6JointDesc::get_drive_orientation(void) const;

2538 19 get_projection_mode 0 4 3082 37 PhysxD6JointDesc::get_projection_mode 0 1 1057 10
/**
 *
 */
82
PhysxEnums::PhysxProjectionMode PhysxD6JointDesc::get_projection_mode(void) const;

2539 12 get_x_motion 0 4 3082 30 PhysxD6JointDesc::get_x_motion 0 1 1058 10
/**
 *
 */
74
PhysxEnums::PhysxD6JointMotion PhysxD6JointDesc::get_x_motion(void) const;

2540 12 get_y_motion 0 4 3082 30 PhysxD6JointDesc::get_y_motion 0 1 1059 10
/**
 *
 */
74
PhysxEnums::PhysxD6JointMotion PhysxD6JointDesc::get_y_motion(void) const;

2541 12 get_z_motion 0 4 3082 30 PhysxD6JointDesc::get_z_motion 0 1 1060 10
/**
 *
 */
74
PhysxEnums::PhysxD6JointMotion PhysxD6JointDesc::get_z_motion(void) const;

2542 17 get_swing1_motion 0 4 3082 35 PhysxD6JointDesc::get_swing1_motion 0 1 1061 10
/**
 *
 */
79
PhysxEnums::PhysxD6JointMotion PhysxD6JointDesc::get_swing1_motion(void) const;

2543 17 get_swing2_motion 0 4 3082 35 PhysxD6JointDesc::get_swing2_motion 0 1 1062 10
/**
 *
 */
79
PhysxEnums::PhysxD6JointMotion PhysxD6JointDesc::get_swing2_motion(void) const;

2544 16 get_twist_motion 0 4 3082 34 PhysxD6JointDesc::get_twist_motion 0 1 1063 10
/**
 *
 */
78
PhysxEnums::PhysxD6JointMotion PhysxD6JointDesc::get_twist_motion(void) const;

2545 11 get_x_drive 0 4 3082 29 PhysxD6JointDesc::get_x_drive 0 1 1064 10
/**
 *
 */
62
PhysxJointDriveDesc PhysxD6JointDesc::get_x_drive(void) const;

2546 11 get_y_drive 0 4 3082 29 PhysxD6JointDesc::get_y_drive 0 1 1065 10
/**
 *
 */
62
PhysxJointDriveDesc PhysxD6JointDesc::get_y_drive(void) const;

2547 11 get_z_drive 0 4 3082 29 PhysxD6JointDesc::get_z_drive 0 1 1066 10
/**
 *
 */
62
PhysxJointDriveDesc PhysxD6JointDesc::get_z_drive(void) const;

2548 15 get_swing_drive 0 4 3082 33 PhysxD6JointDesc::get_swing_drive 0 1 1067 10
/**
 *
 */
66
PhysxJointDriveDesc PhysxD6JointDesc::get_swing_drive(void) const;

2549 15 get_twist_drive 0 4 3082 33 PhysxD6JointDesc::get_twist_drive 0 1 1068 10
/**
 *
 */
66
PhysxJointDriveDesc PhysxD6JointDesc::get_twist_drive(void) const;

2550 15 get_slerp_drive 0 4 3082 33 PhysxD6JointDesc::get_slerp_drive 0 1 1069 10
/**
 *
 */
66
PhysxJointDriveDesc PhysxD6JointDesc::get_slerp_drive(void) const;

2551 16 get_linear_limit 0 4 3082 34 PhysxD6JointDesc::get_linear_limit 0 1 1070 10
/**
 *
 */
71
PhysxJointLimitSoftDesc PhysxD6JointDesc::get_linear_limit(void) const;

2552 16 get_swing1_limit 0 4 3082 34 PhysxD6JointDesc::get_swing1_limit 0 1 1071 10
/**
 *
 */
71
PhysxJointLimitSoftDesc PhysxD6JointDesc::get_swing1_limit(void) const;

2553 16 get_swing2_limit 0 4 3082 34 PhysxD6JointDesc::get_swing2_limit 0 1 1072 10
/**
 *
 */
71
PhysxJointLimitSoftDesc PhysxD6JointDesc::get_swing2_limit(void) const;

2554 19 get_twist_limit_low 0 4 3082 37 PhysxD6JointDesc::get_twist_limit_low 0 1 1073 10
/**
 *
 */
74
PhysxJointLimitSoftDesc PhysxD6JointDesc::get_twist_limit_low(void) const;

2555 20 get_twist_limit_high 0 4 3082 38 PhysxD6JointDesc::get_twist_limit_high 0 1 1074 10
/**
 *
 */
75
PhysxJointLimitSoftDesc PhysxD6JointDesc::get_twist_limit_high(void) const;

2556 19 PhysxJointDriveDesc 0 4 3083 40 PhysxJointDriveDesc::PhysxJointDriveDesc 0 2 1075 1076 22
/**
 *
 */

/**
 *
 */
149
inline PhysxJointDriveDesc::PhysxJointDriveDesc(void);
inline PhysxJointDriveDesc::PhysxJointDriveDesc(float sping, float damping, float forceLimit);

2557 20 ~PhysxJointDriveDesc 0 4 3083 41 PhysxJointDriveDesc::~PhysxJointDriveDesc 0 0 10
/**
 *
 */
55
inline PhysxJointDriveDesc::~PhysxJointDriveDesc(void);

2558 14 set_drive_type 0 4 3083 35 PhysxJointDriveDesc::set_drive_type 0 1 1077 10
/**
 *
 */
81
void PhysxJointDriveDesc::set_drive_type(PhysxEnums::PhysxD6JointDriveType type);

2559 10 set_spring 0 4 3083 31 PhysxJointDriveDesc::set_spring 0 1 1078 10
/**
 *
 */
51
void PhysxJointDriveDesc::set_spring(float spring);

2560 11 set_damping 0 4 3083 32 PhysxJointDriveDesc::set_damping 0 1 1079 10
/**
 *
 */
53
void PhysxJointDriveDesc::set_damping(float damping);

2561 15 set_force_limit 0 4 3083 36 PhysxJointDriveDesc::set_force_limit 0 1 1080 10
/**
 *
 */
55
void PhysxJointDriveDesc::set_force_limit(float limit);

2562 14 get_drive_type 0 4 3083 35 PhysxJointDriveDesc::get_drive_type 0 1 1081 10
/**
 *
 */
82
PhysxEnums::PhysxD6JointDriveType PhysxJointDriveDesc::get_drive_type(void) const;

2563 10 get_spring 0 4 3083 31 PhysxJointDriveDesc::get_spring 0 1 1082 10
/**
 *
 */
50
float PhysxJointDriveDesc::get_spring(void) const;

2564 11 get_damping 0 4 3083 32 PhysxJointDriveDesc::get_damping 0 1 1083 10
/**
 *
 */
51
float PhysxJointDriveDesc::get_damping(void) const;

2565 15 get_force_limit 0 4 3083 36 PhysxJointDriveDesc::get_force_limit 0 1 1084 10
/**
 *
 */
55
float PhysxJointDriveDesc::get_force_limit(void) const;

2566 23 PhysxJointLimitSoftDesc 0 4 3084 48 PhysxJointLimitSoftDesc::PhysxJointLimitSoftDesc 0 2 1085 1086 22
/**
 *
 */

/**
 *
 */
180
inline PhysxJointLimitSoftDesc::PhysxJointLimitSoftDesc(void);
inline PhysxJointLimitSoftDesc::PhysxJointLimitSoftDesc(float value, float restitution, float spring, float damping);

2567 24 ~PhysxJointLimitSoftDesc 0 4 3084 49 PhysxJointLimitSoftDesc::~PhysxJointLimitSoftDesc 0 0 10
/**
 *
 */
63
inline PhysxJointLimitSoftDesc::~PhysxJointLimitSoftDesc(void);

2568 9 set_value 0 4 3084 34 PhysxJointLimitSoftDesc::set_value 0 1 1087 10
/**
 *
 */
53
void PhysxJointLimitSoftDesc::set_value(float value);

2569 15 set_restitution 0 4 3084 40 PhysxJointLimitSoftDesc::set_restitution 0 1 1088 10
/**
 *
 */
65
void PhysxJointLimitSoftDesc::set_restitution(float restitution);

2570 10 set_spring 0 4 3084 35 PhysxJointLimitSoftDesc::set_spring 0 1 1089 10
/**
 *
 */
55
void PhysxJointLimitSoftDesc::set_spring(float spring);

2571 11 set_damping 0 4 3084 36 PhysxJointLimitSoftDesc::set_damping 0 1 1090 10
/**
 *
 */
57
void PhysxJointLimitSoftDesc::set_damping(float damping);

2572 9 get_value 0 4 3084 34 PhysxJointLimitSoftDesc::get_value 0 1 1091 10
/**
 *
 */
53
float PhysxJointLimitSoftDesc::get_value(void) const;

2573 15 get_restitution 0 4 3084 40 PhysxJointLimitSoftDesc::get_restitution 0 1 1092 10
/**
 *
 */
59
float PhysxJointLimitSoftDesc::get_restitution(void) const;

2574 10 get_spring 0 4 3084 35 PhysxJointLimitSoftDesc::get_spring 0 1 1093 10
/**
 *
 */
54
float PhysxJointLimitSoftDesc::get_spring(void) const;

2575 11 get_damping 0 4 3084 36 PhysxJointLimitSoftDesc::get_damping 0 1 1094 10
/**
 *
 */
55
float PhysxJointLimitSoftDesc::get_damping(void) const;

2576 22 PhysxDistanceJointDesc 0 4 3085 46 PhysxDistanceJointDesc::PhysxDistanceJointDesc 0 1 1095 10
/**
 *
 */
60
inline PhysxDistanceJointDesc::PhysxDistanceJointDesc(void);

2577 23 ~PhysxDistanceJointDesc 0 4 3085 47 PhysxDistanceJointDesc::~PhysxDistanceJointDesc 0 0 10
/**
 *
 */
61
inline PhysxDistanceJointDesc::~PhysxDistanceJointDesc(void);

2578 16 set_max_distance 0 4 3085 40 PhysxDistanceJointDesc::set_max_distance 0 1 1096 92
/**
 * Sets the maximum rest length of the rope or rod between the two anchor
 * points.
 */
62
void PhysxDistanceJointDesc::set_max_distance(float distance);

2579 16 set_min_distance 0 4 3085 40 PhysxDistanceJointDesc::set_min_distance 0 1 1097 91
/**
 * Sets the minimum rest length of the rope or rod between the two anchor
 * points
 */
62
void PhysxDistanceJointDesc::set_min_distance(float distance);

2580 10 set_spring 0 4 3085 34 PhysxDistanceJointDesc::set_spring 0 1 1098 72
/**
 * Makes the joint springy.  The spring.targetValue is not used.
 */
71
void PhysxDistanceJointDesc::set_spring(PhysxSpringDesc const &spring);

2581 8 set_flag 0 4 3085 32 PhysxDistanceJointDesc::set_flag 0 1 1099 58
/**
 * Sets or clears a single DistanceJointFlag flag.
 */
91
void PhysxDistanceJointDesc::set_flag(PhysxEnums::PhysxDistanceJointFlag flag, bool value);

2582 16 get_max_distance 0 4 3085 40 PhysxDistanceJointDesc::get_max_distance 0 1 1100 10
/**
 *
 */
59
float PhysxDistanceJointDesc::get_max_distance(void) const;

2583 16 get_min_distance 0 4 3085 40 PhysxDistanceJointDesc::get_min_distance 0 1 1101 10
/**
 *
 */
59
float PhysxDistanceJointDesc::get_min_distance(void) const;

2584 8 get_flag 0 4 3085 32 PhysxDistanceJointDesc::get_flag 0 1 1102 50
/**
 * Return a single DistanceJointFlag flag.
 */
85
bool PhysxDistanceJointDesc::get_flag(PhysxEnums::PhysxDistanceJointFlag flag) const;

2585 10 get_spring 0 4 3085 34 PhysxDistanceJointDesc::get_spring 0 1 1103 10
/**
 *
 */
63
PhysxSpringDesc PhysxDistanceJointDesc::get_spring(void) const;

2586 15 PhysxSpringDesc 0 4 3086 32 PhysxSpringDesc::PhysxSpringDesc 0 2 1104 1105 22
/**
 *
 */

/**
 *
 */
142
inline PhysxSpringDesc::PhysxSpringDesc(void);
inline PhysxSpringDesc::PhysxSpringDesc(float spring, float damper = 0, float targetValue = 0);

2587 16 ~PhysxSpringDesc 0 4 3086 33 PhysxSpringDesc::~PhysxSpringDesc 0 0 10
/**
 *
 */
47
inline PhysxSpringDesc::~PhysxSpringDesc(void);

2588 10 set_spring 0 4 3086 27 PhysxSpringDesc::set_spring 0 1 1106 10
/**
 *
 */
47
void PhysxSpringDesc::set_spring(float spring);

2589 10 set_damper 0 4 3086 27 PhysxSpringDesc::set_damper 0 1 1107 10
/**
 *
 */
47
void PhysxSpringDesc::set_damper(float damper);

2590 16 set_target_value 0 4 3086 33 PhysxSpringDesc::set_target_value 0 1 1108 10
/**
 *
 */
53
void PhysxSpringDesc::set_target_value(float target);

2591 10 get_spring 0 4 3086 27 PhysxSpringDesc::get_spring 0 1 1109 10
/**
 *
 */
46
float PhysxSpringDesc::get_spring(void) const;

2592 10 get_damper 0 4 3086 27 PhysxSpringDesc::get_damper 0 1 1110 10
/**
 *
 */
46
float PhysxSpringDesc::get_damper(void) const;

2593 16 get_target_value 0 4 3086 33 PhysxSpringDesc::get_target_value 0 1 1111 10
/**
 *
 */
52
float PhysxSpringDesc::get_target_value(void) const;

2594 19 PhysxFixedJointDesc 0 4 3087 40 PhysxFixedJointDesc::PhysxFixedJointDesc 0 1 1112 10
/**
 *
 */
54
inline PhysxFixedJointDesc::PhysxFixedJointDesc(void);

2595 20 ~PhysxFixedJointDesc 0 4 3087 41 PhysxFixedJointDesc::~PhysxFixedJointDesc 0 0 10
/**
 *
 */
55
inline PhysxFixedJointDesc::~PhysxFixedJointDesc(void);

2596 19 PhysxForceFieldDesc 0 4 3088 40 PhysxForceFieldDesc::PhysxForceFieldDesc 0 1 1113 10
/**
 *
 */
54
inline PhysxForceFieldDesc::PhysxForceFieldDesc(void);

2597 20 ~PhysxForceFieldDesc 0 4 3088 41 PhysxForceFieldDesc::~PhysxForceFieldDesc 0 0 10
/**
 *
 */
55
inline PhysxForceFieldDesc::~PhysxForceFieldDesc(void);

2598 14 set_to_default 0 4 3088 35 PhysxForceFieldDesc::set_to_default 0 1 1114 49
/**
 * (re)sets the structure to the default.
 */
54
inline void PhysxForceFieldDesc::set_to_default(void);

2599 8 is_valid 0 4 3088 29 PhysxForceFieldDesc::is_valid 0 1 1115 51
/**
 * Returns true if the descriptor is valid.
 */
54
inline bool PhysxForceFieldDesc::is_valid(void) const;

2600 8 set_name 0 4 3088 29 PhysxForceFieldDesc::set_name 0 1 1116 10
/**
 *
 */
53
void PhysxForceFieldDesc::set_name(char const *name);

2601 7 set_pos 0 4 3088 28 PhysxForceFieldDesc::set_pos 0 1 1117 10
/**
 *
 */
55
void PhysxForceFieldDesc::set_pos(LPoint3f const &pos);

2602 7 set_mat 0 4 3088 28 PhysxForceFieldDesc::set_mat 0 1 1118 10
/**
 *
 */
56
void PhysxForceFieldDesc::set_mat(LMatrix4f const &mat);

2603 7 set_hpr 0 4 3088 28 PhysxForceFieldDesc::set_hpr 0 1 1119 10
/**
 *
 */
61
void PhysxForceFieldDesc::set_hpr(float h, float p, float r);

2604 15 set_coordinates 0 4 3088 36 PhysxForceFieldDesc::set_coordinates 0 1 1120 10
/**
 *
 */
94
void PhysxForceFieldDesc::set_coordinates(PhysxEnums::PhysxForceFieldCoordinates coordinates);

2605 9 set_actor 0 4 3088 30 PhysxForceFieldDesc::set_actor 0 1 1121 10
/**
 *
 */
55
void PhysxForceFieldDesc::set_actor(PhysxActor *actor);

2606 19 set_kernel_constant 0 4 3088 40 PhysxForceFieldDesc::set_kernel_constant 0 1 1122 10
/**
 *
 */
73
void PhysxForceFieldDesc::set_kernel_constant(LVector3f const &constant);

2607 26 set_kernel_position_target 0 4 3088 47 PhysxForceFieldDesc::set_kernel_position_target 0 1 1123 10
/**
 *
 */
77
void PhysxForceFieldDesc::set_kernel_position_target(LPoint3f const &target);

2608 30 set_kernel_position_multiplier 0 4 3088 51 PhysxForceFieldDesc::set_kernel_position_multiplier 0 1 1124 10
/**
 *
 */
86
void PhysxForceFieldDesc::set_kernel_position_multiplier(LMatrix3f const &multiplier);

2609 26 set_kernel_velocity_target 0 4 3088 47 PhysxForceFieldDesc::set_kernel_velocity_target 0 1 1125 10
/**
 *
 */
78
void PhysxForceFieldDesc::set_kernel_velocity_target(LVector3f const &target);

2610 30 set_kernel_velocity_multiplier 0 4 3088 51 PhysxForceFieldDesc::set_kernel_velocity_multiplier 0 1 1126 10
/**
 *
 */
86
void PhysxForceFieldDesc::set_kernel_velocity_multiplier(LMatrix3f const &multiplier);

2611 23 set_kernel_torus_radius 0 4 3088 44 PhysxForceFieldDesc::set_kernel_torus_radius 0 1 1127 10
/**
 *
 */
64
void PhysxForceFieldDesc::set_kernel_torus_radius(float radius);

2612 25 set_kernel_falloff_linear 0 4 3088 46 PhysxForceFieldDesc::set_kernel_falloff_linear 0 1 1128 10
/**
 *
 */
78
void PhysxForceFieldDesc::set_kernel_falloff_linear(LVector3f const &falloff);

2613 28 set_kernel_falloff_quadratic 0 4 3088 49 PhysxForceFieldDesc::set_kernel_falloff_quadratic 0 1 1129 10
/**
 *
 */
81
void PhysxForceFieldDesc::set_kernel_falloff_quadratic(LVector3f const &falloff);

2614 16 set_kernel_noise 0 4 3088 37 PhysxForceFieldDesc::set_kernel_noise 0 1 1130 10
/**
 *
 */
67
void PhysxForceFieldDesc::set_kernel_noise(LVector3f const &noise);

2615 23 add_include_group_shape 0 4 3088 44 PhysxForceFieldDesc::add_include_group_shape 0 1 1131 10
/**
 *
 */
87
void PhysxForceFieldDesc::add_include_group_shape(PhysxForceFieldShapeDesc &shapeDesc);

2616 15 add_shape_group 0 4 3088 36 PhysxForceFieldDesc::add_shape_group 0 1 1132 10
/**
 *
 */
76
void PhysxForceFieldDesc::add_shape_group(PhysxForceFieldShapeGroup *group);

2617 29 PhysxForceFieldShapeGroupDesc 0 4 3089 60 PhysxForceFieldShapeGroupDesc::PhysxForceFieldShapeGroupDesc 0 1 1133 10
/**
 *
 */
74
inline PhysxForceFieldShapeGroupDesc::PhysxForceFieldShapeGroupDesc(void);

2618 30 ~PhysxForceFieldShapeGroupDesc 0 4 3089 61 PhysxForceFieldShapeGroupDesc::~PhysxForceFieldShapeGroupDesc 0 0 10
/**
 *
 */
75
inline PhysxForceFieldShapeGroupDesc::~PhysxForceFieldShapeGroupDesc(void);

2619 14 set_to_default 0 4 3089 45 PhysxForceFieldShapeGroupDesc::set_to_default 0 1 1134 49
/**
 * (re)sets the structure to the default.
 */
64
inline void PhysxForceFieldShapeGroupDesc::set_to_default(void);

2620 8 is_valid 0 4 3089 39 PhysxForceFieldShapeGroupDesc::is_valid 0 1 1135 51
/**
 * Returns true if the descriptor is valid.
 */
64
inline bool PhysxForceFieldShapeGroupDesc::is_valid(void) const;

2621 9 add_shape 0 4 3089 40 PhysxForceFieldShapeGroupDesc::add_shape 0 1 1136 85
/**
 * Adds a shape to the list of force field shapes composing this shape group.
 */
78
void PhysxForceFieldShapeGroupDesc::add_shape(PhysxForceFieldShapeDesc &desc);

2622 8 set_name 0 4 3089 39 PhysxForceFieldShapeGroupDesc::set_name 0 1 1137 72
/**
 * Sets the optional debug name for the force field shape group.
 */
63
void PhysxForceFieldShapeGroupDesc::set_name(char const *name);

2623 8 set_flag 0 4 3089 39 PhysxForceFieldShapeGroupDesc::set_flag 0 1 1138 67
/**
 * Raise or lower individual force field shape group flags.
 */
105
void PhysxForceFieldShapeGroupDesc::set_flag(PhysxEnums::PhysxForceFieldShapeGroupFlag flag, bool value);

2624 8 get_name 0 4 3089 39 PhysxForceFieldShapeGroupDesc::get_name 0 1 1139 76
/**
 * Returns the optional debug name for this force field shape group.
 */
64
char const *PhysxForceFieldShapeGroupDesc::get_name(void) const;

2625 8 get_flag 0 4 3089 39 PhysxForceFieldShapeGroupDesc::get_flag 0 1 1140 62
/**
 * Returns the specified force field shape group flag.
 */
99
bool PhysxForceFieldShapeGroupDesc::get_flag(PhysxEnums::PhysxForceFieldShapeGroupFlag flag) const;

2626 20 PhysxHeightFieldDesc 0 4 3090 42 PhysxHeightFieldDesc::PhysxHeightFieldDesc 0 1 1141 10
/**
 *
 */
56
inline PhysxHeightFieldDesc::PhysxHeightFieldDesc(void);

2627 21 ~PhysxHeightFieldDesc 0 4 3090 43 PhysxHeightFieldDesc::~PhysxHeightFieldDesc 0 0 10
/**
 *
 */
57
inline PhysxHeightFieldDesc::~PhysxHeightFieldDesc(void);

2628 14 set_to_default 0 4 3090 36 PhysxHeightFieldDesc::set_to_default 0 1 1142 49
/**
 * (re)sets the structure to the default.
 */
55
inline void PhysxHeightFieldDesc::set_to_default(void);

2629 8 is_valid 0 4 3090 30 PhysxHeightFieldDesc::is_valid 0 1 1143 51
/**
 * Returns true if the descriptor is valid.
 */
55
inline bool PhysxHeightFieldDesc::is_valid(void) const;

2630 8 set_size 0 4 3090 30 PhysxHeightFieldDesc::set_size 0 1 1144 10
/**
 *
 */
92
inline void PhysxHeightFieldDesc::set_size(unsigned int num_rows, unsigned int num_columns);

2631 9 set_image 0 4 3090 31 PhysxHeightFieldDesc::set_image 0 1 1145 10
/**
 *
 */
98
void PhysxHeightFieldDesc::set_image(PNMImage const &image, unsigned short int materialIndex = 0);

2632 13 set_thickness 0 4 3090 35 PhysxHeightFieldDesc::set_thickness 0 1 1146 10
/**
 *
 */
58
void PhysxHeightFieldDesc::set_thickness(float thickness);

2633 25 set_convex_edge_threshold 0 4 3090 47 PhysxHeightFieldDesc::set_convex_edge_threshold 0 1 1147 10
/**
 *
 */
70
void PhysxHeightFieldDesc::set_convex_edge_threshold(float threshold);

2634 10 set_height 0 4 3090 32 PhysxHeightFieldDesc::set_height 0 1 1148 10
/**
 *
 */
95
void PhysxHeightFieldDesc::set_height(unsigned int row, unsigned int column, short int height);

2635 13 set_tess_flag 0 4 3090 35 PhysxHeightFieldDesc::set_tess_flag 0 1 1149 10
/**
 *
 */
106
void PhysxHeightFieldDesc::set_tess_flag(unsigned int row, unsigned int column, unsigned short int value);

2636 18 set_material_index 0 4 3090 40 PhysxHeightFieldDesc::set_material_index 0 1 1150 10
/**
 *
 */
155
void PhysxHeightFieldDesc::set_material_index(unsigned int row, unsigned int column, unsigned short int materialIndex0, unsigned short int materialIndex1);

2637 25 PhysxHeightFieldShapeDesc 0 4 3091 52 PhysxHeightFieldShapeDesc::PhysxHeightFieldShapeDesc 0 1 1151 10
/**
 *
 */
66
inline PhysxHeightFieldShapeDesc::PhysxHeightFieldShapeDesc(void);

2638 16 set_height_field 0 4 3091 43 PhysxHeightFieldShapeDesc::set_height_field 0 1 1152 10
/**
 *
 */
77
void PhysxHeightFieldShapeDesc::set_height_field(PhysxHeightField const &hf);

2639 14 set_dimensions 0 4 3091 41 PhysxHeightFieldShapeDesc::set_dimensions 0 1 1153 10
/**
 *
 */
76
void PhysxHeightFieldShapeDesc::set_dimensions(LVector3f const &dimensions);

2640 17 set_hole_material 0 4 3091 44 PhysxHeightFieldShapeDesc::set_hole_material 0 1 1154 206
/**
 * Sets the the material index that designates holes in the height field.
 * This number is compared directly to sample materials.  Consequently the
 * high 9 bits must be zero.  Default value is 0.
 */
76
void PhysxHeightFieldShapeDesc::set_hole_material(unsigned short int index);

2641 28 set_material_index_high_bits 0 4 3091 55 PhysxHeightFieldShapeDesc::set_material_index_high_bits 0 1 1155 171
/**
 * Sets the high 9 bits of this number are used to complete the material
 * indices in the samples.  The remaining low 7 bits must be zero.  Default
 * value is 0.
 */
87
void PhysxHeightFieldShapeDesc::set_material_index_high_bits(unsigned short int index);

2642 17 get_hole_material 0 4 3091 44 PhysxHeightFieldShapeDesc::get_hole_material 0 1 1156 84
/**
 * Returns the the material index that designates holes in the height field.
 */
76
unsigned short int PhysxHeightFieldShapeDesc::get_hole_material(void) const;

2643 29 get_material_index_hight_bits 0 4 3091 56 PhysxHeightFieldShapeDesc::get_material_index_hight_bits 0 1 1157 110
/**
 * Returns the high 9 bits of this number are used to complete the material
 * indices in the samples.
 */
88
unsigned short int PhysxHeightFieldShapeDesc::get_material_index_hight_bits(void) const;

2644 19 PhysxJointLimitDesc 0 4 3092 40 PhysxJointLimitDesc::PhysxJointLimitDesc 0 2 1158 1159 22
/**
 *
 */

/**
 *
 */
151
inline PhysxJointLimitDesc::PhysxJointLimitDesc(void);
inline PhysxJointLimitDesc::PhysxJointLimitDesc(float value, float restitution, float hardness);

2645 20 ~PhysxJointLimitDesc 0 4 3092 41 PhysxJointLimitDesc::~PhysxJointLimitDesc 0 0 10
/**
 *
 */
55
inline PhysxJointLimitDesc::~PhysxJointLimitDesc(void);

2646 9 set_value 0 4 3092 30 PhysxJointLimitDesc::set_value 0 1 1160 10
/**
 *
 */
49
void PhysxJointLimitDesc::set_value(float value);

2647 15 set_restitution 0 4 3092 36 PhysxJointLimitDesc::set_restitution 0 1 1161 10
/**
 *
 */
61
void PhysxJointLimitDesc::set_restitution(float restitution);

2648 12 set_hardness 0 4 3092 33 PhysxJointLimitDesc::set_hardness 0 1 1162 10
/**
 *
 */
55
void PhysxJointLimitDesc::set_hardness(float hardness);

2649 9 get_value 0 4 3092 30 PhysxJointLimitDesc::get_value 0 1 1163 10
/**
 *
 */
49
float PhysxJointLimitDesc::get_value(void) const;

2650 15 get_restitution 0 4 3092 36 PhysxJointLimitDesc::get_restitution 0 1 1164 10
/**
 *
 */
55
float PhysxJointLimitDesc::get_restitution(void) const;

2651 12 get_hardness 0 4 3092 33 PhysxJointLimitDesc::get_hardness 0 1 1165 10
/**
 *
 */
52
float PhysxJointLimitDesc::get_hardness(void) const;

2652 12 PhysxKitchen 0 4 3093 26 PhysxKitchen::PhysxKitchen 0 2 1166 1167 10
/**
 *
 */
107
inline PhysxKitchen::PhysxKitchen(void);
inline PhysxKitchen::PhysxKitchen(PhysxKitchen const &) = default;

2653 13 ~PhysxKitchen 0 4 3093 27 PhysxKitchen::~PhysxKitchen 0 0 10
/**
 *
 */
41
inline PhysxKitchen::~PhysxKitchen(void);

2654 18 set_cooking_params 0 4 3093 32 PhysxKitchen::set_cooking_params 0 1 1168 479
/**
 * Sets two parameters which affect mesh cooking:
 *
 * Skin width for convex meshes: Specifies the amount to inflate the convex
 * mesh by when the new convex hull generator is used.  Inflating the mesh
 * allows the user to hide interpenetration errors by increasing the size of
 * the collision mesh with respect to the size of the rendered geometry.
 * Default value: 0.025f
 *
 * Hint to choose speed or less memory for collision structures.  Default
 * value: false
 */
80
void PhysxKitchen::set_cooking_params(float skinWidth, bool hintCollisionSpeed);

2655 16 cook_convex_mesh 0 4 3093 30 PhysxKitchen::cook_convex_mesh 0 2 1169 1170 22
/**
 *
 */

/**
 *
 */
185
bool PhysxKitchen::cook_convex_mesh(PhysxConvexMeshDesc const &meshDesc, Filename const &filename);
PhysxConvexMesh *PhysxKitchen::cook_convex_mesh(PhysxConvexMeshDesc const &meshDesc);

2656 18 cook_triangle_mesh 0 4 3093 32 PhysxKitchen::cook_triangle_mesh 0 2 1171 1172 22
/**
 *
 */

/**
 *
 */
195
bool PhysxKitchen::cook_triangle_mesh(PhysxTriangleMeshDesc const &meshDesc, Filename const &filename);
PhysxTriangleMesh *PhysxKitchen::cook_triangle_mesh(PhysxTriangleMeshDesc const &meshDesc);

2657 15 cook_cloth_mesh 0 4 3093 29 PhysxKitchen::cook_cloth_mesh 0 2 1173 1174 22
/**
 *
 */

/**
 *
 */
180
bool PhysxKitchen::cook_cloth_mesh(PhysxClothMeshDesc const &meshDesc, Filename const &filename);
PhysxClothMesh *PhysxKitchen::cook_cloth_mesh(PhysxClothMeshDesc const &meshDesc);

2658 19 cook_soft_body_mesh 0 4 3093 33 PhysxKitchen::cook_soft_body_mesh 0 2 1175 1176 22
/**
 *
 */

/**
 *
 */
197
bool PhysxKitchen::cook_soft_body_mesh(PhysxSoftBodyMeshDesc const &meshDesc, Filename const &filename);
PhysxSoftBodyMesh *PhysxKitchen::cook_soft_body_mesh(PhysxSoftBodyMeshDesc const &meshDesc);

2659 14 cook_texcoords 0 4 3093 28 PhysxKitchen::cook_texcoords 0 1 1177 10
/**
 *
 */
96
bool PhysxKitchen::cook_texcoords(PhysxClothMeshDesc const &meshDesc, Filename const &filename);

2660 21 PhysxTriangleMeshDesc 0 4 3094 44 PhysxTriangleMeshDesc::PhysxTriangleMeshDesc 0 1 1178 10
/**
 *
 */
58
inline PhysxTriangleMeshDesc::PhysxTriangleMeshDesc(void);

2661 22 ~PhysxTriangleMeshDesc 0 4 3094 45 PhysxTriangleMeshDesc::~PhysxTriangleMeshDesc 0 0 10
/**
 *
 */
59
inline PhysxTriangleMeshDesc::~PhysxTriangleMeshDesc(void);

2662 8 is_valid 0 4 3094 31 PhysxTriangleMeshDesc::is_valid 0 1 1179 51
/**
 * Returns true if the descriptor is valid.
 */
56
inline bool PhysxTriangleMeshDesc::is_valid(void) const;

2663 16 set_num_vertices 0 4 3094 39 PhysxTriangleMeshDesc::set_num_vertices 0 1 1180 241
/**
 * Sets the number of vertices to be stored within this triangle mesh.  The
 * function allocates memory for the vertices, but it does not set any
 * vertices.
 *
 * This method must be called before any calls to set_vertex are done!
 */
61
void PhysxTriangleMeshDesc::set_num_vertices(unsigned int n);

2664 10 set_vertex 0 4 3094 33 PhysxTriangleMeshDesc::set_vertex 0 1 1181 118
/**
 * Sets a single vertex.  You have to call the function set_num_vertices
 * before you can call this function.
 */
79
void PhysxTriangleMeshDesc::set_vertex(unsigned int idx, LPoint3f const &vert);

2665 17 set_num_triangles 0 4 3094 40 PhysxTriangleMeshDesc::set_num_triangles 0 1 1182 151
/**
 * Sets the number of triangles to be stored in this triangle mesh.
 *
 * This method must be called before any calls to set_triangle are done!
 */
97
void PhysxTriangleMeshDesc::set_num_triangles(unsigned int n, bool use_material_indices = false);

2666 12 set_triangle 0 4 3094 35 PhysxTriangleMeshDesc::set_triangle 0 1 1183 77
/**
 * Sets a single triangle, by providing the three indices i1, i2, i3.
 */
143
void PhysxTriangleMeshDesc::set_triangle(unsigned int idx, unsigned int i1, unsigned int i2, unsigned int i3, unsigned int material_index = 1);

2667 18 set_from_node_path 0 4 3094 41 PhysxTriangleMeshDesc::set_from_node_path 0 1 1184 308
/**
 * A convenience method to set the mesh data from a NodePath in a single call.
 * The method iterates over the NodePath geoms and collects data for the
 * triangle mesh.
 *
 * Do not use the following function when using this one: - set_num_vertices -
 * set_vertex - set_num_triangles - set_triangle
 */
67
void PhysxTriangleMeshDesc::set_from_node_path(NodePath const &np);

2668 21 PhysxSoftBodyMeshDesc 0 4 3095 44 PhysxSoftBodyMeshDesc::PhysxSoftBodyMeshDesc 0 1 1185 10
/**
 *
 */
58
inline PhysxSoftBodyMeshDesc::PhysxSoftBodyMeshDesc(void);

2669 22 ~PhysxSoftBodyMeshDesc 0 4 3095 45 PhysxSoftBodyMeshDesc::~PhysxSoftBodyMeshDesc 0 0 10
/**
 *
 */
59
inline PhysxSoftBodyMeshDesc::~PhysxSoftBodyMeshDesc(void);

2670 8 is_valid 0 4 3095 31 PhysxSoftBodyMeshDesc::is_valid 0 1 1186 51
/**
 * Returns true if the descriptor is valid.
 */
56
inline bool PhysxSoftBodyMeshDesc::is_valid(void) const;

2671 16 set_num_vertices 0 4 3095 39 PhysxSoftBodyMeshDesc::set_num_vertices 0 1 1187 242
/**
 * Sets the number of vertices to be stored within this soft body mesh.  The
 * function allocates memory for the vertices, but it does not set any
 * vertices.
 *
 * This method must be called before any calls to set_vertex are done!
 */
61
void PhysxSoftBodyMeshDesc::set_num_vertices(unsigned int n);

2672 10 set_vertex 0 4 3095 33 PhysxSoftBodyMeshDesc::set_vertex 0 1 1188 118
/**
 * Sets a single vertex.  You have to call the function set_num_vertices
 * before you can call this function.
 */
79
void PhysxSoftBodyMeshDesc::set_vertex(unsigned int idx, LPoint3f const &vert);

2673 18 set_num_tetrahedra 0 4 3095 41 PhysxSoftBodyMeshDesc::set_num_tetrahedra 0 1 1189 156
/**
 * Sets the number of tetrahedra to be stored in this soft body mesh.
 *
 * This method must be called before any calls to set_tetrahedron are done!
 */
63
void PhysxSoftBodyMeshDesc::set_num_tetrahedra(unsigned int n);

2674 15 set_tetrahedron 0 4 3095 38 PhysxSoftBodyMeshDesc::set_tetrahedron 0 1 1190 84
/**
 * Sets a single tetrahedron, by providing the three indices i1, i2, i3, i4.
 */
130
void PhysxSoftBodyMeshDesc::set_tetrahedron(unsigned int idx, unsigned int i1, unsigned int i2, unsigned int i3, unsigned int i4);

2675 14 PhysxSceneDesc 0 4 3096 30 PhysxSceneDesc::PhysxSceneDesc 0 1 1191 10
/**
 *
 */
44
inline PhysxSceneDesc::PhysxSceneDesc(void);

2676 15 ~PhysxSceneDesc 0 4 3096 31 PhysxSceneDesc::~PhysxSceneDesc 0 0 10
/**
 *
 */
45
inline PhysxSceneDesc::~PhysxSceneDesc(void);

2677 14 set_to_default 0 4 3096 30 PhysxSceneDesc::set_to_default 0 1 1192 49
/**
 * (re)sets the structure to the default.
 */
49
inline void PhysxSceneDesc::set_to_default(void);

2678 8 is_valid 0 4 3096 24 PhysxSceneDesc::is_valid 0 1 1193 51
/**
 * Returns true if the descriptor is valid.
 */
49
inline bool PhysxSceneDesc::is_valid(void) const;

2679 8 set_flag 0 4 3096 24 PhysxSceneDesc::set_flag 0 1 1194 49
/**
 * Raise or lower individual scene flags.
 */
75
void PhysxSceneDesc::set_flag(PhysxEnums::PhysxSceneFlag flag, bool value);

2680 11 set_gravity 0 4 3096 27 PhysxSceneDesc::set_gravity 0 1 1195 35
/**
 * Sets the gravity vector.
 */
59
void PhysxSceneDesc::set_gravity(LVector3f const &gravity);

2681 14 set_max_bounds 0 4 3096 30 PhysxSceneDesc::set_max_bounds 0 1 1196 624
/**
 * Set the max scene bounds.
 *
 * If scene bounds are provided (maxBounds in the descriptor), the SDK takes
 * advantage of this information to accelerate scene-level collision queries
 * (e.g.  raycasting). When using maxBounds, you have to make sure created
 * objects stay within the scene bounds.  In particular, the position of
 * dynamic shapes should stay within the provided bounds.  Otherwise the
 * shapes outside the bounds will not be taken into account by all scene
 * queries (raycasting, sweep tests, overlap tests, etc). They will
 * nonetheless still work correctly for the main physics simulation.
 */
58
void PhysxSceneDesc::set_max_bounds(PhysxBounds3 &bounds);

2682 20 set_static_structure 0 4 3096 36 PhysxSceneDesc::set_static_structure 0 1 1197 62
/**
 * Defines the structure used to store static objects.
 */
83
void PhysxSceneDesc::set_static_structure(PhysxEnums::PhysxPruningStructure value);

2683 21 set_dynamic_structure 0 4 3096 37 PhysxSceneDesc::set_dynamic_structure 0 1 1198 142
/**
 * Defines the subdivision level for acceleration structures used for scene
 * queries.  This is only used when maxBounds are defined!
 */
84
void PhysxSceneDesc::set_dynamic_structure(PhysxEnums::PhysxPruningStructure value);

2684 11 set_bp_type 0 4 3096 27 PhysxSceneDesc::set_bp_type 0 1 1199 917
/**
 * Defines which type of broadphase to use.
 *
 * (1) BPT_sap_single: A sweep-and-prune (SAP) algorithm to find pairs of
 * potentially colliding shapes.
 *
 * (2) BPT_sap_multi: A multi sweep-and-prune algorithm to find pairs of
 * potentially colliding shapes.  Uses a configurable 2D grid to divide the
 * scene space into cells.  The potentially overlapping shape pairs are
 * detected in each cell and the information is merged together.  This
 * approach is usually faster than BPT_sap_single in scenarios with many
 * shapes and a high creation/deletion rate of shapes.  However, the amount of
 * memory required is considerably higher depending on the number of grid
 * cells used.  The following extra parameters need to be defined: -
 * PhysxSceneDesc.set_max_bounds - PhysxSceneDesc.set_num_grid_cells_x -
 * PhysxSceneDesc.set_num_grid_cells_y (the scene up direction is set via
 * config options)
 */
72
void PhysxSceneDesc::set_bp_type(PhysxEnums::PhysxBroadPhaseType value);

2685 21 set_subdivision_level 0 4 3096 37 PhysxSceneDesc::set_subdivision_level 0 1 1200 142
/**
 * Defines the subdivision level for acceleration structures used for scene
 * queries.  This is only used when maxBounds are defined!
 */
63
void PhysxSceneDesc::set_subdivision_level(unsigned int value);

2686 20 set_num_grid_cells_x 0 4 3096 36 PhysxSceneDesc::set_num_grid_cells_x 0 1 1201 214
/**
 * Defines the number of broadphase cells along the grid x-axis.  Must be
 * power of two.  Max is 8 at the moment.  The broadphase type must be set to
 * BPT_sap_multi for this parameter to have an effect.
 */
62
void PhysxSceneDesc::set_num_grid_cells_x(unsigned int value);

2687 20 set_num_grid_cells_y 0 4 3096 36 PhysxSceneDesc::set_num_grid_cells_y 0 1 1202 214
/**
 * Defines the number of broadphase cells along the grid y-axis.  Must be
 * power of two.  Max is 8 at the moment.  The broadphase type must be set to
 * BPT_sap_multi for this parameter to have an effect.
 */
62
void PhysxSceneDesc::set_num_grid_cells_y(unsigned int value);

2688 8 get_flag 0 4 3096 24 PhysxSceneDesc::get_flag 0 1 1203 44
/**
 * Returns the specified scene flag.
 */
69
bool PhysxSceneDesc::get_flag(PhysxEnums::PhysxSceneFlag flag) const;

2689 11 get_gravity 0 4 3096 27 PhysxSceneDesc::get_gravity 0 1 1204 34
/**
 * Get the gravity vector.
 */
50
LVector3f PhysxSceneDesc::get_gravity(void) const;

2690 14 get_max_bounds 0 4 3096 30 PhysxSceneDesc::get_max_bounds 0 1 1205 10
/**
 *
 */
56
PhysxBounds3 PhysxSceneDesc::get_max_bounds(void) const;

2691 20 get_static_structure 0 4 3096 36 PhysxSceneDesc::get_static_structure 0 1 1206 62
/**
 * Returns the structure used to store static objects.
 */
83
PhysxEnums::PhysxPruningStructure PhysxSceneDesc::get_static_structure(void) const;

2692 21 get_dynamic_structure 0 4 3096 37 PhysxSceneDesc::get_dynamic_structure 0 1 1207 95
/**
 * Returns the subdivision level for acceleration structures used for scene
 * queries.
 */
84
PhysxEnums::PhysxPruningStructure PhysxSceneDesc::get_dynamic_structure(void) const;

2693 11 get_bp_type 0 4 3096 27 PhysxSceneDesc::get_bp_type 0 1 1208 49
/**
 * Returns the type of broadphase to use.
 */
72
PhysxEnums::PhysxBroadPhaseType PhysxSceneDesc::get_bp_type(void) const;

2694 21 get_subdivision_level 0 4 3096 37 PhysxSceneDesc::get_subdivision_level 0 1 1209 95
/**
 * Returns the subdivision level for acceleration structures used for scene
 * queries.
 */
63
unsigned int PhysxSceneDesc::get_subdivision_level(void) const;

2695 20 get_num_grid_cells_x 0 4 3096 36 PhysxSceneDesc::get_num_grid_cells_x 0 1 1210 72
/**
 * Returns the number of broadphase cells along the grid x-axis.
 */
62
unsigned int PhysxSceneDesc::get_num_grid_cells_x(void) const;

2696 20 get_num_grid_cells_y 0 4 3096 36 PhysxSceneDesc::get_num_grid_cells_y 0 1 1211 72
/**
 * Returns the number of broadphase cells along the grid y-axis.
 */
62
unsigned int PhysxSceneDesc::get_num_grid_cells_y(void) const;

2697 17 PhysxMaterialDesc 0 4 3097 36 PhysxMaterialDesc::PhysxMaterialDesc 0 1 1212 10
/**
 *
 */
50
inline PhysxMaterialDesc::PhysxMaterialDesc(void);

2698 18 ~PhysxMaterialDesc 0 4 3097 37 PhysxMaterialDesc::~PhysxMaterialDesc 0 0 10
/**
 *
 */
51
inline PhysxMaterialDesc::~PhysxMaterialDesc(void);

2699 14 set_to_default 0 4 3097 33 PhysxMaterialDesc::set_to_default 0 1 1213 49
/**
 * (re)sets the structure to the default.
 */
52
inline void PhysxMaterialDesc::set_to_default(void);

2700 8 is_valid 0 4 3097 27 PhysxMaterialDesc::is_valid 0 1 1214 51
/**
 * Returns true if the descriptor is valid.
 */
52
inline bool PhysxMaterialDesc::is_valid(void) const;

2701 20 set_dynamic_friction 0 4 3097 39 PhysxMaterialDesc::set_dynamic_friction 0 1 1215 302
/**
 * Sets the coefficient of dynamic friction -- should be in [0, +inf]. If set
 * to greater than staticFriction, the effective value of staticFriction will
 * be increased to match.  If the flag MF_anisotropic is set, then this value
 * is used for the primary direction of anisotropy (U axis).
 */
57
void PhysxMaterialDesc::set_dynamic_friction(float coef);

2702 19 set_static_friction 0 4 3097 38 PhysxMaterialDesc::set_static_friction 0 1 1216 192
/**
 * Sets the coefficient of static friction -- should be in [0, +inf]. If the
 * flag MF_anisotropic is set, then this value is used for the primary
 * direction of anisotropy (U axis).
 */
56
void PhysxMaterialDesc::set_static_friction(float coef);

2703 15 set_restitution 0 4 3097 34 PhysxMaterialDesc::set_restitution 0 1 1217 274
/**
 * Sets the coefficient of restitution -- 0 makes the object bounce as little
 * as possible, higher values up to 1.0 result in more bounce.  Note that
 * values close to or above 1 may cause stability problems and/or increasing
 * energy.  Range: [0,1] Default: 0.0
 */
52
void PhysxMaterialDesc::set_restitution(float rest);

2704 22 set_dynamic_friction_v 0 4 3097 41 PhysxMaterialDesc::set_dynamic_friction_v 0 1 1218 168
/**
 * Sets the anisotropic dynamic friction coefficient for along the secondary
 * (V) axis of anisotropy.  This is only used if the flag MF_anisotropic is
 * set.
 */
59
void PhysxMaterialDesc::set_dynamic_friction_v(float coef);

2705 21 set_static_friction_v 0 4 3097 40 PhysxMaterialDesc::set_static_friction_v 0 1 1219 167
/**
 * Sets the anisotropic static friction coefficient for along the secondary
 * (V) axis of anisotropy.  This is only used if the flag MF_anisotropic is
 * set.
 */
58
void PhysxMaterialDesc::set_static_friction_v(float coef);

2706 21 set_dir_of_anisotropy 0 4 3097 40 PhysxMaterialDesc::set_dir_of_anisotropy 0 1 1220 127
/**
 * Sets the shape space direction (unit vector) of anisotropy.  This is only
 * used if the flag MF_anisotropic is set.
 */
67
void PhysxMaterialDesc::set_dir_of_anisotropy(LVector3f const dir);

2707 8 set_flag 0 4 3097 27 PhysxMaterialDesc::set_flag 0 1 1221 63
/**
 * Sets flags which control the behavior of a material.
 */
81
void PhysxMaterialDesc::set_flag(PhysxEnums::PhysxMaterialFlag flag, bool value);

2708 25 set_friction_combine_mode 0 4 3097 44 PhysxMaterialDesc::set_friction_combine_mode 0 1 1222 176
/**
 * Sets the friction combine mode.  - CM_average : Average: (a + b)/2. -
 * CM_min : Minimum: min(a,b). - CM_multiply : Multiply: a*b.  - CM_max :
 * Maximum: max(a,b).
 */
85
void PhysxMaterialDesc::set_friction_combine_mode(PhysxEnums::PhysxCombineMode mode);

2709 28 set_restitution_combine_mode 0 4 3097 47 PhysxMaterialDesc::set_restitution_combine_mode 0 1 1223 179
/**
 * Sets the restitution combine mode.  - CM_average : Average: (a + b)/2. -
 * CM_min : Minimum: min(a,b). - CM_multiply : Multiply: a*b.  - CM_max :
 * Maximum: max(a,b).
 */
88
void PhysxMaterialDesc::set_restitution_combine_mode(PhysxEnums::PhysxCombineMode mode);

2710 20 get_dynamic_friction 0 4 3097 39 PhysxMaterialDesc::get_dynamic_friction 0 1 1224 55
/**
 * Returns the coefficient of dynamic friction.
 */
58
float PhysxMaterialDesc::get_dynamic_friction(void) const;

2711 19 get_static_friction 0 4 3097 38 PhysxMaterialDesc::get_static_friction 0 1 1225 54
/**
 * Retruns the coefficient of static friction.
 */
57
float PhysxMaterialDesc::get_static_friction(void) const;

2712 15 get_restitution 0 4 3097 34 PhysxMaterialDesc::get_restitution 0 1 1226 50
/**
 * Returns the coefficient of restitution.
 */
53
float PhysxMaterialDesc::get_restitution(void) const;

2713 22 get_dynamic_friction_v 0 4 3097 41 PhysxMaterialDesc::get_dynamic_friction_v 0 1 1227 114
/**
 * Returns the anisotropic dynamic friction coefficient for along the
 * secondary (V) axis of anisotropy.
 */
60
float PhysxMaterialDesc::get_dynamic_friction_v(void) const;

2714 21 get_static_friction_v 0 4 3097 40 PhysxMaterialDesc::get_static_friction_v 0 1 1228 113
/**
 * Returns the anisotropic static friction coefficient for along the secondary
 * (V) axis of anisotropy.
 */
59
float PhysxMaterialDesc::get_static_friction_v(void) const;

2715 21 get_dir_of_anisotropy 0 4 3097 40 PhysxMaterialDesc::get_dir_of_anisotropy 0 1 1229 73
/**
 * Returns the shape space direction (unit vector) of anisotropy.
 */
63
LVector3f PhysxMaterialDesc::get_dir_of_anisotropy(void) const;

2716 8 get_flag 0 4 3097 27 PhysxMaterialDesc::get_flag 0 1 1230 66
/**
 * Returns flags which control the behavior of a material.
 */
75
bool PhysxMaterialDesc::get_flag(PhysxEnums::PhysxMaterialFlag flag) const;

2717 25 get_friction_combine_mode 0 4 3097 44 PhysxMaterialDesc::get_friction_combine_mode 0 1 1231 45
/**
 * Returns the friction combine mode.
 */
86
PhysxEnums::PhysxCombineMode PhysxMaterialDesc::get_friction_combine_mode(void) const;

2718 28 get_restitution_combine_mode 0 4 3097 47 PhysxMaterialDesc::get_restitution_combine_mode 0 1 1232 48
/**
 * Returns the restitution combine mode.
 */
89
PhysxEnums::PhysxCombineMode PhysxMaterialDesc::get_restitution_combine_mode(void) const;

2719 14 PhysxMotorDesc 0 4 3098 30 PhysxMotorDesc::PhysxMotorDesc 0 2 1233 1234 22
/**
 *
 */

/**
 *
 */
139
inline PhysxMotorDesc::PhysxMotorDesc(void);
inline PhysxMotorDesc::PhysxMotorDesc(float velTarget, float maxForce = 0, bool freeSpin = 0);

2720 15 ~PhysxMotorDesc 0 4 3098 31 PhysxMotorDesc::~PhysxMotorDesc 0 0 10
/**
 *
 */
45
inline PhysxMotorDesc::~PhysxMotorDesc(void);

2721 14 set_vel_target 0 4 3098 30 PhysxMotorDesc::set_vel_target 0 1 1235 10
/**
 *
 */
53
void PhysxMotorDesc::set_vel_target(float velTarget);

2722 13 set_max_force 0 4 3098 29 PhysxMotorDesc::set_max_force 0 1 1236 10
/**
 *
 */
51
void PhysxMotorDesc::set_max_force(float maxForce);

2723 13 set_free_spin 0 4 3098 29 PhysxMotorDesc::set_free_spin 0 1 1237 10
/**
 *
 */
50
void PhysxMotorDesc::set_free_spin(bool freeSpin);

2724 14 get_vel_target 0 4 3098 30 PhysxMotorDesc::get_vel_target 0 1 1238 10
/**
 *
 */
49
float PhysxMotorDesc::get_vel_target(void) const;

2725 13 get_max_force 0 4 3098 29 PhysxMotorDesc::get_max_force 0 1 1239 10
/**
 *
 */
48
float PhysxMotorDesc::get_max_force(void) const;

2726 13 get_free_spin 0 4 3098 29 PhysxMotorDesc::get_free_spin 0 1 1240 10
/**
 *
 */
47
bool PhysxMotorDesc::get_free_spin(void) const;

2727 10 PhysxPlane 0 4 3099 22 PhysxPlane::PhysxPlane 0 2 1241 1242 22
/**
 *
 */

/**
 *
 */
92
inline PhysxPlane::PhysxPlane(void);
inline PhysxPlane::PhysxPlane(PhysxPlane const &plane);

2728 11 ~PhysxPlane 0 4 3099 23 PhysxPlane::~PhysxPlane 0 0 10
/**
 *
 */
37
inline PhysxPlane::~PhysxPlane(void);

2729 8 distance 0 4 3099 20 PhysxPlane::distance 0 1 1243 10
/**
 *
 */
52
float PhysxPlane::distance(LPoint3f const &p) const;

2730 7 belongs 0 4 3099 19 PhysxPlane::belongs 0 1 1244 10
/**
 *
 */
50
bool PhysxPlane::belongs(LPoint3f const &p) const;

2731 9 normalize 0 4 3099 21 PhysxPlane::normalize 0 1 1245 10
/**
 *
 */
33
void PhysxPlane::normalize(void);

2732 14 point_in_plane 0 4 3099 26 PhysxPlane::point_in_plane 0 1 1246 10
/**
 *
 */
48
LPoint3f PhysxPlane::point_in_plane(void) const;

2733 7 project 0 4 3099 19 PhysxPlane::project 0 1 1247 10
/**
 *
 */
54
LPoint3f PhysxPlane::project(LPoint3f const &p) const;

2734 9 transform 0 4 3099 21 PhysxPlane::transform 0 1 1248 10
/**
 *
 */
86
void PhysxPlane::transform(LMatrix4f const &transform, PhysxPlane &transformed) const;

2735 17 inverse_transform 0 4 3099 29 PhysxPlane::inverse_transform 0 1 1249 10
/**
 *
 */
94
void PhysxPlane::inverse_transform(LMatrix4f const &transform, PhysxPlane &transformed) const;

2736 3 set 0 4 3099 15 PhysxPlane::set 0 1 1250 10
/**
 *
 */
87
PhysxPlane PhysxPlane::set(LPoint3f const &p0, LPoint3f const &p1, LPoint3f const &p2);

2737 4 zero 0 4 3099 16 PhysxPlane::zero 0 1 1251 10
/**
 *
 */
34
PhysxPlane PhysxPlane::zero(void);

2738 5 get_d 0 4 3099 17 PhysxPlane::get_d 0 1 1252 10
/**
 *
 */
36
float PhysxPlane::get_d(void) const;

2739 10 get_normal 0 4 3099 22 PhysxPlane::get_normal 0 1 1253 10
/**
 *
 */
45
LVector3f PhysxPlane::get_normal(void) const;

2740 5 set_d 0 4 3099 17 PhysxPlane::set_d 0 1 1254 10
/**
 *
 */
32
void PhysxPlane::set_d(float d);

2741 10 set_normal 0 4 3099 22 PhysxPlane::set_normal 0 1 1255 10
/**
 *
 */
46
void PhysxPlane::set_normal(LVector3f normal);

2742 19 PhysxPlaneShapeDesc 0 4 3100 40 PhysxPlaneShapeDesc::PhysxPlaneShapeDesc 0 1 1256 10
/**
 *
 */
54
inline PhysxPlaneShapeDesc::PhysxPlaneShapeDesc(void);

2743 9 set_plane 0 4 3100 30 PhysxPlaneShapeDesc::set_plane 0 1 1257 113
/**
 * Sets the parameters of the plane equation.  normal: Plane normal.  d: The
 * distance from the origin.
 */
70
void PhysxPlaneShapeDesc::set_plane(LVector3f const &normal, float d);

2744 26 PhysxPointInPlaneJointDesc 0 4 3101 54 PhysxPointInPlaneJointDesc::PhysxPointInPlaneJointDesc 0 1 1258 10
/**
 *
 */
68
inline PhysxPointInPlaneJointDesc::PhysxPointInPlaneJointDesc(void);

2745 27 ~PhysxPointInPlaneJointDesc 0 4 3101 55 PhysxPointInPlaneJointDesc::~PhysxPointInPlaneJointDesc 0 0 10
/**
 *
 */
69
inline PhysxPointInPlaneJointDesc::~PhysxPointInPlaneJointDesc(void);

2746 25 PhysxPointOnLineJointDesc 0 4 3102 52 PhysxPointOnLineJointDesc::PhysxPointOnLineJointDesc 0 1 1259 10
/**
 *
 */
66
inline PhysxPointOnLineJointDesc::PhysxPointOnLineJointDesc(void);

2747 26 ~PhysxPointOnLineJointDesc 0 4 3102 53 PhysxPointOnLineJointDesc::~PhysxPointOnLineJointDesc 0 0 10
/**
 *
 */
67
inline PhysxPointOnLineJointDesc::~PhysxPointOnLineJointDesc(void);

2748 23 PhysxPrismaticJointDesc 0 4 3103 48 PhysxPrismaticJointDesc::PhysxPrismaticJointDesc 0 1 1260 10
/**
 *
 */
62
inline PhysxPrismaticJointDesc::PhysxPrismaticJointDesc(void);

2749 24 ~PhysxPrismaticJointDesc 0 4 3103 49 PhysxPrismaticJointDesc::~PhysxPrismaticJointDesc 0 0 10
/**
 *
 */
63
inline PhysxPrismaticJointDesc::~PhysxPrismaticJointDesc(void);

2750 20 PhysxPulleyJointDesc 0 4 3104 42 PhysxPulleyJointDesc::PhysxPulleyJointDesc 0 1 1261 10
/**
 *
 */
56
inline PhysxPulleyJointDesc::PhysxPulleyJointDesc(void);

2751 21 ~PhysxPulleyJointDesc 0 4 3104 43 PhysxPulleyJointDesc::~PhysxPulleyJointDesc 0 0 10
/**
 *
 */
57
inline PhysxPulleyJointDesc::~PhysxPulleyJointDesc(void);

2752 12 set_distance 0 4 3104 34 PhysxPulleyJointDesc::set_distance 0 1 1262 71
/**
 * Sets the rest length of the rope connecting the two objects.
 */
56
void PhysxPulleyJointDesc::set_distance(float distance);

2753 13 set_stiffness 0 4 3104 35 PhysxPulleyJointDesc::set_stiffness 0 1 1263 71
/**
 * Sets how stiff the constraint is, between 0 and 1 (stiffest)
 */
58
void PhysxPulleyJointDesc::set_stiffness(float stiffness);

2754 9 set_ratio 0 4 3104 31 PhysxPulleyJointDesc::set_ratio 0 1 1264 39
/**
 * Sets the transmission ratio.
 */
51
void PhysxPulleyJointDesc::set_ratio(float ration);

2755 10 set_pulley 0 4 3104 32 PhysxPulleyJointDesc::set_pulley 0 1 1265 67
/**
 * Sets the suspension points of two bodies in world space.
 */
76
void PhysxPulleyJointDesc::set_pulley(unsigned int idx, LPoint3f const pos);

2756 9 set_motor 0 4 3104 31 PhysxPulleyJointDesc::set_motor 0 1 1266 40
/**
 * Sets an optional joint motor.
 */
66
void PhysxPulleyJointDesc::set_motor(PhysxMotorDesc const &motor);

2757 8 set_flag 0 4 3104 30 PhysxPulleyJointDesc::set_flag 0 1 1267 56
/**
 * Sets or clears a single PulleyJointFlag flag.
 */
87
void PhysxPulleyJointDesc::set_flag(PhysxEnums::PhysxPulleyJointFlag flag, bool value);

2758 12 get_distance 0 4 3104 34 PhysxPulleyJointDesc::get_distance 0 1 1268 10
/**
 *
 */
53
float PhysxPulleyJointDesc::get_distance(void) const;

2759 13 get_stiffness 0 4 3104 35 PhysxPulleyJointDesc::get_stiffness 0 1 1269 10
/**
 *
 */
54
float PhysxPulleyJointDesc::get_stiffness(void) const;

2760 9 get_ratio 0 4 3104 31 PhysxPulleyJointDesc::get_ratio 0 1 1270 10
/**
 *
 */
50
float PhysxPulleyJointDesc::get_ratio(void) const;

2761 8 get_flag 0 4 3104 30 PhysxPulleyJointDesc::get_flag 0 1 1271 10
/**
 *
 */
81
bool PhysxPulleyJointDesc::get_flag(PhysxEnums::PhysxPulleyJointFlag flag) const;

2762 10 get_pulley 0 4 3104 32 PhysxPulleyJointDesc::get_pulley 0 1 1272 10
/**
 *
 */
66
LPoint3f PhysxPulleyJointDesc::get_pulley(unsigned int idx) const;

2763 9 get_motor 0 4 3104 31 PhysxPulleyJointDesc::get_motor 0 1 1273 10
/**
 *
 */
59
PhysxMotorDesc PhysxPulleyJointDesc::get_motor(void) const;

2764 8 PhysxRay 0 4 3105 18 PhysxRay::PhysxRay 0 1 1274 10
/**
 *
 */
32
inline PhysxRay::PhysxRay(void);

2765 9 ~PhysxRay 0 4 3105 19 PhysxRay::~PhysxRay 0 0 10
/**
 *
 */
33
inline PhysxRay::~PhysxRay(void);

2766 10 set_length 0 4 3105 20 PhysxRay::set_length 0 1 1275 173
/**
 * Sets the ray length.  If no length is set then the ray will be virtually
 * infinite (the maximum floating point number will be used, e.g.
 * 3.40282346639e+038).
 */
40
void PhysxRay::set_length(float length);

2767 10 set_origin 0 4 3105 20 PhysxRay::set_origin 0 1 1276 31
/**
 * Sets the ray origin.
 */
50
void PhysxRay::set_origin(LPoint3f const &origin);

2768 13 set_direction 0 4 3105 23 PhysxRay::set_direction 0 1 1277 82
/**
 * Set the ray direction.  It is not required to pass a normalized vector.
 */
57
void PhysxRay::set_direction(LVector3f const &direction);

2769 10 get_length 0 4 3105 20 PhysxRay::get_length 0 1 1278 34
/**
 * Returns the ray length.
 */
39
float PhysxRay::get_length(void) const;

2770 10 get_origin 0 4 3105 20 PhysxRay::get_origin 0 1 1279 33
/**
 * Returns the ray origin
 */
42
LPoint3f PhysxRay::get_origin(void) const;

2771 13 get_direction 0 4 3105 23 PhysxRay::get_direction 0 1 1280 37
/**
 * Returns the ray direction.
 */
46
LVector3f PhysxRay::get_direction(void) const;

2772 15 PhysxRaycastHit 0 4 3106 32 PhysxRaycastHit::PhysxRaycastHit 0 1 1281 10
/**
 *
 */
64
inline PhysxRaycastHit::PhysxRaycastHit(NxRaycastHit const hit);

2773 16 ~PhysxRaycastHit 0 4 3106 33 PhysxRaycastHit::~PhysxRaycastHit 0 0 10
/**
 *
 */
47
inline PhysxRaycastHit::~PhysxRaycastHit(void);

2774 8 is_empty 0 4 3106 25 PhysxRaycastHit::is_empty 0 1 1282 10
/**
 *
 */
43
bool PhysxRaycastHit::is_empty(void) const;

2775 9 get_shape 0 4 3106 26 PhysxRaycastHit::get_shape 0 1 1283 10
/**
 *
 */
51
PhysxShape *PhysxRaycastHit::get_shape(void) const;

2776 14 get_impact_pos 0 4 3106 31 PhysxRaycastHit::get_impact_pos 0 1 1284 10
/**
 *
 */
53
LPoint3f PhysxRaycastHit::get_impact_pos(void) const;

2777 17 get_impact_normal 0 4 3106 34 PhysxRaycastHit::get_impact_normal 0 1 1285 10
/**
 *
 */
57
LVector3f PhysxRaycastHit::get_impact_normal(void) const;

2778 12 get_distance 0 4 3106 29 PhysxRaycastHit::get_distance 0 1 1286 10
/**
 *
 */
48
float PhysxRaycastHit::get_distance(void) const;

2779 29 upcast_to_NxUserRaycastReport 0 12 3107 49 PhysxRaycastReport::upcast_to_NxUserRaycastReport 0 1 1292 53
upcast from PhysxRaycastReport to NxUserRaycastReport
77
NxUserRaycastReport *PhysxRaycastReport::upcast_to_NxUserRaycastReport(void);

2780 50 downcast_NxUserRaycastReport_to_PhysxRaycastReport 0 8 0 50 downcast_NxUserRaycastReport_to_PhysxRaycastReport 0 1 1293 55
downcast from NxUserRaycastReport to PhysxRaycastReport
98
PhysxRaycastReport *downcast_NxUserRaycastReport_to_PhysxRaycastReport(NxUserRaycastReport *this);

2781 12 get_num_hits 0 4 3107 32 PhysxRaycastReport::get_num_hits 0 1 1288 10
/**
 *
 */
58
unsigned int PhysxRaycastReport::get_num_hits(void) const;

2782 13 get_first_hit 0 4 3107 33 PhysxRaycastReport::get_first_hit 0 1 1289 10
/**
 *
 */
56
PhysxRaycastHit PhysxRaycastReport::get_first_hit(void);

2783 12 get_next_hit 0 4 3107 32 PhysxRaycastReport::get_next_hit 0 1 1290 10
/**
 *
 */
55
PhysxRaycastHit PhysxRaycastReport::get_next_hit(void);

2784 7 get_hit 0 4 3107 27 PhysxRaycastReport::get_hit 0 1 1291 10
/**
 *
 */
62
PhysxRaycastHit PhysxRaycastReport::get_hit(unsigned int idx);

2785 19 ~PhysxRaycastReport 0 4 3107 39 PhysxRaycastReport::~PhysxRaycastReport 0 0 10
/**
 *
 */
53
inline PhysxRaycastReport::~PhysxRaycastReport(void);

2786 18 PhysxRaycastReport 0 4 3107 38 PhysxRaycastReport::PhysxRaycastReport 0 1 1287 10
/**
 *
 */
84
inline PhysxRaycastReport::PhysxRaycastReport(PhysxRaycastReport const &) = default;

2787 22 PhysxRevoluteJointDesc 0 4 3109 46 PhysxRevoluteJointDesc::PhysxRevoluteJointDesc 0 1 1294 10
/**
 *
 */
60
inline PhysxRevoluteJointDesc::PhysxRevoluteJointDesc(void);

2788 23 ~PhysxRevoluteJointDesc 0 4 3109 47 PhysxRevoluteJointDesc::~PhysxRevoluteJointDesc 0 0 10
/**
 *
 */
61
inline PhysxRevoluteJointDesc::~PhysxRevoluteJointDesc(void);

2789 23 set_projection_distance 0 4 3109 47 PhysxRevoluteJointDesc::set_projection_distance 0 1 1295 65
/**
 * Sets the distance beyond which the joint is projected.
 */
69
void PhysxRevoluteJointDesc::set_projection_distance(float distance);

2790 20 set_projection_angle 0 4 3109 44 PhysxRevoluteJointDesc::set_projection_angle 0 1 1296 62
/**
 * Sets the angle beyond which the joint is projected.
 */
63
void PhysxRevoluteJointDesc::set_projection_angle(float angle);

2791 10 set_spring 0 4 3109 34 PhysxRevoluteJointDesc::set_spring 0 1 1297 35
/**
 * Sets an aptional spring.
 */
71
void PhysxRevoluteJointDesc::set_spring(PhysxSpringDesc const &spring);

2792 8 set_flag 0 4 3109 32 PhysxRevoluteJointDesc::set_flag 0 1 1298 58
/**
 * Sets or clears a single RevoluteJointFlag flag.
 */
91
void PhysxRevoluteJointDesc::set_flag(PhysxEnums::PhysxRevoluteJointFlag flag, bool value);

2793 9 set_motor 0 4 3109 33 PhysxRevoluteJointDesc::set_motor 0 1 1299 40
/**
 * Sets an optional joint motor.
 */
68
void PhysxRevoluteJointDesc::set_motor(PhysxMotorDesc const &motor);

2794 13 set_limit_low 0 4 3109 37 PhysxRevoluteJointDesc::set_limit_low 0 1 1300 68
/**
 * Sets optional limits for the angular motion of the joint.
 */
75
void PhysxRevoluteJointDesc::set_limit_low(PhysxJointLimitDesc const &low);

2795 14 set_limit_high 0 4 3109 38 PhysxRevoluteJointDesc::set_limit_high 0 1 1301 68
/**
 * Sets optional limits for the angular motion of the joint.
 */
77
void PhysxRevoluteJointDesc::set_limit_high(PhysxJointLimitDesc const &high);

2796 19 set_projection_mode 0 4 3109 43 PhysxRevoluteJointDesc::set_projection_mode 0 1 1302 68
/**
 * Use this to enable joint projection.  Default is PM_none.
 */
87
void PhysxRevoluteJointDesc::set_projection_mode(PhysxEnums::PhysxProjectionMode mode);

2797 23 get_projection_distance 0 4 3109 47 PhysxRevoluteJointDesc::get_projection_distance 0 1 1303 67
/**
 * Return the distance beyond which the joint is projected.
 */
66
float PhysxRevoluteJointDesc::get_projection_distance(void) const;

2798 20 get_projection_angle 0 4 3109 44 PhysxRevoluteJointDesc::get_projection_angle 0 1 1304 64
/**
 * Return the angle beyond which the joint is projected.
 */
63
float PhysxRevoluteJointDesc::get_projection_angle(void) const;

2799 8 get_flag 0 4 3109 32 PhysxRevoluteJointDesc::get_flag 0 1 1305 10
/**
 *
 */
85
bool PhysxRevoluteJointDesc::get_flag(PhysxEnums::PhysxRevoluteJointFlag flag) const;

2800 10 get_spring 0 4 3109 34 PhysxRevoluteJointDesc::get_spring 0 1 1306 10
/**
 *
 */
63
PhysxSpringDesc PhysxRevoluteJointDesc::get_spring(void) const;

2801 9 get_motor 0 4 3109 33 PhysxRevoluteJointDesc::get_motor 0 1 1307 40
/**
 * Sets an optional joint motor.
 */
61
PhysxMotorDesc PhysxRevoluteJointDesc::get_motor(void) const;

2802 13 get_limit_low 0 4 3109 37 PhysxRevoluteJointDesc::get_limit_low 0 1 1308 10
/**
 *
 */
70
PhysxJointLimitDesc PhysxRevoluteJointDesc::get_limit_low(void) const;

2803 14 get_limit_high 0 4 3109 38 PhysxRevoluteJointDesc::get_limit_high 0 1 1309 10
/**
 *
 */
71
PhysxJointLimitDesc PhysxRevoluteJointDesc::get_limit_high(void) const;

2804 19 get_projection_mode 0 4 3109 43 PhysxRevoluteJointDesc::get_projection_mode 0 1 1310 10
/**
 *
 */
88
PhysxEnums::PhysxProjectionMode PhysxRevoluteJointDesc::get_projection_mode(void) const;

2805 16 PhysxSceneStats2 0 4 3110 34 PhysxSceneStats2::PhysxSceneStats2 0 2 1311 1312 10
/**
 *
 */
140
PhysxSceneStats2::PhysxSceneStats2(NxSceneStats2 const *ptr);
inline PhysxSceneStats2::PhysxSceneStats2(PhysxSceneStats2 const &) = default;

2806 17 ~PhysxSceneStats2 0 4 3110 35 PhysxSceneStats2::~PhysxSceneStats2 0 0 10
/**
 *
 */
42
PhysxSceneStats2::~PhysxSceneStats2(void);

2807 13 get_num_stats 0 4 3110 31 PhysxSceneStats2::get_num_stats 0 1 1313 10
/**
 *
 */
64
inline unsigned int PhysxSceneStats2::get_num_stats(void) const;

2808 13 get_cur_value 0 4 3110 31 PhysxSceneStats2::get_cur_value 0 1 1314 10
/**
 *
 */
69
inline int PhysxSceneStats2::get_cur_value(unsigned int index) const;

2809 13 get_max_value 0 4 3110 31 PhysxSceneStats2::get_max_value 0 1 1315 10
/**
 *
 */
69
inline int PhysxSceneStats2::get_max_value(unsigned int index) const;

2810 8 get_name 0 4 3110 26 PhysxSceneStats2::get_name 0 1 1316 10
/**
 *
 */
72
inline char const *PhysxSceneStats2::get_name(unsigned int index) const;

2811 10 get_parent 0 4 3110 28 PhysxSceneStats2::get_parent 0 1 1317 10
/**
 *
 */
75
inline unsigned int PhysxSceneStats2::get_parent(unsigned int index) const;

2812 16 PhysxVehicleDesc 0 4 3111 34 PhysxVehicleDesc::PhysxVehicleDesc 0 2 1318 1319 10
/**
 *
 */
127
inline PhysxVehicleDesc::PhysxVehicleDesc(void);
inline PhysxVehicleDesc::PhysxVehicleDesc(PhysxVehicleDesc const &) = default;

2813 14 set_to_default 0 4 3111 32 PhysxVehicleDesc::set_to_default 0 1 1320 49
/**
 * (re)sets the structure to the default.
 */
51
inline void PhysxVehicleDesc::set_to_default(void);

2814 8 is_valid 0 4 3111 26 PhysxVehicleDesc::is_valid 0 1 1321 51
/**
 * Returns true if the descriptor is valid.
 */
51
inline bool PhysxVehicleDesc::is_valid(void) const;

2815 17 PhysxSoftBodyDesc 0 4 3112 36 PhysxSoftBodyDesc::PhysxSoftBodyDesc 0 1 1322 10
/**
 *
 */
50
inline PhysxSoftBodyDesc::PhysxSoftBodyDesc(void);

2816 18 ~PhysxSoftBodyDesc 0 4 3112 37 PhysxSoftBodyDesc::~PhysxSoftBodyDesc 0 0 10
/**
 *
 */
51
inline PhysxSoftBodyDesc::~PhysxSoftBodyDesc(void);

2817 14 set_to_default 0 4 3112 33 PhysxSoftBodyDesc::set_to_default 0 1 1323 49
/**
 * (re)sets the structure to the default.
 */
52
inline void PhysxSoftBodyDesc::set_to_default(void);

2818 8 is_valid 0 4 3112 27 PhysxSoftBodyDesc::is_valid 0 1 1324 51
/**
 * Returns true if the descriptor is valid.
 */
52
inline bool PhysxSoftBodyDesc::is_valid(void) const;

2819 18 set_soft_body_mesh 0 4 3112 37 PhysxSoftBodyDesc::set_soft_body_mesh 0 1 1325 10
/**
 *
 */
68
void PhysxSoftBodyDesc::set_soft_body_mesh(PhysxSoftBodyMesh *mesh);

2820 8 set_name 0 4 3112 27 PhysxSoftBodyDesc::set_name 0 1 1326 10
/**
 *
 */
51
void PhysxSoftBodyDesc::set_name(char const *name);

2821 14 set_global_pos 0 4 3112 33 PhysxSoftBodyDesc::set_global_pos 0 1 1327 10
/**
 *
 */
60
void PhysxSoftBodyDesc::set_global_pos(LPoint3f const &pos);

2822 14 set_global_mat 0 4 3112 33 PhysxSoftBodyDesc::set_global_mat 0 1 1328 10
/**
 *
 */
61
void PhysxSoftBodyDesc::set_global_mat(LMatrix4f const &mat);

2823 14 set_global_hpr 0 4 3112 33 PhysxSoftBodyDesc::set_global_hpr 0 1 1329 10
/**
 *
 */
66
void PhysxSoftBodyDesc::set_global_hpr(float h, float p, float r);

2824 11 set_density 0 4 3112 30 PhysxSoftBodyDesc::set_density 0 1 1330 10
/**
 *
 */
51
void PhysxSoftBodyDesc::set_density(float density);

2825 20 set_volume_stiffness 0 4 3112 39 PhysxSoftBodyDesc::set_volume_stiffness 0 1 1331 10
/**
 *
 */
62
void PhysxSoftBodyDesc::set_volume_stiffness(float stiffness);

2826 24 set_stretching_stiffness 0 4 3112 43 PhysxSoftBodyDesc::set_stretching_stiffness 0 1 1332 10
/**
 *
 */
66
void PhysxSoftBodyDesc::set_stretching_stiffness(float stiffness);

2827 23 set_damping_coefficient 0 4 3112 42 PhysxSoftBodyDesc::set_damping_coefficient 0 1 1333 10
/**
 *
 */
63
void PhysxSoftBodyDesc::set_damping_coefficient(float damping);

2828 12 set_friction 0 4 3112 31 PhysxSoftBodyDesc::set_friction 0 1 1334 10
/**
 *
 */
53
void PhysxSoftBodyDesc::set_friction(float friction);

2829 15 set_tear_factor 0 4 3112 34 PhysxSoftBodyDesc::set_tear_factor 0 1 1335 10
/**
 *
 */
58
void PhysxSoftBodyDesc::set_tear_factor(float tearFactor);

2830 19 set_particle_radius 0 4 3112 38 PhysxSoftBodyDesc::set_particle_radius 0 1 1336 10
/**
 *
 */
58
void PhysxSoftBodyDesc::set_particle_radius(float radius);

2831 25 set_relative_grid_spacing 0 4 3112 44 PhysxSoftBodyDesc::set_relative_grid_spacing 0 1 1337 10
/**
 *
 */
65
void PhysxSoftBodyDesc::set_relative_grid_spacing(float spacing);

2832 34 set_collision_response_coefficient 0 4 3112 53 PhysxSoftBodyDesc::set_collision_response_coefficient 0 1 1338 10
/**
 *
 */
71
void PhysxSoftBodyDesc::set_collision_response_coefficient(float coef);

2833 35 set_attachment_response_coefficient 0 4 3112 54 PhysxSoftBodyDesc::set_attachment_response_coefficient 0 1 1339 10
/**
 *
 */
72
void PhysxSoftBodyDesc::set_attachment_response_coefficient(float coef);

2834 21 set_solver_iterations 0 4 3112 40 PhysxSoftBodyDesc::set_solver_iterations 0 1 1340 121
/**
 * Number of solver iterations.  Small numbers make the simulation faster
 * while the soft body gets less stiff.
 */
72
void PhysxSoftBodyDesc::set_solver_iterations(unsigned int interations);

2835 8 set_flag 0 4 3112 27 PhysxSoftBodyDesc::set_flag 0 1 1341 56
/**
 * Raise or lower individual SoftBodyFlag flags.
 */
81
void PhysxSoftBodyDesc::set_flag(PhysxEnums::PhysxSoftBodyFlag flag, bool value);

2836 8 get_name 0 4 3112 27 PhysxSoftBodyDesc::get_name 0 1 1342 10
/**
 *
 */
52
char const *PhysxSoftBodyDesc::get_name(void) const;

2837 14 get_global_pos 0 4 3112 33 PhysxSoftBodyDesc::get_global_pos 0 1 1343 10
/**
 *
 */
55
LPoint3f PhysxSoftBodyDesc::get_global_pos(void) const;

2838 14 get_global_mat 0 4 3112 33 PhysxSoftBodyDesc::get_global_mat 0 1 1344 10
/**
 *
 */
56
LMatrix4f PhysxSoftBodyDesc::get_global_mat(void) const;

2839 11 get_density 0 4 3112 30 PhysxSoftBodyDesc::get_density 0 1 1345 10
/**
 *
 */
49
float PhysxSoftBodyDesc::get_density(void) const;

2840 20 get_volume_stiffness 0 4 3112 39 PhysxSoftBodyDesc::get_volume_stiffness 0 1 1346 10
/**
 *
 */
58
float PhysxSoftBodyDesc::get_volume_stiffness(void) const;

2841 24 get_stretching_stiffness 0 4 3112 43 PhysxSoftBodyDesc::get_stretching_stiffness 0 1 1347 10
/**
 *
 */
62
float PhysxSoftBodyDesc::get_stretching_stiffness(void) const;

2842 23 get_damping_coefficient 0 4 3112 42 PhysxSoftBodyDesc::get_damping_coefficient 0 1 1348 10
/**
 *
 */
61
float PhysxSoftBodyDesc::get_damping_coefficient(void) const;

2843 12 get_friction 0 4 3112 31 PhysxSoftBodyDesc::get_friction 0 1 1349 10
/**
 *
 */
50
float PhysxSoftBodyDesc::get_friction(void) const;

2844 15 get_tear_factor 0 4 3112 34 PhysxSoftBodyDesc::get_tear_factor 0 1 1350 10
/**
 *
 */
53
float PhysxSoftBodyDesc::get_tear_factor(void) const;

2845 19 get_particle_radius 0 4 3112 38 PhysxSoftBodyDesc::get_particle_radius 0 1 1351 10
/**
 *
 */
57
float PhysxSoftBodyDesc::get_particle_radius(void) const;

2846 25 get_relative_grid_spacing 0 4 3112 44 PhysxSoftBodyDesc::get_relative_grid_spacing 0 1 1352 10
/**
 *
 */
63
float PhysxSoftBodyDesc::get_relative_grid_spacing(void) const;

2847 34 get_collision_response_coefficient 0 4 3112 53 PhysxSoftBodyDesc::get_collision_response_coefficient 0 1 1353 10
/**
 *
 */
72
float PhysxSoftBodyDesc::get_collision_response_coefficient(void) const;

2848 35 get_attachment_response_coefficient 0 4 3112 54 PhysxSoftBodyDesc::get_attachment_response_coefficient 0 1 1354 10
/**
 *
 */
73
float PhysxSoftBodyDesc::get_attachment_response_coefficient(void) const;

2849 21 get_solver_iterations 0 4 3112 40 PhysxSoftBodyDesc::get_solver_iterations 0 1 1355 10
/**
 *
 */
66
unsigned int PhysxSoftBodyDesc::get_solver_iterations(void) const;

2850 8 get_flag 0 4 3112 27 PhysxSoftBodyDesc::get_flag 0 1 1356 10
/**
 *
 */
75
bool PhysxSoftBodyDesc::get_flag(PhysxEnums::PhysxSoftBodyFlag flag) const;

2851 11 PhysxSphere 0 4 3113 24 PhysxSphere::PhysxSphere 0 2 1357 1358 22
/**
 *
 */

/**
 *
 */
98
inline PhysxSphere::PhysxSphere(void);
inline PhysxSphere::PhysxSphere(PhysxSphere const &sphere);

2852 12 ~PhysxSphere 0 4 3113 25 PhysxSphere::~PhysxSphere 0 0 10
/**
 *
 */
39
inline PhysxSphere::~PhysxSphere(void);

2853 8 contains 0 4 3113 21 PhysxSphere::contains 0 3 1359 1360 1361 276
/**
 * Tests if a point is contained within the sphere.
 */

/**
 * Tests if a sphere is contained within the sphere.
 */

/**
 * Tests if an axis aligned box is contained within the sphere.  The axis
 * aligned box is defined by the minimum corner and the maximum corner.
 */
189
bool PhysxSphere::contains(LPoint3f const &p) const;
bool PhysxSphere::contains(PhysxSphere const &sphere) const;
bool PhysxSphere::contains(LPoint3f const &min, LPoint3f const &max) const;

2854 9 intersect 0 4 3113 22 PhysxSphere::intersect 0 1 1362 98
/**
 * Tests if the sphere intersects another sphere.  Returns TRUE if the spheres
 * overlap.
 */
61
bool PhysxSphere::intersect(PhysxSphere const &sphere) const;

2855 8 is_valid 0 4 3113 21 PhysxSphere::is_valid 0 1 1363 48
/**
 * Returns TRUE if this sphere is valid.
 */
39
bool PhysxSphere::is_valid(void) const;

2856 10 get_center 0 4 3113 23 PhysxSphere::get_center 0 1 1364 44
/**
 * Returns the center of the sphere.
 */
45
LPoint3f PhysxSphere::get_center(void) const;

2857 10 get_radius 0 4 3113 23 PhysxSphere::get_radius 0 1 1365 39
/**
 * Returns the sphere's radius.
 */
42
float PhysxSphere::get_radius(void) const;

2858 10 set_center 0 4 3113 23 PhysxSphere::set_center 0 1 1366 41
/**
 * Sets the center of the sphere.
 */
45
void PhysxSphere::set_center(LPoint3f value);

2859 10 set_radius 0 4 3113 23 PhysxSphere::set_radius 0 1 1367 36
/**
 * Sets the sphere's radius.
 */
42
void PhysxSphere::set_radius(float value);

2860 30 PhysxSphereForceFieldShapeDesc 0 4 3114 62 PhysxSphereForceFieldShapeDesc::PhysxSphereForceFieldShapeDesc 0 1 1368 10
/**
 *
 */
76
inline PhysxSphereForceFieldShapeDesc::PhysxSphereForceFieldShapeDesc(void);

2861 31 ~PhysxSphereForceFieldShapeDesc 0 4 3114 63 PhysxSphereForceFieldShapeDesc::~PhysxSphereForceFieldShapeDesc 0 0 10
/**
 *
 */
77
inline PhysxSphereForceFieldShapeDesc::~PhysxSphereForceFieldShapeDesc(void);

2862 10 set_radius 0 4 3114 42 PhysxSphereForceFieldShapeDesc::set_radius 0 1 1369 46
/**
 * Radius of shape.  Must be positive.
 */
62
void PhysxSphereForceFieldShapeDesc::set_radius(float radius);

2863 10 get_radius 0 4 3114 42 PhysxSphereForceFieldShapeDesc::get_radius 0 1 1370 27
/**
 * Radius of shape.
 */
61
float PhysxSphereForceFieldShapeDesc::get_radius(void) const;

2864 20 PhysxSphereShapeDesc 0 4 3115 42 PhysxSphereShapeDesc::PhysxSphereShapeDesc 0 1 1371 10
/**
 *
 */
56
inline PhysxSphereShapeDesc::PhysxSphereShapeDesc(void);

2865 10 set_radius 0 4 3115 32 PhysxSphereShapeDesc::set_radius 0 1 1372 46
/**
 * Radius of shape.  Must be positive.
 */
52
void PhysxSphereShapeDesc::set_radius(float radius);

2866 10 get_radius 0 4 3115 32 PhysxSphereShapeDesc::get_radius 0 1 1373 27
/**
 * Radius of shape.
 */
51
float PhysxSphereShapeDesc::get_radius(void) const;

2867 23 PhysxSphericalJointDesc 0 4 3116 48 PhysxSphericalJointDesc::PhysxSphericalJointDesc 0 1 1374 10
/**
 *
 */
62
inline PhysxSphericalJointDesc::PhysxSphericalJointDesc(void);

2868 24 ~PhysxSphericalJointDesc 0 4 3116 49 PhysxSphericalJointDesc::~PhysxSphericalJointDesc 0 0 10
/**
 *
 */
63
inline PhysxSphericalJointDesc::~PhysxSphericalJointDesc(void);

2869 23 set_projection_distance 0 4 3116 48 PhysxSphericalJointDesc::set_projection_distance 0 1 1375 57
/**
 * Set the distance above which to project joint.
 */
70
void PhysxSphericalJointDesc::set_projection_distance(float distance);

2870 8 set_flag 0 4 3116 33 PhysxSphericalJointDesc::set_flag 0 1 1376 59
/**
 * Sets or clears a single SphericalJointFlag flag.
 */
93
void PhysxSphericalJointDesc::set_flag(PhysxEnums::PhysxSphericalJointFlag flag, bool value);

2871 14 set_swing_axis 0 4 3116 39 PhysxSphericalJointDesc::set_swing_axis 0 1 1377 74
/**
 * Set the swing limit axis defined in the joint space of actor 0.
 */
68
void PhysxSphericalJointDesc::set_swing_axis(LVector3f const &axis);

2872 16 set_twist_spring 0 4 3116 41 PhysxSphericalJointDesc::set_twist_spring 0 1 1378 53
/**
 * Sets a spring that works against twisting.
 */
78
void PhysxSphericalJointDesc::set_twist_spring(PhysxSpringDesc const &spring);

2873 16 set_swing_spring 0 4 3116 41 PhysxSphericalJointDesc::set_swing_spring 0 1 1379 53
/**
 * Sets a spring that works against swinging.
 */
78
void PhysxSphericalJointDesc::set_swing_spring(PhysxSpringDesc const &spring);

2874 16 set_joint_spring 0 4 3116 41 PhysxSphericalJointDesc::set_joint_spring 0 1 1380 62
/**
 * Sets a spring that lets the joint get pulled apart.
 */
78
void PhysxSphericalJointDesc::set_joint_spring(PhysxSpringDesc const &spring);

2875 19 set_twist_limit_low 0 4 3116 44 PhysxSphericalJointDesc::set_twist_limit_low 0 1 1381 45
/**
 * Limits rotation around twist axis.
 */
82
void PhysxSphericalJointDesc::set_twist_limit_low(PhysxJointLimitDesc const &low);

2876 20 set_twist_limit_high 0 4 3116 45 PhysxSphericalJointDesc::set_twist_limit_high 0 1 1382 45
/**
 * Limits rotation around twist axis.
 */
84
void PhysxSphericalJointDesc::set_twist_limit_high(PhysxJointLimitDesc const &high);

2877 15 set_swing_limit 0 4 3116 40 PhysxSphericalJointDesc::set_swing_limit 0 1 1383 38
/**
 * Limits swing of twist axis.
 */
80
void PhysxSphericalJointDesc::set_swing_limit(PhysxJointLimitDesc const &limit);

2878 19 set_projection_mode 0 4 3116 44 PhysxSphericalJointDesc::set_projection_mode 0 1 1384 68
/**
 * Use this to enable joint projection.  Default is PM_none.
 */
88
void PhysxSphericalJointDesc::set_projection_mode(PhysxEnums::PhysxProjectionMode mode);

2879 23 get_projection_distance 0 4 3116 48 PhysxSphericalJointDesc::get_projection_distance 0 1 1385 10
/**
 *
 */
67
float PhysxSphericalJointDesc::get_projection_distance(void) const;

2880 8 get_flag 0 4 3116 33 PhysxSphericalJointDesc::get_flag 0 1 1386 10
/**
 *
 */
87
bool PhysxSphericalJointDesc::get_flag(PhysxEnums::PhysxSphericalJointFlag flag) const;

2881 14 get_swing_axis 0 4 3116 39 PhysxSphericalJointDesc::get_swing_axis 0 1 1387 10
/**
 *
 */
62
LVector3f PhysxSphericalJointDesc::get_swing_axis(void) const;

2882 16 get_twist_spring 0 4 3116 41 PhysxSphericalJointDesc::get_twist_spring 0 1 1388 10
/**
 *
 */
70
PhysxSpringDesc PhysxSphericalJointDesc::get_twist_spring(void) const;

2883 16 get_swing_spring 0 4 3116 41 PhysxSphericalJointDesc::get_swing_spring 0 1 1389 10
/**
 *
 */
70
PhysxSpringDesc PhysxSphericalJointDesc::get_swing_spring(void) const;

2884 16 get_joint_spring 0 4 3116 41 PhysxSphericalJointDesc::get_joint_spring 0 1 1390 10
/**
 *
 */
70
PhysxSpringDesc PhysxSphericalJointDesc::get_joint_spring(void) const;

2885 19 get_twist_limit_low 0 4 3116 44 PhysxSphericalJointDesc::get_twist_limit_low 0 1 1391 10
/**
 *
 */
77
PhysxJointLimitDesc PhysxSphericalJointDesc::get_twist_limit_low(void) const;

2886 20 get_twist_limit_high 0 4 3116 45 PhysxSphericalJointDesc::get_twist_limit_high 0 1 1392 10
/**
 *
 */
78
PhysxJointLimitDesc PhysxSphericalJointDesc::get_twist_limit_high(void) const;

2887 15 get_swing_limit 0 4 3116 40 PhysxSphericalJointDesc::get_swing_limit 0 1 1393 38
/**
 * Limits swing of twist axis.
 */
73
PhysxJointLimitDesc PhysxSphericalJointDesc::get_swing_limit(void) const;

2888 19 get_projection_mode 0 4 3116 44 PhysxSphericalJointDesc::get_projection_mode 0 1 1394 10
/**
 *
 */
89
PhysxEnums::PhysxProjectionMode PhysxSphericalJointDesc::get_projection_mode(void) const;

2889 26 PhysxTriangleMeshShapeDesc 0 4 3117 54 PhysxTriangleMeshShapeDesc::PhysxTriangleMeshShapeDesc 0 1 1395 10
/**
 *
 */
68
inline PhysxTriangleMeshShapeDesc::PhysxTriangleMeshShapeDesc(void);

2890 8 set_mesh 0 4 3117 36 PhysxTriangleMeshShapeDesc::set_mesh 0 1 1396 10
/**
 *
 */
67
void PhysxTriangleMeshShapeDesc::set_mesh(PhysxTriangleMesh *mesh);

2891 12 PhysxUtilLib 0 4 3118 26 PhysxUtilLib::PhysxUtilLib 0 2 1397 1398 10
/**
 *
 */
107
inline PhysxUtilLib::PhysxUtilLib(void);
inline PhysxUtilLib::PhysxUtilLib(PhysxUtilLib const &) = default;

2892 13 ~PhysxUtilLib 0 4 3118 27 PhysxUtilLib::~PhysxUtilLib 0 0 10
/**
 *
 */
41
inline PhysxUtilLib::~PhysxUtilLib(void);

2893 18 box_contains_point 0 4 3118 32 PhysxUtilLib::box_contains_point 0 1 1399 88
/**
 * Test if an oriented box contains a point.
 *
 * \param [in] box \param [in] p
 */
78
bool PhysxUtilLib::box_contains_point(PhysxBox const &box, LPoint3f const &p);

2894 10 create_box 0 4 3118 24 PhysxUtilLib::create_box 0 1 1400 119
/**
 * Create an oriented box from an axis aligned box and a transformation.
 *
 * \param [in] aabb \param [in] mat
 */
82
PhysxBox PhysxUtilLib::create_box(PhysxBounds3 const &aabb, LMatrix4f const &mat);

2895 29 compute_box_world_edge_normal 0 4 3118 43 PhysxUtilLib::compute_box_world_edge_normal 0 1 1401 240
/**
 * Compute and edge normals for an oriented box.  This is an averaged normal,
 * from the two faces sharing the edge.  The edge index should be from 0 to 11
 * (i.e.  a box has 12 edges).
 *
 * \param [in] box \param [in] edge_index
 */
100
LVector3f PhysxUtilLib::compute_box_world_edge_normal(PhysxBox const &box, unsigned int edge_index);

2896 26 compute_capsule_around_box 0 4 3118 40 PhysxUtilLib::compute_capsule_around_box 0 1 1402 72
/**
 * Compute a capsule which encloses a box.
 *
 * \param [in] box
 */
75
PhysxCapsule PhysxUtilLib::compute_capsule_around_box(PhysxBox const &box);

2897 21 is_box_a_inside_box_b 0 4 3118 35 PhysxUtilLib::is_box_a_inside_box_b 0 1 1403 125
/**
 * Test if box A is inside another box B. Returns TRUE if box A is inside box
 * B.
 *
 * \param [in] a \param [in] b
 */
79
bool PhysxUtilLib::is_box_a_inside_box_b(PhysxBox const &a, PhysxBox const &b);

2898 26 compute_box_around_capsule 0 4 3118 40 PhysxUtilLib::compute_box_around_capsule 0 1 1404 76
/**
 * Compute a box which encloses a capsule.
 *
 * \param [in] capsule
 */
79
PhysxBox PhysxUtilLib::compute_box_around_capsule(PhysxCapsule const &capsule);

2899 18 set_fpu_exceptions 0 4 3118 32 PhysxUtilLib::set_fpu_exceptions 0 1 1405 29
/**
 * Set FPU precision.
 */
46
void PhysxUtilLib::set_fpu_exceptions(bool b);

2900 19 set_fpu_precision24 0 4 3118 33 PhysxUtilLib::set_fpu_precision24 0 1 1406 29
/**
 * Set FPU precision.
 */
45
void PhysxUtilLib::set_fpu_precision24(void);

2901 19 set_fpu_precision53 0 4 3118 33 PhysxUtilLib::set_fpu_precision53 0 1 1407 29
/**
 * Set FPU precision.
 */
45
void PhysxUtilLib::set_fpu_precision53(void);

2902 19 set_fpu_precision64 0 4 3118 33 PhysxUtilLib::set_fpu_precision64 0 1 1408 29
/**
 * Set FPU precision.
 */
45
void PhysxUtilLib::set_fpu_precision64(void);

2903 21 set_fpu_rounding_chop 0 4 3118 35 PhysxUtilLib::set_fpu_rounding_chop 0 1 1409 29
/**
 * Set FPU precision.
 */
47
void PhysxUtilLib::set_fpu_rounding_chop(void);

2904 21 set_fpu_rounding_down 0 4 3118 35 PhysxUtilLib::set_fpu_rounding_down 0 1 1410 33
/**
 * Set FPU rounding mode.
 */
47
void PhysxUtilLib::set_fpu_rounding_down(void);

2905 21 set_fpu_rounding_near 0 4 3118 35 PhysxUtilLib::set_fpu_rounding_near 0 1 1411 33
/**
 * Set FPU rounding mode.
 */
47
void PhysxUtilLib::set_fpu_rounding_near(void);

2906 19 set_fpu_rounding_up 0 4 3118 33 PhysxUtilLib::set_fpu_rounding_up 0 1 1412 33
/**
 * Set FPU rounding mode.
 */
45
void PhysxUtilLib::set_fpu_rounding_up(void);

2907 8 int_ceil 0 4 3118 22 PhysxUtilLib::int_ceil 0 1 1413 57
/**
 * Convert a floating point number to an integer.
 */
43
int PhysxUtilLib::int_ceil(float const &f);

2908 8 int_chop 0 4 3118 22 PhysxUtilLib::int_chop 0 1 1414 57
/**
 * Convert a floating point number to an integer.
 */
43
int PhysxUtilLib::int_chop(float const &f);

2909 9 int_floor 0 4 3118 23 PhysxUtilLib::int_floor 0 1 1415 57
/**
 * Convert a floating point number to an integer.
 */
44
int PhysxUtilLib::int_floor(float const &f);

2910 24 compute_distance_squared 0 4 3118 38 PhysxUtilLib::compute_distance_squared 0 1 1416 102
/**
 * Compute the distance squared from a point to a ray.
 *
 * \param [in] ray \param [in] point
 */
89
float PhysxUtilLib::compute_distance_squared(PhysxRay const &ray, LPoint3f const &point);

2911 23 compute_square_distance 0 4 3118 37 PhysxUtilLib::compute_square_distance 0 1 1417 111
/**
 * Compute the distance squared from a point to a line segment.
 *
 * \param [in] seg \param [in] point
 */
92
float PhysxUtilLib::compute_square_distance(PhysxSegment const &seg, LPoint3f const &point);

2912 13 merge_spheres 0 4 3118 27 PhysxUtilLib::merge_spheres 0 1 1418 114
/**
 * Compute an overall bounding sphere for a pair of spheres.
 *
 * \param [in] sphere0 \param [in] sphere1
 */
96
PhysxSphere PhysxUtilLib::merge_spheres(PhysxSphere const &sphere0, PhysxSphere const &sphere1);

2913 18 normal_to_tangents 0 4 3118 32 PhysxUtilLib::normal_to_tangents 0 1 1419 112
/**
 * Get the tangent vectors associated with a normal.
 *
 * \param [in] n \param [out] t1 \param [out] t2
 */
88
void PhysxUtilLib::normal_to_tangents(LVector3f const &n, LVector3f &t1, LVector3f &t2);

2914 20 find_rotation_matrix 0 4 3118 34 PhysxUtilLib::find_rotation_matrix 0 1 1420 120
/**
 * Computes a rotation matrix M so that: M * x = b (x and b are unit vectors).
 *
 * \param [in] x \param [in] b
 */
85
LMatrix3f PhysxUtilLib::find_rotation_matrix(LVector3f const &x, LVector3f const &b);

2915 19 compute_sphere_mass 0 4 3118 33 PhysxUtilLib::compute_sphere_mass 0 1 1421 122
/**
 * Computes mass of a homogeneous sphere according to sphere density.
 *
 * \param [in] radius \param [in] density
 */
69
float PhysxUtilLib::compute_sphere_mass(float radius, float density);

2916 22 compute_sphere_density 0 4 3118 36 PhysxUtilLib::compute_sphere_density 0 1 1422 118
/**
 * Computes density of a homogeneous sphere according to sphere mass
 *
 * \param [in] radius \param [in] mass
 */
69
float PhysxUtilLib::compute_sphere_density(float radius, float mass);

2917 16 compute_box_mass 0 4 3118 30 PhysxUtilLib::compute_box_mass 0 1 1423 116
/**
 * Computes mass of a homogeneous box according to box density.
 *
 * \param [in] radius \param [in] density
 */
78
float PhysxUtilLib::compute_box_mass(LVector3f const &extents, float density);

2918 19 compute_box_density 0 4 3118 33 PhysxUtilLib::compute_box_density 0 1 1424 113
/**
 * Computes density of a homogeneous box according to box mass.
 *
 * \param [in] radius \param [in] mass
 */
78
float PhysxUtilLib::compute_box_density(LVector3f const &extents, float mass);

2919 22 compute_ellipsoid_mass 0 4 3118 36 PhysxUtilLib::compute_ellipsoid_mass 0 1 1425 128
/**
 * Computes mass of a homogeneous ellipsoid according to ellipsoid density.
 *
 * \param [in] radius \param [in] density
 */
84
float PhysxUtilLib::compute_ellipsoid_mass(LVector3f const &extents, float density);

2920 25 compute_ellipsoid_density 0 4 3118 39 PhysxUtilLib::compute_ellipsoid_density 0 1 1426 125
/**
 * Computes density of a homogeneous ellipsoid according to ellipsoid mass.
 *
 * \param [in] radius \param [in] mass
 */
84
float PhysxUtilLib::compute_ellipsoid_density(LVector3f const &extents, float mass);

2921 21 compute_cylinder_mass 0 4 3118 35 PhysxUtilLib::compute_cylinder_mass 0 1 1427 126
/**
 * Computes mass of a homogeneous cylinder according to cylinder density.
 *
 * \param [in] radius \param [in] density
 */
85
float PhysxUtilLib::compute_cylinder_mass(float radius, float length, float density);

2922 24 compute_cylinder_density 0 4 3118 38 PhysxUtilLib::compute_cylinder_density 0 1 1428 123
/**
 * Computes density of a homogeneous cylinder according to cylinder mass.
 *
 * \param [in] radius \param [in] mass
 */
85
float PhysxUtilLib::compute_cylinder_density(float radius, float length, float mass);

2923 17 compute_cone_mass 0 4 3118 31 PhysxUtilLib::compute_cone_mass 0 1 1429 118
/**
 * Computes mass of a homogeneous cone according to cone density.
 *
 * \param [in] radius \param [in] density
 */
81
float PhysxUtilLib::compute_cone_mass(float radius, float length, float density);

2924 20 compute_cone_density 0 4 3118 34 PhysxUtilLib::compute_cone_density 0 1 1430 115
/**
 * Computes density of a homogeneous cone according to cone mass.
 *
 * \param [in] radius \param [in] mass
 */
81
float PhysxUtilLib::compute_cone_density(float radius, float length, float mass);

2925 26 compute_box_inertia_tensor 0 4 3118 40 PhysxUtilLib::compute_box_inertia_tensor 0 1 1431 144
/**
 * Computes diagonalized inertia tensor for a box.
 *
 * \param [in] mass \param [in] xlength \param [in] ylength \param [in]
 * zlength
 */
108
LVector3f PhysxUtilLib::compute_box_inertia_tensor(float mass, float xlength, float ylength, float zlength);

2926 29 compute_sphere_inertia_tensor 0 4 3118 43 PhysxUtilLib::compute_sphere_inertia_tensor 0 1 1432 122
/**
 * Computes diagonalized inertia tensor for a sphere.
 *
 * \param [in] mass \param [in] radius \param [in] hollow
 */
93
LVector3f PhysxUtilLib::compute_sphere_inertia_tensor(float mass, float radius, bool hollow);

2927 17 box_box_intersect 0 4 3118 31 PhysxUtilLib::box_box_intersect 0 1 1433 310
/**
 * Boolean intersection test between two OBBs.  Uses the separating axis
 * theorem.  Disabling 'full_test' only performs 6 axis tests out of 15.
 *
 * \param [in] extents0 \param [in] center0 \param [in] rotation0 \param [in]
 * extents1 \param [in] center1 \param [in] rotation1 \param [in] full_test
 */
213
bool PhysxUtilLib::box_box_intersect(LVector3f const &extents0, LPoint3f const &center0, LMatrix3f const &rotation0, LVector3f const &extents1, LPoint3f const &center1, LMatrix3f const &rotation1, bool full_test);

2928 17 tri_box_intersect 0 4 3118 31 PhysxUtilLib::tri_box_intersect 0 1 1434 174
/**
 * Boolean intersection test between a triangle and a box.
 *
 * \param [in] vertex0 \param [in] vertex1 \param [in] vertex2 \param [in]
 * center \param [in] extents
 */
162
bool PhysxUtilLib::tri_box_intersect(LPoint3f const &vertex0, LPoint3f const &vertex1, LPoint3f const &vertex2, LPoint3f const &center, LVector3f const &extents);

2929 19 ray_plane_intersect 0 4 3118 33 PhysxUtilLib::ray_plane_intersect 0 1 1435 107
/**
 * Ray-plane intersection test.
 *
 * \param [in] ray \param [in] plane \param [out] point_on_plane
 */
111
bool PhysxUtilLib::ray_plane_intersect(PhysxRay const &ray, PhysxPlane const &plane, LPoint3f &point_on_plane);

2930 20 ray_sphere_intersect 0 4 3118 34 PhysxUtilLib::ray_sphere_intersect 0 1 1436 245
/**
 * Ray-sphere intersection test.  Returns true if the ray intersects the
 * sphere, and the impact point if needed.
 *
 * \param [in] origin \param [in] dir \param [in] length \param [in] center
 * \param [in] radius \param [out] hit_pos
 */
157
bool PhysxUtilLib::ray_sphere_intersect(LPoint3f const &origin, LVector3f const &dir, float length, LPoint3f const &center, float radius, LPoint3f &hit_pos);

2931 21 segment_box_intersect 0 4 3118 35 PhysxUtilLib::segment_box_intersect 0 1 1437 181
/**
 * Segment-AABB intersection test.  Also computes intersection point.
 *
 * \param [in] p1 \param [in] p2 \param [in] bbox_min \param [in] bbox_max
 * \param [out] intercept
 */
154
bool PhysxUtilLib::segment_box_intersect(LPoint3f const &p1, LPoint3f const &p2, LPoint3f const &bbox_min, LPoint3f const &bbox_max, LPoint3f &intercept);

2932 18 ray_aabb_intersect 0 4 3118 32 PhysxUtilLib::ray_aabb_intersect 0 1 1438 168
/**
 * Ray-AABB intersection test.  Also computes intersection point.
 *
 * \param [in] min \param [in] max \param [in] origin \param [in] dir \param
 * [out] coord
 */
143
bool PhysxUtilLib::ray_aabb_intersect(LPoint3f const &min, LPoint3f const &max, LPoint3f const &origin, LVector3f const &dir, LPoint3f &coord);

2933 21 segment_obb_intersect 0 4 3118 35 PhysxUtilLib::segment_obb_intersect 0 1 1439 178
/**
 * Boolean segment-OBB intersection test.  Based on separating axis theorem.
 *
 * \param [in] p0 \param [in] p1 \param [in] center \param [in] extents \param
 * [in] rot
 */
153
bool PhysxUtilLib::segment_obb_intersect(LPoint3f const &p0, LPoint3f const &p1, LPoint3f const &center, LVector3f const &extents, LMatrix3f const &rot);

2934 22 segment_aabb_intersect 0 4 3118 36 PhysxUtilLib::segment_aabb_intersect 0 1 1440 153
/**
 * Boolean segment-AABB intersection test.  Based on separating axis theorem.
 *
 * \param [in] p0 \param [in] p1 \param [in] min \param [in] max
 */
124
bool PhysxUtilLib::segment_aabb_intersect(LPoint3f const &p0, LPoint3f const &p1, LPoint3f const &min, LPoint3f const &max);

2935 17 ray_obb_intersect 0 4 3118 31 PhysxUtilLib::ray_obb_intersect 0 1 1441 157
/**
 * Boolean ray-OBB intersection test.  Based on separating axis theorem.
 *
 * \param [in] ray \param [in] center \param [in] extents \param [in] rot
 */
130
bool PhysxUtilLib::ray_obb_intersect(PhysxRay const &ray, LPoint3f const &center, LVector3f const &extents, LMatrix3f const &rot);

2936 21 ray_capsule_intersect 0 4 3118 35 PhysxUtilLib::ray_capsule_intersect 0 1 1442 170
/**
 * Ray-capsule intersection test.  Returns number of intersection points (0,1
 * or 2) along the ray.
 *
 * \param [in] origin \param [in] dir \param [in] capsule
 */
124
unsigned int PhysxUtilLib::ray_capsule_intersect(LPoint3f const &origin, LVector3f const &dir, PhysxCapsule const &capsule);

2937 23 swept_spheres_intersect 0 4 3118 37 PhysxUtilLib::swept_spheres_intersect 0 1 1443 227
/**
 * Sphere-sphere sweep test.  Returns true if spheres intersect during their
 * linear motion along provided velocity vectors.
 *
 * \param [in] sphere0 \param [in] velocity0 \param [in] sphere1 \param [in]
 * velocity1
 */
155
bool PhysxUtilLib::swept_spheres_intersect(PhysxSphere const &sphere0, LVector3f const &velocity0, PhysxSphere const &sphere1, LVector3f const &velocity1);

2938 17 ray_tri_intersect 0 4 3118 31 PhysxUtilLib::ray_tri_intersect 0 1 1444 356
/**
 * Ray-triangle intersection test.  Returns impact distance (t) as well as
 * barycentric coordinates (u,v) of impact point.  The test performs back face
 * culling or not according to 'cull'.
 *
 * \param [in] orig \param [in] dir \param [in] vert0 \param [in] vert1 \param
 * [in] vert2 \param [out] hit, with coordinates (t,u,v) \param [in] cull
 */
177
bool PhysxUtilLib::ray_tri_intersect(LPoint3f const &orig, LVector3f const &dir, LPoint3f const &vert0, LPoint3f const &vert1, LPoint3f const &vert2, LVector3f &hit, bool cull);

2939 17 sweep_box_capsule 0 4 3118 31 PhysxUtilLib::sweep_box_capsule 0 1 1445 323
/**
 * Box-vs-capsule sweep test.  Sweeps a box against a capsule, returns true if
 * box hit the capsule.  Also returns contact information.
 *
 * \param [in] box Box \param [in] lss Capsule \param [in] dir Unit-length
 * sweep direction \param [in] length Length of sweep \param [out] normal
 * Normal at impact point
 */
138
bool PhysxUtilLib::sweep_box_capsule(PhysxBox const &box, PhysxCapsule const &lss, LVector3f const &dir, float length, LVector3f &normal);

2940 16 sweep_box_sphere 0 4 3118 30 PhysxUtilLib::sweep_box_sphere 0 1 1446 322
/**
 * Box-vs-sphere sweep test.  Sweeps a box against a sphere, returns true if
 * box hit the sphere.  Also returns contact information.
 *
 * \param [in] box Box \param [in] sphere Sphere \param [in] dir Unit-length
 * sweep direction \param [in] length Length of sweep \param [out] normal
 * Normal at impact point
 */
139
bool PhysxUtilLib::sweep_box_sphere(PhysxBox const &box, PhysxSphere const &sphere, LVector3f const &dir, float length, LVector3f &normal);

2941 21 sweep_capsule_capsule 0 4 3118 35 PhysxUtilLib::sweep_capsule_capsule 0 1 1447 360
/**
 * Capsule-vs-capsule sweep test.  Sweeps a capsule against a capsule, returns
 * true if capsule hit the other capsule.  Also returns contact information.
 *
 * \param [in] lss0 \param [in] lss1 \param [in] dir Unit-length sweep
 * direction \param [in] length Length of sweep \param [out] ip Impact point
 * \param [out] normal Normal at impact point
 */
162
bool PhysxUtilLib::sweep_capsule_capsule(PhysxCapsule const &lss0, PhysxCapsule const &lss1, LVector3f const &dir, float length, LPoint3f &ip, LVector3f &normal);

2942 20 sweep_sphere_capsule 0 4 3118 34 PhysxUtilLib::sweep_sphere_capsule 0 1 1448 352
/**
 * Sphere-vs-capsule sweep test.  Sweeps a sphere against a capsule, returns
 * true if sphere hit the capsule.  Also returns contact information.
 *
 * \param [in] sphere \param [in] lss \param [in] dir Unit-length sweep
 * direction \param [in] length Length of sweep \param [out] ip Impact point
 * \param [out] normal Normal at impact point
 */
161
bool PhysxUtilLib::sweep_sphere_capsule(PhysxSphere const &sphere, PhysxCapsule const &lss, LVector3f const &dir, float length, LPoint3f &ip, LVector3f &normal);

2943 13 sweep_box_box 0 4 3118 27 PhysxUtilLib::sweep_box_box 0 1 1449 336
/**
 * Box-vs-box sweep test.  Sweeps a box against a box, returns true if box hit
 * the other box.  Also returns contact information.
 *
 * \param [in] box0 \param [in] box1 \param [in] dir Unit-length sweep
 * direction \param [in] length Length of sweep \param [out] ip Impact point
 * \param [out] normal Normal at impact point
 */
146
bool PhysxUtilLib::sweep_box_box(PhysxBox const &box0, PhysxBox const &box1, LVector3f const &dir, float length, LPoint3f &ip, LVector3f &normal);

2944 18 point_obb_sqr_dist 0 4 3118 32 PhysxUtilLib::point_obb_sqr_dist 0 1 1450 284
/**
 * Point-vs-OBB distance computation.  Returns distance between a point and an
 * OBB.
 *
 * \param [in] point The point \param [in] center OBB center \param [in]
 * extents OBB extents \param [in] rot OBB rotation \param [out] params
 * Closest point on the box, in box space
 */
152
float PhysxUtilLib::point_obb_sqr_dist(LPoint3f const &point, LPoint3f const &center, LVector3f const &extents, LMatrix3f const &rot, LPoint3f &params);

2945 14 PhysxWheelDesc 0 4 3119 30 PhysxWheelDesc::PhysxWheelDesc 0 2 1451 1452 10
/**
 *
 */
117
inline PhysxWheelDesc::PhysxWheelDesc(void);
inline PhysxWheelDesc::PhysxWheelDesc(PhysxWheelDesc const &) = default;

2946 14 set_to_default 0 4 3119 30 PhysxWheelDesc::set_to_default 0 1 1453 49
/**
 * (re)sets the structure to the default.
 */
49
inline void PhysxWheelDesc::set_to_default(void);

2947 8 is_valid 0 4 3119 24 PhysxWheelDesc::is_valid 0 1 1454 51
/**
 * Returns true if the descriptor is valid.
 */
49
inline bool PhysxWheelDesc::is_valid(void) const;

2948 19 PhysxWheelShapeDesc 0 4 3120 40 PhysxWheelShapeDesc::PhysxWheelShapeDesc 0 1 1455 10
/**
 *
 */
54
inline PhysxWheelShapeDesc::PhysxWheelShapeDesc(void);

2949 10 set_radius 0 4 3120 31 PhysxWheelShapeDesc::set_radius 0 1 1456 46
/**
 * Radius of shape.  Must be positive.
 */
51
void PhysxWheelShapeDesc::set_radius(float radius);

2950 21 set_suspension_travel 0 4 3120 42 PhysxWheelShapeDesc::set_suspension_travel 0 1 1457 82
/**
 * Set the maximum extension distance of suspension along shape's -Y axis.
 */
72
void PhysxWheelShapeDesc::set_suspension_travel(float suspensionTravel);

2951 22 set_inverse_wheel_mass 0 4 3120 43 PhysxWheelShapeDesc::set_inverse_wheel_mass 0 1 1458 45
/**
 * Set the inverse mass of the wheel.
 */
73
void PhysxWheelShapeDesc::set_inverse_wheel_mass(float inverseWheelMass);

2952 16 set_motor_torque 0 4 3120 37 PhysxWheelShapeDesc::set_motor_torque 0 1 1459 55
/**
 * Set the sum engine torque on the wheel axle.
 */
62
void PhysxWheelShapeDesc::set_motor_torque(float motorTorque);

2953 16 set_brake_torque 0 4 3120 37 PhysxWheelShapeDesc::set_brake_torque 0 1 1460 56
/**
 * Set the amount of torque applied for braking.
 */
62
void PhysxWheelShapeDesc::set_brake_torque(float brakeTorque);

2954 15 set_steer_angle 0 4 3120 36 PhysxWheelShapeDesc::set_steer_angle 0 1 1461 102
/**
 * Set the steering angle, around shape Y axis.  The steering angle is
 * measured in degrees.
 */
60
void PhysxWheelShapeDesc::set_steer_angle(float steerAngle);

2955 14 set_wheel_flag 0 4 3120 35 PhysxWheelShapeDesc::set_wheel_flag 0 1 1462 57
/**
 * Turn the specified wheel shape flag on or off.
 */
91
void PhysxWheelShapeDesc::set_wheel_flag(PhysxEnums::PhysxWheelShapeFlag flag, bool value);

2956 14 set_suspension 0 4 3120 35 PhysxWheelShapeDesc::set_suspension 0 1 1463 66
/**
 * Set the data intended for car wheel suspension effects.
 */
72
void PhysxWheelShapeDesc::set_suspension(PhysxSpringDesc const &spring);

2957 10 get_radius 0 4 3120 31 PhysxWheelShapeDesc::get_radius 0 1 1464 27
/**
 * Radius of shape.
 */
50
float PhysxWheelShapeDesc::get_radius(void) const;

2958 21 get_suspension_travel 0 4 3120 42 PhysxWheelShapeDesc::get_suspension_travel 0 1 1465 10
/**
 *
 */
61
float PhysxWheelShapeDesc::get_suspension_travel(void) const;

2959 22 get_inverse_wheel_mass 0 4 3120 43 PhysxWheelShapeDesc::get_inverse_wheel_mass 0 1 1466 10
/**
 *
 */
62
float PhysxWheelShapeDesc::get_inverse_wheel_mass(void) const;

2960 16 get_motor_torque 0 4 3120 37 PhysxWheelShapeDesc::get_motor_torque 0 1 1467 10
/**
 *
 */
56
float PhysxWheelShapeDesc::get_motor_torque(void) const;

2961 16 get_brake_torque 0 4 3120 37 PhysxWheelShapeDesc::get_brake_torque 0 1 1468 10
/**
 *
 */
56
float PhysxWheelShapeDesc::get_brake_torque(void) const;

2962 15 get_steer_angle 0 4 3120 36 PhysxWheelShapeDesc::get_steer_angle 0 1 1469 10
/**
 *
 */
55
float PhysxWheelShapeDesc::get_steer_angle(void) const;

2963 14 get_wheel_flag 0 4 3120 35 PhysxWheelShapeDesc::get_wheel_flag 0 1 1470 50
/**
 * Returns the specified wheel shape flag.
 */
85
bool PhysxWheelShapeDesc::get_wheel_flag(PhysxEnums::PhysxWheelShapeFlag flag) const;

2964 14 get_suspension 0 4 3120 35 PhysxWheelShapeDesc::get_suspension 0 1 1471 10
/**
 *
 */
64
PhysxSpringDesc PhysxWheelShapeDesc::get_suspension(void) const;

1471
1 0 0 7 32 3121 1473 0 0 0 
2 0 0 7 32 3121 1473 0 0 1 6 param0 0 3122  
3 0 0 4 36 3129 0 0 10 /**
 *
 */ 3 4 this 3 3124  3 key 1 3125  5 value 1 3126  
4 0 0 6 37 3126 0 0 10 /**
 *
 */ 2 4 this 3 3130  3 key 1 3125  
5 0 0 6 38 3132 0 0 10 /**
 *
 */ 2 4 this 3 3130  3 key 1 3125  
6 0 0 4 39 3129 0 0 10 /**
 *
 */ 2 4 this 3 3124  3 key 1 3125  
7 0 0 6 40 3132 0 0 10 /**
 *
 */ 1 4 this 3 3130  
8 0 0 4 41 3129 0 0 0 1 4 this 3 3130  
9 0 0 4 41 3129 0 0 0 3 4 this 3 3130  3 out 1 3133  12 indent_level 1 3135  
10 0 0 7 42 3137 0 0 0 0 
11 0 0 7 48 3138 1486 0 10 /**
 *
 */ 0 
12 0 0 6 50 3132 0 0 90 /**
 * Saves the body information of a dynamic actor to the passed body
 * descriptor.
 */ 2 4 this 3 3139  8 bodyDesc 1 3141  
13 0 0 4 51 3129 0 0 65 /**
 * Saves the state of the actor to the passed descriptor.
 */ 2 4 this 3 3139  9 actorDesc 1 3142  
14 0 0 4 52 3129 0 0 139 /**
 * Sets a name string for the object that can be retrieved with get_name().
 * This is for debugging and is not used by the engine.
 */ 2 4 this 3 3138  4 name 1 3125  
15 0 0 4 53 3129 0 0 118 /**
 * Method for setting a dynamic actor's position in the world.  Please see
 * set_global_mat for some caveats.
 */ 2 4 this 3 3138  3 pos 1 3143  
16 0 0 4 54 3129 0 0 1191 /**
 * Method for setting a dynamic actor's transform matrix in the world.
 *
 * This method instantaneously changes the actor space to world space
 * transformation.
 *
 * One should exercise restraint in making use of these methods.
 *
 * Static actors should not be moved at all.  There are various internal data
 * structures for static actors which may need to be recomputed when one
 * moves.  Also, moving static actors will not interact correctly with dynamic
 * actors or joints.  If you would like to directly control an actor's
 * position and would like to have it correctly interact with dynamic bodies
 * and joints, you should create a dynamic body with the BF_kinematic flag,
 * and then use the move_global_*() commands to move it along a path!
 *
 * When briefly moving dynamic actors, one should not: - Move actors into
 * other actors, thus causing interpenetration (an invalid physical state). -
 * Move an actor that is connected by a joint to another away from the other
 * (thus causing joint error). - When moving jointed actors the joints' cached
 * transform information is destroyed and recreated next frame; thus this call
 * is expensive for jointed actors.
 */ 2 4 this 3 3138  3 mat 1 3146  
17 0 0 4 55 3129 0 0 121 /**
 * Method for setting a dynamic actor's orientation in the world.  Please see
 * set_global_mat for some caveats.
 */ 4 4 this 3 3138  1 h 1 3149  1 p 1 3149  1 r 1 3149  
18 0 0 4 56 3129 0 0 52 /**
 * Raise or lower individual BodyFlag flags.
 */ 3 4 this 3 3138  4 flag 1 2968  5 value 1 3132  
19 0 0 4 57 3129 0 0 53 /**
 * Raise or lower individual ActorFlag flags.
 */ 3 4 this 3 3138  4 flag 1 2967  5 value 1 3132  
20 0 0 4 58 3129 0 0 478 /**
 * Sets the actor's contact report flags.
 *
 * These flags are used to determine the kind of report that is generated for
 * interactions with other actors.
 *
 * Please note: If the actor is part of an interacting pair for which the
 * contact report generation is controlled already through any other mechanism
 * (for example by use of PhysxScene::set_actor_pair_flags) then the union of
 * all the specified contact report flags will be used to generate the report.
 */ 3 4 this 3 3138  4 flag 1 2971  5 value 1 3132  
21 0 0 4 59 3129 0 0 84 /**
 * Sets the force threshold for contact reports.  The actor must be dynamic.
 */ 2 4 this 3 3138  9 threshold 1 3149  
22 0 0 4 60 3129 0 0 406 /**
 * Assigns the actor to a user defined group of actors.  The actor group must
 * be an integer in between 0 and 0x7fff (32767).
 *
 * This is similar to NxShape groups, except those are only five bits and
 * serve a different purpose.
 *
 * The PhysxScene::set_actor_group_pair_flags() lets you set certain behaviors
 * for pairs of actor groups.
 *
 * By default every actor is created in group 0.
 */ 2 4 this 3 3138  5 group 1 3150  
23 0 0 4 61 3129 0 0 455 /**
 * Assigns dynamic actors a dominance group identifier.  Dominance groups are
 * integere in the range from 0 to 31.
 *
 * This is similar to shape groups, except those serve a different purpose.
 *
 * The PhysxScene::set_dominance_group_pair() lets you set certain behaviors
 * for pairs of dominance groups.
 *
 * By default every actor is created in group 0. Static actors must stay in
 * group 0; thus you can only call this on dynamic actors.
 */ 2 4 this 3 3138  5 group 1 3150  
24 0 0 4 62 3129 0 0 96 /**
 * Sets the collision group for all shapes of this actor.  See
 * PhysxShape.setGroup().
 */ 2 4 this 3 3138  5 group 1 3150  
25 0 0 6 63 3125 0 0 37 /**
 * Retrieves the name string.
 */ 1 4 this 3 3139  
26 0 0 7 64 3151 0 0 53 /**
 * Retrieves the actors world space position.
 */ 1 4 this 3 3139  
27 0 0 7 65 3152 0 0 54 /**
 * Retrieves the actors world space transform.
 */ 1 4 this 3 3139  
28 0 0 7 66 3154 0 0 56 /**
 * Retrieves the actors world space orientation.
 */ 1 4 this 3 3139  
29 0 0 6 67 3132 0 0 46 /**
 * Return the specified BodyFlag flag.
 */ 2 4 this 3 3139  4 flag 1 2968  
30 0 0 6 68 3132 0 0 47 /**
 * Return the specified ActorFlag flag.
 */ 2 4 this 3 3139  4 flag 1 2967  
31 0 0 6 69 3150 0 0 63 /**
 * Retrieves the actor group this actor is assigned to.
 */ 1 4 this 3 3139  
32 0 0 6 70 3150 0 0 55 /**
 * Retrieves the dominance group of this actor.
 */ 1 4 this 3 3139  
33 0 0 6 71 3132 0 0 48 /**
 * Returns true if the actor is dynamic.
 */ 1 4 this 3 3139  
34 0 0 6 72 3149 0 0 121 /**
 * Computes the total kinetic (rotational and translational) energy of the
 * object.  The actor must be dynamic.
 */ 1 4 this 3 3139  
35 0 0 6 73 3132 0 0 1143 /**
 * Recomputes a dynamic actor's mass properties from its shapes.
 *
 * Given a constant density or total mass, the actors mass properties can be
 * recomputed using the shapes attached to the actor.  If the actor has no
 * shapes, then only the totalMass parameter can be used.  If all shapes in
 * the actor are trigger shapes (non-physical), the call will fail.
 *
 * The mass of each shape is either the shape's local density (as specified in
 * the PhysxShapeDesc; default 1.0) multiplied by the shape's volume or a
 * directly specified shape mass.
 *
 * The inertia tensor, mass frame and center of mass will always be
 * recomputed.  If there are no shapes in the actor, the mass will be
 * totalMass, and the mass frame will be set to the center of the actor.
 *
 * If you supply a non-zero total mass, the actor's mass and inertia will
 * first be computed as above and then scaled to fit this total mass.
 *
 * If you supply a non-zero density, the actor's mass and inertia will first
 * be computed as above and then scaled by this factor.
 *
 * Either totalMass or density must be non-zero.
 *
 * The actor must be dynamic.
 */ 3 4 this 3 3138  7 density 1 3149  9 totalMass 1 3149  
36 0 0 7 74 3155 2028 0 59 /**
 * Retrieves the scene which this actor belongs to.
 */ 1 4 this 3 3139  
37 0 0 4 75 3129 0 0 287 /**
 * Attaches a node path to this actor.  The node path's transform will be
 * updated automatically if the actor's transform changes (and only then).
 *
 * Note: any non-uniform scale or shear set on the NodePath's transform will
 * be overwritten at the time of the first update.
 */ 2 4 this 3 3138  2 np 1 3156  
38 0 0 4 76 3129 0 0 150 /**
 * Detaches a previously assigned NodePath from this actor.  The NodePath's
 * transform will no longer be updated from the actor's transform.
 */ 1 4 this 3 3138  
39 0 0 7 77 3159 0 0 139 /**
 * Retrieves a previously attached NodePath.  An empty NodePath will be
 * returned if no NodePath has been attached to this actor.
 */ 1 4 this 3 3139  
40 0 0 6 78 3150 0 0 62 /**
 * Returns the number of shapes assigned to the actor.
 */ 1 4 this 3 3139  
41 0 0 7 79 3161 1661 0 292 /**
 * Creates a new shape and adds it to the list of shapes of this actor.
 *
 * Mass properties of dynamic actors will not automatically be recomputed to
 * reflect the new mass distribution implied by the shape.  Follow this call
 * with a call to update_mass_from_shapes() to do that.
 */ 2 4 this 3 3138  4 desc 1 3160  
42 0 0 7 80 3161 1661 0 146 /**
 * Retrieves an individual shape from the actor's array of shapes.  Index must
 * be in the range from zero to (number-of-shapes minus 1).
 */ 2 4 this 3 3139  3 idx 1 3150  
43 0 0 7 81 3161 1661 0 205 /**
 * Retrieves an individual shape from the actor's array of shapes.  The first
 * shape for which the shape's name matches the specified name is returned, or
 * NULL if no shape has a matching name.
 */ 2 4 this 3 3139  4 name 1 3125  
44 0 0 4 83 3129 0 0 329 /**
 * Applies a force (or impulse) defined in the global coordinate frame to the
 * actor.
 *
 * This will not induce a torque.
 *
 * Mode determines if the torque is to be conventional or impulsive.
 *
 * The actor must be dynamic.  This call wakes the actor if it is sleeping and
 * the wakeup parameter is true (default).
 */ 4 4 this 3 3138  5 force 1 3162  4 mode 1 2980  6 wakeup 1 3132  
45 0 0 4 84 3129 0 0 623 /**
 * Applies a force (or impulse) defined in the global coordinate frame, acting
 * at a particular point in global coordinates, to the actor.
 *
 * Note that if the force does not act along the center of mass of the actor,
 * this will also add the corresponding torque.  Because forces are reset at
 * the end of every timestep, you can maintain a total external force on an
 * object by calling this once every frame.
 *
 * Mode determines if the torque is to be conventional or impulsive.
 *
 * The actor must be dynamic.  This call wakes the actor if it is sleeping and
 * the wakeup parameter is true (default).
 */ 5 4 this 3 3138  5 force 1 3162  3 pos 1 3143  4 mode 1 2980  6 wakeup 1 3132  
46 0 0 4 85 3129 0 0 622 /**
 * Applies a force (or impulse) defined in the global coordinate frame, acting
 * at a particular point in local coordinates, to the actor.
 *
 * Note that if the force does not act along the center of mass of the actor,
 * this will also add the corresponding torque.  Because forces are reset at
 * the end of every timestep, you can maintain a total external force on an
 * object by calling this once every frame.
 *
 * Mode determines if the torque is to be conventional or impulsive.
 *
 * The actor must be dynamic.  This call wakes the actor if it is sleeping and
 * the wakeup parameter is true (default).
 */ 5 4 this 3 3138  5 force 1 3162  3 pos 1 3143  4 mode 1 2980  6 wakeup 1 3132  
47 0 0 4 86 3129 0 0 291 /**
 * Applies an impulsive torque defined in the global coordinate frame to the
 * actor.
 *
 * Mode determines if the torque is to be conventional or impulsive.
 *
 * The actor must be dynamic.  This call wakes the actor if it is sleeping and
 * the wakeup parameter is true (default).
 */ 4 4 this 3 3138  6 torque 1 3162  4 mode 1 2980  6 wakeup 1 3132  
48 0 0 4 87 3129 0 0 329 /**
 * Applies a force (or impulse) defined in the actor local coordinate frame to
 * the actor.  This will not induce a torque.
 *
 * Mode determines if the torque is to be conventional or impulsive.
 *
 * The actor must be dynamic.  This call wakes the actor if it is sleeping and
 * the wakeup parameter is true (default).
 */ 4 4 this 3 3138  5 force 1 3162  4 mode 1 2980  6 wakeup 1 3132  
49 0 0 4 88 3129 0 0 628 /**
 * Applies a force (or impulse) defined in the actor local coordinate frame,
 * acting at a particular point in global coordinates, to the actor.
 *
 * Note that if the force does not act along the center of mass of the actor,
 * this will also add the corresponding torque.  Because forces are reset at
 * the end of every timestep, you can maintain a total external force on an
 * object by calling this once every frame.
 *
 * Mode determines if the torque is to be conventional or impulsive.
 *
 * The actor must be dynamic.  This call wakes the actor if it is sleeping and
 * the wakeup parameter is true (default).
 */ 5 4 this 3 3138  5 force 1 3162  3 pos 1 3143  4 mode 1 2980  6 wakeup 1 3132  
50 0 0 4 89 3129 0 0 627 /**
 * Applies a force (or impulse) defined in the actor local coordinate frame,
 * acting at a particular point in local coordinates, to the actor.
 *
 * Note that if the force does not act along the center of mass of the actor,
 * this will also add the corresponding torque.  Because forces are reset at
 * the end of every timestep, you can maintain a total external force on an
 * object by calling this once every frame.
 *
 * Mode determines if the torque is to be conventional or impulsive.
 *
 * The actor must be dynamic.  This call wakes the actor if it is sleeping and
 * the wakeup parameter is true (default).
 */ 5 4 this 3 3138  5 force 1 3162  3 pos 1 3143  4 mode 1 2980  6 wakeup 1 3132  
51 0 0 4 90 3129 0 0 296 /**
 * Applies an impulsive torque defined in the actor local coordinate frame to
 * the actor.
 *
 * Mode determines if the torque is to be conventional or impulsive.
 *
 * The actor must be dynamic.  This call wakes the actor if it is sleeping and
 * the wakeup parameter is true (default).
 */ 4 4 this 3 3138  6 torque 1 3162  4 mode 1 2980  6 wakeup 1 3132  
52 0 0 4 91 3129 0 0 44 /**
 * Sets the mass of a dynamic actor.
 */ 2 4 this 3 3138  4 mass 1 3149  
53 0 0 4 92 3129 0 0 71 /**
 * Sets the matrix of the center of mass relative to the actor.
 */ 2 4 this 3 3138  3 mat 1 3146  
54 0 0 4 93 3129 0 0 73 /**
 * Sets the position of the center of mass relative to the actor.
 */ 2 4 this 3 3138  3 pos 1 3143  
55 0 0 4 94 3129 0 0 76 /**
 * Sets the orientation of the center of mass relative to the actor.
 */ 2 4 this 3 3138  3 mat 1 3165  
56 0 0 4 95 3129 0 0 73 /**
 * Sets the matrix of the center of mass relative to world space.
 */ 2 4 this 3 3138  3 mat 1 3146  
57 0 0 4 96 3129 0 0 75 /**
 * Sets the position of the center of mass relative to world space.
 */ 2 4 this 3 3138  3 pos 1 3143  
58 0 0 4 97 3129 0 0 78 /**
 * Sets the orientation of the center of mass relative to world space.
 */ 2 4 this 3 3138  3 mat 1 3165  
59 0 0 4 98 3129 0 0 74 /**
 * Moves the actor by setting the transform of the center of mass.
 */ 2 4 this 3 3138  3 mat 1 3146  
60 0 0 4 99 3129 0 0 73 /**
 * Moves the actor by setting the position of the center of mass.
 */ 2 4 this 3 3138  3 pos 1 3143  
61 0 0 4 100 3129 0 0 76 /**
 * Moves the actor by setting the orientation of the center of mass.
 */ 2 4 this 3 3138  3 mat 1 3165  
62 0 0 4 101 3129 0 0 93 /**
 * Sets the inertia tensor, using a parameter specified in mass space
 * coordinates.
 */ 2 4 this 3 3138  1 m 1 3162  
63 0 0 6 102 3149 0 0 41 /**
 * Returns the mass of the actor.
 */ 1 4 this 3 3139  
64 0 0 7 103 3152 0 0 63 /**
 * Returns the center of mass transform in world space.
 */ 1 4 this 3 3139  
65 0 0 7 104 3151 0 0 62 /**
 * Returns the center of mass position in world space.
 */ 1 4 this 3 3139  
66 0 0 7 105 3168 0 0 65 /**
 * Returns the center of mass orientation in world space.
 */ 1 4 this 3 3139  
67 0 0 7 106 3152 0 0 70 /**
 * Returns the center of mass transform relative to the actor.
 */ 1 4 this 3 3139  
68 0 0 7 107 3151 0 0 69 /**
 * Returns the center of mass position relative to the actor.
 */ 1 4 this 3 3139  
69 0 0 7 108 3168 0 0 72 /**
 * Returns the center of mass orientation relative to the actor.
 */ 1 4 this 3 3139  
70 0 0 7 109 3169 0 0 101 /**
 * Returns the diagonal inertia tensor of the actor relative to the mass
 * coordinate frame.
 */ 1 4 this 3 3139  
71 0 0 7 110 3168 0 0 93 /**
 * Returns the inertia tensor of the actor relative to the world coordinate
 * frame.
 */ 1 4 this 3 3139  
72 0 0 7 111 3168 0 0 108 /**
 * Returns the inverse of the inertia tensor of the actor relative to the
 * world coordinate frame.
 */ 1 4 this 3 3139  
73 0 0 4 112 3129 0 0 167 /**
 * Sets the linear damping coefficient.  Zero represents no damping.  The
 * damping coefficient must be nonnegative.  The actor must be dynamic.
 * Default: 0
 */ 2 4 this 3 3138  7 linDamp 1 3149  
74 0 0 4 113 3129 0 0 180 /**
 * Sets the angular damping coefficient.  Zero represents no damping.  The
 * angular damping coefficient must be nonnegative.  The actor must be
 * dynamic.  Default: 0.05
 */ 2 4 this 3 3138  7 angDamp 1 3149  
75 0 0 6 114 3149 0 0 80 /**
 * Retrieves the linear damping coefficient.  The actor must be dynamic.
 */ 1 4 this 3 3139  
76 0 0 6 115 3149 0 0 79 /**
 * Returns the angular damping coefficient.  The actor must be dynamic.
 */ 1 4 this 3 3139  
77 0 0 4 116 3129 0 0 313 /**
 * Sets the linear velocity of the actor.
 *
 * Note that if you continuously set the velocity of an actor yourself, forces
 * such as gravity or friction will not be able to manifest themselves,
 * because forces directly influence only the velocity/momentum of an actor.
 *
 * The actor must be dynamic.
 */ 2 4 this 3 3138  6 linVel 1 3162  
78 0 0 4 117 3129 0 0 296 /**
 * Sets the angular velocity of the actor.
 *
 * Note that if you continuously set the angular velocity of an actor
 * yourself, forces such as friction will not be able to rotate the actor,
 * because forces directly influence only the velocity/momentum.
 *
 * The actor must be dynamic.
 */ 2 4 this 3 3138  6 angVel 1 3162  
79 0 0 4 118 3129 0 0 863 /**
 * Lets you set the maximum angular velocity permitted for this actor.
 *
 * Because for various internal computations, very quickly rotating actors
 * introduce error into the simulation, which leads to undesired results.
 *
 * With PhysxManager::set_parameter(PP_max_angular_velocity) you can set the
 * default maximum velocity for actors created after the call.  Bodies' high
 * angular velocities are clamped to this value.
 *
 * However, because some actors, such as car wheels, should be able to rotate
 * quickly, you can override the default setting on a per-actor basis with the
 * below call.  Note that objects such as wheels which are approximated with
 * spherical or other smooth collision primitives can be simulated with
 * stability at a much higher angular velocity than, say, a box that has
 * corners.
 *
 * The actor must be dynamic.
 */ 2 4 this 3 3138  9 maxAngVel 1 3149  
80 0 0 7 119 3169 0 0 79 /**
 * Returns the linear velocity of an actor.  The actor must be dynamic.
 */ 1 4 this 3 3139  
81 0 0 7 120 3169 0 0 81 /**
 * Returns the angular velocity of the actor.  The actor must be dynamic.
 */ 1 4 this 3 3139  
82 0 0 6 121 3149 0 0 73 /**
 * Returns the maximum angular velocity permitted for this actor.
 */ 1 4 this 3 3139  
83 0 0 7 122 3169 0 0 159 /**
 * Computes the velocity of a point given in world coordinates if it were
 * attached to the actor and moving with it.
 *
 * The actor must be dynamic.
 */ 2 4 this 3 3139  5 point 1 3143  
84 0 0 7 123 3169 0 0 167 /**
 * Computes the velocity of a point given in body local coordinates as if it
 * were attached to the actor and moving with it.
 *
 * The actor must be dynamic.
 */ 2 4 this 3 3139  5 point 1 3143  
85 0 0 4 124 3129 0 0 315 /**
 * Sets the linear momentum of the actor.  Note that if you continuously set
 * the linear momentum of an actor yourself, forces such as gravity or
 * friction will not be able to manifest themselves, because forces directly
 * influence only the velocity/momentum of a actor.  The actor must be
 * dynamic.
 */ 2 4 this 3 3138  8 momentum 1 3162  
86 0 0 4 125 3129 0 0 289 /**
 * Sets the angular momentum of the actor.  Note that if you continuously set
 * the angular velocity of an actor yourself, forces such as friction will not
 * be able to rotate the actor, because forces directly influence only the
 * velocity of actor.  The actor must be dynamic.
 */ 2 4 this 3 3138  8 momentum 1 3162  
87 0 0 7 126 3169 0 0 139 /**
 * Retrieves the linear momentum of an actor.  The momentum is equal to the
 * velocity times the mass.  The actor must be dynamic.
 */ 1 4 this 3 3139  
88 0 0 7 127 3169 0 0 182 /**
 * Retrieves the angular momentum of an actor.  The angular momentum is equal
 * to the angular velocity times the global space inertia tensor.  The actor
 * must be dynamic.
 */ 1 4 this 3 3139  
89 0 0 4 128 3129 0 0 299 /**
 * Sets the linear velocity below which an actor may go to sleep.  Actors
 * whose linear velocity is above this threshold will not be put to sleep.
 *
 * Setting the sleep angular/linear velocity only makes sense when the
 * BF_energy_sleep_test is not set.
 *
 * The actor must be dynamic.
 */ 2 4 this 3 3138  9 threshold 1 3149  
90 0 0 4 129 3129 0 0 301 /**
 * Sets the angular velocity below which an actor may go to sleep.  Actors
 * whose angular velocity is above this threshold will not be put to sleep.
 *
 * Setting the sleep angular/linear velocity only makes sense when the
 * BF_energy_sleep_test is not set.
 *
 * The actor must be dynamic.
 */ 2 4 this 3 3138  9 threshold 1 3149  
91 0 0 4 130 3129 0 0 409 /**
 * Sets the energy threshold below which an actor may go to sleep.  Actors
 * whose kinematic energy is above this threshold will not be put to sleep.
 *
 * Setting the sleep energy threshold only makes sense when the
 * BF_energy_sleep_test is set.  There are also other types of sleeping that
 * uses the linear and angular velocities directly instead of the energy.
 *
 * The actor must be dynamic.
 */ 2 4 this 3 3138  9 threshold 1 3149  
92 0 0 6 131 3149 0 0 189 /**
 * Returns the linear velocity below which an actor may go to sleep.  Actors
 * whose linear velocity is above this threshold will not be put to sleep.
 * The actor must be dynamic.
 */ 1 4 this 3 3139  
93 0 0 6 132 3149 0 0 191 /**
 * Returns the angular velocity below which an actor may go to sleep.  Actors
 * whose angular velocity is above this threshold will not be put to sleep.
 * The actor must be dynamic.
 */ 1 4 this 3 3139  
94 0 0 6 133 3149 0 0 172 /**
 * Returns the energy below which an actor may go to sleep.  Actors whose
 * energy is above this threshold will not be put to sleep.  The actor must be
 * dynamic.
 */ 1 4 this 3 3139  
95 0 0 6 134 3132 0 0 440 /**
 * Returns true if this body is sleeping.
 *
 * When an actor does not move for a period of time, it is no longer simulated
 * in order to save time.  This state is called sleeping.  However, because
 * the object automatically wakes up when it is either touched by an awake
 * object, or one of its properties is changed by the user, the entire sleep
 * mechanism should be transparent to the user.
 *
 * The actor must be dynamic.
 */ 1 4 this 3 3139  
96 0 0 4 135 3129 0 0 272 /**
 * Wakes up the actor if it is sleeping.
 *
 * The wakeCounterValue determines how long until the body is put to sleep, a
 * value of zero means that the body is sleeping.  wake_up(0) is equivalent to
 * PhysxActor::put_to_sleep().
 *
 * The actor must be dynamic.
 */ 2 4 this 3 3138  16 wakeCounterValue 1 3149  
97 0 0 4 136 3129 0 0 299 /**
 * Forces the actor to sleep.
 *
 * The actor will stay asleep until the next call to simulate, and will not
 * wake up until then even when otherwise it would (for example a force is
 * applied to it). It can however wake up during the next do_physics call.
 *
 * The actor must be dynamic.
 */ 1 4 this 3 3138  
98 0 0 4 137 3129 0 0 216 /**
 * The move_global_* calls serve to move kinematically controlled dynamic
 * actors through the game world.
 *
 * See move_global_mat() for more information.
 *
 * This call wakes the actor if it is sleeping.
 */ 2 4 this 3 3138  3 pos 1 3143  
99 0 0 4 138 3129 0 0 881 /**
 * The move_global_* calls serve to move kinematically controlled dynamic
 * actors through the game world.
 *
 * You set a dynamic actor to be kinematic using the BF_KINEMATIC body flag,
 * used either in the PhysBodyDesc or with set_body_flag().
 *
 * The move command will result in a velocity that, when successfully carried
 * out (i.e.  the motion is not blocked due to joints or collisions) inside
 * run*(), will move the body into the desired pose.  After the move is
 * carried out during a single time step, the velocity is returned to zero.
 * Thus, you must continuously call this in every time step for kinematic
 * actors so that they move along a path.
 *
 * These functions simply store the move destination until run*() is called,
 * so consecutive calls will simply overwrite the stored target variable.
 *
 * This call wakes the actor if it is sleeping.
 */ 2 4 this 3 3138  3 mat 1 3146  
100 0 0 4 139 3129 0 0 216 /**
 * The move_global_* calls serve to move kinematically controlled dynamic
 * actors through the game world.
 *
 * See move_global_mat() for more information.
 *
 * This call wakes the actor if it is sleeping.
 */ 4 4 this 3 3138  1 h 1 3149  1 p 1 3149  1 r 1 3149  
101 0 0 4 140 3129 0 0 10 /**
 *
 */ 1 4 this 3 3139  
102 0 0 4 140 3129 0 0 10 /**
 *
 */ 3 4 this 3 3139  3 out 1 3133  12 indent_level 1 3135  
103 0 0 4 141 3129 0 0 10 /**
 *
 */ 1 4 this 3 3138  
104 0 0 7 142 3137 0 0 0 0 
105 0 0 6 44 3124 0 0 0 1 4 this 3 3138  
106 0 0 7 45 3138 1486 0 0 1 4 this 3 3124  
107 0 0 6 46 3121 0 0 0 1 4 this 3 3138  
108 0 0 7 47 3138 1486 0 0 1 4 this 3 3121  
109 0 0 4 148 3129 0 0 10 /**
 *
 */ 1 4 this 3 3170  
110 0 0 7 149 3138 1486 0 72 /**
 * Retrieves the actor which this controller is associated with.
 */ 1 4 this 3 3171  
111 0 0 4 150 3129 0 0 140 /**
 * Sets the position of the controller is global space.  This can be used for
 * initial placement or for teleporting the character.
 */ 2 4 this 3 3170  3 pos 1 3143  
112 0 0 4 151 3129 0 0 279 /**
 * Sharpness is used to smooth motion with a feedback filter, having a value
 * between 0 (so smooth it doesn't move) and 1 (no smoothing = unfiltered
 * motion). Sharpness can ease the motion curve when the auto-step feature is
 * used with boxes.  Default value is 1.0.
 */ 2 4 this 3 3170  9 sharpness 1 3149  
113 0 0 4 152 3129 0 0 67 /**
 * Enable/Disable collisions for this controller and actor.
 */ 2 4 this 3 3170  6 enable 1 3132  
114 0 0 4 153 3129 0 0 288 /**
 * Sets the the minimum travelled distance to consider when moving the
 * controller.  If travelled distance is smaller, the character doesn't move.
 * This is used to stop the recursive motion algorithm when remaining distance
 * to travel is small.  The default value is 0.0001.
 */ 2 4 this 3 3170  8 min_dist 1 3149  
115 0 0 4 154 3129 0 0 58 /**
 * Sets the step height/offset for the controller.
 */ 2 4 this 3 3170  6 offset 1 3149  
116 0 0 7 155 3151 0 0 66 /**
 * Retruns the position of the controller is global space.
 */ 1 4 this 3 3171  
117 0 0 6 156 3149 0 0 124 /**
 * Returns the sharpness used to ease the motion curve when the auto-step
 * feature is used.  Default value is 1.0.
 */ 1 4 this 3 3171  
118 0 0 4 157 3129 0 0 67 /**
 * Sets the linear speed of the controller in global space.
 */ 2 4 this 3 3170  5 speed 1 3162  
119 0 0 4 158 3129 0 0 72 /**
 * Sets the linear speed of the controller in local coordinates.
 */ 2 4 this 3 3170  5 speed 1 3162  
120 0 0 4 159 3129 0 0 169 /**
 * Sets the angular velocity (degrees per second) of the controller.  The
 * angular velocity is used to compute the new heading when updating the
 * controller.
 */ 2 4 this 3 3170  5 omega 1 3149  
121 0 0 4 160 3129 0 0 191 /**
 * Sets the heading of the controller is global space.  Note: only heading is
 * supported.  Pitch and roll are constrained by PhysX in order to alyways
 * keep the character upright.
 */ 2 4 this 3 3170  7 heading 1 3149  
122 0 0 6 161 3149 0 0 65 /**
 * Returns the heading of the controller in global space.
 */ 1 4 this 3 3171  
123 0 0 4 162 3129 0 0 233 /**
 * The character controller uses caching in order to speed up collision
 * testing, this caching can not detect when static objects have changed in
 * the scene.  You need to call this method when such changes have been made.
 */ 1 4 this 3 3170  
124 0 0 4 163 3129 0 0 98 /**
 * Enters the jump mode.  The parameter is the intial upward velocity of the
 * character.
 */ 2 4 this 3 3170  2 v0 1 3149  
125 0 0 4 164 3129 0 0 149 /**
 * Leaves the jump mode.  This method is automatically called if a ground
 * collision is detected.  Usually users need not call this method.
 */ 1 4 this 3 3170  
126 0 0 4 165 3129 0 0 10 /**
 *
 */ 1 4 this 3 3171  
127 0 0 4 165 3129 0 0 10 /**
 *
 */ 3 4 this 3 3171  3 out 1 3133  12 indent_level 1 3135  
128 0 0 7 166 3137 0 0 0 0 
129 0 0 6 144 3124 0 0 0 1 4 this 3 3170  
130 0 0 7 145 3170 1602 0 0 1 4 this 3 3124  
131 0 0 6 146 3121 0 0 0 1 4 this 3 3170  
132 0 0 7 147 3170 1602 0 0 1 4 this 3 3121  
133 0 0 7 169 3173 1602 0 10 /**
 *
 */ 0 
134 0 0 4 170 3129 0 0 37 /**
 * Sets controller's extents.
 */ 2 4 this 3 3173  7 extents 1 3162  
135 0 0 7 171 3169 0 0 40 /**
 * Returns controller's extents.
 */ 1 4 this 3 3174  
136 0 0 7 172 3137 0 0 0 0 
137 0 0 4 178 3129 0 0 10 /**
 *
 */ 1 4 this 3 3176  
138 0 0 7 179 3179 0 0 112 /**
 * Returns the owning force field if this is a shape of an include group, else
 * NULL will be returned.
 */ 1 4 this 3 3177  
139 0 0 7 180 3180 1902 0 54 /**
 * Returns the owning force field shape group.
 */ 1 4 this 3 3177  
140 0 0 4 181 3129 0 0 99 /**
 * Sets a name string for this object.  The name can be retrieved again with
 * get_name().
 */ 2 4 this 3 3176  4 name 1 3125  
141 0 0 4 182 3129 0 0 50 /**
 * Sets the force field shape's transform.
 */ 2 4 this 3 3176  3 mat 1 3146  
142 0 0 4 183 3129 0 0 52 /**
 * Sets the force field shape's translation.
 */ 2 4 this 3 3176  3 pos 1 3143  
143 0 0 6 184 3125 0 0 35 /**
 * Returns the name string.
 */ 1 4 this 3 3177  
144 0 0 7 185 3152 0 0 53 /**
 * Returns the force field shape's transform.
 */ 1 4 this 3 3177  
145 0 0 7 186 3151 0 0 55 /**
 * Returns the force field shape's translation.
 */ 1 4 this 3 3177  
146 0 0 4 187 3129 0 0 10 /**
 *
 */ 1 4 this 3 3177  
147 0 0 4 187 3129 0 0 10 /**
 *
 */ 3 4 this 3 3177  3 out 1 3133  12 indent_level 1 3135  
148 0 0 7 188 3137 0 0 0 0 
149 0 0 6 174 3124 0 0 0 1 4 this 3 3176  
150 0 0 7 175 3176 1622 0 0 1 4 this 3 3124  
151 0 0 6 176 3121 0 0 0 1 4 this 3 3176  
152 0 0 7 177 3176 1622 0 0 1 4 this 3 3121  
153 0 0 7 191 3181 1622 0 10 /**
 *
 */ 0 
154 0 0 4 192 3129 0 0 63 /**
 * Saves the state of the shape object to a descriptor.
 */ 2 4 this 3 3182  9 shapeDesc 1 3184  
155 0 0 4 193 3129 0 0 179 /**
 * Sets the box dimensions.
 *
 * The dimensions are the 'radii' of the box, meaning 1/2 extents in x
 * dimension, 1/2 extents in y dimension, 1/2 extents in z dimension.
 */ 2 4 this 3 3181  10 dimensions 1 3162  
156 0 0 7 194 3169 0 0 191 /**
 * Retrieves the dimensions of the box.
 *
 * The dimensions are the 'radii' of the box, meaning 1/2 extents in x
 * dimension, 1/2 extents in y dimension, 1/2 extents in z dimension.
 */ 1 4 this 3 3182  
157 0 0 7 195 3137 0 0 0 0 
158 0 0 4 201 3129 0 0 10 /**
 *
 */ 1 4 this 3 3161  
159 0 0 7 202 3138 1486 0 67 /**
 * Retrieves the actor which this shape is associated with.
 */ 1 4 this 3 3185  
160 0 0 4 203 3129 0 0 160 /**
 * Sets a name string for this object.  The name can be retrieved again with
 * get_name(). This is for debugging and is not used by the physics engine.
 */ 2 4 this 3 3161  4 name 1 3125  
161 0 0 4 204 3129 0 0 0 3 4 this 3 3161  4 flag 1 3187  5 value 1 3132  
162 0 0 4 205 3129 0 0 69 /**
 * Sets the skin width.  The skin width must be non-negative.
 */ 2 4 this 3 3161  9 skinWidth 1 3149  
163 0 0 4 206 3129 0 0 285 /**
 * Sets which collision group this shape is part of.
 *
 * Default group is 0. Maximum possible group is 31. Collision groups are sets
 * of shapes which may or may not be set to collision detect with each other;
 * this can be set using PhysxScene::set_group_collision_flag().
 */ 2 4 this 3 3161  5 group 1 3188  
164 0 0 4 207 3129 0 0 358 /**
 * Set the position of the shape in actor space, i.e.  relative to the actor
 * it is owned by.
 *
 * Calling this method does NOT wake the associated actor up automatically.
 *
 * Calling this method does not automatically update the inertia properties of
 * the owning actor (if applicable); use PhysxActor::update_mass_from_shapes()
 * to do this.
 */ 2 4 this 3 3161  3 pos 1 3143  
165 0 0 4 208 3129 0 0 359 /**
 * Set the transform of the shape in actor space, i.e.  relative to the actor
 * it is owned by.
 *
 * Calling this method does NOT wake the associated actor up automatically.
 *
 * Calling this method does not automatically update the inertia properties of
 * the owning actor (if applicable); use PhysxActor::update_mass_from_shapes()
 * to do this.
 */ 2 4 this 3 3161  3 mat 1 3146  
166 0 0 4 209 3129 0 0 43 /**
 * Assigns a material to the shape.
 */ 2 4 this 3 3161  8 material 1 3189  
167 0 0 4 210 3129 0 0 288 /**
 * Assigns a material index to the shape.
 *
 * The material index can be retrieved by calling
 * PhysxMaterial::get_material_index(). If the material index is invalid, it
 * will still be recorded, but the default material (at index 0) will
 * effectively be used for simulation.
 */ 2 4 this 3 3161  3 idx 1 3188  
168 0 0 4 211 3129 0 0 115 /**
 * Sets 128-bit mask used for collision filtering.  Does NOT wake the
 * associated actor up automatically.
 */ 2 4 this 3 3161  4 mask 1 3191  
169 0 0 4 212 3129 0 0 10 /**
 *
 */ 2 4 this 3 3161  4 skel 1 3193  
170 0 0 6 213 3125 0 0 35 /**
 * Returns the name string.
 */ 1 4 this 3 3185  
171 0 0 6 214 3132 0 0 0 2 4 this 3 3185  4 flag 1 3187  
172 0 0 6 215 3149 0 0 34 /**
 * Returns the skin width.
 */ 1 4 this 3 3185  
173 0 0 6 216 3188 0 0 116 /**
 * Retrieves the collision group set for this shape.  The collision group is
 * an integer between 0 and 31.
 */ 1 4 this 3 3185  
174 0 0 7 217 3151 0 0 108 /**
 * Retrieve the position of the shape in actor space, i.e.  relative to the
 * actor it is owned by.
 */ 1 4 this 3 3185  
175 0 0 7 218 3152 0 0 109 /**
 * Retrieve the transform of the shape in actor space, i.e.  relative to the
 * actor it is owned by.
 */ 1 4 this 3 3185  
176 0 0 6 219 3188 0 0 70 /**
 * Returns the material index currently assigned to the shape.
 */ 1 4 this 3 3185  
177 0 0 7 220 3194 2008 0 58 /**
 * Gets 128-bit mask used for collision filtering.
 */ 1 4 this 3 3185  
178 0 0 7 221 3195 2294 0 59 /**
 * Returns a world space AABB enclosing this shape.
 */ 1 4 this 3 3185  
179 0 0 7 222 3193 0 0 10 /**
 *
 */ 1 4 this 3 3185  
180 0 0 6 223 3132 0 0 71 /**
 * Checks whether the shape overlaps a world-space AABB or not.
 */ 2 4 this 3 3185  12 world_bounds 1 3196  
181 0 0 6 224 3132 0 0 74 /**
 * Checks whether the shape overlaps a world-space capsule or not.
 */ 2 4 this 3 3185  13 world_capsule 1 3198  
182 0 0 6 225 3132 0 0 70 /**
 * Checks whether the shape overlaps a world-space OBB or not.
 */ 2 4 this 3 3185  9 world_box 1 3200  
183 0 0 6 226 3132 0 0 73 /**
 * Checks whether the shape overlaps a world-space sphere or not.
 */ 2 4 this 3 3185  12 world_sphere 1 3202  
184 0 0 7 227 3206 2773 0 10 /**
 *
 */ 4 4 this 3 3185  8 worldRay 1 3204  8 firstHit 1 3132  12 smoothNormal 1 3132  
185 0 0 4 228 3129 0 0 10 /**
 *
 */ 1 4 this 3 3185  
186 0 0 4 228 3129 0 0 10 /**
 *
 */ 3 4 this 3 3185  3 out 1 3133  12 indent_level 1 3135  
187 0 0 7 229 3137 0 0 0 0 
188 0 0 6 197 3124 0 0 0 1 4 this 3 3161  
189 0 0 7 198 3161 1661 0 0 1 4 this 3 3124  
190 0 0 6 199 3121 0 0 0 1 4 this 3 3161  
191 0 0 7 200 3161 1661 0 0 1 4 this 3 3121  
192 0 0 7 232 3207 1661 0 10 /**
 *
 */ 0 
193 0 0 4 233 3129 0 0 63 /**
 * Saves the state of the shape object to a descriptor.
 */ 2 4 this 3 3208  9 shapeDesc 1 3210  
194 0 0 4 234 3129 0 0 179 /**
 * Sets the box dimensions.
 *
 * The dimensions are the 'radii' of the box, meaning 1/2 extents in x
 * dimension, 1/2 extents in y dimension, 1/2 extents in z dimension.
 */ 2 4 this 3 3207  10 dimensions 1 3162  
195 0 0 7 235 3169 0 0 191 /**
 * Retrieves the dimensions of the box.
 *
 * The dimensions are the 'radii' of the box, meaning 1/2 extents in x
 * dimension, 1/2 extents in y dimension, 1/2 extents in z dimension.
 */ 1 4 this 3 3208  
196 0 0 7 236 3137 0 0 0 0 
197 0 0 7 238 3211 1602 0 10 /**
 *
 */ 0 
198 0 0 4 239 3129 0 0 42 /**
 * Resets the controller's radius.
 */ 2 4 this 3 3211  6 radius 1 3149  
199 0 0 4 240 3129 0 0 42 /**
 * Resets the controller's height.
 */ 2 4 this 3 3211  6 height 1 3149  
200 0 0 6 241 3149 0 0 43 /**
 * Returns the controller's radius.
 */ 1 4 this 3 3212  
201 0 0 6 242 3149 0 0 43 /**
 * Returns the controller's height.
 */ 1 4 this 3 3212  
202 0 0 7 243 3137 0 0 0 0 
203 0 0 7 245 3214 1622 0 10 /**
 *
 */ 0 
204 0 0 4 246 3129 0 0 63 /**
 * Saves the state of the shape object to a descriptor.
 */ 2 4 this 3 3215  9 shapeDesc 1 3217  
205 0 0 4 247 3129 0 0 44 /**
 * Alters the radius of the capsule.
 */ 2 4 this 3 3214  6 radius 1 3149  
206 0 0 4 248 3129 0 0 44 /**
 * Alters the height of the capsule.
 */ 2 4 this 3 3214  6 height 1 3149  
207 0 0 6 249 3149 0 0 47 /**
 * Retrieves the radius of the capsule.
 */ 1 4 this 3 3215  
208 0 0 6 250 3149 0 0 47 /**
 * Retrieves the height of the capsule.
 */ 1 4 this 3 3215  
209 0 0 7 251 3137 0 0 0 0 
210 0 0 7 253 3218 1661 0 10 /**
 *
 */ 0 
211 0 0 4 254 3129 0 0 63 /**
 * Saves the state of the shape object to a descriptor.
 */ 2 4 this 3 3219  9 shapeDesc 1 3221  
212 0 0 4 255 3129 0 0 44 /**
 * Alters the radius of the capsule.
 */ 2 4 this 3 3218  6 radius 1 3149  
213 0 0 4 256 3129 0 0 44 /**
 * Alters the height of the capsule.
 */ 2 4 this 3 3218  6 height 1 3149  
214 0 0 6 257 3149 0 0 47 /**
 * Retrieves the radius of the capsule.
 */ 1 4 this 3 3219  
215 0 0 6 258 3149 0 0 47 /**
 * Retrieves the height of the capsule.
 */ 1 4 this 3 3219  
216 0 0 7 259 3137 0 0 0 0 
217 0 0 6 261 3150 0 0 57 /**
 * Returns the reference count for shared meshes.
 */ 1 4 this 3 3222  
218 0 0 4 262 3129 0 0 10 /**
 *
 */ 1 4 this 3 3193  
219 0 0 7 263 3137 0 0 0 0 
220 0 0 7 269 3224 1695 0 10 /**
 *
 */ 0 
221 0 0 7 271 3155 2028 0 57 /**
 * Returns the scene which this cloth belongs to.
 */ 1 4 this 3 3225  
222 0 0 7 272 3227 0 0 10 /**
 *
 */ 1 4 this 3 3225  
223 0 0 7 273 3227 0 0 10 /**
 *
 */ 2 4 this 3 3224  4 name 1 3125  
224 0 0 4 274 3129 0 0 139 /**
 * Sets a name string for the object that can be retrieved with get_name().
 * This is for debugging and is not used by the engine.
 */ 2 4 this 3 3224  4 name 1 3125  
225 0 0 4 275 3129 0 0 106 /**
 * Sets which collision group this cloth is part of.  Collision group must be
 * between 0 and 31.
 */ 2 4 this 3 3224  5 group 1 3150  
226 0 0 4 276 3129 0 0 58 /**
 * Sets 128-bit mask used for collision filtering.
 */ 2 4 this 3 3224  4 mask 1 3191  
227 0 0 4 277 3129 0 0 43 /**
 * Sets the value of a single flag.
 */ 3 4 this 3 3224  4 flag 1 2970  5 value 1 3132  
228 0 0 4 278 3129 0 0 55 /**
 * Sets the cloth thickness (must be positive).
 */ 2 4 this 3 3224  9 thickness 1 3149  
229 0 0 6 279 3125 0 0 37 /**
 * Retrieves the name string.
 */ 1 4 this 3 3225  
230 0 0 6 280 3150 0 0 46 /**
 * Gets the number of cloth particles.
 */ 1 4 this 3 3224  
231 0 0 6 281 3150 0 0 63 /**
 * Retrieves the collision group this cloth is part of.
 */ 1 4 this 3 3225  
232 0 0 7 282 3194 2008 0 69 /**
 * Gets the 128-bit groups mask used for collision filtering.
 */ 1 4 this 3 3225  
233 0 0 6 283 3132 0 0 48 /**
 * Retrieves the value of a single flag.
 */ 2 4 this 3 3225  4 flag 1 2970  
234 0 0 6 284 3149 0 0 36 /**
 * Gets the cloth thickness.
 */ 1 4 this 3 3225  
235 0 0 6 285 3149 0 0 34 /**
 * Gets the cloth density.
 */ 1 4 this 3 3225  
236 0 0 6 286 3149 0 0 296 /**
 * Gets the relative grid spacing for the broad phase.  The cloth is
 * represented by a set of world aligned cubical cells in broad phase.  The
 * size of these cells is determined by multiplying the length of the diagonal
 * of the AABB of the initial soft body size with this constant.
 */ 1 4 this 3 3225  
237 0 0 4 287 3129 0 0 64 /**
 * Attaches a cloth vertex to a position in world space.
 */ 3 4 this 3 3224  8 vertexId 1 3150  3 pos 1 3143  
238 0 0 4 288 3129 0 0 51 /**
 * Frees a previously attached cloth point.
 */ 2 4 this 3 3224  8 vertexId 1 3150  
239 0 0 4 289 3129 0 0 238 /**
 * Attaches the cloth to a shape.  All cloth points currently inside the shape
 * are attached.
 *
 * This method only works with primitive and convex shapes.  Since the inside
 * of a general triangle mesh is not clearly defined.
 */ 2 4 this 3 3224  5 shape 1 3161  
240 0 0 4 290 3129 0 0 200 /**
 * Attaches the cloth to all shapes, currently colliding.
 *
 * This method only works with primitive and convex shapes.  Since the inside
 * of a general triangle mesh is not clearly defined.
 */ 1 4 this 3 3224  
241 0 0 4 291 3129 0 0 163 /**
 * Detaches the cloth from a shape it has been attached to before.
 *
 * If the cloth has not been attached to the shape before, the call has no
 * effect.
 */ 2 4 this 3 3224  5 shape 1 3161  
242 0 0 4 292 3129 0 0 70 /**
 * Attaches a cloth vertex to a local position within a shape.
 */ 4 4 this 3 3224  8 vertexId 1 3150  5 shape 1 3161  8 localPos 1 3143  
243 0 0 6 293 2993 0 0 60 /**
 * Return the attachment status of the given vertex.
 */ 2 4 this 3 3225  8 vertexId 1 3150  
244 0 0 7 294 3161 1661 0 169 /**
 * Returns the pointer to an attached shape pointer of the given vertex.  If
 * the vertex is not attached or attached to a global position, NULL is
 * returned.
 */ 2 4 this 3 3225  8 vertexId 1 3150  
245 0 0 7 295 3151 0 0 221 /**
 * Returns the attachment position of the given vertex.  If the vertex is
 * attached to shape, the position local to the shape's pose is returned.  If
 * the vertex is not attached, the return value is undefined.
 */ 2 4 this 3 3225  8 vertexId 1 3150  
246 0 0 6 296 3132 0 0 407 /**
 * Returns true if this cloth is sleeping.
 *
 * When a cloth does not move for a period of time, it is no longer simulated
 * in order to save time.  This state is called sleeping.  However, because
 * the object automatically wakes up when it is either touched by an awake
 * object, or one of its properties is changed by the user, the entire sleep
 * mechanism should be transparent to the user.
 */ 1 4 this 3 3225  
247 0 0 4 297 3129 0 0 239 /**
 * Wakes up the cloth if it is sleeping.
 *
 * The wakeCounterValue determines how long until the body is put to sleep, a
 * value of zero means that the body is sleeping.  wake_up(0) is equivalent to
 * PhysxCloth::put_to_sleep().
 */ 2 4 this 3 3224  16 wakeCounterValue 1 3149  
248 0 0 4 298 3129 0 0 267 /**
 * Forces the cloth to sleep.
 *
 * The cloth  will stay asleep until the next call to simulate, and will not
 * wake up until then even when otherwise it would (for example a force is
 * applied to it). It can however wake up during the next do_physics call.
 */ 1 4 this 3 3224  
249 0 0 4 299 3129 0 0 266 /**
 * Sets the linear velocity below which an cloth may go to sleep.  Cloths
 * whose linear velocity is above this threshold will not be put to sleep.
 *
 * Setting the sleep angular/linear velocity only makes sense when the
 * BF_energy_sleep_test is not set.
 */ 2 4 this 3 3224  9 threshold 1 3149  
250 0 0 6 300 3149 0 0 165 /**
 * Returns the linear velocity below which an soft body may go to sleep.
 * cloths whose linear velocity is above this threshold will not be put to
 * sleep.
 */ 1 4 this 3 3225  
251 0 0 4 301 3129 0 0 98 /**
 * Sets an external acceleration which affects all non attached particles of
 * the cloth.
 */ 2 4 this 3 3224  12 acceleration 1 3162  
252 0 0 7 302 3169 0 0 104 /**
 * Retrieves the external acceleration which affects all non attached
 * particles of the cloth.
 */ 1 4 this 3 3225  
253 0 0 4 303 3129 0 0 82 /**
 * Sets an acceleration acting normal to the cloth surface at each vertex.
 */ 2 4 this 3 3224  12 acceleration 1 3162  
254 0 0 7 304 3169 0 0 90 /**
 * Retrieves the acceleration acting normal to the cloth surface at each
 * vertex
 */ 1 4 this 3 3225  
255 0 0 4 305 3129 0 0 119 /**
 * Applies a force (or impulse) defined in the global coordinate frame, to a
 * particular vertex of the cloth.
 */ 4 4 this 3 3224  5 force 1 3162  8 vertexId 1 3135  4 mode 1 2980  
256 0 0 4 306 3129 0 0 147 /**
 * Applies a radial force (or impulse) at a particular position.  All vertices
 * within radius will be affected with a quadratic drop-off.
 */ 5 4 this 3 3224  3 pos 1 3143  9 magnitude 1 3149  6 radius 1 3149  4 mode 1 2980  
257 0 0 4 307 3129 0 0 149 /**
 * Applies a directed force (or impulse) at a particular position.  All
 * vertices within radius will be affected with a quadratic drop-off.
 */ 5 4 this 3 3224  3 pos 1 3143  5 force 1 3162  6 radius 1 3149  4 mode 1 2980  
258 0 0 4 308 3129 0 0 10 /**
 *
 */ 1 4 this 3 3225  
259 0 0 4 308 3129 0 0 10 /**
 *
 */ 3 4 this 3 3225  3 out 1 3133  12 indent_level 1 3135  
260 0 0 4 309 3129 0 0 10 /**
 *
 */ 1 4 this 3 3224  
261 0 0 7 310 3137 0 0 0 0 
262 0 0 6 265 3124 0 0 0 1 4 this 3 3224  
263 0 0 7 266 3224 1695 0 0 1 4 this 3 3124  
264 0 0 6 267 3121 0 0 0 1 4 this 3 3224  
265 0 0 7 268 3224 1695 0 0 1 4 this 3 3121  
266 0 0 6 312 3150 0 0 57 /**
 * Returns the reference count for shared meshes.
 */ 1 4 this 3 3228  
267 0 0 4 313 3129 0 0 10 /**
 *
 */ 1 4 this 3 3230  
268 0 0 7 314 3137 0 0 0 0 
269 0 0 7 317 3227 0 0 10 /**
 *
 */ 1 4 name 1 3125  
270 0 0 6 318 3132 0 0 10 /**
 *
 */ 2 4 this 3 3227  8 filename 1 3231  
271 0 0 7 319 3137 0 0 0 0 
272 0 0 6 321 3132 0 0 66 /**
 * Returns true if the first of the two actors is deleted.
 */ 1 4 this 3 3234  
273 0 0 6 322 3132 0 0 67 /**
 * Returns true if the second of the two actors is deleted.
 */ 1 4 this 3 3234  
274 0 0 7 323 3138 1486 0 71 /**
 * Returns the first of the two actors that makes up this pair.
 */ 1 4 this 3 3234  
275 0 0 7 324 3138 1486 0 70 /**
 * Returns the second of the two actors that make up his pair.
 */ 1 4 this 3 3234  
276 0 0 7 325 3169 0 0 307 /**
 * Returns the total contact normal force that was applied for this pair, to
 * maintain nonpenetration constraints.
 *
 * You should set the ContactPairFlag CPF_notify_forces in order to receive
 * this value.
 *
 * @see PhysxScene::set_actor_pair_flag @see
 * PhysxScene::set_actor_group_pair_flag
 */ 1 4 this 3 3234  
277 0 0 7 326 3169 0 0 260 /**
 * Returns the total tangential force that was applied for this pair.
 *
 * You should set the ContactPairFlag CPF_notify_forces in order to receive
 * this value.
 *
 * @see PhysxScene::set_actor_pair_flag @see
 * PhysxScene::set_actor_group_pair_flag
 */ 1 4 this 3 3234  
278 0 0 6 327 3150 0 0 172 /**
 * Returns the total number of contact points reported in this pair's contact
 * stream.
 *
 * This method is a helper for iterating over the pair's contact stream.
 */ 1 4 this 3 3236  
279 0 0 7 328 3237 0 0 194 /**
 * Returns an instance of PhysxContactPoint, which represents a single entry
 * of this pair's contact stream.
 *
 * This method is a helper for iterating over the pair's contact stream.
 */ 2 4 this 3 3234  3 idx 1 3150  
280 0 0 7 330 3137 0 0 0 0 
281 0 0 7 333 3237 0 0 10 /**
 *
 */ 0 
282 0 0 7 334 3151 0 0 46 /**
 * Returns the contact point position.
 */ 1 4 this 3 3238  
283 0 0 7 335 3169 0 0 38 /**
 * Retrieves the patch normal.
 */ 1 4 this 3 3238  
284 0 0 6 336 3149 0 0 44 /**
 * Retrieves the point normal force.
 */ 1 4 this 3 3238  
285 0 0 6 337 3149 0 0 55 /**
 * Return the separation for the contact point.
 */ 1 4 this 3 3238  
286 0 0 6 338 3150 0 0 39 /**
 * Retrieves the feature index.
 */ 1 4 this 3 3238  
287 0 0 6 339 3150 0 0 39 /**
 * Retrieves the feature index.
 */ 1 4 this 3 3238  
288 0 0 7 340 3137 0 0 0 0 
289 0 0 7 375 3242 1759 0 0 1 6 param0 0 3240  
290 0 0 6 343 3242 0 0 63 /**
 * Returns a pointer to the global PhysxManager object.
 */ 0 
291 0 0 4 344 3129 0 0 10 /**
 *
 */ 3 4 this 3 3242  5 param 1 2966  5 value 1 3149  
292 0 0 6 345 3149 0 0 10 /**
 *
 */ 2 4 this 3 3242  5 param 1 2966  
293 0 0 6 346 3132 0 0 78 /**
 * Returns TRUE if a physcis hardware is available on the host system.
 */ 1 4 this 3 3242  
294 0 0 6 347 3150 0 0 67 /**
 * Reports the number of PPUs installed in the host system.
 */ 1 4 this 3 3242  
295 0 0 6 348 3150 0 0 171 /**
 * Reports the available revision of the PhysX Hardware.  Returns 0 if there
 * is no hardware present in the machine, 1 for the PhysX Athena revision 1.0
 * card.
 */ 1 4 this 3 3242  
296 0 0 6 349 3125 0 0 62 /**
 * Reports the internal API version number of the SDK.
 */ 1 4 this 3 3242  
297 0 0 6 350 3150 0 0 10 /**
 *
 */ 1 4 this 3 3240  
298 0 0 7 351 3155 2028 0 10 /**
 *
 */ 2 4 this 3 3242  4 desc 1 3243  
299 0 0 7 352 3155 2028 0 10 /**
 *
 */ 2 4 this 3 3240  3 idx 1 3150  
300 0 0 6 354 3150 0 0 10 /**
 *
 */ 1 4 this 3 3242  
301 0 0 7 355 3245 0 0 10 /**
 *
 */ 2 4 this 3 3242  4 desc 1 3244  
302 0 0 7 356 3245 0 0 10 /**
 *
 */ 2 4 this 3 3242  3 idx 1 3150  
303 0 0 6 358 3150 0 0 10 /**
 *
 */ 1 4 this 3 3242  
304 0 0 7 359 3246 0 0 10 /**
 *
 */ 2 4 this 3 3242  3 idx 1 3150  
305 0 0 6 361 3150 0 0 10 /**
 *
 */ 1 4 this 3 3242  
306 0 0 7 362 3247 0 0 10 /**
 *
 */ 2 4 this 3 3242  3 idx 1 3150  
307 0 0 6 364 3150 0 0 10 /**
 *
 */ 1 4 this 3 3242  
308 0 0 7 365 3230 0 0 10 /**
 *
 */ 2 4 this 3 3242  3 idx 1 3150  
309 0 0 6 367 3150 0 0 10 /**
 *
 */ 1 4 this 3 3242  
310 0 0 7 368 3248 0 0 10 /**
 *
 */ 2 4 this 3 3242  3 idx 1 3150  
311 0 0 6 370 3150 0 0 10 /**
 *
 */ 1 4 this 3 3242  
312 0 0 7 371 3193 0 0 10 /**
 *
 */ 2 4 this 3 3242  4 desc 1 3249  
313 0 0 7 372 3193 0 0 10 /**
 *
 */ 2 4 this 3 3242  3 idx 1 3150  
314 0 0 4 374 3129 0 0 10 /**
 *
 */ 1 4 this 3 3240  
315 0 0 4 374 3129 0 0 10 /**
 *
 */ 3 4 this 3 3240  3 out 1 3133  12 indent_level 1 3135  
316 0 0 7 378 3253 0 0 10 /**
 *
 */ 1 3 hit 1 3250  
317 0 0 7 379 3170 1602 0 10 /**
 *
 */ 1 4 this 3 3254  
318 0 0 7 380 3161 1661 0 10 /**
 *
 */ 1 4 this 3 3254  
319 0 0 7 381 3257 0 0 10 /**
 *
 */ 1 4 this 3 3254  
320 0 0 7 382 3259 0 0 10 /**
 *
 */ 1 4 this 3 3254  
321 0 0 7 383 3259 0 0 10 /**
 *
 */ 1 4 this 3 3254  
322 0 0 6 384 3260 0 0 10 /**
 *
 */ 1 4 this 3 3254  
323 0 0 7 385 3137 0 0 0 0 
324 0 0 7 387 3264 0 0 10 /**
 *
 */ 1 3 hit 1 3261  
325 0 0 7 388 3170 1602 0 10 /**
 *
 */ 1 4 this 3 3265  
326 0 0 7 389 3170 1602 0 10 /**
 *
 */ 1 4 this 3 3265  
327 0 0 7 390 3137 0 0 0 0 
328 0 0 6 392 3150 0 0 57 /**
 * Returns the reference count for shared meshes.
 */ 1 4 this 3 3267  
329 0 0 4 393 3129 0 0 10 /**
 *
 */ 1 4 this 3 3246  
330 0 0 7 394 3137 0 0 0 0 
331 0 0 7 396 3269 1622 0 10 /**
 *
 */ 0 
332 0 0 4 397 3129 0 0 63 /**
 * Saves the state of the shape object to a descriptor.
 */ 2 4 this 3 3270  9 shapeDesc 1 3272  
333 0 0 7 398 3137 0 0 0 0 
334 0 0 7 400 3273 1661 0 10 /**
 *
 */ 0 
335 0 0 4 401 3129 0 0 63 /**
 * Saves the state of the shape object to a descriptor.
 */ 2 4 this 3 3274  9 shapeDesc 1 3276  
336 0 0 7 402 3137 0 0 0 0 
337 0 0 4 408 3129 0 0 10 /**
 *
 */ 1 4 this 3 3277  
338 0 0 7 409 3138 1486 0 67 /**
 * Retrieves the actor which this joint is associated with.
 */ 2 4 this 3 3278  3 idx 1 3150  
339 0 0 7 410 3155 2028 0 67 /**
 * Retrieves the scene which this joint is associated with.
 */ 1 4 this 3 3278  
340 0 0 4 411 3129 0 0 55 /**
 * Deletes all limit planes added to the joint.
 */ 1 4 this 3 3277  
341 0 0 4 412 3129 0 0 160 /**
 * Sets a name string for this object.  The name can be retrieved again with
 * get_name(). This is for debugging and is not used by the physics engine.
 */ 2 4 this 3 3277  4 name 1 3125  
342 0 0 4 413 3129 0 0 96 /**
 * Sets the point where the two actors are attached, specified in global
 * coordinates.
 */ 2 4 this 3 3277  6 anchor 1 3143  
343 0 0 4 414 3129 0 0 94 /**
 * Sets the direction of the joint's primary axis, specified in global
 * coordinates.
 */ 2 4 this 3 3277  4 axis 1 3162  
344 0 0 4 415 3129 0 0 888 /**
 * Sets the maximum force magnitude that the joint is able to withstand
 * without breaking.
 *
 * If the joint force rises above this threshold, the joint breaks, and
 * becomes disabled.
 *
 * There are two values, one for linear forces, and one for angular forces.
 * Both values are used directly as a value for the maximum impulse tolerated
 * by the joint constraints.
 *
 * Both force values are NX_MAX_REAL by default.  This setting makes the joint
 * unbreakable.  The values should always be nonnegative.
 *
 * The distinction between maxForce and maxTorque is dependent on how the
 * joint is implemented internally, which may not be obvious.  For example
 * what appears to be an angular degree of freedom may be constrained
 * indirectly by a linear constraint.
 *
 * So in most practical applications the user should set both maxTorque and
 * maxForce to low values.
 */ 3 4 this 3 3277  8 maxForce 1 3149  9 maxTorque 1 3149  
345 0 0 4 416 3129 0 0 48 /**
 * Sets the solver extrapolation factor.
 */ 2 4 this 3 3277  6 factor 1 3149  
346 0 0 4 417 3129 0 0 62 /**
 * Switch between acceleration and force based spring.
 */ 2 4 this 3 3277  5 value 1 3132  
347 0 0 4 418 3129 0 0 684 /**
 * Sets the limit point.  The point is specified in the global coordinate
 * frame.
 *
 * All types of joints may be limited with the same system: You may elect a
 * point attached to one of the two actors to act as the limit point.  You may
 * also specify several planes attached to the other actor.
 *
 * The points and planes move together with the actor they are attached to.
 *
 * The simulation then makes certain that the pair of actors only move
 * relative to each other so that the limit point stays on the positive side
 * of all limit planes.
 *
 * The default limit point is (0,0,0) in the local frame of actor2. Calling
 * this deletes all existing limit planes
 */ 3 4 this 3 3277  3 pos 1 3143  10 isOnActor2 1 3132  
348 0 0 4 419 3129 0 0 402 /**
 * Adds a limit plane.  The parameters are given in global coordinates.  The
 * plane is affixed to the actor that does not have the limit point.
 *
 * The normal of the plane points toward the positive side of the plane, and
 * thus toward the limit point.  If the normal points away from the limit
 * point at the time of this call, the method returns false and the limit
 * plane is ignored.
 */ 4 4 this 3 3277  6 normal 1 3162  12 pointInPlane 1 3143  11 restitution 1 3149  
349 0 0 6 420 3125 0 0 35 /**
 * Returns the name string.
 */ 1 4 this 3 3278  
350 0 0 7 421 3151 0 0 38 /**
 * Retrieves the joint anchor.
 */ 1 4 this 3 3278  
351 0 0 7 422 3169 0 0 36 /**
 * Retrieves the joint axis.
 */ 1 4 this 3 3278  
352 0 0 6 423 3149 0 0 53 /**
 * Retrieves the solver extrapolation factor.
 */ 1 4 this 3 3278  
353 0 0 6 424 3132 0 0 54 /**
 * Checks whether acceleration spring is used.
 */ 1 4 this 3 3278  
354 0 0 4 425 3129 0 0 10 /**
 *
 */ 1 4 this 3 3278  
355 0 0 4 425 3129 0 0 10 /**
 *
 */ 3 4 this 3 3278  3 out 1 3133  12 indent_level 1 3135  
356 0 0 7 426 3137 0 0 0 0 
357 0 0 6 404 3124 0 0 0 1 4 this 3 3277  
358 0 0 7 405 3277 1830 0 0 1 4 this 3 3124  
359 0 0 6 406 3121 0 0 0 1 4 this 3 3277  
360 0 0 7 407 3277 1830 0 0 1 4 this 3 3121  
361 0 0 7 429 3280 1830 0 10 /**
 *
 */ 0 
362 0 0 4 430 3129 0 0 63 /**
 * Saves the state of the joint object to a descriptor.
 */ 2 4 this 3 3281  9 jointDesc 1 3283  
363 0 0 4 431 3129 0 0 84 /**
 * Loads the entire state of the joint from a descriptor with a single call.
 */ 2 4 this 3 3280  9 jointDesc 1 3284  
364 0 0 7 432 3137 0 0 0 0 
365 0 0 7 434 3286 1830 0 10 /**
 *
 */ 0 
366 0 0 4 435 3129 0 0 63 /**
 * Saves the state of the joint object to a descriptor.
 */ 2 4 this 3 3287  9 jointDesc 1 3289  
367 0 0 4 436 3129 0 0 84 /**
 * Loads the entire state of the joint from a descriptor with a single call.
 */ 2 4 this 3 3286  9 jointDesc 1 3290  
368 0 0 4 437 3129 0 0 10 /**
 *
 */ 2 4 this 3 3286  1 v 1 3162  
369 0 0 4 438 3129 0 0 10 /**
 *
 */ 2 4 this 3 3286  1 v 1 3162  
370 0 0 4 439 3129 0 0 10 /**
 *
 */ 2 4 this 3 3286  4 quat 1 3292  
371 0 0 4 440 3129 0 0 10 /**
 *
 */ 2 4 this 3 3286  3 pos 1 3143  
372 0 0 7 441 3137 0 0 0 0 
373 0 0 7 443 3294 0 0 10 /**
 *
 */ 0 
374 0 0 7 443 3294 0 0 0 1 6 param0 0 3295  
375 0 0 4 444 3129 0 0 10 /**
 *
 */ 1 4 this 3 3294  
376 0 0 4 445 3129 0 0 10 /**
 *
 */ 1 4 this 3 3294  
377 0 0 4 446 3129 0 0 10 /**
 *
 */ 1 4 this 3 3294  
378 0 0 4 447 3129 0 0 10 /**
 *
 */ 2 4 this 3 3294  5 value 1 3132  
379 0 0 4 448 3129 0 0 10 /**
 *
 */ 2 4 this 3 3294  5 value 1 3132  
380 0 0 4 449 3129 0 0 10 /**
 *
 */ 2 4 this 3 3294  5 value 1 3132  
381 0 0 4 450 3129 0 0 10 /**
 *
 */ 2 4 this 3 3294  5 value 1 3132  
382 0 0 4 451 3129 0 0 10 /**
 *
 */ 2 4 this 3 3294  5 value 1 3132  
383 0 0 4 452 3129 0 0 10 /**
 *
 */ 2 4 this 3 3294  5 value 1 3132  
384 0 0 4 453 3129 0 0 10 /**
 *
 */ 2 4 this 3 3294  5 value 1 3132  
385 0 0 4 454 3129 0 0 10 /**
 *
 */ 2 4 this 3 3294  5 value 1 3132  
386 0 0 4 455 3129 0 0 10 /**
 *
 */ 2 4 this 3 3294  5 value 1 3132  
387 0 0 4 456 3129 0 0 10 /**
 *
 */ 2 4 this 3 3294  5 value 1 3132  
388 0 0 4 457 3129 0 0 10 /**
 *
 */ 2 4 this 3 3294  5 value 1 3132  
389 0 0 4 458 3129 0 0 10 /**
 *
 */ 2 4 this 3 3294  5 value 1 3132  
390 0 0 4 459 3129 0 0 10 /**
 *
 */ 2 4 this 3 3294  5 value 1 3132  
391 0 0 4 460 3129 0 0 10 /**
 *
 */ 2 4 this 3 3294  5 value 1 3132  
392 0 0 4 461 3129 0 0 10 /**
 *
 */ 2 4 this 3 3294  5 value 1 3132  
393 0 0 4 462 3129 0 0 10 /**
 *
 */ 2 4 this 3 3294  5 value 1 3132  
394 0 0 4 463 3129 0 0 10 /**
 *
 */ 2 4 this 3 3294  5 value 1 3132  
395 0 0 4 464 3129 0 0 10 /**
 *
 */ 2 4 this 3 3294  5 value 1 3132  
396 0 0 4 465 3129 0 0 10 /**
 *
 */ 2 4 this 3 3294  5 value 1 3132  
397 0 0 4 466 3129 0 0 10 /**
 *
 */ 2 4 this 3 3294  5 value 1 3132  
398 0 0 4 467 3129 0 0 10 /**
 *
 */ 2 4 this 3 3294  5 value 1 3132  
399 0 0 4 468 3129 0 0 10 /**
 *
 */ 2 4 this 3 3294  5 value 1 3132  
400 0 0 4 469 3129 0 0 10 /**
 *
 */ 2 4 this 3 3294  5 value 1 3132  
401 0 0 4 470 3129 0 0 10 /**
 *
 */ 2 4 this 3 3294  5 value 1 3132  
402 0 0 4 471 3129 0 0 10 /**
 *
 */ 2 4 this 3 3294  5 value 1 3132  
403 0 0 4 472 3129 0 0 10 /**
 *
 */ 2 4 this 3 3294  5 value 1 3132  
404 0 0 4 473 3129 0 0 10 /**
 *
 */ 2 4 this 3 3294  5 value 1 3132  
405 0 0 4 474 3129 0 0 10 /**
 *
 */ 2 4 this 3 3294  5 value 1 3132  
406 0 0 4 475 3129 0 0 10 /**
 *
 */ 2 4 this 3 3294  5 value 1 3132  
407 0 0 4 476 3129 0 0 10 /**
 *
 */ 2 4 this 3 3294  5 value 1 3132  
408 0 0 4 477 3129 0 0 10 /**
 *
 */ 2 4 this 3 3294  5 value 1 3132  
409 0 0 4 478 3129 0 0 10 /**
 *
 */ 2 4 this 3 3294  5 value 1 3132  
410 0 0 7 479 3137 0 0 0 0 
411 0 0 7 481 3297 1830 0 10 /**
 *
 */ 0 
412 0 0 4 482 3129 0 0 63 /**
 * Saves the state of the joint object to a descriptor.
 */ 2 4 this 3 3298  9 jointDesc 1 3300  
413 0 0 4 483 3129 0 0 84 /**
 * Loads the entire state of the joint from a descriptor with a single call.
 */ 2 4 this 3 3297  9 jointDesc 1 3301  
414 0 0 7 484 3137 0 0 0 0 
415 0 0 7 486 3303 1830 0 10 /**
 *
 */ 0 
416 0 0 4 487 3129 0 0 63 /**
 * Saves the state of the joint object to a descriptor.
 */ 2 4 this 3 3304  9 jointDesc 1 3306  
417 0 0 4 488 3129 0 0 84 /**
 * Loads the entire state of the joint from a descriptor with a single call.
 */ 2 4 this 3 3303  9 jointDesc 1 3307  
418 0 0 7 489 3137 0 0 0 0 
419 0 0 7 491 3179 0 0 10 /**
 *
 */ 0 
420 0 0 4 492 3129 0 0 10 /**
 *
 */ 2 4 this 3 3179  4 name 1 3125  
421 0 0 6 493 3125 0 0 10 /**
 *
 */ 1 4 this 3 3309  
422 0 0 7 494 3155 2028 0 10 /**
 *
 */ 1 4 this 3 3309  
423 0 0 7 495 3180 1902 0 10 /**
 *
 */ 1 4 this 3 3309  
424 0 0 6 496 3150 0 0 10 /**
 *
 */ 1 4 this 3 3309  
425 0 0 7 497 3180 1902 0 10 /**
 *
 */ 2 4 this 3 3309  3 idx 1 3150  
426 0 0 4 499 3129 0 0 10 /**
 *
 */ 1 4 this 3 3179  
427 0 0 7 500 3137 0 0 0 0 
428 0 0 7 506 3180 1902 0 10 /**
 *
 */ 0 
429 0 0 4 508 3129 0 0 82 /**
 * Saves the state of the force field shape group object to a  descriptor.
 */ 2 4 this 3 3311  9 groupDesc 1 3313  
430 0 0 7 509 3155 2028 0 68 /**
 * Returns the scene that owns this force field shape group.
 */ 1 4 this 3 3311  
431 0 0 7 510 3179 0 0 111 /**
 * Returns the force field of this group if this is an include group.  If not
 * NULL will be returned.
 */ 1 4 this 3 3311  
432 0 0 6 511 3125 0 0 35 /**
 * Returns the name string.
 */ 1 4 this 3 3311  
433 0 0 4 512 3129 0 0 139 /**
 * Sets a name string for the object that can be retrieved with get_name().
 * This is for debugging and is not used by the engine.
 */ 2 4 this 3 3180  4 name 1 3125  
434 0 0 6 513 3150 0 0 80 /**
 * Returns the number of shapes assigned to the force field shape group.
 */ 1 4 this 3 3311  
435 0 0 7 514 3176 1622 0 64 /**
 * Creates a force field shape and adds it to the group.
 */ 2 4 this 3 3180  4 desc 1 3314  
436 0 0 7 515 3176 1622 0 59 /**
 * Returns the i-th shape in the force field group.
 */ 2 4 this 3 3311  3 idx 1 3150  
437 0 0 4 517 3129 0 0 42 /**
 * Releases the force field shape.
 */ 1 4 this 3 3180  
438 0 0 4 518 3129 0 0 10 /**
 *
 */ 1 4 this 3 3311  
439 0 0 4 518 3129 0 0 10 /**
 *
 */ 3 4 this 3 3311  3 out 1 3133  12 indent_level 1 3135  
440 0 0 7 519 3137 0 0 0 0 
441 0 0 6 502 3124 0 0 0 1 4 this 3 3180  
442 0 0 7 503 3180 1902 0 0 1 4 this 3 3124  
443 0 0 6 504 3121 0 0 0 1 4 this 3 3180  
444 0 0 7 505 3180 1902 0 0 1 4 this 3 3121  
445 0 0 4 521 3129 0 0 10 /**
 *
 */ 1 4 this 3 3245  
446 0 0 6 522 3150 0 0 57 /**
 * Returns the reference count for shared meshes.
 */ 1 4 this 3 3315  
447 0 0 6 523 3149 0 0 10 /**
 *
 */ 3 4 this 3 3315  1 x 1 3149  1 y 1 3149  
448 0 0 7 524 3137 0 0 0 0 
449 0 0 7 526 3317 1661 0 10 /**
 *
 */ 0 
450 0 0 4 527 3129 0 0 63 /**
 * Saves the state of the shape object to a descriptor.
 */ 2 4 this 3 3318  9 shapeDesc 1 3320  
451 0 0 7 528 3137 0 0 0 0 
452 0 0 7 534 3321 1926 0 10 /**
 *
 */ 0 
453 0 0 7 536 3155 2028 0 53 /**
 * Returns the scene that owns this material.
 */ 1 4 this 3 3189  
454 0 0 6 537 3188 0 0 342 /**
 * Returns the material index for this material.
 *
 * Materials are associated with mesh faces and shapes using material index
 * identifiers.
 *
 * If you release a material while its material index is still in use by
 * shapes or meshes, the material usage of these objects becomes undefined as
 * the material index gets recycled.
 */ 1 4 this 3 3189  
455 0 0 4 538 3129 0 0 90 /**
 * Loads the entire state of the material from a descriptor with a single
 * call.
 */ 2 4 this 3 3321  12 materialDesc 1 3322  
456 0 0 4 539 3129 0 0 66 /**
 * Saves the state of the material object to a descriptor.
 */ 2 4 this 3 3189  12 materialDesc 1 3324  
457 0 0 4 540 3129 0 0 340 /**
 * Sets the coefficient of dynamic friction.  The coefficient of dynamic
 * friction should be in [0, +inf]. If set to greater than staticFriction, the
 * effective value of staticFriction will be increased to match.  If the flag
 * MF_anisotropic is set, then this value is used for the primary direction of
 * anisotropy (U axis).
 */ 2 4 this 3 3321  4 coef 1 3149  
458 0 0 4 541 3129 0 0 239 /**
 * Sets the coefficient of static friction.  The coefficient of static
 * friction should be in the range [0, +inf]. If the flag MF_anisotropic is
 * set, then this value is used for the primary direction of anisotropy (U
 * axis).
 */ 2 4 this 3 3321  4 coef 1 3149  
459 0 0 4 542 3129 0 0 167 /**
 * Sets the coefficient of restitution.  A coefficient of 0 makes the object
 * bounce as little as possible, higher values up to 1.0 result in more
 * bounce.
 */ 2 4 this 3 3321  4 rest 1 3149  
460 0 0 4 543 3129 0 0 181 /**
 * Sets the dynamic friction coefficient along the secondary (V) axis.  This
 * is used when anisotropic friction is being applied.  I.e.  the flag
 * MF_anisotropic is set.
 */ 2 4 this 3 3321  4 coef 1 3149  
461 0 0 4 544 3129 0 0 180 /**
 * Sets the static friction coefficient along the secondary (V) axis.  This is
 * used when anisotropic friction is being applied.  I.e.  the flag
 * MF_anisotropic is set.
 */ 2 4 this 3 3321  4 coef 1 3149  
462 0 0 4 545 3129 0 0 127 /**
 * Sets the shape space direction (unit vector) of anisotropy.  This is only
 * used if the flag MF_anisotropic is set.
 */ 2 4 this 3 3321  3 dir 1 3162  
463 0 0 4 546 3129 0 0 43 /**
 * Sets the value of a single flag.
 */ 3 4 this 3 3321  4 flag 1 2982  5 value 1 3132  
464 0 0 4 547 3129 0 0 176 /**
 * Sets the friction combine mode.  - CM_average : Average: (a + b)/2. -
 * CM_min : Minimum: min(a,b). - CM_multiply : Multiply: a*b.  - CM_max :
 * Maximum: max(a,b).
 */ 2 4 this 3 3321  4 mode 1 2972  
465 0 0 4 548 3129 0 0 179 /**
 * Sets the restitution combine mode.  - CM_average : Average: (a + b)/2. -
 * CM_min : Minimum: min(a,b). - CM_multiply : Multiply: a*b.  - CM_max :
 * Maximum: max(a,b).
 */ 2 4 this 3 3321  4 mode 1 2972  
466 0 0 6 549 3149 0 0 45 /**
 * Returns the DynamicFriction value.
 */ 1 4 this 3 3189  
467 0 0 6 550 3149 0 0 54 /**
 * Returns the coefficient of static friction.
 */ 1 4 this 3 3189  
468 0 0 6 551 3149 0 0 50 /**
 * Returns the coefficient of restitution.
 */ 1 4 this 3 3189  
469 0 0 6 552 3149 0 0 72 /**
 * Returns the dynamic friction coefficient for the V direction.
 */ 1 4 this 3 3189  
470 0 0 6 553 3149 0 0 71 /**
 * Returns the static friction coefficient for the V direction.
 */ 1 4 this 3 3189  
471 0 0 7 554 3169 0 0 53 /**
 * Returns the direction of anisotropy value.
 */ 1 4 this 3 3189  
472 0 0 6 555 3132 0 0 46 /**
 * Returns the value of a single flag.
 */ 2 4 this 3 3189  4 flag 1 2982  
473 0 0 6 556 2972 0 0 45 /**
 * Returns the friction combine mode.
 */ 1 4 this 3 3189  
474 0 0 6 557 2972 0 0 48 /**
 * Returns the restitution combine mode.
 */ 1 4 this 3 3189  
475 0 0 4 558 3129 0 0 10 /**
 *
 */ 1 4 this 3 3189  
476 0 0 4 558 3129 0 0 10 /**
 *
 */ 3 4 this 3 3189  3 out 1 3133  12 indent_level 1 3135  
477 0 0 4 559 3129 0 0 10 /**
 *
 */ 1 4 this 3 3321  
478 0 0 7 560 3137 0 0 0 0 
479 0 0 6 530 3124 0 0 0 1 4 this 3 3321  
480 0 0 7 531 3321 1926 0 0 1 4 this 3 3124  
481 0 0 6 532 3121 0 0 0 1 4 this 3 3321  
482 0 0 7 533 3321 1926 0 0 1 4 this 3 3121  
483 0 0 7 562 3325 1661 0 10 /**
 *
 */ 0 
484 0 0 4 563 3129 0 0 63 /**
 * Saves the state of the shape object to a descriptor.
 */ 2 4 this 3 3326  9 shapeDesc 1 3328  
485 0 0 4 564 3129 0 0 189 /**
 * Sets the plane equation.  - normal:  Normal for the plane, in the global
 * frame.  Range: direction vector - d: Distance coefficient of the plane
 * equation.  Range: (-inf,inf)
 */ 3 4 this 3 3325  6 normal 1 3162  1 d 1 3149  
486 0 0 7 565 3137 0 0 0 0 
487 0 0 7 567 3329 1830 0 10 /**
 *
 */ 0 
488 0 0 4 568 3129 0 0 63 /**
 * Saves the state of the joint object to a descriptor.
 */ 2 4 this 3 3330  9 jointDesc 1 3332  
489 0 0 4 569 3129 0 0 84 /**
 * Loads the entire state of the joint from a descriptor with a single call.
 */ 2 4 this 3 3329  9 jointDesc 1 3333  
490 0 0 7 570 3137 0 0 0 0 
491 0 0 7 572 3335 1830 0 10 /**
 *
 */ 0 
492 0 0 4 573 3129 0 0 63 /**
 * Saves the state of the joint object to a descriptor.
 */ 2 4 this 3 3336  9 jointDesc 1 3338  
493 0 0 4 574 3129 0 0 84 /**
 * Loads the entire state of the joint from a descriptor with a single call.
 */ 2 4 this 3 3335  9 jointDesc 1 3339  
494 0 0 7 575 3137 0 0 0 0 
495 0 0 7 577 3341 1830 0 10 /**
 *
 */ 0 
496 0 0 4 578 3129 0 0 63 /**
 * Saves the state of the joint object to a descriptor.
 */ 2 4 this 3 3342  9 jointDesc 1 3344  
497 0 0 4 579 3129 0 0 84 /**
 * Loads the entire state of the joint from a descriptor with a single call.
 */ 2 4 this 3 3341  9 jointDesc 1 3345  
498 0 0 7 580 3137 0 0 0 0 
499 0 0 7 582 3347 1830 0 10 /**
 *
 */ 0 
500 0 0 4 583 3129 0 0 63 /**
 * Saves the state of the joint object to a descriptor.
 */ 2 4 this 3 3348  9 jointDesc 1 3350  
501 0 0 4 584 3129 0 0 84 /**
 * Loads the entire state of the joint from a descriptor with a single call.
 */ 2 4 this 3 3347  9 jointDesc 1 3351  
502 0 0 4 585 3129 0 0 1037 /**
 * Sets motor parameters for the joint.
 *
 * For a positive velTarget, the motor pulls the first body towards its
 * pulley, for a negative velTarget, the motor pulls the second body towards
 * its pulley.
 *
 * velTarget - the relative velocity the motor is trying to achieve.  The
 * motor will only be able to reach this velocity if the maxForce is
 * sufficiently large.  If the joint is moving faster than this velocity, the
 * motor will actually try to brake.  If you set this to infinity then the
 * motor will keep speeding up, unless there is some sort of resistance on the
 * attached bodies.
 *
 * maxForce - the maximum force the motor can exert.  Zero disables the motor.
 * Default is 0, should be >= 0. Setting this to a very large value if
 * velTarget is also very large may not be a good idea.
 *
 * freeSpin - if this flag is set, and if the joint is moving faster than
 * velTarget, then neither braking nor additional acceleration will result.
 * default: false.
 *
 * This automatically enables the motor.
 */ 2 4 this 3 3347  5 motor 1 3353  
503 0 0 4 586 3129 0 0 52 /**
 * Sets or clear a single pulley joint flag.
 */ 3 4 this 3 3347  4 flag 1 2985  5 value 1 3132  
504 0 0 6 587 3132 0 0 59 /**
 * Retrieves the value of a single PulleyJointFlag.
 */ 2 4 this 3 3348  4 flag 1 2985  
505 0 0 7 588 3355 2720 0 10 /**
 *
 */ 1 4 this 3 3348  
506 0 0 7 589 3137 0 0 0 0 
507 0 0 7 591 3356 1830 0 10 /**
 *
 */ 0 
508 0 0 4 592 3129 0 0 63 /**
 * Saves the state of the joint object to a descriptor.
 */ 2 4 this 3 3357  9 jointDesc 1 3359  
509 0 0 4 593 3129 0 0 84 /**
 * Loads the entire state of the joint from a descriptor with a single call.
 */ 2 4 this 3 3356  9 jointDesc 1 3360  
510 0 0 4 594 3129 0 0 886 /**
 * Sets spring parameters.
 *
 * The spring is implicitly integrated so no instability should result for
 * arbitrary spring and damping constants.  Using these settings together with
 * a motor is not possible -- the motor will have priority and the spring
 * settings are ignored.  If you would like to simulate your motor's internal
 * friction, do this by altering the motor parameters directly.
 *
 * spring - The rotational spring acts along the hinge axis and tries to force
 * the joint angle to zero.  A setting of zero disables the spring.  Default
 * is 0, should be >= 0.
 *
 * damper - Damping coefficient; acts against the hinge's angular velocity.  A
 * setting of zero disables the damping.  The default is 0, should be >= 0.
 *
 * targetValue - The angle at which the spring is relaxed.  In [-Pi,Pi].
 * Default is 0.
 *
 * This automatically enables the spring
 */ 2 4 this 3 3356  6 spring 1 3362  
511 0 0 4 595 3129 0 0 1037 /**
 * Sets motor parameters for the joint.
 *
 * For a positive velTarget, the motor pulls the first body towards its
 * pulley, for a negative velTarget, the motor pulls the second body towards
 * its pulley.
 *
 * velTarget - the relative velocity the motor is trying to achieve.  The
 * motor will only be able to reach this velocity if the maxForce is
 * sufficiently large.  If the joint is moving faster than this velocity, the
 * motor will actually try to brake.  If you set this to infinity then the
 * motor will keep speeding up, unless there is some sort of resistance on the
 * attached bodies.
 *
 * maxForce - the maximum force the motor can exert.  Zero disables the motor.
 * Default is 0, should be >= 0. Setting this to a very large value if
 * velTarget is also very large may not be a good idea.
 *
 * freeSpin - if this flag is set, and if the joint is moving faster than
 * velTarget, then neither braking nor additional acceleration will result.
 * default: false.
 *
 * This automatically enables the motor.
 */ 2 4 this 3 3356  5 motor 1 3353  
512 0 0 4 596 3129 0 0 916 /**
 * Sets angular joint limits.
 *
 * If either of these limits are set, any planar limits in PhysxJoint are
 * ignored.  The limits are angles defined the same way as the values that
 * get_angle() returns.
 *
 * The following has to hold:
 *
 * Pi < lowAngle < highAngle < Pi Both limits are disabled by default.  Also
 * sets coefficients of restitutions for the low and high angular limits.
 * These settings are only used if valid limits are set using set_limits().
 * These restitution coefficients work the same way as for contacts.
 *
 * The coefficient of restitution determines whether a collision with the
 * joint limit is completely elastic (like pool balls, restitution = 1, no
 * energy is lost in the collision), completely inelastic (like putty,
 * restitution = 0, no rebound after collision) or somewhere in between.  The
 * default is 0 for both.
 *
 * This automatically enables the limit.
 */ 3 4 this 3 3356  3 low 1 3364  4 high 1 3364  
513 0 0 4 597 3129 0 0 53 /**
 * Sets or clears a single RevoluteJointFlag.
 */ 3 4 this 3 3356  4 flag 1 2986  5 value 1 3132  
514 0 0 4 598 3129 0 0 42 /**
 * Sets the joint projection mode.
 */ 2 4 this 3 3356  4 mode 1 2983  
515 0 0 6 599 3149 0 0 411 /**
 * Retrieves the current revolute joint angle.
 *
 * The relative orientation of the bodies is stored when the joint is created,
 * or when set_axis() or set_anchor() is called.  This initial orientation
 * returns an angle of zero, and joint angles are measured relative to this
 * pose.  The angle is in the range [-180, 180], with positive angles CCW
 * around the axis, measured from body2 to body1.
 */ 1 4 this 3 3357  
516 0 0 6 600 3149 0 0 159 /**
 * Retrieves the revolute joint angle's rate of change (angular velocity). It
 * is the angular velocity of body1 minus body2 projected along the axis.
 */ 1 4 this 3 3357  
517 0 0 6 601 3132 0 0 59 /**
 * Returns the value of a single RevoluteJointFlag.
 */ 2 4 this 3 3357  4 flag 1 2986  
518 0 0 6 602 2983 0 0 48 /**
 * Retrieves the joints projection mode.
 */ 1 4 this 3 3357  
519 0 0 7 603 3355 2720 0 10 /**
 *
 */ 1 4 this 3 3357  
520 0 0 7 604 3366 2587 0 10 /**
 *
 */ 1 4 this 3 3357  
521 0 0 7 605 3137 0 0 0 0 
522 0 0 7 616 3369 1997 0 0 1 6 param0 0 3367  
523 0 0 6 610 3150 0 0 10 /**
 *
 */ 1 4 this 3 3367  
524 0 0 7 611 3161 1661 0 10 /**
 *
 */ 1 4 this 3 3369  
525 0 0 7 612 3161 1661 0 10 /**
 *
 */ 1 4 this 3 3369  
526 0 0 7 613 3161 1661 0 10 /**
 *
 */ 2 4 this 3 3369  3 idx 1 3150  
527 0 0 7 618 3370 2000 0 10 /**
 *
 */ 0 
528 0 0 7 618 3370 2000 0 0 1 6 param0 0 3371  
529 0 0 4 620 3129 0 0 68 /**
 * Sets the nth bit on.  Index must be in the range [0, 31].
 */ 2 4 this 3 3370  3 idx 1 3150  
530 0 0 4 621 3129 0 0 69 /**
 * Sets the nth bit off.  Index must be in the range [0, 31].
 */ 2 4 this 3 3370  3 idx 1 3150  
531 0 0 6 622 3132 0 0 110 /**
 * Returns true if the nth bit is set, false if it is cleared.  Index must be
 * in the range [0, 31].
 */ 2 4 this 3 3371  3 idx 1 3150  
532 0 0 4 623 3129 0 0 64 /**
 * Writes the PhysxMask out as a list of ones and zeros.
 */ 2 4 this 3 3371  3 out 1 3133  
533 0 0 7 624 3370 2000 0 53 /**
 * Returns a PhysxMask whose bits are all on.
 */ 0 
534 0 0 7 625 3370 2000 0 54 /**
 * Returns a PhysxMask whose bits are all off.
 */ 0 
535 0 0 7 627 3194 2008 0 10 /**
 *
 */ 0 
536 0 0 7 627 3194 2008 0 10 /**
 *
 */ 1 4 mask 1 3373  
537 0 0 7 627 3194 2008 0 0 1 6 param0 0 3191  
538 0 0 4 629 3129 0 0 69 /**
 * Sets the nth bit on.  Index must be in the range [0, 127].
 */ 2 4 this 3 3194  3 idx 1 3150  
539 0 0 4 630 3129 0 0 70 /**
 * Sets the nth bit off.  Index must be in the range [0, 127].
 */ 2 4 this 3 3194  3 idx 1 3150  
540 0 0 6 631 3132 0 0 111 /**
 * Returns true if the nth bit is set, false if it is cleared.  Index must be
 * in the range [0, 127].
 */ 2 4 this 3 3191  3 idx 1 3150  
541 0 0 4 632 3129 0 0 70 /**
 * Writes the PhysxGroupsMask out as a list of ones and zeros.
 */ 2 4 this 3 3191  3 out 1 3133  
542 0 0 7 633 3194 2008 0 59 /**
 * Returns a PhysxGroupsMask whose bits are all on.
 */ 0 
543 0 0 7 634 3194 2008 0 60 /**
 * Returns a PhysxGroupsMask whose bits are all off.
 */ 0 
544 0 0 6 635 3150 0 0 10 /**
 *
 */ 1 4 this 3 3191  
545 0 0 6 636 3150 0 0 10 /**
 *
 */ 1 4 this 3 3191  
546 0 0 6 637 3150 0 0 10 /**
 *
 */ 1 4 this 3 3191  
547 0 0 6 638 3150 0 0 10 /**
 *
 */ 1 4 this 3 3191  
548 0 0 4 639 3129 0 0 10 /**
 *
 */ 2 4 this 3 3194  4 bits 1 3150  
549 0 0 4 640 3129 0 0 10 /**
 *
 */ 2 4 this 3 3194  4 bits 1 3150  
550 0 0 4 641 3129 0 0 10 /**
 *
 */ 2 4 this 3 3194  4 bits 1 3150  
551 0 0 4 642 3129 0 0 10 /**
 *
 */ 2 4 this 3 3194  4 bits 1 3150  
552 0 0 7 648 3155 2028 0 10 /**
 *
 */ 0 
553 0 0 4 650 3129 0 0 337 /**
 * Advances the simulation by an elapsedTime time.  The elapsed time has to be
 * in the range (0, inf).
 *
 * It is not allowed to modify the physics scene in between the simulate(dt)
 * and the fetch_results calls!  But it is allowed to read from the scene and
 * do additional computations, e.  g.  AI, in between these calls.
 */ 2 4 this 3 3155  2 dt 1 3149  
554 0 0 4 651 3129 0 0 342 /**
 * Waits until the simulation has finished, and then updates the scene graph
 * with with simulation results.
 *
 * It is not allowed to modify the physics scene in between the simulate(dt)
 * and the fetch_results calls!  But it is allowed to read from the scene and
 * do additional computations, e.  g.  AI, in between these calls.
 */ 1 4 this 3 3155  
555 0 0 4 652 3129 0 0 62 /**
 * Sets simulation timing parameters used in simulate.
 */ 1 4 this 3 3155  
556 0 0 4 653 3129 0 0 611 /**
 * Sets simulation timing parameters used in simulate.  The elapsed time
 * (parameter "dt" in simulate()) is internally subdivided into up to maxIter
 * substeps no larger than maxTimestep.  If the elapsed time is not a multiple
 * of maxTimestep then any remaining time is accumulated to be added onto the
 * elapsed time for the next time step.  If more sub steps than maxIter are
 * needed to advance the simulation by elapsed time, then the remaining time
 * is also accumulated for the next call to simulate().
 *
 * This timing method is strongly preferred for stable, reproducible
 * simulation.
 */ 3 4 this 3 3155  11 maxTimestep 1 3149  7 maxIter 1 3150  
557 0 0 7 654 3294 0 0 407 /**
 * Retrieves the debug geom node for this scene.  The debug geom node is used
 * to visualize information about the physical scene which can be useful for
 * debugging an application.
 *
 * The debug geom node geometry is generated in global coordinates.  In order
 * to see correct information it is important not to dislocate the debug node.
 * Reparent it to render and leave position at (0,0,0).
 */ 1 4 this 3 3155  
558 0 0 4 655 3129 0 0 10 /**
 *
 */ 2 4 this 3 3155  7 enabled 1 3132  
559 0 0 6 656 3132 0 0 10 /**
 *
 */ 1 4 this 3 3375  
560 0 0 4 657 3129 0 0 10 /**
 *
 */ 2 4 this 3 3155  7 enabled 1 3132  
561 0 0 6 658 3132 0 0 10 /**
 *
 */ 1 4 this 3 3375  
562 0 0 4 659 3129 0 0 10 /**
 *
 */ 2 4 this 3 3155  7 enabled 1 3132  
563 0 0 6 660 3132 0 0 10 /**
 *
 */ 1 4 this 3 3375  
564 0 0 4 661 3129 0 0 10 /**
 *
 */ 2 4 this 3 3155  5 cbobj 1 3377  
565 0 0 4 662 3129 0 0 10 /**
 *
 */ 2 4 this 3 3155  5 cbobj 1 3377  
566 0 0 4 663 3129 0 0 56 /**
 * Sets a constant gravity for the entire scene.
 */ 2 4 this 3 3155  7 gravity 1 3162  
567 0 0 7 664 3169 0 0 49 /**
 * Retrieves the current gravity setting.
 */ 1 4 this 3 3375  
568 0 0 7 665 3379 2806 0 10 /**
 *
 */ 1 4 this 3 3375  
569 0 0 6 666 3132 0 0 48 /**
 * Return the specified scene flag flag.
 */ 2 4 this 3 3375  4 flag 1 2987  
570 0 0 6 667 3132 0 0 115 /**
 * Returns TRUE if the the scene is simulated in hardware.  FALSE if the scene
 * is simulated in software.
 */ 1 4 this 3 3375  
571 0 0 6 668 3150 0 0 9 // Actors 1 4 this 3 3375  
572 0 0 7 669 3138 1486 0 10 /**
 *
 */ 2 4 this 3 3155  4 desc 1 3142  
573 0 0 7 670 3138 1486 0 10 /**
 *
 */ 2 4 this 3 3375  3 idx 1 3150  
574 0 0 6 672 3150 0 0 120 /**
 * Returns the number of joints in the scene (excluding "dead" joints). Note
 * that this includes compartments.
 */ 1 4 this 3 3375  
575 0 0 7 673 3277 1830 0 41 /**
 * Creates a joint in this scene.
 */ 2 4 this 3 3155  4 desc 1 3380  
576 0 0 7 674 3277 1830 0 81 /**
 * Retrieve the n-th joint from the array of all the joints in the scene.
 */ 2 4 this 3 3375  3 idx 1 3150  
577 0 0 6 676 3150 0 0 319 /**
 * Return the number of materials in the scene.
 *
 * Note that the returned value is not related to material indices.  Those may
 * not be allocated continuously, and its values may be higher than
 * get_num_materials(). This will also include the default material which
 * exists without having to be created.
 */ 1 4 this 3 3375  
578 0 0 6 677 3150 0 0 167 /**
 * Returns current highest valid material index.
 *
 * Note that not all indices below this are valid if some of them belong to
 * meshes that have beed freed.
 */ 1 4 this 3 3375  
579 0 0 7 678 3321 1926 0 90 /**
 * Creates a new PhysxMaterial using the default settings of
 * PhysxMaterialDesc.
 */ 1 4 this 3 3155  
580 0 0 7 678 3321 1926 0 289 /**
 * Creates a new PhysxMaterial.
 *
 * The material library consists of an array of material objects.  Each
 * material has a well defined index that can be used to refer to it.  If an
 * object references an undefined material, the default material with index 0
 * is used instead.
 */ 2 4 this 3 3155  4 desc 1 3324  
581 0 0 7 679 3321 1926 0 156 /**
 * Retrieves the n-th material from the array of materials.  See also
 * get_material_from_index, which retrieves a material by it's material index.
 */ 2 4 this 3 3375  3 idx 1 3150  
582 0 0 7 680 3321 1926 0 367 /**
 * Retrieves the material with the given material index.
 *
 * There is always at least one material in the Scene, the default material
 * (index 0). If the specified material index is out of range (larger than
 * get_hightest_material_index) or belongs to a material that has been
 * released, then the default material is returned, but no error is reported.
 */ 2 4 this 3 3375  3 idx 1 3150  
583 0 0 6 682 3150 0 0 57 /**
 * Return the number of controllers in the scene.
 */ 1 4 this 3 3375  
584 0 0 7 683 3170 1602 0 46 /**
 * Creates a new character controller.
 */ 2 4 this 3 3155  14 controllerDesc 1 3381  
585 0 0 7 684 3170 1602 0 58 /**
 * Retrieves the n-th controller within the scene.
 */ 2 4 this 3 3375  3 idx 1 3150  
586 0 0 6 686 3150 0 0 56 /**
 * Gets the number of force fields in the scene.
 */ 1 4 this 3 3375  
587 0 0 7 687 3179 0 0 47 /**
 * Creates a force field in this scene.
 */ 2 4 this 3 3155  4 desc 1 3382  
588 0 0 7 688 3179 0 0 95 /**
 * Returns the n-th force field from the array of all the force fields in the
 * scene.
 */ 2 4 this 3 3375  3 idx 1 3150  
589 0 0 6 690 3150 0 0 68 /**
 * Gets the number of force field shape groups in the scene.
 */ 1 4 this 3 3375  
590 0 0 7 691 3180 1902 0 63 /**
 * Creates a new force field shape group in this scene.
 */ 2 4 this 3 3155  4 desc 1 3313  
591 0 0 7 692 3180 1902 0 65 /**
 * Returns the n-th force field shape group in this scene
 */ 2 4 this 3 3375  3 idx 1 3150  
592 0 0 6 694 3150 0 0 50 /**
 * Gets the number of cloths in the scene.
 */ 1 4 this 3 3375  
593 0 0 7 695 3224 1695 0 41 /**
 * Creates a cloth in this scene.
 */ 2 4 this 3 3155  4 desc 1 3383  
594 0 0 7 696 3224 1695 0 80 /**
 * Returns the n-th cloth from the array of all the cloths in the scene.
 */ 2 4 this 3 3375  3 idx 1 3150  
595 0 0 6 698 3150 0 0 55 /**
 * Gets the number of soft bodies in the scene.
 */ 1 4 this 3 3375  
596 0 0 7 699 3385 2112 0 45 /**
 * Creates a soft body in this scene.
 */ 2 4 this 3 3155  4 desc 1 3384  
597 0 0 7 700 3385 2112 0 92 /**
 * Returns the n-th soft body from the array of all the soft bodies in the
 * scene.
 */ 2 4 this 3 3375  3 idx 1 3150  
598 0 0 6 702 3150 0 0 55 /**
 * Returns the number of vehicles in the scene.
 */ 1 4 this 3 3375  
599 0 0 7 703 3387 0 0 43 /**
 * Creates a vehicle in this scene.
 */ 2 4 this 3 3155  4 desc 1 3386  
600 0 0 7 704 3387 0 0 84 /**
 * Returns the n-th vehicle from the array of all the vehicles in the scene.
 */ 2 4 this 3 3375  3 idx 1 3150  
601 0 0 6 706 3132 0 0 63 /**
 * Returns true if any shape is intersected by the ray.
 */ 5 4 this 3 3375  3 ray 1 3204  10 shapesType 1 2990  4 mask 1 3370  6 groups 1 3194  
602 0 0 7 707 3206 2773 0 145 /**
 * Returns the first shape that is hit along the ray.  If not shape is hit
 * then an empty raycast hit is returned (is_empty() == true).
 */ 6 4 this 3 3375  3 ray 1 3204  10 shapesType 1 2990  4 mask 1 3370  6 groups 1 3194  12 smoothNormal 1 3132  
603 0 0 7 708 3388 2785 0 125 /**
 * Returns a PhysxRaycastReport object which can be used to iterate over all
 * shapes that have been hit by the ray.
 */ 6 4 this 3 3375  3 ray 1 3204  10 shapesType 1 2990  4 mask 1 3370  6 groups 1 3194  12 smoothNormal 1 3132  
604 0 0 6 709 3132 0 0 104 /**
 * Returns true if any axis aligned bounding box enclosing a shape is
 * intersected by the ray.
 */ 5 4 this 3 3375  3 ray 1 3204  10 shapesType 1 2990  4 mask 1 3370  6 groups 1 3194  
605 0 0 7 710 3206 2773 0 186 /**
 * Returns the first axis aligned bounding box enclosing a shape that is hit
 * along the ray.  If not shape is hit then an empty raycast hit is returned
 * (is_empty() == true).
 */ 6 4 this 3 3375  3 ray 1 3204  10 shapesType 1 2990  4 mask 1 3370  6 groups 1 3194  12 smoothNormal 1 3132  
606 0 0 7 711 3388 2785 0 168 /**
 * Returns a PhysxRaycastReport object which can be used to iterate over all
 * shapes that have been enclosed by axis aligned bounding boxes hit by the
 * ray.
 */ 6 4 this 3 3375  3 ray 1 3204  10 shapesType 1 2990  4 mask 1 3370  6 groups 1 3194  12 smoothNormal 1 3132  
607 0 0 7 712 3369 1997 0 155 /**
 * Returns the set of shapes overlapped by the world-space sphere.  You can
 * test against static and/or dynamic objects by adjusting 'shapeType'.
 */ 6 4 this 3 3375  6 center 1 3143  6 radius 1 3149  10 shapesType 1 2990  4 mask 1 3370  17 accurateCollision 1 3132  
608 0 0 7 713 3369 1997 0 156 /**
 * Returns the set of shapes overlapped by the world-space capsule.  You can
 * test against static and/or dynamic objects by adjusting 'shapeType'.
 */ 7 4 this 3 3375  2 p0 1 3143  2 p1 1 3143  6 radius 1 3149  10 shapesType 1 2990  4 mask 1 3370  17 accurateCollision 1 3132  
609 0 0 4 714 3129 0 0 416 /**
 * Sets the pair flags for the given pair of actors.
 *
 * Calling this on an actor that has no shape(s) has no effect.  The two actor
 * references must not reference the same actor.
 *
 * It is important to note that the engine stores pair flags per shape, even
 * for actor pair flags.  This means that shapes should be created before
 * actor pair flags are set, otherwise the pair flags will be ignored.
 */ 5 4 this 3 3155  6 actorA 1 3138  6 actorB 1 3138  4 flag 1 2971  5 value 1 3132  
610 0 0 4 715 3129 0 0 137 /**
 * Disables or enables contact generation for a pair of shapes.
 *
 * The two shape references must not reference the same shape.
 */ 4 4 this 3 3155  6 shapeA 1 3161  6 shapeB 1 3161  5 value 1 3132  
611 0 0 4 716 3129 0 0 730 /**
 * With this method one can set contact reporting flags between actors
 * belonging to a pair of groups.
 *
 * It is possible to assign each actor to a group using
 * PhysxActor::set_group(). This is a different set of groups from the shape
 * groups despite the similar name.  Here up to 0xffff different groups are
 * permitted, With this method one can set contact reporting flags between
 * actors belonging to a pair of groups.
 *
 * The following flags are permitted: - CPF_start_touch - CPF_end_touch -
 * CPF_touch - CPF_start_touch_treshold - CPF_end_touch_treshold -
 * CPF_touch_treshold
 *
 * Note that finer grain control of pairwise flags is possible using the
 * function PhysxScene::set_actor_pair_flags().
 */ 5 4 this 3 3155  2 g1 1 3150  2 g2 1 3150  4 flag 1 2971  5 value 1 3132  
612 0 0 4 717 3129 0 0 448 /**
 * Specifies if collision should be performed by a pair of shape groups.
 *
 * It is possible to assign each shape to a collision groups using
 * PhysxShape::set_group(). With this method one can set whether collisions
 * should be detected between shapes belonging to a given pair of groups.
 * Initially all pairs are enabled.
 *
 * Fluids can be assigned to collision groups as well.
 *
 * Collision groups are integers between 0 and 31.
 */ 4 4 this 3 3155  2 g1 1 3150  2 g2 1 3150  6 enable 1 3132  
613 0 0 4 718 3129 0 0 39 /**
 * Setups filtering operations.
 */ 4 4 this 3 3155  3 op0 1 2977  3 op1 1 2977  3 op2 1 2977  
614 0 0 4 719 3129 0 0 44 /**
 * Setups filtering's boolean value.
 */ 2 4 this 3 3155  4 flag 1 3132  
615 0 0 4 720 3129 0 0 39 /**
 * Setups filtering's K0 value.
 */ 2 4 this 3 3155  4 mask 1 3191  
616 0 0 4 721 3129 0 0 39 /**
 * Setups filtering's K1 value.
 */ 2 4 this 3 3155  4 mask 1 3191  
617 0 0 4 722 3129 0 0 1934 /**
 * Specifies the dominance behavior of constraints between two actors with two
 * certain dominance groups.
 *
 * It is possible to assign each actor to a dominance groups using
 * PhysxActor::set_dominance_group().
 *
 * With dominance groups one can have all constraints (contacts and joints)
 * created between actors act in one direction only.  This is useful if you
 * want to make sure that the movement of the rider of a vehicle or the pony
 * tail of a character doesn't influence the object it is attached to, while
 * keeping the motion of both inherently physical.
 *
 * Whenever a constraint (i.e.  joint or contact) between two actors (a0, a1)
 * needs to be solved, the groups (g0, g1) of both actors are retrieved.  Then
 * the constraint dominance setting for this group pair is retrieved.
 *
 * In the constraint, PhysxConstraintDominance::get_0() becomes the dominance
 * setting for a0, and PhysxConstraintDominance::get_1() becomes the dominance
 * setting for a1. A dominance setting of 1.0f, the default, will permit the
 * actor to be pushed or pulled by the other actor.  A dominance setting of
 * 0.0f will however prevent the actor to be pushed or pulled by the other
 * actor.  Thus, a PhysxConstraintDominance of (1.0f, 0.0f) makes the
 * interaction one-way.
 *
 * The dominance matrix is initialised by default such that: - if g1 == g2,
 * then (1.0f, 1.0f) is returned - if g1 < g2, then (0.0f, 1.0f) is returned -
 * if g1 > g2, then (1.0f, 0.0f) is returned
 *
 * In other words, actors in higher groups can be pushed around by actors in
 * lower groups by default.
 *
 * These settings should cover most applications, and in fact not overriding
 * these settings may likely result in higher performance.
 *
 * Dominance settings are currently specified as floats 0.0f or 1.0f because
 * in the future PhysX may permit arbitrary fractional settings to express
 * 'partly-one-way' interactions.
 */ 4 4 this 3 3155  2 g1 1 3150  2 g2 1 3150  9 dominance 1 3389  
618 0 0 6 723 3132 0 0 130 /**
 * Retrieves a single flag for the given pair of actors.
 *
 * The two actor references must not reference the same actor.
 */ 4 4 this 3 3155  6 actorA 1 3138  6 actorB 1 3138  4 flag 1 2971  
619 0 0 6 724 3132 0 0 200 /**
 * Returns /true/ if contact generation between a pair of shapes is enabled,
 * and /false/ if contact generation is disables.
 *
 * The two shape references must not reference the same shape.
 */ 3 4 this 3 3155  6 shapeA 1 3161  6 shapeB 1 3161  
620 0 0 6 725 3132 0 0 83 /**
 * Retrieves a single flag set with PhysxScene::set_actor_group_pair_flag()
 */ 4 4 this 3 3155  2 g1 1 3150  2 g2 1 3150  4 flag 1 2971  
621 0 0 6 726 3132 0 0 134 /**
 * Determines if collision detection is performed between a pair of groups.
 * Collision groups are integers between 0 and 31.
 */ 3 4 this 3 3155  2 g1 1 3150  2 g2 1 3150  
622 0 0 6 727 3132 0 0 47 /**
 * Retrieves filtering's boolean value.
 */ 1 4 this 3 3375  
623 0 0 7 728 3194 2008 0 38 /**
 * Gets filtering constant K0.
 */ 1 4 this 3 3375  
624 0 0 7 729 3194 2008 0 38 /**
 * Gets filtering constant K1.
 */ 1 4 this 3 3375  
625 0 0 6 730 2977 0 0 49 /**
 * Retrieves the op0 filtering operation.
 */ 1 4 this 3 3375  
626 0 0 6 731 2977 0 0 49 /**
 * Retrieves the op1 filtering operation.
 */ 1 4 this 3 3375  
627 0 0 6 732 2977 0 0 49 /**
 * Retrieves the op2 filtering operation.
 */ 1 4 this 3 3375  
628 0 0 7 733 3389 2460 0 40 /**
 * Samples the dominance matrix.
 */ 3 4 this 3 3155  2 g1 1 3150  2 g2 1 3150  
629 0 0 4 734 3129 0 0 10 /**
 *
 */ 1 4 this 3 3155  
630 0 0 4 735 3129 0 0 10 /**
 *
 */ 1 4 this 3 3375  
631 0 0 4 735 3129 0 0 10 /**
 *
 */ 3 4 this 3 3375  3 out 1 3133  12 indent_level 1 3135  
632 0 0 7 736 3137 0 0 0 0 
633 0 0 6 644 3124 0 0 0 1 4 this 3 3155  
634 0 0 7 645 3155 2028 0 0 1 4 this 3 3124  
635 0 0 6 646 3121 0 0 0 1 4 this 3 3155  
636 0 0 7 647 3155 2028 0 0 1 4 this 3 3121  
637 0 0 7 742 3385 2112 0 10 /**
 *
 */ 0 
638 0 0 7 744 3155 2028 0 61 /**
 * Returns the scene which this soft body belongs to.
 */ 1 4 this 3 3390  
639 0 0 7 745 3392 0 0 10 /**
 *
 */ 1 4 this 3 3390  
640 0 0 7 746 3392 0 0 10 /**
 *
 */ 2 4 this 3 3385  4 name 1 3125  
641 0 0 4 747 3129 0 0 139 /**
 * Sets a name string for the object that can be retrieved with get_name().
 * This is for debugging and is not used by the engine.
 */ 2 4 this 3 3385  4 name 1 3125  
642 0 0 4 748 3129 0 0 43 /**
 * Sets the value of a single flag.
 */ 3 4 this 3 3385  4 flag 1 2989  5 value 1 3132  
643 0 0 4 749 3129 0 0 58 /**
 * Sets 128-bit mask used for collision filtering.
 */ 2 4 this 3 3385  4 mask 1 3191  
644 0 0 4 750 3129 0 0 110 /**
 * Sets which collision group this soft body is part of.  Collision group must
 * be between 0 and 31.
 */ 2 4 this 3 3385  5 group 1 3150  
645 0 0 4 751 3129 0 0 48 /**
 * Sets the soft body solver iterations.
 */ 2 4 this 3 3385  10 iterations 1 3150  
646 0 0 4 752 3129 0 0 65 /**
 * Sets the soft body particle radius (must be positive).
 */ 2 4 this 3 3385  6 radius 1 3149  
647 0 0 4 753 3129 0 0 74 /**
 * Sets the soft body self collision thickness (must be positive).
 */ 2 4 this 3 3385  9 thickness 1 3149  
648 0 0 4 754 3129 0 0 60 /**
 * Sets the soft body hard stretch elongation limit.
 */ 2 4 this 3 3385  6 factor 1 3149  
649 0 0 4 755 3129 0 0 72 /**
 * Sets the soft body volume stiffness in the range from 0 to 1.
 */ 2 4 this 3 3385  9 stiffness 1 3149  
650 0 0 4 756 3129 0 0 76 /**
 * Sets the soft body stretching stiffness in the range from 0 to 1.
 */ 2 4 this 3 3385  9 stiffness 1 3149  
651 0 0 4 757 3129 0 0 65 /**
 * Sets the damping coefficient in the range from 0 to 1.
 */ 2 4 this 3 3385  4 coef 1 3149  
652 0 0 4 758 3129 0 0 76 /**
 * Sets the soft body friction coefficient in the range from 0 to 1.
 */ 2 4 this 3 3385  8 friction 1 3149  
653 0 0 4 759 3129 0 0 68 /**
 * Sets the soft body tear factor (must be larger than one).
 */ 2 4 this 3 3385  6 factor 1 3149  
654 0 0 4 760 3129 0 0 79 /**
 * Sets the soft body attachment tear factor (must be larger than one).
 */ 2 4 this 3 3385  6 factor 1 3149  
655 0 0 6 761 3125 0 0 37 /**
 * Retrieves the name string.
 */ 1 4 this 3 3390  
656 0 0 6 762 3132 0 0 48 /**
 * Retrieves the value of a single flag.
 */ 2 4 this 3 3390  4 flag 1 2989  
657 0 0 7 763 3194 2008 0 69 /**
 * Gets the 128-bit groups mask used for collision filtering.
 */ 1 4 this 3 3390  
658 0 0 6 764 3150 0 0 67 /**
 * Retrieves the collision group this soft body is part of.
 */ 1 4 this 3 3390  
659 0 0 6 765 3150 0 0 46 /**
 * Gets the number of cloth particles.
 */ 1 4 this 3 3385  
660 0 0 6 766 3150 0 0 53 /**
 * Retrieves the soft body solver iterations.
 */ 1 4 this 3 3390  
661 0 0 6 767 3149 0 0 46 /**
 * Gets the soft body particle radius.
 */ 1 4 this 3 3390  
662 0 0 6 768 3149 0 0 38 /**
 * Gets the soft body density.
 */ 1 4 this 3 3390  
663 0 0 6 769 3149 0 0 296 /**
 * Gets the relative grid spacing for the broad phase.  The cloth is
 * represented by a set of world aligned cubical cells in broad phase.  The
 * size of these cells is determined by multiplying the length of the diagonal
 * of the AABB of the initial soft body size with this constant.
 */ 1 4 this 3 3390  
664 0 0 6 770 3149 0 0 55 /**
 * Gets the soft body self collision thickness.
 */ 1 4 this 3 3390  
665 0 0 6 771 3149 0 0 65 /**
 * Retrieves the soft body hard stretch elongation limit.
 */ 1 4 this 3 3390  
666 0 0 6 772 3149 0 0 52 /**
 * Retrieves the soft body volume stiffness.
 */ 1 4 this 3 3390  
667 0 0 6 773 3149 0 0 56 /**
 * Retrieves the soft body stretching stiffness.
 */ 1 4 this 3 3390  
668 0 0 6 774 3149 0 0 45 /**
 * Retrieves the damping coefficient.
 */ 1 4 this 3 3390  
669 0 0 6 775 3149 0 0 56 /**
 * Retrieves the soft body friction coefficient.
 */ 1 4 this 3 3390  
670 0 0 6 776 3149 0 0 47 /**
 * Retrieves the soft body tear factor.
 */ 1 4 this 3 3390  
671 0 0 6 777 3149 0 0 58 /**
 * Retrieves the attachment soft body tear factor.
 */ 1 4 this 3 3390  
672 0 0 6 778 3132 0 0 415 /**
 * Returns true if this soft body is sleeping.
 *
 * When a soft body does not move for a period of time, it is no longer
 * simulated in order to save time.  This state is called sleeping.  However,
 * because the object automatically wakes up when it is either touched by an
 * awake object, or one of its properties is changed by the user, the entire
 * sleep mechanism should be transparent to the user.
 */ 1 4 this 3 3390  
673 0 0 4 779 3129 0 0 246 /**
 * Wakes up the soft body if it is sleeping.
 *
 * The wakeCounterValue determines how long until the body is put to sleep, a
 * value of zero means that the body is sleeping.  wake_up(0) is equivalent to
 * PhysxSoftBody::put_to_sleep().
 */ 2 4 this 3 3385  16 wakeCounterValue 1 3149  
674 0 0 4 780 3129 0 0 275 /**
 * Forces the soft body to sleep.
 *
 * The soft body  will stay asleep until the next call to simulate, and will
 * not wake up until then even when otherwise it would (for example a force is
 * applied to it). It can however wake up during the next do_physics call.
 */ 1 4 this 3 3385  
675 0 0 4 781 3129 0 0 275 /**
 * Sets the linear velocity below which an soft body may go to sleep.
 * SoftBodys whose linear velocity is above this threshold will not be put to
 * sleep.
 *
 * Setting the sleep angular/linear velocity only makes sense when the
 * BF_energy_sleep_test is not set.
 */ 2 4 this 3 3385  9 threshold 1 3149  
676 0 0 6 782 3149 0 0 171 /**
 * Returns the linear velocity below which an soft body may go to sleep.  Soft
 * bodies whose linear velocity is above this threshold will not be put to
 * sleep.
 */ 1 4 this 3 3390  
677 0 0 4 783 3129 0 0 10 /**
 *
 */ 1 4 this 3 3390  
678 0 0 4 783 3129 0 0 10 /**
 *
 */ 3 4 this 3 3390  3 out 1 3133  12 indent_level 1 3135  
679 0 0 4 784 3129 0 0 10 /**
 *
 */ 1 4 this 3 3385  
680 0 0 7 785 3137 0 0 0 0 
681 0 0 6 738 3124 0 0 0 1 4 this 3 3385  
682 0 0 7 739 3385 2112 0 0 1 4 this 3 3124  
683 0 0 6 740 3121 0 0 0 1 4 this 3 3385  
684 0 0 7 741 3385 2112 0 0 1 4 this 3 3121  
685 0 0 6 787 3150 0 0 57 /**
 * Returns the reference count for shared meshes.
 */ 1 4 this 3 3393  
686 0 0 4 788 3129 0 0 10 /**
 *
 */ 1 4 this 3 3248  
687 0 0 7 789 3137 0 0 0 0 
688 0 0 7 791 3392 0 0 10 /**
 *
 */ 1 4 name 1 3125  
689 0 0 4 792 3129 0 0 243 /**
 * Reads the vertices and indices from an existing Geom and makes a decomposed
 * copy of the data.  Then computes links between the owning soft body
 * tetrahedron mesh in order to render an updated geometry every simulation
 * frame.
 */ 2 4 this 3 3392  4 geom 1 3395  
690 0 0 7 793 3137 0 0 0 0 
691 0 0 7 795 3398 1622 0 10 /**
 *
 */ 0 
692 0 0 4 796 3129 0 0 63 /**
 * Saves the state of the shape object to a descriptor.
 */ 2 4 this 3 3399  9 shapeDesc 1 3401  
693 0 0 4 797 3129 0 0 34 /**
 * Sets the sphere radius.
 */ 2 4 this 3 3398  6 radius 1 3149  
694 0 0 6 798 3149 0 0 44 /**
 * Returns the radius of the sphere.
 */ 1 4 this 3 3399  
695 0 0 7 799 3137 0 0 0 0 
696 0 0 7 801 3402 1661 0 10 /**
 *
 */ 0 
697 0 0 4 802 3129 0 0 63 /**
 * Saves the state of the shape object to a descriptor.
 */ 2 4 this 3 3403  9 shapeDesc 1 3405  
698 0 0 4 803 3129 0 0 34 /**
 * Sets the sphere radius.
 */ 2 4 this 3 3402  6 radius 1 3149  
699 0 0 6 804 3149 0 0 44 /**
 * Returns the radius of the sphere.
 */ 1 4 this 3 3403  
700 0 0 7 805 3137 0 0 0 0 
701 0 0 7 807 3406 1830 0 10 /**
 *
 */ 0 
702 0 0 4 808 3129 0 0 63 /**
 * Saves the state of the joint object to a descriptor.
 */ 2 4 this 3 3407  9 jointDesc 1 3409  
703 0 0 4 809 3129 0 0 84 /**
 * Loads the entire state of the joint from a descriptor with a single call.
 */ 2 4 this 3 3406  9 jointDesc 1 3410  
704 0 0 4 810 3129 0 0 54 /**
 * Sets or clears a single SphericalJointFlag.
 */ 3 4 this 3 3406  4 flag 1 2991  5 value 1 3132  
705 0 0 4 811 3129 0 0 42 /**
 * Sets the joint projection mode.
 */ 2 4 this 3 3406  4 mode 1 2983  
706 0 0 6 812 3132 0 0 60 /**
 * Returns the value of a single SphericalJointFlag.
 */ 2 4 this 3 3407  4 flag 1 2991  
707 0 0 6 813 2983 0 0 56 /**
 * Returns the current projection mode settings.
 */ 1 4 this 3 3407  
708 0 0 7 814 3137 0 0 0 0 
709 0 0 6 816 3150 0 0 57 /**
 * Returns the reference count for shared meshes.
 */ 1 4 this 3 3412  
710 0 0 4 817 3129 0 0 10 /**
 *
 */ 1 4 this 3 3247  
711 0 0 7 818 3137 0 0 0 0 
712 0 0 7 820 3414 1661 0 10 /**
 *
 */ 0 
713 0 0 4 821 3129 0 0 63 /**
 * Saves the state of the shape object to a descriptor.
 */ 2 4 this 3 3415  9 shapeDesc 1 3417  
714 0 0 7 822 3137 0 0 0 0 
715 0 0 7 824 3387 0 0 10 /**
 *
 */ 0 
716 0 0 4 825 3129 0 0 33 /**
 * Destroys this vehicle.
 */ 1 4 this 3 3387  
717 0 0 7 826 3137 0 0 0 0 
718 0 0 7 828 3418 0 0 10 /**
 *
 */ 0 
719 0 0 7 829 3137 0 0 0 0 
720 0 0 7 831 3419 1661 0 10 /**
 *
 */ 0 
721 0 0 4 832 3129 0 0 63 /**
 * Saves the state of the shape object to a descriptor.
 */ 2 4 this 3 3420  9 shapeDesc 1 3422  
722 0 0 4 833 3129 0 0 34 /**
 * Sets the sphere radius.
 */ 2 4 this 3 3419  6 radius 1 3149  
723 0 0 4 834 3129 0 0 120 /**
 * Set the maximum extension distance of suspension along shape's -Y axis.
 * The minimum extension is always 0.
 */ 2 4 this 3 3419  6 travel 1 3149  
724 0 0 4 835 3129 0 0 111 /**
 * Set the inverse mass of the wheel.  Determines the wheel velocity that
 * wheel torques can achieve.
 */ 2 4 this 3 3419  7 invMass 1 3149  
725 0 0 4 836 3129 0 0 103 /**
 * Set the sum engine torque on the wheel axle.  Positive or negative
 * depending on direction
 */ 2 4 this 3 3419  6 torque 1 3149  
726 0 0 4 837 3129 0 0 93 /**
 * Must be nonnegative.  Very large values should lock wheel but should be
 * stable.
 */ 2 4 this 3 3419  6 torque 1 3149  
727 0 0 4 838 3129 0 0 102 /**
 * Set the steering angle, around shape Y axis.  The steering angle is
 * measured in degrees.
 */ 2 4 this 3 3419  5 angle 1 3149  
728 0 0 4 839 3129 0 0 102 /**
 * Set the steering angle, around shape Y axis.  The steering angle is
 * measured in radians.
 */ 2 4 this 3 3419  5 angle 1 3149  
729 0 0 4 840 3129 0 0 126 /**
 * Set the current axle rotation speed.  Note: WSF_axle_speed_override flag
 * must be raised for this to have effect!
 */ 2 4 this 3 3419  5 speed 1 3149  
730 0 0 4 841 3129 0 0 58 /**
 * Turns the specified wheel shape flag on or off.
 */ 3 4 this 3 3419  4 flag 1 2995  5 value 1 3132  
731 0 0 4 842 3129 0 0 66 /**
 * Set the data intended for car wheel suspension effects.
 */ 2 4 this 3 3419  6 spring 1 3362  
732 0 0 6 843 3149 0 0 44 /**
 * Returns the radius of the sphere.
 */ 1 4 this 3 3420  
733 0 0 6 844 3149 0 0 40 /**
 * Returns the suspension travel
 */ 1 4 this 3 3420  
734 0 0 6 845 3149 0 0 115 /**
 * Returns the inverse mass of the wheel.  Determines the wheel velocity that
 * wheel torques can achieve.
 */ 1 4 this 3 3420  
735 0 0 6 846 3149 0 0 109 /**
 * Retrieves the sum engine torque on the wheel axle.  Positive or negative
 * depending on direction
 */ 1 4 this 3 3420  
736 0 0 6 847 3149 0 0 93 /**
 * Must be nonnegative.  Very large values should lock wheel but should be
 * stable.
 */ 1 4 this 3 3420  
737 0 0 6 848 3149 0 0 108 /**
 * Retrieves the steering angle, around shape Y axis.  The steering angle is
 * measured in degrees.
 */ 1 4 this 3 3420  
738 0 0 6 849 3149 0 0 108 /**
 * Retrieves the steering angle, around shape Y axis.  The steering angle is
 * measured in radians.
 */ 1 4 this 3 3420  
739 0 0 6 850 3149 0 0 53 /**
 * Retrieves the current axle rotation speed.
 */ 1 4 this 3 3420  
740 0 0 6 851 3132 0 0 63 /**
 * Returns the value of the specified wheel shape flag.
 */ 2 4 this 3 3420  4 flag 1 2995  
741 0 0 7 852 3137 0 0 0 0 
742 0 0 7 854 3142 2213 0 10 /**
 *
 */ 0 
743 0 0 4 856 3129 0 0 49 /**
 * (re)sets the structure to the default.
 */ 1 4 this 3 3142  
744 0 0 6 857 3132 0 0 51 /**
 * Returns true if the descriptor is valid.
 */ 1 4 this 3 3423  
745 0 0 4 858 3129 0 0 77 /**
 * Adds a shape to the list of collision shapes composing this actor.
 */ 2 4 this 3 3142  4 desc 1 3160  
746 0 0 4 859 3129 0 0 54 /**
 * Sets the optional debug name for the actor.
 */ 2 4 this 3 3142  4 name 1 3125  
747 0 0 4 860 3129 0 0 138 /**
 * Set the density used during mass/intertia computation.  This value is used
 * if the actor's shapes do not have a mass asigned.
 */ 2 4 this 3 3142  7 density 1 3149  
748 0 0 4 861 3129 0 0 57 /**
 * Set the position of the actor in global space.
 */ 2 4 this 3 3142  3 pos 1 3143  
749 0 0 4 862 3129 0 0 159 /**
 * Set the position and orientation of the actor in global space.  Scaling and
 * shear arenot supported, even if the matrix contains a scale or shear.
 */ 2 4 this 3 3142  3 mat 1 3146  
750 0 0 4 863 3129 0 0 112 /**
 * Sets the orientation of the actor in global space by providing angles for
 * heading, pitch and roll.
 */ 4 4 this 3 3142  1 h 1 3149  1 p 1 3149  1 r 1 3149  
751 0 0 4 864 3129 0 0 151 /**
 * Sets the body descriptor for this actor.  The actor will be dynmaic if a
 * body descriptor is set, and static if no body descriptor is set.
 */ 2 4 this 3 3142  4 desc 1 3141  
752 0 0 6 865 3125 0 0 58 /**
 * Returns the optional debug name for this actor.
 */ 1 4 this 3 3423  
753 0 0 6 866 3149 0 0 39 /**
 * Returns the actor's density.
 */ 1 4 this 3 3423  
754 0 0 7 867 3151 0 0 56 /**
 * Returns the actor's position in global space.
 */ 1 4 this 3 3423  
755 0 0 7 868 3152 0 0 57 /**
 * Returns the actor's transform in global space.
 */ 1 4 this 3 3423  
756 0 0 7 869 3141 2229 0 51 /**
 * Gets the body descriptor for this actor.
 */ 1 4 this 3 3423  
757 0 0 7 871 3141 2229 0 10 /**
 *
 */ 0 
758 0 0 4 873 3129 0 0 49 /**
 * (re)sets the structure to the default.
 */ 1 4 this 3 3141  
759 0 0 6 874 3132 0 0 51 /**
 * Returns true if the descriptor is valid.
 */ 1 4 this 3 3425  
760 0 0 4 875 3129 0 0 32 /**
 * Set the mass of body.
 */ 2 4 this 3 3141  4 mass 1 3149  
761 0 0 4 876 3129 0 0 54 /**
 * Set the linear damping applied to the body.
 */ 2 4 this 3 3141  7 damping 1 3149  
762 0 0 4 877 3129 0 0 55 /**
 * Set the angular damping applied to the body.
 */ 2 4 this 3 3141  7 damping 1 3149  
763 0 0 4 878 3129 0 0 47 /**
 * Set the linear Velocity of the body.
 */ 2 4 this 3 3141  8 velocity 1 3162  
764 0 0 4 879 3129 0 0 48 /**
 * Set the angular velocity of the body.
 */ 2 4 this 3 3141  8 velocity 1 3162  
765 0 0 4 880 3129 0 0 66 /**
 * Set the maximum allowed angular velocity for this body.
 */ 2 4 this 3 3141  7 maximum 1 3149  
766 0 0 4 881 3129 0 0 77 /**
 * Set the maximum linear velocity at which the body can go to sleep.
 */ 2 4 this 3 3141  8 velocity 1 3149  
767 0 0 4 882 3129 0 0 74 /**
 * Set the maximum angular velocity at which body can go to sleep.
 */ 2 4 this 3 3141  8 velocity 1 3149  
768 0 0 4 883 3129 0 0 114 /**
 * Set the number of solver iterations performed when processing
 * joint/contacts connected to this body.
 */ 2 4 this 3 3141  5 count 1 3150  
769 0 0 4 884 3129 0 0 126 /**
 * Set the threshold for the energy-based sleeping algorithm.  Only used when
 * the BF_energy_sleep_test flag is set.
 */ 2 4 this 3 3141  9 threshold 1 3149  
770 0 0 4 885 3129 0 0 69 /**
 * Set the damping factor for bodies that are about to sleep.
 */ 2 4 this 3 3141  7 damping 1 3149  
771 0 0 4 886 3129 0 0 66 /**
 * Set the position and orientation of the center of mass.
 */ 2 4 this 3 3141  3 mat 1 3146  
772 0 0 4 887 3129 0 0 75 /**
 * Set the diagonal mass space inertia tensor in bodies mass frame.
 */ 2 4 this 3 3141  7 inertia 1 3162  
773 0 0 4 888 3129 0 0 0 3 4 this 3 3141  4 flag 1 2968  5 value 1 3132  
774 0 0 4 889 3129 0 0 143 /**
 * When CCD is globally enabled, it is still not performed if the motion
 * distance of all points on the body is below this threshold.
 */ 2 4 this 3 3141  9 threshold 1 3149  
775 0 0 4 890 3129 0 0 50 /**
 * Set the body's initial wake up counter.
 */ 2 4 this 3 3141  5 value 1 3149  
776 0 0 4 891 3129 0 0 55 /**
 * Set The force threshold for contact reports.
 */ 2 4 this 3 3141  9 threshold 1 3149  
777 0 0 6 892 3149 0 0 32 /**
 * Get the mass of body.
 */ 1 4 this 3 3425  
778 0 0 6 893 3149 0 0 54 /**
 * Get the linear damping applied to the body.
 */ 1 4 this 3 3425  
779 0 0 6 894 3149 0 0 55 /**
 * Get the angular damping applied to the body.
 */ 1 4 this 3 3425  
780 0 0 7 895 3169 0 0 47 /**
 * Get the linear Velocity of the body.
 */ 1 4 this 3 3425  
781 0 0 7 896 3169 0 0 48 /**
 * Get the angular velocity of the body.
 */ 1 4 this 3 3425  
782 0 0 6 897 3149 0 0 66 /**
 * Get the maximum allowed angular velocity for this body.
 */ 1 4 this 3 3425  
783 0 0 6 898 3149 0 0 77 /**
 * Get the maximum linear velocity at which the body can go to sleep.
 */ 1 4 this 3 3425  
784 0 0 6 899 3149 0 0 74 /**
 * Get the maximum angular velocity at which body can go to sleep.
 */ 1 4 this 3 3425  
785 0 0 6 900 3150 0 0 114 /**
 * Get the number of solver iterations performed when processing
 * joint/contacts connected to this body.
 */ 1 4 this 3 3425  
786 0 0 6 901 3149 0 0 126 /**
 * Get the threshold for the energy-based sleeping algorithm.  Only used when
 * the BF_energy_sleep_test flag is set.
 */ 1 4 this 3 3425  
787 0 0 6 902 3149 0 0 69 /**
 * Get the damping factor for bodies that are about to sleep.
 */ 1 4 this 3 3425  
788 0 0 7 903 3152 0 0 66 /**
 * Get the position and orientation of the center of mass.
 */ 1 4 this 3 3425  
789 0 0 7 904 3169 0 0 75 /**
 * Get the diagonal mass space inertia tensor in bodies mass frame.
 */ 1 4 this 3 3425  
790 0 0 6 905 3132 0 0 0 2 4 this 3 3425  4 flag 1 2968  
791 0 0 6 906 3149 0 0 10 /**
 *
 */ 1 4 this 3 3425  
792 0 0 6 907 3149 0 0 10 /**
 *
 */ 1 4 this 3 3425  
793 0 0 6 908 3149 0 0 10 /**
 *
 */ 1 4 this 3 3425  
794 0 0 4 915 3129 0 0 0 1 4 this 3 3160  
795 0 0 6 916 3132 0 0 0 1 4 this 3 3427  
796 0 0 4 917 3129 0 0 38 /**
 * Sets a possible debug name.
 */ 2 4 this 3 3160  4 name 1 3125  
797 0 0 4 918 3129 0 0 181 /**
 * This shape will become a trigger shape if this parameter is set to TRUE. It
 * won't take part in collisions, but trigger events if some other shape
 * passes through it.
 */ 2 4 this 3 3160  5 value 1 3132  
798 0 0 4 919 3129 0 0 10 /**
 *
 */ 2 4 this 3 3160  3 pos 1 3143  
799 0 0 4 920 3129 0 0 10 /**
 *
 */ 2 4 this 3 3160  3 mat 1 3146  
800 0 0 4 921 3129 0 0 10 /**
 *
 */ 4 4 this 3 3160  1 h 1 3149  1 p 1 3149  1 r 1 3149  
801 0 0 4 922 3129 0 0 619 /**
 * Specifies by how much shapes can interpenetrate.
 *
 * Two shapes will interpenetrate by the sum of their skin widths.  This means
 * that their graphical representations should be adjusted so that they just
 * touch when the shapes are interpenetrating.
 *
 * The default skin width is the 'physx-skin-width' parameter.
 *
 * A skin width sum of zero for two bodies is not permitted because it will
 * lead to an unstable simulation.
 *
 * If your simulation jitters because resting bodies occasionally lose
 * contact, increasing the size of your collision volumes and the skin width
 * may improve things.
 */ 2 4 this 3 3160  9 skinWidth 1 3149  
802 0 0 4 923 3129 0 0 10 /**
 *
 */ 3 4 this 3 3160  4 flag 1 3187  5 value 1 3132  
803 0 0 4 924 3129 0 0 314 /**
 * Sets the mass of this individual shape when computing mass inertial
 * properties for a rigidbody.  When mass<=0.0 then density and volume
 * determine the mass.  Note that this will only be used if the body has a
 * zero inertia tensor, or if you call PhysxActor::update_mass_from_shapes
 * explicitly.
 */ 2 4 this 3 3160  4 mass 1 3149  
804 0 0 4 925 3129 0 0 292 /**
 * Sets the density of this individual shape when computing mass inertial
 * properties for a rigidbody (unless a valid mass >0.0 is provided). Note
 * that this will only be used if the body has a zero inertia tensor, or if
 * you call PhysxActor::update_mass_from_shapes explicitly.
 */ 2 4 this 3 3160  7 density 1 3149  
805 0 0 4 926 3129 0 0 10 /**
 *
 */ 2 4 this 3 3160  5 group 1 3188  
806 0 0 4 927 3129 0 0 10 /**
 *
 */ 2 4 this 3 3160  8 material 1 3189  
807 0 0 4 928 3129 0 0 10 /**
 *
 */ 2 4 this 3 3160  5 index 1 3188  
808 0 0 6 929 3125 0 0 10 /**
 *
 */ 1 4 this 3 3427  
809 0 0 7 930 3151 0 0 10 /**
 *
 */ 1 4 this 3 3427  
810 0 0 7 931 3152 0 0 10 /**
 *
 */ 1 4 this 3 3427  
811 0 0 6 932 3149 0 0 10 /**
 *
 */ 1 4 this 3 3427  
812 0 0 6 933 3132 0 0 10 /**
 *
 */ 2 4 this 3 3427  4 flag 1 3187  
813 0 0 6 934 3149 0 0 10 /**
 *
 */ 1 4 this 3 3427  
814 0 0 6 935 3149 0 0 10 /**
 *
 */ 1 4 this 3 3427  
815 0 0 6 936 3188 0 0 10 /**
 *
 */ 1 4 this 3 3427  
816 0 0 6 937 3188 0 0 10 /**
 *
 */ 1 4 this 3 3427  
817 0 0 6 910 3121 0 0 0 1 4 this 3 3160  
818 0 0 6 911 3160 0 0 0 1 4 this 3 3121  
819 0 0 7 913 3429 0 0 0 1 4 this 3 3160  
820 0 0 6 914 3160 0 0 0 1 4 this 3 3429  
821 0 0 7 939 3195 2294 0 10 /**
 *
 */ 0 
822 0 0 4 941 3129 0 0 171 /**
 * Sets this to the AABB (axis ligned bounding box) of the OBB (oriented
 * bounding box). The OBB is described by orientation, translation and half
 * dimensions.
 */ 4 4 this 3 3195  11 orientation 1 3165  11 translation 1 3143  9 half_dims 1 3162  
823 0 0 4 942 3129 0 0 49 /**
 * Sets this to the union of this and b2.
 */ 2 4 this 3 3195  2 b2 1 3196  
824 0 0 6 943 3132 0 0 60 /**
 * Returns TRUE if these bounds contain the point v.
 */ 2 4 this 3 3196  1 p 1 3143  
825 0 0 4 944 3129 0 0 74 /**
 * Fattens the AABB in all three dimensions by the given distance.
 */ 2 4 this 3 3195  8 distance 1 3149  
826 0 0 4 945 3129 0 0 53 /**
 * Expands the volume to include the point v.
 */ 2 4 this 3 3195  1 v 1 3143  
827 0 0 6 946 3132 0 0 74 /**
 * Returns TRUE if the intersection of this and b is is not empty.
 */ 2 4 this 3 3196  1 b 1 3196  
828 0 0 6 947 3132 0 0 146 /**
 * Indicates whether the intersection of this and b is empty or not in the
 * plane orthogonal to the axis passed (X = 0, Y = 1 or Z = 2).
 */ 3 4 this 3 3196  1 b 1 3196  14 axis_to_ignore 1 3150  
829 0 0 6 948 3132 0 0 53 /**
 * Returns TRUE if the bounding box is empty.
 */ 1 4 this 3 3196  
830 0 0 4 949 3129 0 0 47 /**
 * Scales the AABB by the given factor.
 */ 2 4 this 3 3195  5 scale 1 3149  
831 0 0 4 950 3129 0 0 66 /**
 * Setup this AABB from minimum corner and maximum corner.
 */ 3 4 this 3 3195  3 min 1 3143  3 max 1 3143  
832 0 0 4 951 3129 0 0 64 /**
 * Setup this AABB from center point and extents vector.
 */ 3 4 this 3 3195  6 center 1 3143  7 extents 1 3162  
833 0 0 4 952 3129 0 0 30 /**
 * Sets empty to TRUE.
 */ 1 4 this 3 3195  
834 0 0 4 953 3129 0 0 32 /**
 * Sets infinite bounds.
 */ 1 4 this 3 3195  
835 0 0 4 954 3129 0 0 185 /**
 * Transforms this volume as if it was an axis aligned bounding box, and then
 * assigns the results' bounds to this.  The orientation is applied first,
 * then the translation.
 */ 3 4 this 3 3195  11 orientation 1 3165  11 translation 1 3143  
836 0 0 7 955 3151 0 0 58 /**
 * Returns the minimum corner of the bounding box.
 */ 1 4 this 3 3196  
837 0 0 7 956 3151 0 0 58 /**
 * Returns the maximum corner of the bounding box.
 */ 1 4 this 3 3196  
838 0 0 7 957 3151 0 0 50 /**
 * Returns the center of the bounding box.
 */ 1 4 this 3 3196  
839 0 0 7 958 3169 0 0 51 /**
 * Returns the extents of the bounding box.
 */ 1 4 this 3 3196  
840 0 0 4 959 3129 0 0 55 /**
 * Sets the maximum corner of the bounding box.
 */ 2 4 this 3 3195  5 value 1 3151  
841 0 0 4 960 3129 0 0 55 /**
 * Sets the minimum corner of the bounding box.
 */ 2 4 this 3 3195  5 value 1 3151  
842 0 0 7 962 3430 2316 0 10 /**
 *
 */ 0 
843 0 0 7 962 3430 2316 0 10 /**
 *
 */ 3 6 center 1 3143  7 extents 1 3162  3 rot 1 3165  
844 0 0 6 964 3132 0 0 44 /**
 * Returns TRUE if the box is valid.
 */ 1 4 this 3 3200  
845 0 0 4 965 3129 0 0 75 /**
 * Recomputes the box after an arbitrary transform by a 4x4 matrix.
 */ 3 4 this 3 3200  1 m 1 3146  3 obb 1 3430  
846 0 0 4 966 3129 0 0 31 /**
 * Setups an empty box.
 */ 1 4 this 3 3430  
847 0 0 7 967 3151 0 0 36 /**
 * Return center of the box.
 */ 1 4 this 3 3200  
848 0 0 7 968 3169 0 0 50 /**
 * Returns the extents (radii) of the box.
 */ 1 4 this 3 3200  
849 0 0 7 969 3168 0 0 42 /**
 * Return the rotation of the box.
 */ 1 4 this 3 3200  
850 0 0 4 970 3129 0 0 38 /**
 * Sets the center of the box.
 */ 2 4 this 3 3430  6 center 1 3151  
851 0 0 4 971 3129 0 0 39 /**
 * Sets the extents of the box.
 */ 2 4 this 3 3430  7 extents 1 3169  
852 0 0 4 972 3129 0 0 40 /**
 * Sets the rotation of the box.
 */ 2 4 this 3 3430  3 rot 1 3168  
853 0 0 4 975 3129 0 0 0 1 4 this 3 3381  
854 0 0 6 976 3132 0 0 0 1 4 this 3 3431  
855 0 0 4 977 3129 0 0 45 /**
 * Set the position of the character.
 */ 2 4 this 3 3381  3 pos 1 3143  
856 0 0 4 978 3129 0 0 289 /**
 * Sets the maximum slope which the character can walk up.  In general it is
 * desirable to limit where the character can walk, in particular it is
 * unrealistic for the character to be able to climb arbitary slopes.  The
 * value is expressed in degrees.  Default: 45.0 degrees.
 */ 2 4 this 3 3381  10 slopeLimit 1 3149  
857 0 0 4 979 3129 0 0 258 /**
 * Sets the skin width used by the controller.  A "skin" around the controller
 * is necessary to avoid numerical precision issues.  This is dependant on the
 * scale of the users world, but should be a small, positive non zero value.
 * Default: 0.1
 */ 2 4 this 3 3381  9 skinWidth 1 3149  
858 0 0 4 980 3129 0 0 295 /**
 * Defines the maximum height of an obstacle which the character can climb.  A
 * small value will mean that the character gets stuck and cannot walk up
 * stairs etc, a value which is too large will mean that the character can
 * climb over unrealistically high obstacles.  Default: 0.5
 */ 2 4 this 3 3381  10 setpOffset 1 3149  
859 0 0 4 981 3129 0 0 153 /**
 * The interaction flag controls if a character controller collides with other
 * controllers.  The default is to collide with other controllers.
 */ 2 4 this 3 3381  15 interactionFlag 1 3132  
860 0 0 7 982 3151 0 0 49 /**
 * Returns the position of the character.
 */ 1 4 this 3 3431  
861 0 0 6 983 3149 0 0 69 /**
 * Returns the maximum slope which the character can walk up.
 */ 1 4 this 3 3431  
862 0 0 6 984 3149 0 0 57 /**
 * Returns the skin width used by the controller.
 */ 1 4 this 3 3431  
863 0 0 6 985 3149 0 0 83 /**
 * Returns the maximum height of an obstacle which the character can climb.
 */ 1 4 this 3 3431  
864 0 0 6 986 3132 0 0 40 /**
 * Returns the interaction flag.
 */ 1 4 this 3 3431  
865 0 0 7 988 3433 2326 0 10 /**
 *
 */ 0 
866 0 0 4 989 3129 0 0 186 /**
 * Sets the dimensions of the box.
 *
 * The dimensions are the 'radii' of the box, meaning 1/2 extents in x
 * dimension, 1/2 extents in y dimension, 1/2 extents in z dimension.
 */ 2 4 this 3 3433  7 extents 1 3162  
867 0 0 7 990 3169 0 0 45 /**
 * Returns the dimensions of the box.
 */ 1 4 this 3 3434  
868 0 0 4 992 3129 0 0 0 1 4 this 3 3314  
869 0 0 6 993 3132 0 0 0 1 4 this 3 3436  
870 0 0 4 994 3129 0 0 38 /**
 * Sets a possible debug name.
 */ 2 4 this 3 3314  4 name 1 3125  
871 0 0 4 995 3129 0 0 10 /**
 *
 */ 2 4 this 3 3314  3 pos 1 3143  
872 0 0 4 996 3129 0 0 10 /**
 *
 */ 2 4 this 3 3314  3 mat 1 3146  
873 0 0 4 997 3129 0 0 10 /**
 *
 */ 4 4 this 3 3314  1 h 1 3149  1 p 1 3149  1 r 1 3149  
874 0 0 6 998 3125 0 0 10 /**
 *
 */ 1 4 this 3 3436  
875 0 0 7 999 3151 0 0 10 /**
 *
 */ 1 4 this 3 3436  
876 0 0 7 1000 3152 0 0 10 /**
 *
 */ 1 4 this 3 3436  
877 0 0 7 1002 3184 2352 0 10 /**
 *
 */ 0 
878 0 0 4 1004 3129 0 0 186 /**
 * Sets the dimensions of the box.
 *
 * The dimensions are the 'radii' of the box, meaning 1/2 extents in x
 * dimension, 1/2 extents in y dimension, 1/2 extents in z dimension.
 */ 2 4 this 3 3184  10 dimensions 1 3162  
879 0 0 7 1005 3169 0 0 45 /**
 * Returns the dimensions of the box.
 */ 1 4 this 3 3438  
880 0 0 7 1007 3210 0 0 10 /**
 *
 */ 0 
881 0 0 4 1008 3129 0 0 186 /**
 * Sets the dimensions of the box.
 *
 * The dimensions are the 'radii' of the box, meaning 1/2 extents in x
 * dimension, 1/2 extents in y dimension, 1/2 extents in z dimension.
 */ 2 4 this 3 3210  10 dimensions 1 3162  
882 0 0 7 1009 3169 0 0 45 /**
 * Returns the dimensions of the box.
 */ 1 4 this 3 3440  
883 0 0 7 1011 3442 2359 0 10 /**
 *
 */ 0 
884 0 0 7 1011 3442 2359 0 10 /**
 *
 */ 2 2 p0 1 3143  2 p1 1 3143  
885 0 0 7 1011 3442 2359 0 10 /**
 *
 */ 1 7 segment 1 3443  
886 0 0 4 1013 3129 0 0 92 /**
 * Returns the direction vector from the segment's start point to it's end
 * point.
 */ 2 4 this 3 3443  3 dir 1 3151  
887 0 0 6 1014 3149 0 0 81 /**
 * Returns the distance from the segment's start point to it's end point.
 */ 1 4 this 3 3443  
888 0 0 4 1015 3129 0 0 43 /**
 * Computes a point on the segment.
 */ 3 4 this 3 3443  1 p 1 3151  1 t 1 3149  
889 0 0 6 1016 3149 0 0 91 /**
 * Returns the square distance from the segment's start point to it's end
 * point.
 */ 1 4 this 3 3443  
890 0 0 7 1017 3151 0 0 50 /**
 * Returns the start point of the segment.
 */ 1 4 this 3 3443  
891 0 0 4 1018 3129 0 0 77 /**
 * Setup this segment from origin (start point) and direction vector.
 */ 3 4 this 3 3442  6 origin 1 3143  9 direction 1 3162  
892 0 0 7 1019 3151 0 0 50 /**
 * Returns the start point of the segment.
 */ 1 4 this 3 3443  
893 0 0 7 1020 3151 0 0 48 /**
 * Returns the end point of the segment.
 */ 1 4 this 3 3443  
894 0 0 4 1021 3129 0 0 47 /**
 * Sets the start point of the segment.
 */ 2 4 this 3 3442  1 p 1 3151  
895 0 0 4 1022 3129 0 0 45 /**
 * Sets the end point of the segment.
 */ 2 4 this 3 3442  1 p 1 3151  
896 0 0 7 1024 3445 2371 0 10 /**
 *
 */ 0 
897 0 0 7 1024 3445 2371 0 10 /**
 *
 */ 2 7 segment 1 3443  6 radius 1 3149  
898 0 0 4 1026 3129 0 0 92 /**
 * Returns the direction vector from the segment's start point to it's end
 * point.
 */ 2 4 this 3 3198  3 dir 1 3151  
899 0 0 6 1027 3149 0 0 81 /**
 * Returns the distance from the segment's start point to it's end point.
 */ 1 4 this 3 3198  
900 0 0 4 1028 3129 0 0 43 /**
 * Computes a point on the segment.
 */ 3 4 this 3 3198  1 p 1 3151  1 t 1 3149  
901 0 0 6 1029 3149 0 0 91 /**
 * Returns the square distance from the segment's start point to it's end
 * point.
 */ 1 4 this 3 3198  
902 0 0 7 1030 3151 0 0 50 /**
 * Returns the start point of the segment.
 */ 1 4 this 3 3198  
903 0 0 4 1031 3129 0 0 77 /**
 * Setup this capsule from origin (start point) and direction vector.
 */ 3 4 this 3 3445  6 origin 1 3143  9 direction 1 3162  
904 0 0 6 1032 3149 0 0 40 /**
 * Returns the capsule's radius.
 */ 1 4 this 3 3198  
905 0 0 7 1033 3151 0 0 50 /**
 * Returns the start point of the segment.
 */ 1 4 this 3 3198  
906 0 0 7 1034 3151 0 0 48 /**
 * Returns the end point of the segment.
 */ 1 4 this 3 3198  
907 0 0 4 1035 3129 0 0 37 /**
 * Sets the capsule's radius.
 */ 2 4 this 3 3445  5 value 1 3149  
908 0 0 4 1036 3129 0 0 47 /**
 * Sets the start point of the segment.
 */ 2 4 this 3 3445  1 p 1 3151  
909 0 0 4 1037 3129 0 0 45 /**
 * Sets the end point of the segment.
 */ 2 4 this 3 3445  1 p 1 3151  
910 0 0 7 1039 3446 2326 0 10 /**
 *
 */ 0 
911 0 0 4 1040 3129 0 0 77 /**
 * Sets the radius of the capsule's hemispherical ends and its trunk.
 */ 2 4 this 3 3446  6 radius 1 3149  
912 0 0 4 1041 3129 0 0 79 /**
 * Sets the distance between the two hemispherical ends of the capsule.
 */ 2 4 this 3 3446  6 height 1 3149  
913 0 0 6 1042 3149 0 0 72 /**
 * The radius of the capsule's hemispherical ends and its trunk.
 */ 1 4 this 3 3447  
914 0 0 6 1043 3149 0 0 74 /**
 * The distance between the two hemispherical ends of the capsule.
 */ 1 4 this 3 3447  
915 0 0 7 1045 3217 2390 0 10 /**
 *
 */ 0 
916 0 0 4 1047 3129 0 0 77 /**
 * Sets the radius of the capsule's hemispherical ends and its trunk.
 */ 2 4 this 3 3217  6 radius 1 3149  
917 0 0 4 1048 3129 0 0 79 /**
 * Sets the distance between the two hemispherical ends of the capsule.
 */ 2 4 this 3 3217  6 height 1 3149  
918 0 0 6 1049 3149 0 0 72 /**
 * The radius of the capsule's hemispherical ends and its trunk.
 */ 1 4 this 3 3449  
919 0 0 6 1050 3149 0 0 74 /**
 * The distance between the two hemispherical ends of the capsule.
 */ 1 4 this 3 3449  
920 0 0 7 1052 3221 0 0 10 /**
 *
 */ 0 
921 0 0 4 1053 3129 0 0 77 /**
 * Sets the radius of the capsule's hemispherical ends and its trunk.
 */ 2 4 this 3 3221  6 radius 1 3149  
922 0 0 4 1054 3129 0 0 79 /**
 * Sets the distance between the two hemispherical ends of the capsule.
 */ 2 4 this 3 3221  6 height 1 3149  
923 0 0 6 1055 3149 0 0 72 /**
 * The radius of the capsule's hemispherical ends and its trunk.
 */ 1 4 this 3 3451  
924 0 0 6 1056 3149 0 0 74 /**
 * The distance between the two hemispherical ends of the capsule.
 */ 1 4 this 3 3451  
925 0 0 7 1058 3453 2401 0 10 /**
 *
 */ 0 
926 0 0 7 1058 3453 2401 0 0 1 6 param0 0 3454  
927 0 0 7 1060 3246 0 0 10 /**
 *
 */ 1 8 filename 1 3231  
928 0 0 7 1061 3247 0 0 10 /**
 *
 */ 1 8 filename 1 3231  
929 0 0 7 1062 3230 0 0 10 /**
 *
 */ 1 8 filename 1 3231  
930 0 0 7 1063 3248 0 0 10 /**
 *
 */ 1 8 filename 1 3231  
931 0 0 6 1064 3132 0 0 10 /**
 *
 */ 1 4 mesh 1 3246  
932 0 0 6 1065 3132 0 0 10 /**
 *
 */ 1 4 mesh 1 3247  
933 0 0 6 1066 3132 0 0 10 /**
 *
 */ 1 4 mesh 1 3230  
934 0 0 6 1067 3132 0 0 10 /**
 *
 */ 1 4 mesh 1 3248  
935 0 0 4 1068 3129 0 0 10 /**
 *
 */ 0 
936 0 0 4 1068 3129 0 0 10 /**
 *
 */ 1 3 out 1 3133  
937 0 0 7 1070 3249 2412 0 10 /**
 *
 */ 0 
938 0 0 6 1072 3132 0 0 51 /**
 * Returns true if the descriptor is valid.
 */ 1 4 this 3 3456  
939 0 0 4 1073 3129 0 0 241 /**
 * Sets the number of vertices to be stored within this triangle mesh.  The
 * function allocates memory for the vertices, but it does not set any
 * vertices.
 *
 * This method must be called before any calls to set_vertex are done!
 */ 2 4 this 3 3249  1 n 1 3150  
940 0 0 4 1074 3129 0 0 118 /**
 * Sets a single vertex.  You have to call the function set_num_vertices
 * before you can call this function.
 */ 3 4 this 3 3249  3 idx 1 3150  4 vert 1 3143  
941 0 0 4 1075 3129 0 0 151 /**
 * Sets the number of triangles to be stored in this triangle mesh.
 *
 * This method must be called before any calls to set_triangle are done!
 */ 2 4 this 3 3249  1 n 1 3150  
942 0 0 4 1076 3129 0 0 77 /**
 * Sets a single triangle, by providing the three indices i1, i2, i3.
 */ 5 4 this 3 3249  3 idx 1 3150  2 i1 1 3150  2 i2 1 3150  2 i3 1 3150  
943 0 0 4 1077 3129 0 0 308 /**
 * A convenience method to set the mesh data from a NodePath in a single call.
 * The method iterates over the NodePath geoms and collects data for the
 * triangle mesh.
 *
 * Do not use the following function when using this one: - set_num_vertices -
 * set_vertex - set_num_triangles - set_triangle
 */ 2 4 this 3 3249  2 np 1 3156  
944 0 0 7 1079 3383 2420 0 10 /**
 *
 */ 0 
945 0 0 4 1081 3129 0 0 49 /**
 * (re)sets the structure to the default.
 */ 1 4 this 3 3383  
946 0 0 6 1082 3132 0 0 51 /**
 * Returns true if the descriptor is valid.
 */ 1 4 this 3 3458  
947 0 0 4 1083 3129 0 0 10 /**
 *
 */ 2 4 this 3 3383  4 mesh 1 3230  
948 0 0 4 1084 3129 0 0 10 /**
 *
 */ 2 4 this 3 3383  4 name 1 3125  
949 0 0 4 1085 3129 0 0 10 /**
 *
 */ 2 4 this 3 3383  3 pos 1 3143  
950 0 0 4 1086 3129 0 0 10 /**
 *
 */ 2 4 this 3 3383  3 mat 1 3146  
951 0 0 4 1087 3129 0 0 10 /**
 *
 */ 4 4 this 3 3383  1 h 1 3149  1 p 1 3149  1 r 1 3149  
952 0 0 4 1088 3129 0 0 10 /**
 *
 */ 2 4 this 3 3383  9 thickness 1 3149  
953 0 0 4 1089 3129 0 0 10 /**
 *
 */ 2 4 this 3 3383  7 density 1 3149  
954 0 0 4 1090 3129 0 0 10 /**
 *
 */ 2 4 this 3 3383  9 stiffness 1 3149  
955 0 0 4 1091 3129 0 0 10 /**
 *
 */ 2 4 this 3 3383  9 stiffness 1 3149  
956 0 0 4 1092 3129 0 0 10 /**
 *
 */ 2 4 this 3 3383  7 damping 1 3149  
957 0 0 4 1093 3129 0 0 10 /**
 *
 */ 2 4 this 3 3383  8 friction 1 3149  
958 0 0 4 1094 3129 0 0 10 /**
 *
 */ 2 4 this 3 3383  8 pressure 1 3149  
959 0 0 4 1095 3129 0 0 10 /**
 *
 */ 2 4 this 3 3383  10 tearFactor 1 3149  
960 0 0 4 1096 3129 0 0 117 /**
 * Number of solver iterations.  Small numbers make the simulation faster
 * while the cloth gets less stiff.
 */ 2 4 this 3 3383  11 interations 1 3150  
961 0 0 4 1097 3129 0 0 53 /**
 * Raise or lower individual ClothFlag flags.
 */ 3 4 this 3 3383  4 flag 1 2970  5 value 1 3132  
962 0 0 6 1098 3125 0 0 10 /**
 *
 */ 1 4 this 3 3458  
963 0 0 7 1099 3151 0 0 10 /**
 *
 */ 1 4 this 3 3458  
964 0 0 7 1100 3152 0 0 10 /**
 *
 */ 1 4 this 3 3458  
965 0 0 6 1101 3149 0 0 10 /**
 *
 */ 1 4 this 3 3458  
966 0 0 6 1102 3149 0 0 10 /**
 *
 */ 1 4 this 3 3458  
967 0 0 6 1103 3149 0 0 10 /**
 *
 */ 1 4 this 3 3458  
968 0 0 6 1104 3149 0 0 10 /**
 *
 */ 1 4 this 3 3458  
969 0 0 6 1105 3149 0 0 10 /**
 *
 */ 1 4 this 3 3458  
970 0 0 6 1106 3149 0 0 10 /**
 *
 */ 1 4 this 3 3458  
971 0 0 6 1107 3149 0 0 10 /**
 *
 */ 1 4 this 3 3458  
972 0 0 6 1108 3149 0 0 10 /**
 *
 */ 1 4 this 3 3458  
973 0 0 6 1109 3150 0 0 10 /**
 *
 */ 1 4 this 3 3458  
974 0 0 6 1110 3132 0 0 10 /**
 *
 */ 2 4 this 3 3458  4 flag 1 2970  
975 0 0 7 1112 3460 2452 0 10 /**
 *
 */ 0 
976 0 0 6 1114 3132 0 0 51 /**
 * Returns true if the descriptor is valid.
 */ 1 4 this 3 3461  
977 0 0 4 1115 3129 0 0 241 /**
 * Sets the number of vertices to be stored within this triangle mesh.  The
 * function allocates memory for the vertices, but it does not set any
 * vertices.
 *
 * This method must be called before any calls to set_vertex are done!
 */ 2 4 this 3 3460  1 n 1 3150  
978 0 0 4 1116 3129 0 0 118 /**
 * Sets a single vertex.  You have to call the function set_num_vertices
 * before you can call this function.
 */ 4 4 this 3 3460  3 idx 1 3150  4 vert 1 3143  8 texcoord 1 3463  
979 0 0 4 1117 3129 0 0 151 /**
 * Sets the number of triangles to be stored in this triangle mesh.
 *
 * This method must be called before any calls to set_triangle are done!
 */ 2 4 this 3 3460  1 n 1 3150  
980 0 0 4 1118 3129 0 0 77 /**
 * Sets a single triangle, by providing the three indices i1, i2, i3.
 */ 5 4 this 3 3460  3 idx 1 3150  2 i1 1 3150  2 i2 1 3150  2 i3 1 3150  
981 0 0 4 1119 3129 0 0 308 /**
 * A convenience method to set the mesh data from a NodePath in a single call.
 * The method iterates over the NodePath geoms and collects data for the
 * triangle mesh.
 *
 * Do not use the following function when using this one: - set_num_vertices -
 * set_vertex - set_num_triangles - set_triangle
 */ 2 4 this 3 3460  2 np 1 3156  
982 0 0 7 1121 3389 2460 0 0 1 6 param0 0 3466  
983 0 0 7 1121 3389 2460 0 10 /**
 *
 */ 2 2 d0 1 3149  2 d1 1 3149  
984 0 0 6 1123 3149 0 0 46 /**
 * Retruns the first dominance factor.
 */ 1 4 this 3 3466  
985 0 0 6 1124 3149 0 0 47 /**
 * Returns the second dominance factor.
 */ 1 4 this 3 3466  
986 0 0 4 1125 3129 0 0 43 /**
 * Sets the first dominance factor.
 */ 2 4 this 3 3389  2 d0 1 3149  
987 0 0 4 1126 3129 0 0 44 /**
 * Sets the second dominance factor.
 */ 2 4 this 3 3389  2 d1 1 3149  
988 0 0 7 1128 3272 2466 0 10 /**
 *
 */ 0 
989 0 0 4 1130 3129 0 0 59 /**
 * Sets the convex mesh for this force field shape.
 */ 2 4 this 3 3272  4 mesh 1 3246  
990 0 0 7 1132 3468 2469 0 10 /**
 *
 */ 0 
991 0 0 6 1134 3132 0 0 51 /**
 * Returns true if the descriptor is valid.
 */ 1 4 this 3 3469  
992 0 0 4 1135 3129 0 0 320 /**
 * Sets the number of vertices to be stored within this convex mesh.  The
 * function allocates memory for the vertices, but it does not set any
 * vertices.
 *
 * This method must be called before any calls to set_vertex are done!
 *
 * The number of vertices in a single convex mesh has to be smaller than 256.
 */ 2 4 this 3 3468  1 n 1 3150  
993 0 0 4 1136 3129 0 0 118 /**
 * Sets a single vertex.  You have to call the function set_num_vertices
 * before you can call this function.
 */ 3 4 this 3 3468  3 idx 1 3150  4 vert 1 3143  
994 0 0 4 1137 3129 0 0 271 /**
 * A convenience method to set the mesh data from a NodePath in a single call.
 * The method iterates over the NodePath geoms and collects data for the
 * convex mesh.
 *
 * Do not use the following function when using this one: - set_num_vertices -
 * set_vertex
 */ 2 4 this 3 3468  2 np 1 3156  
995 0 0 7 1139 3276 0 0 10 /**
 *
 */ 0 
996 0 0 4 1140 3129 0 0 10 /**
 *
 */ 2 4 this 3 3276  4 mesh 1 3246  
997 0 0 4 1144 3129 0 0 0 1 4 this 3 3380  
998 0 0 6 1145 3132 0 0 0 1 4 this 3 3471  
999 0 0 4 1146 3129 0 0 38 /**
 * Sets a possible debug name.
 */ 2 4 this 3 3380  4 name 1 3125  
1000 0 0 4 1147 3129 0 0 43 /**
 * Set or clear a single JointFlag.
 */ 3 4 this 3 3380  4 flag 1 2981  5 value 1 3132  
1001 0 0 4 1148 3129 0 0 37 /**
 * Set a possible debug name.
 */ 2 4 this 3 3380  5 force 1 3149  
1002 0 0 4 1149 3129 0 0 116 /**
 * Set the maximum angular force (torque) that the joint can withstand before
 * breaking, must be positive.
 */ 2 4 this 3 3380  6 torque 1 3149  
1003 0 0 4 1150 3129 0 0 70 /**
 * Set the extrapolation factor for solving joint constraints.
 */ 2 4 this 3 3380  6 factor 1 3149  
1004 0 0 4 1151 3129 0 0 62 /**
 * Set the local axis/normal using a world space axis.
 */ 2 4 this 3 3380  4 axis 1 3162  
1005 0 0 4 1152 3129 0 0 52 /**
 * Set the anchor using a world space point.
 */ 2 4 this 3 3380  6 anchor 1 3143  
1006 0 0 4 1153 3129 0 0 120 /**
 * Set the X axis of joint space, in actor[i]'s space, orthogonal to
 * localAxis[i]. idx must be either 0 or 1.
 */ 3 4 this 3 3380  3 idx 1 3150  6 normal 1 3162  
1007 0 0 4 1154 3129 0 0 133 /**
 * Set the Z axis of joint space, in actor[i]'s space.  This is the primary
 * axis of the joint.  idx must be either 0 or 1.
 */ 3 4 this 3 3380  3 idx 1 3150  4 axis 1 3162  
1008 0 0 4 1155 3129 0 0 96 /**
 * Set the attachment point of joint in actor[i]'s space.  idx must be either
 * 0 or 1.
 */ 3 4 this 3 3380  3 idx 1 3150  6 anchor 1 3143  
1009 0 0 4 1156 3129 0 0 81 /**
 * Set the two actors connected by the joint.  idx must be either 0 or 1.
 */ 3 4 this 3 3380  3 idx 1 3150  5 actor 1 3139  
1010 0 0 6 1157 3125 0 0 10 /**
 *
 */ 1 4 this 3 3471  
1011 0 0 6 1158 3132 0 0 0 2 4 this 3 3471  4 flag 1 2981  
1012 0 0 6 1159 3149 0 0 10 /**
 *
 */ 1 4 this 3 3471  
1013 0 0 6 1160 3149 0 0 10 /**
 *
 */ 1 4 this 3 3471  
1014 0 0 6 1161 3149 0 0 10 /**
 *
 */ 1 4 this 3 3471  
1015 0 0 7 1162 3169 0 0 10 /**
 *
 */ 2 4 this 3 3471  3 idx 1 3150  
1016 0 0 7 1163 3169 0 0 10 /**
 *
 */ 2 4 this 3 3471  3 idx 1 3150  
1017 0 0 7 1164 3151 0 0 10 /**
 *
 */ 2 4 this 3 3471  3 idx 1 3150  
1018 0 0 7 1165 3138 1486 0 10 /**
 *
 */ 2 4 this 3 3471  3 idx 1 3150  
1019 0 0 6 1142 3121 0 0 0 1 4 this 3 3380  
1020 0 0 6 1143 3380 0 0 0 1 4 this 3 3121  
1021 0 0 7 1167 3283 2501 0 10 /**
 *
 */ 0 
1022 0 0 7 1170 3289 2503 0 10 /**
 *
 */ 0 
1023 0 0 4 1172 3129 0 0 52 /**
 * Sets or clears a single D6JointFlag flag.
 */ 3 4 this 3 3289  4 flag 1 2974  5 value 1 3132  
1024 0 0 4 1173 3129 0 0 10 /**
 *
 */ 2 4 this 3 3289  8 distance 1 3149  
1025 0 0 4 1174 3129 0 0 10 /**
 *
 */ 2 4 this 3 3289  5 angle 1 3149  
1026 0 0 4 1175 3129 0 0 10 /**
 *
 */ 2 4 this 3 3289  5 ratio 1 3149  
1027 0 0 4 1176 3129 0 0 10 /**
 *
 */ 2 4 this 3 3289  3 pos 1 3143  
1028 0 0 4 1177 3129 0 0 10 /**
 *
 */ 2 4 this 3 3289  1 v 1 3162  
1029 0 0 4 1178 3129 0 0 10 /**
 *
 */ 2 4 this 3 3289  1 v 1 3162  
1030 0 0 4 1179 3129 0 0 10 /**
 *
 */ 2 4 this 3 3289  4 quat 1 3292  
1031 0 0 4 1180 3129 0 0 68 /**
 * Use this to enable joint projection.  Default is PM_none.
 */ 2 4 this 3 3289  4 mode 1 2983  
1032 0 0 4 1181 3129 0 0 10 /**
 *
 */ 2 4 this 3 3289  7 xMotion 1 2975  
1033 0 0 4 1182 3129 0 0 10 /**
 *
 */ 2 4 this 3 3289  7 yMotion 1 2975  
1034 0 0 4 1183 3129 0 0 10 /**
 *
 */ 2 4 this 3 3289  7 zMotion 1 2975  
1035 0 0 4 1184 3129 0 0 10 /**
 *
 */ 2 4 this 3 3289  7 xMotion 1 2975  
1036 0 0 4 1185 3129 0 0 10 /**
 *
 */ 2 4 this 3 3289  7 yMotion 1 2975  
1037 0 0 4 1186 3129 0 0 10 /**
 *
 */ 2 4 this 3 3289  7 zMotion 1 2975  
1038 0 0 4 1187 3129 0 0 10 /**
 *
 */ 2 4 this 3 3289  5 drive 1 3473  
1039 0 0 4 1188 3129 0 0 10 /**
 *
 */ 2 4 this 3 3289  5 drive 1 3473  
1040 0 0 4 1189 3129 0 0 10 /**
 *
 */ 2 4 this 3 3289  5 drive 1 3473  
1041 0 0 4 1190 3129 0 0 10 /**
 *
 */ 2 4 this 3 3289  5 drive 1 3473  
1042 0 0 4 1191 3129 0 0 10 /**
 *
 */ 2 4 this 3 3289  5 drive 1 3473  
1043 0 0 4 1192 3129 0 0 10 /**
 *
 */ 2 4 this 3 3289  5 drive 1 3473  
1044 0 0 4 1193 3129 0 0 10 /**
 *
 */ 2 4 this 3 3289  5 limit 1 3475  
1045 0 0 4 1194 3129 0 0 10 /**
 *
 */ 2 4 this 3 3289  5 limit 1 3475  
1046 0 0 4 1195 3129 0 0 10 /**
 *
 */ 2 4 this 3 3289  5 limit 1 3475  
1047 0 0 4 1196 3129 0 0 10 /**
 *
 */ 2 4 this 3 3289  5 limit 1 3475  
1048 0 0 4 1197 3129 0 0 10 /**
 *
 */ 2 4 this 3 3289  5 limit 1 3475  
1049 0 0 6 1198 3132 0 0 10 /**
 *
 */ 2 4 this 3 3290  4 flag 1 2974  
1050 0 0 6 1199 3149 0 0 10 /**
 *
 */ 1 4 this 3 3290  
1051 0 0 6 1200 3149 0 0 10 /**
 *
 */ 1 4 this 3 3290  
1052 0 0 6 1201 3149 0 0 10 /**
 *
 */ 1 4 this 3 3290  
1053 0 0 7 1202 3151 0 0 10 /**
 *
 */ 1 4 this 3 3290  
1054 0 0 7 1203 3169 0 0 10 /**
 *
 */ 1 4 this 3 3290  
1055 0 0 7 1204 3169 0 0 10 /**
 *
 */ 1 4 this 3 3290  
1056 0 0 7 1205 3154 0 0 10 /**
 *
 */ 1 4 this 3 3290  
1057 0 0 6 1206 2983 0 0 10 /**
 *
 */ 1 4 this 3 3290  
1058 0 0 6 1207 2975 0 0 10 /**
 *
 */ 1 4 this 3 3290  
1059 0 0 6 1208 2975 0 0 10 /**
 *
 */ 1 4 this 3 3290  
1060 0 0 6 1209 2975 0 0 10 /**
 *
 */ 1 4 this 3 3290  
1061 0 0 6 1210 2975 0 0 10 /**
 *
 */ 1 4 this 3 3290  
1062 0 0 6 1211 2975 0 0 10 /**
 *
 */ 1 4 this 3 3290  
1063 0 0 6 1212 2975 0 0 10 /**
 *
 */ 1 4 this 3 3290  
1064 0 0 7 1213 3477 2557 0 10 /**
 *
 */ 1 4 this 3 3290  
1065 0 0 7 1214 3477 2557 0 10 /**
 *
 */ 1 4 this 3 3290  
1066 0 0 7 1215 3477 2557 0 10 /**
 *
 */ 1 4 this 3 3290  
1067 0 0 7 1216 3477 2557 0 10 /**
 *
 */ 1 4 this 3 3290  
1068 0 0 7 1217 3477 2557 0 10 /**
 *
 */ 1 4 this 3 3290  
1069 0 0 7 1218 3477 2557 0 10 /**
 *
 */ 1 4 this 3 3290  
1070 0 0 7 1219 3478 2567 0 10 /**
 *
 */ 1 4 this 3 3290  
1071 0 0 7 1220 3478 2567 0 10 /**
 *
 */ 1 4 this 3 3290  
1072 0 0 7 1221 3478 2567 0 10 /**
 *
 */ 1 4 this 3 3290  
1073 0 0 7 1222 3478 2567 0 10 /**
 *
 */ 1 4 this 3 3290  
1074 0 0 7 1223 3478 2567 0 10 /**
 *
 */ 1 4 this 3 3290  
1075 0 0 7 1225 3477 2557 0 10 /**
 *
 */ 0 
1076 0 0 7 1225 3477 2557 0 10 /**
 *
 */ 3 5 sping 1 3149  7 damping 1 3149  10 forceLimit 1 3149  
1077 0 0 4 1227 3129 0 0 10 /**
 *
 */ 2 4 this 3 3477  4 type 1 2973  
1078 0 0 4 1228 3129 0 0 10 /**
 *
 */ 2 4 this 3 3477  6 spring 1 3149  
1079 0 0 4 1229 3129 0 0 10 /**
 *
 */ 2 4 this 3 3477  7 damping 1 3149  
1080 0 0 4 1230 3129 0 0 10 /**
 *
 */ 2 4 this 3 3477  5 limit 1 3149  
1081 0 0 6 1231 2973 0 0 10 /**
 *
 */ 1 4 this 3 3473  
1082 0 0 6 1232 3149 0 0 10 /**
 *
 */ 1 4 this 3 3473  
1083 0 0 6 1233 3149 0 0 10 /**
 *
 */ 1 4 this 3 3473  
1084 0 0 6 1234 3149 0 0 10 /**
 *
 */ 1 4 this 3 3473  
1085 0 0 7 1236 3478 2567 0 10 /**
 *
 */ 0 
1086 0 0 7 1236 3478 2567 0 10 /**
 *
 */ 4 5 value 1 3149  11 restitution 1 3149  6 spring 1 3149  7 damping 1 3149  
1087 0 0 4 1238 3129 0 0 10 /**
 *
 */ 2 4 this 3 3478  5 value 1 3149  
1088 0 0 4 1239 3129 0 0 10 /**
 *
 */ 2 4 this 3 3478  11 restitution 1 3149  
1089 0 0 4 1240 3129 0 0 10 /**
 *
 */ 2 4 this 3 3478  6 spring 1 3149  
1090 0 0 4 1241 3129 0 0 10 /**
 *
 */ 2 4 this 3 3478  7 damping 1 3149  
1091 0 0 6 1242 3149 0 0 10 /**
 *
 */ 1 4 this 3 3475  
1092 0 0 6 1243 3149 0 0 10 /**
 *
 */ 1 4 this 3 3475  
1093 0 0 6 1244 3149 0 0 10 /**
 *
 */ 1 4 this 3 3475  
1094 0 0 6 1245 3149 0 0 10 /**
 *
 */ 1 4 this 3 3475  
1095 0 0 7 1247 3300 2577 0 10 /**
 *
 */ 0 
1096 0 0 4 1249 3129 0 0 92 /**
 * Sets the maximum rest length of the rope or rod between the two anchor
 * points.
 */ 2 4 this 3 3300  8 distance 1 3149  
1097 0 0 4 1250 3129 0 0 91 /**
 * Sets the minimum rest length of the rope or rod between the two anchor
 * points
 */ 2 4 this 3 3300  8 distance 1 3149  
1098 0 0 4 1251 3129 0 0 72 /**
 * Makes the joint springy.  The spring.targetValue is not used.
 */ 2 4 this 3 3300  6 spring 1 3362  
1099 0 0 4 1252 3129 0 0 58 /**
 * Sets or clears a single DistanceJointFlag flag.
 */ 3 4 this 3 3300  4 flag 1 2976  5 value 1 3132  
1100 0 0 6 1253 3149 0 0 10 /**
 *
 */ 1 4 this 3 3301  
1101 0 0 6 1254 3149 0 0 10 /**
 *
 */ 1 4 this 3 3301  
1102 0 0 6 1255 3132 0 0 50 /**
 * Return a single DistanceJointFlag flag.
 */ 2 4 this 3 3301  4 flag 1 2976  
1103 0 0 7 1256 3366 2587 0 10 /**
 *
 */ 1 4 this 3 3301  
1104 0 0 7 1258 3366 2587 0 10 /**
 *
 */ 0 
1105 0 0 7 1258 3366 2587 0 10 /**
 *
 */ 3 6 spring 1 3149  6 damper 1 3149  11 targetValue 1 3149  
1106 0 0 4 1260 3129 0 0 10 /**
 *
 */ 2 4 this 3 3366  6 spring 1 3149  
1107 0 0 4 1261 3129 0 0 10 /**
 *
 */ 2 4 this 3 3366  6 damper 1 3149  
1108 0 0 4 1262 3129 0 0 10 /**
 *
 */ 2 4 this 3 3366  6 target 1 3149  
1109 0 0 6 1263 3149 0 0 10 /**
 *
 */ 1 4 this 3 3362  
1110 0 0 6 1264 3149 0 0 10 /**
 *
 */ 1 4 this 3 3362  
1111 0 0 6 1265 3149 0 0 10 /**
 *
 */ 1 4 this 3 3362  
1112 0 0 7 1267 3306 2595 0 10 /**
 *
 */ 0 
1113 0 0 7 1270 3382 2597 0 10 /**
 *
 */ 0 
1114 0 0 4 1272 3129 0 0 49 /**
 * (re)sets the structure to the default.
 */ 1 4 this 3 3382  
1115 0 0 6 1273 3132 0 0 51 /**
 * Returns true if the descriptor is valid.
 */ 1 4 this 3 3479  
1116 0 0 4 1274 3129 0 0 10 /**
 *
 */ 2 4 this 3 3382  4 name 1 3125  
1117 0 0 4 1275 3129 0 0 10 /**
 *
 */ 2 4 this 3 3382  3 pos 1 3143  
1118 0 0 4 1276 3129 0 0 10 /**
 *
 */ 2 4 this 3 3382  3 mat 1 3146  
1119 0 0 4 1277 3129 0 0 10 /**
 *
 */ 4 4 this 3 3382  1 h 1 3149  1 p 1 3149  1 r 1 3149  
1120 0 0 4 1278 3129 0 0 10 /**
 *
 */ 2 4 this 3 3382  11 coordinates 1 2978  
1121 0 0 4 1279 3129 0 0 10 /**
 *
 */ 2 4 this 3 3382  5 actor 1 3138  
1122 0 0 4 1280 3129 0 0 10 /**
 *
 */ 2 4 this 3 3382  8 constant 1 3162  
1123 0 0 4 1281 3129 0 0 10 /**
 *
 */ 2 4 this 3 3382  6 target 1 3143  
1124 0 0 4 1282 3129 0 0 10 /**
 *
 */ 2 4 this 3 3382  10 multiplier 1 3165  
1125 0 0 4 1283 3129 0 0 10 /**
 *
 */ 2 4 this 3 3382  6 target 1 3162  
1126 0 0 4 1284 3129 0 0 10 /**
 *
 */ 2 4 this 3 3382  10 multiplier 1 3165  
1127 0 0 4 1285 3129 0 0 10 /**
 *
 */ 2 4 this 3 3382  6 radius 1 3149  
1128 0 0 4 1286 3129 0 0 10 /**
 *
 */ 2 4 this 3 3382  7 falloff 1 3162  
1129 0 0 4 1287 3129 0 0 10 /**
 *
 */ 2 4 this 3 3382  7 falloff 1 3162  
1130 0 0 4 1288 3129 0 0 10 /**
 *
 */ 2 4 this 3 3382  5 noise 1 3162  
1131 0 0 4 1289 3129 0 0 10 /**
 *
 */ 2 4 this 3 3382  9 shapeDesc 1 3314  
1132 0 0 4 1290 3129 0 0 10 /**
 *
 */ 2 4 this 3 3382  5 group 1 3180  
1133 0 0 7 1292 3313 2618 0 10 /**
 *
 */ 0 
1134 0 0 4 1294 3129 0 0 49 /**
 * (re)sets the structure to the default.
 */ 1 4 this 3 3313  
1135 0 0 6 1295 3132 0 0 51 /**
 * Returns true if the descriptor is valid.
 */ 1 4 this 3 3481  
1136 0 0 4 1296 3129 0 0 85 /**
 * Adds a shape to the list of force field shapes composing this shape group.
 */ 2 4 this 3 3313  4 desc 1 3314  
1137 0 0 4 1297 3129 0 0 72 /**
 * Sets the optional debug name for the force field shape group.
 */ 2 4 this 3 3313  4 name 1 3125  
1138 0 0 4 1298 3129 0 0 0 3 4 this 3 3313  4 flag 1 2979  5 value 1 3132  
1139 0 0 6 1299 3125 0 0 76 /**
 * Returns the optional debug name for this force field shape group.
 */ 1 4 this 3 3481  
1140 0 0 6 1300 3132 0 0 0 2 4 this 3 3481  4 flag 1 2979  
1141 0 0 7 1302 3244 2627 0 10 /**
 *
 */ 0 
1142 0 0 4 1304 3129 0 0 49 /**
 * (re)sets the structure to the default.
 */ 1 4 this 3 3244  
1143 0 0 6 1305 3132 0 0 51 /**
 * Returns true if the descriptor is valid.
 */ 1 4 this 3 3483  
1144 0 0 4 1306 3129 0 0 10 /**
 *
 */ 3 4 this 3 3244  8 num_rows 1 3150  11 num_columns 1 3150  
1145 0 0 4 1307 3129 0 0 10 /**
 *
 */ 3 4 this 3 3244  5 image 1 3485  13 materialIndex 1 3188  
1146 0 0 4 1308 3129 0 0 10 /**
 *
 */ 2 4 this 3 3244  9 thickness 1 3149  
1147 0 0 4 1309 3129 0 0 10 /**
 *
 */ 2 4 this 3 3244  9 threshold 1 3149  
1148 0 0 4 1310 3129 0 0 10 /**
 *
 */ 4 4 this 3 3244  3 row 1 3150  6 column 1 3150  6 height 1 3488  
1149 0 0 4 1311 3129 0 0 10 /**
 *
 */ 4 4 this 3 3244  3 row 1 3150  6 column 1 3150  5 value 1 3188  
1150 0 0 4 1312 3129 0 0 10 /**
 *
 */ 5 4 this 3 3244  3 row 1 3150  6 column 1 3150  14 materialIndex0 1 3188  14 materialIndex1 1 3188  
1151 0 0 7 1314 3320 0 0 10 /**
 *
 */ 0 
1152 0 0 4 1315 3129 0 0 10 /**
 *
 */ 2 4 this 3 3320  2 hf 1 3315  
1153 0 0 4 1316 3129 0 0 10 /**
 *
 */ 2 4 this 3 3320  10 dimensions 1 3162  
1154 0 0 4 1317 3129 0 0 206 /**
 * Sets the the material index that designates holes in the height field.
 * This number is compared directly to sample materials.  Consequently the
 * high 9 bits must be zero.  Default value is 0.
 */ 2 4 this 3 3320  5 index 1 3188  
1155 0 0 4 1318 3129 0 0 171 /**
 * Sets the high 9 bits of this number are used to complete the material
 * indices in the samples.  The remaining low 7 bits must be zero.  Default
 * value is 0.
 */ 2 4 this 3 3320  5 index 1 3188  
1156 0 0 6 1319 3188 0 0 84 /**
 * Returns the the material index that designates holes in the height field.
 */ 1 4 this 3 3489  
1157 0 0 6 1320 3188 0 0 110 /**
 * Returns the high 9 bits of this number are used to complete the material
 * indices in the samples.
 */ 1 4 this 3 3489  
1158 0 0 7 1322 3491 2645 0 10 /**
 *
 */ 0 
1159 0 0 7 1322 3491 2645 0 10 /**
 *
 */ 3 5 value 1 3149  11 restitution 1 3149  8 hardness 1 3149  
1160 0 0 4 1324 3129 0 0 10 /**
 *
 */ 2 4 this 3 3491  5 value 1 3149  
1161 0 0 4 1325 3129 0 0 10 /**
 *
 */ 2 4 this 3 3491  11 restitution 1 3149  
1162 0 0 4 1326 3129 0 0 10 /**
 *
 */ 2 4 this 3 3491  8 hardness 1 3149  
1163 0 0 6 1327 3149 0 0 10 /**
 *
 */ 1 4 this 3 3364  
1164 0 0 6 1328 3149 0 0 10 /**
 *
 */ 1 4 this 3 3364  
1165 0 0 6 1329 3149 0 0 10 /**
 *
 */ 1 4 this 3 3364  
1166 0 0 7 1331 3492 2653 0 10 /**
 *
 */ 0 
1167 0 0 7 1331 3492 2653 0 0 1 6 param0 0 3493  
1168 0 0 4 1333 3129 0 0 479 /**
 * Sets two parameters which affect mesh cooking:
 *
 * Skin width for convex meshes: Specifies the amount to inflate the convex
 * mesh by when the new convex hull generator is used.  Inflating the mesh
 * allows the user to hide interpenetration errors by increasing the size of
 * the collision mesh with respect to the size of the rendered geometry.
 * Default value: 0.025f
 *
 * Hint to choose speed or less memory for collision structures.  Default
 * value: false
 */ 3 4 this 3 3492  9 skinWidth 1 3149  18 hintCollisionSpeed 1 3132  
1169 0 0 7 1334 3246 0 0 10 /**
 *
 */ 2 4 this 3 3492  8 meshDesc 1 3469  
1170 0 0 6 1334 3132 0 0 10 /**
 *
 */ 3 4 this 3 3492  8 meshDesc 1 3469  8 filename 1 3231  
1171 0 0 7 1335 3247 0 0 10 /**
 *
 */ 2 4 this 3 3492  8 meshDesc 1 3495  
1172 0 0 6 1335 3132 0 0 10 /**
 *
 */ 3 4 this 3 3492  8 meshDesc 1 3495  8 filename 1 3231  
1173 0 0 7 1336 3230 0 0 10 /**
 *
 */ 2 4 this 3 3492  8 meshDesc 1 3461  
1174 0 0 6 1336 3132 0 0 10 /**
 *
 */ 3 4 this 3 3492  8 meshDesc 1 3461  8 filename 1 3231  
1175 0 0 7 1337 3248 0 0 10 /**
 *
 */ 2 4 this 3 3492  8 meshDesc 1 3497  
1176 0 0 6 1337 3132 0 0 10 /**
 *
 */ 3 4 this 3 3492  8 meshDesc 1 3497  8 filename 1 3231  
1177 0 0 6 1338 3132 0 0 10 /**
 *
 */ 3 4 this 3 3492  8 meshDesc 1 3461  8 filename 1 3231  
1178 0 0 7 1340 3499 2661 0 10 /**
 *
 */ 0 
1179 0 0 6 1342 3132 0 0 51 /**
 * Returns true if the descriptor is valid.
 */ 1 4 this 3 3495  
1180 0 0 4 1343 3129 0 0 241 /**
 * Sets the number of vertices to be stored within this triangle mesh.  The
 * function allocates memory for the vertices, but it does not set any
 * vertices.
 *
 * This method must be called before any calls to set_vertex are done!
 */ 2 4 this 3 3499  1 n 1 3150  
1181 0 0 4 1344 3129 0 0 118 /**
 * Sets a single vertex.  You have to call the function set_num_vertices
 * before you can call this function.
 */ 3 4 this 3 3499  3 idx 1 3150  4 vert 1 3143  
1182 0 0 4 1345 3129 0 0 151 /**
 * Sets the number of triangles to be stored in this triangle mesh.
 *
 * This method must be called before any calls to set_triangle are done!
 */ 3 4 this 3 3499  1 n 1 3150  20 use_material_indices 1 3132  
1183 0 0 4 1346 3129 0 0 77 /**
 * Sets a single triangle, by providing the three indices i1, i2, i3.
 */ 6 4 this 3 3499  3 idx 1 3150  2 i1 1 3150  2 i2 1 3150  2 i3 1 3150  14 material_index 1 3150  
1184 0 0 4 1347 3129 0 0 308 /**
 * A convenience method to set the mesh data from a NodePath in a single call.
 * The method iterates over the NodePath geoms and collects data for the
 * triangle mesh.
 *
 * Do not use the following function when using this one: - set_num_vertices -
 * set_vertex - set_num_triangles - set_triangle
 */ 2 4 this 3 3499  2 np 1 3156  
1185 0 0 7 1349 3500 2669 0 10 /**
 *
 */ 0 
1186 0 0 6 1351 3132 0 0 51 /**
 * Returns true if the descriptor is valid.
 */ 1 4 this 3 3497  
1187 0 0 4 1352 3129 0 0 242 /**
 * Sets the number of vertices to be stored within this soft body mesh.  The
 * function allocates memory for the vertices, but it does not set any
 * vertices.
 *
 * This method must be called before any calls to set_vertex are done!
 */ 2 4 this 3 3500  1 n 1 3150  
1188 0 0 4 1353 3129 0 0 118 /**
 * Sets a single vertex.  You have to call the function set_num_vertices
 * before you can call this function.
 */ 3 4 this 3 3500  3 idx 1 3150  4 vert 1 3143  
1189 0 0 4 1354 3129 0 0 156 /**
 * Sets the number of tetrahedra to be stored in this soft body mesh.
 *
 * This method must be called before any calls to set_tetrahedron are done!
 */ 2 4 this 3 3500  1 n 1 3150  
1190 0 0 4 1355 3129 0 0 84 /**
 * Sets a single tetrahedron, by providing the three indices i1, i2, i3, i4.
 */ 6 4 this 3 3500  3 idx 1 3150  2 i1 1 3150  2 i2 1 3150  2 i3 1 3150  2 i4 1 3150  
1191 0 0 7 1357 3243 2676 0 10 /**
 *
 */ 0 
1192 0 0 4 1359 3129 0 0 49 /**
 * (re)sets the structure to the default.
 */ 1 4 this 3 3243  
1193 0 0 6 1360 3132 0 0 51 /**
 * Returns true if the descriptor is valid.
 */ 1 4 this 3 3501  
1194 0 0 4 1361 3129 0 0 0 3 4 this 3 3243  4 flag 1 2987  5 value 1 3132  
1195 0 0 4 1362 3129 0 0 35 /**
 * Sets the gravity vector.
 */ 2 4 this 3 3243  7 gravity 1 3162  
1196 0 0 4 1363 3129 0 0 624 /**
 * Set the max scene bounds.
 *
 * If scene bounds are provided (maxBounds in the descriptor), the SDK takes
 * advantage of this information to accelerate scene-level collision queries
 * (e.g.  raycasting). When using maxBounds, you have to make sure created
 * objects stay within the scene bounds.  In particular, the position of
 * dynamic shapes should stay within the provided bounds.  Otherwise the
 * shapes outside the bounds will not be taken into account by all scene
 * queries (raycasting, sweep tests, overlap tests, etc). They will
 * nonetheless still work correctly for the main physics simulation.
 */ 2 4 this 3 3243  6 bounds 1 3195  
1197 0 0 4 1364 3129 0 0 62 /**
 * Defines the structure used to store static objects.
 */ 2 4 this 3 3243  5 value 1 2984  
1198 0 0 4 1365 3129 0 0 142 /**
 * Defines the subdivision level for acceleration structures used for scene
 * queries.  This is only used when maxBounds are defined!
 */ 2 4 this 3 3243  5 value 1 2984  
1199 0 0 4 1366 3129 0 0 917 /**
 * Defines which type of broadphase to use.
 *
 * (1) BPT_sap_single: A sweep-and-prune (SAP) algorithm to find pairs of
 * potentially colliding shapes.
 *
 * (2) BPT_sap_multi: A multi sweep-and-prune algorithm to find pairs of
 * potentially colliding shapes.  Uses a configurable 2D grid to divide the
 * scene space into cells.  The potentially overlapping shape pairs are
 * detected in each cell and the information is merged together.  This
 * approach is usually faster than BPT_sap_single in scenarios with many
 * shapes and a high creation/deletion rate of shapes.  However, the amount of
 * memory required is considerably higher depending on the number of grid
 * cells used.  The following extra parameters need to be defined: -
 * PhysxSceneDesc.set_max_bounds - PhysxSceneDesc.set_num_grid_cells_x -
 * PhysxSceneDesc.set_num_grid_cells_y (the scene up direction is set via
 * config options)
 */ 2 4 this 3 3243  5 value 1 2969  
1200 0 0 4 1367 3129 0 0 142 /**
 * Defines the subdivision level for acceleration structures used for scene
 * queries.  This is only used when maxBounds are defined!
 */ 2 4 this 3 3243  5 value 1 3150  
1201 0 0 4 1368 3129 0 0 214 /**
 * Defines the number of broadphase cells along the grid x-axis.  Must be
 * power of two.  Max is 8 at the moment.  The broadphase type must be set to
 * BPT_sap_multi for this parameter to have an effect.
 */ 2 4 this 3 3243  5 value 1 3150  
1202 0 0 4 1369 3129 0 0 214 /**
 * Defines the number of broadphase cells along the grid y-axis.  Must be
 * power of two.  Max is 8 at the moment.  The broadphase type must be set to
 * BPT_sap_multi for this parameter to have an effect.
 */ 2 4 this 3 3243  5 value 1 3150  
1203 0 0 6 1370 3132 0 0 0 2 4 this 3 3501  4 flag 1 2987  
1204 0 0 7 1371 3169 0 0 34 /**
 * Get the gravity vector.
 */ 1 4 this 3 3501  
1205 0 0 7 1372 3195 2294 0 10 /**
 *
 */ 1 4 this 3 3501  
1206 0 0 6 1373 2984 0 0 62 /**
 * Returns the structure used to store static objects.
 */ 1 4 this 3 3501  
1207 0 0 6 1374 2984 0 0 95 /**
 * Returns the subdivision level for acceleration structures used for scene
 * queries.
 */ 1 4 this 3 3501  
1208 0 0 6 1375 2969 0 0 49 /**
 * Returns the type of broadphase to use.
 */ 1 4 this 3 3501  
1209 0 0 6 1376 3150 0 0 95 /**
 * Returns the subdivision level for acceleration structures used for scene
 * queries.
 */ 1 4 this 3 3501  
1210 0 0 6 1377 3150 0 0 72 /**
 * Returns the number of broadphase cells along the grid x-axis.
 */ 1 4 this 3 3501  
1211 0 0 6 1378 3150 0 0 72 /**
 * Returns the number of broadphase cells along the grid y-axis.
 */ 1 4 this 3 3501  
1212 0 0 7 1380 3324 2698 0 10 /**
 *
 */ 0 
1213 0 0 4 1382 3129 0 0 49 /**
 * (re)sets the structure to the default.
 */ 1 4 this 3 3324  
1214 0 0 6 1383 3132 0 0 51 /**
 * Returns true if the descriptor is valid.
 */ 1 4 this 3 3322  
1215 0 0 4 1384 3129 0 0 302 /**
 * Sets the coefficient of dynamic friction -- should be in [0, +inf]. If set
 * to greater than staticFriction, the effective value of staticFriction will
 * be increased to match.  If the flag MF_anisotropic is set, then this value
 * is used for the primary direction of anisotropy (U axis).
 */ 2 4 this 3 3324  4 coef 1 3149  
1216 0 0 4 1385 3129 0 0 192 /**
 * Sets the coefficient of static friction -- should be in [0, +inf]. If the
 * flag MF_anisotropic is set, then this value is used for the primary
 * direction of anisotropy (U axis).
 */ 2 4 this 3 3324  4 coef 1 3149  
1217 0 0 4 1386 3129 0 0 274 /**
 * Sets the coefficient of restitution -- 0 makes the object bounce as little
 * as possible, higher values up to 1.0 result in more bounce.  Note that
 * values close to or above 1 may cause stability problems and/or increasing
 * energy.  Range: [0,1] Default: 0.0
 */ 2 4 this 3 3324  4 rest 1 3149  
1218 0 0 4 1387 3129 0 0 168 /**
 * Sets the anisotropic dynamic friction coefficient for along the secondary
 * (V) axis of anisotropy.  This is only used if the flag MF_anisotropic is
 * set.
 */ 2 4 this 3 3324  4 coef 1 3149  
1219 0 0 4 1388 3129 0 0 167 /**
 * Sets the anisotropic static friction coefficient for along the secondary
 * (V) axis of anisotropy.  This is only used if the flag MF_anisotropic is
 * set.
 */ 2 4 this 3 3324  4 coef 1 3149  
1220 0 0 4 1389 3129 0 0 127 /**
 * Sets the shape space direction (unit vector) of anisotropy.  This is only
 * used if the flag MF_anisotropic is set.
 */ 2 4 this 3 3324  3 dir 1 3162  
1221 0 0 4 1390 3129 0 0 63 /**
 * Sets flags which control the behavior of a material.
 */ 3 4 this 3 3324  4 flag 1 2982  5 value 1 3132  
1222 0 0 4 1391 3129 0 0 176 /**
 * Sets the friction combine mode.  - CM_average : Average: (a + b)/2. -
 * CM_min : Minimum: min(a,b). - CM_multiply : Multiply: a*b.  - CM_max :
 * Maximum: max(a,b).
 */ 2 4 this 3 3324  4 mode 1 2972  
1223 0 0 4 1392 3129 0 0 179 /**
 * Sets the restitution combine mode.  - CM_average : Average: (a + b)/2. -
 * CM_min : Minimum: min(a,b). - CM_multiply : Multiply: a*b.  - CM_max :
 * Maximum: max(a,b).
 */ 2 4 this 3 3324  4 mode 1 2972  
1224 0 0 6 1393 3149 0 0 55 /**
 * Returns the coefficient of dynamic friction.
 */ 1 4 this 3 3322  
1225 0 0 6 1394 3149 0 0 54 /**
 * Retruns the coefficient of static friction.
 */ 1 4 this 3 3322  
1226 0 0 6 1395 3149 0 0 50 /**
 * Returns the coefficient of restitution.
 */ 1 4 this 3 3322  
1227 0 0 6 1396 3149 0 0 114 /**
 * Returns the anisotropic dynamic friction coefficient for along the
 * secondary (V) axis of anisotropy.
 */ 1 4 this 3 3322  
1228 0 0 6 1397 3149 0 0 113 /**
 * Returns the anisotropic static friction coefficient for along the secondary
 * (V) axis of anisotropy.
 */ 1 4 this 3 3322  
1229 0 0 7 1398 3169 0 0 73 /**
 * Returns the shape space direction (unit vector) of anisotropy.
 */ 1 4 this 3 3322  
1230 0 0 6 1399 3132 0 0 66 /**
 * Returns flags which control the behavior of a material.
 */ 2 4 this 3 3322  4 flag 1 2982  
1231 0 0 6 1400 2972 0 0 45 /**
 * Returns the friction combine mode.
 */ 1 4 this 3 3322  
1232 0 0 6 1401 2972 0 0 48 /**
 * Returns the restitution combine mode.
 */ 1 4 this 3 3322  
1233 0 0 7 1403 3355 2720 0 10 /**
 *
 */ 0 
1234 0 0 7 1403 3355 2720 0 10 /**
 *
 */ 3 9 velTarget 1 3149  8 maxForce 1 3149  8 freeSpin 1 3132  
1235 0 0 4 1405 3129 0 0 10 /**
 *
 */ 2 4 this 3 3355  9 velTarget 1 3149  
1236 0 0 4 1406 3129 0 0 10 /**
 *
 */ 2 4 this 3 3355  8 maxForce 1 3149  
1237 0 0 4 1407 3129 0 0 10 /**
 *
 */ 2 4 this 3 3355  8 freeSpin 1 3132  
1238 0 0 6 1408 3149 0 0 10 /**
 *
 */ 1 4 this 3 3353  
1239 0 0 6 1409 3149 0 0 10 /**
 *
 */ 1 4 this 3 3353  
1240 0 0 6 1410 3132 0 0 10 /**
 *
 */ 1 4 this 3 3353  
1241 0 0 7 1412 3503 2728 0 10 /**
 *
 */ 0 
1242 0 0 7 1412 3503 2728 0 10 /**
 *
 */ 1 5 plane 1 3504  
1243 0 0 6 1414 3149 0 0 10 /**
 *
 */ 2 4 this 3 3504  1 p 1 3143  
1244 0 0 6 1415 3132 0 0 10 /**
 *
 */ 2 4 this 3 3504  1 p 1 3143  
1245 0 0 4 1416 3129 0 0 10 /**
 *
 */ 1 4 this 3 3503  
1246 0 0 7 1417 3151 0 0 10 /**
 *
 */ 1 4 this 3 3504  
1247 0 0 7 1418 3151 0 0 10 /**
 *
 */ 2 4 this 3 3504  1 p 1 3143  
1248 0 0 4 1419 3129 0 0 10 /**
 *
 */ 3 4 this 3 3504  9 transform 1 3146  11 transformed 1 3503  
1249 0 0 4 1420 3129 0 0 10 /**
 *
 */ 3 4 this 3 3504  9 transform 1 3146  11 transformed 1 3503  
1250 0 0 7 1421 3503 2728 0 10 /**
 *
 */ 4 4 this 3 3503  2 p0 1 3143  2 p1 1 3143  2 p2 1 3143  
1251 0 0 7 1422 3503 2728 0 10 /**
 *
 */ 1 4 this 3 3503  
1252 0 0 6 1423 3149 0 0 10 /**
 *
 */ 1 4 this 3 3504  
1253 0 0 7 1424 3169 0 0 10 /**
 *
 */ 1 4 this 3 3504  
1254 0 0 4 1425 3129 0 0 10 /**
 *
 */ 2 4 this 3 3503  1 d 1 3149  
1255 0 0 4 1426 3129 0 0 10 /**
 *
 */ 2 4 this 3 3503  6 normal 1 3169  
1256 0 0 7 1428 3328 0 0 10 /**
 *
 */ 0 
1257 0 0 4 1429 3129 0 0 113 /**
 * Sets the parameters of the plane equation.  normal: Plane normal.  d: The
 * distance from the origin.
 */ 3 4 this 3 3328  6 normal 1 3162  1 d 1 3149  
1258 0 0 7 1431 3332 2745 0 10 /**
 *
 */ 0 
1259 0 0 7 1434 3338 2747 0 10 /**
 *
 */ 0 
1260 0 0 7 1437 3344 2749 0 10 /**
 *
 */ 0 
1261 0 0 7 1440 3350 2751 0 10 /**
 *
 */ 0 
1262 0 0 4 1442 3129 0 0 71 /**
 * Sets the rest length of the rope connecting the two objects.
 */ 2 4 this 3 3350  8 distance 1 3149  
1263 0 0 4 1443 3129 0 0 71 /**
 * Sets how stiff the constraint is, between 0 and 1 (stiffest)
 */ 2 4 this 3 3350  9 stiffness 1 3149  
1264 0 0 4 1444 3129 0 0 39 /**
 * Sets the transmission ratio.
 */ 2 4 this 3 3350  6 ration 1 3149  
1265 0 0 4 1445 3129 0 0 67 /**
 * Sets the suspension points of two bodies in world space.
 */ 3 4 this 3 3350  3 idx 1 3150  3 pos 1 3143  
1266 0 0 4 1446 3129 0 0 40 /**
 * Sets an optional joint motor.
 */ 2 4 this 3 3350  5 motor 1 3353  
1267 0 0 4 1447 3129 0 0 56 /**
 * Sets or clears a single PulleyJointFlag flag.
 */ 3 4 this 3 3350  4 flag 1 2985  5 value 1 3132  
1268 0 0 6 1448 3149 0 0 10 /**
 *
 */ 1 4 this 3 3351  
1269 0 0 6 1449 3149 0 0 10 /**
 *
 */ 1 4 this 3 3351  
1270 0 0 6 1450 3149 0 0 10 /**
 *
 */ 1 4 this 3 3351  
1271 0 0 6 1451 3132 0 0 10 /**
 *
 */ 2 4 this 3 3351  4 flag 1 2985  
1272 0 0 7 1452 3151 0 0 10 /**
 *
 */ 2 4 this 3 3351  3 idx 1 3150  
1273 0 0 7 1453 3355 2720 0 10 /**
 *
 */ 1 4 this 3 3351  
1274 0 0 7 1455 3506 2765 0 10 /**
 *
 */ 0 
1275 0 0 4 1457 3129 0 0 173 /**
 * Sets the ray length.  If no length is set then the ray will be virtually
 * infinite (the maximum floating point number will be used, e.g.
 * 3.40282346639e+038).
 */ 2 4 this 3 3506  6 length 1 3149  
1276 0 0 4 1458 3129 0 0 31 /**
 * Sets the ray origin.
 */ 2 4 this 3 3506  6 origin 1 3143  
1277 0 0 4 1459 3129 0 0 82 /**
 * Set the ray direction.  It is not required to pass a normalized vector.
 */ 2 4 this 3 3506  9 direction 1 3162  
1278 0 0 6 1460 3149 0 0 34 /**
 * Returns the ray length.
 */ 1 4 this 3 3204  
1279 0 0 7 1461 3151 0 0 33 /**
 * Returns the ray origin
 */ 1 4 this 3 3204  
1280 0 0 7 1462 3169 0 0 37 /**
 * Returns the ray direction.
 */ 1 4 this 3 3204  
1281 0 0 7 1464 3206 2773 0 10 /**
 *
 */ 1 3 hit 1 3507  
1282 0 0 6 1466 3132 0 0 10 /**
 *
 */ 1 4 this 3 3510  
1283 0 0 7 1467 3161 1661 0 10 /**
 *
 */ 1 4 this 3 3510  
1284 0 0 7 1468 3151 0 0 10 /**
 *
 */ 1 4 this 3 3510  
1285 0 0 7 1469 3169 0 0 10 /**
 *
 */ 1 4 this 3 3510  
1286 0 0 6 1470 3149 0 0 10 /**
 *
 */ 1 4 this 3 3510  
1287 0 0 7 1481 3388 2785 0 0 1 6 param0 0 3512  
1288 0 0 6 1475 3150 0 0 10 /**
 *
 */ 1 4 this 3 3512  
1289 0 0 7 1476 3206 2773 0 10 /**
 *
 */ 1 4 this 3 3388  
1290 0 0 7 1477 3206 2773 0 10 /**
 *
 */ 1 4 this 3 3388  
1291 0 0 7 1478 3206 2773 0 10 /**
 *
 */ 2 4 this 3 3388  3 idx 1 3150  
1292 0 0 6 1473 3514 0 0 0 1 4 this 3 3388  
1293 0 0 6 1474 3388 0 0 0 2 4 this 3 3514  4 this 1 3514  
1294 0 0 7 1483 3359 2788 0 10 /**
 *
 */ 0 
1295 0 0 4 1485 3129 0 0 65 /**
 * Sets the distance beyond which the joint is projected.
 */ 2 4 this 3 3359  8 distance 1 3149  
1296 0 0 4 1486 3129 0 0 62 /**
 * Sets the angle beyond which the joint is projected.
 */ 2 4 this 3 3359  5 angle 1 3149  
1297 0 0 4 1487 3129 0 0 35 /**
 * Sets an aptional spring.
 */ 2 4 this 3 3359  6 spring 1 3362  
1298 0 0 4 1488 3129 0 0 58 /**
 * Sets or clears a single RevoluteJointFlag flag.
 */ 3 4 this 3 3359  4 flag 1 2986  5 value 1 3132  
1299 0 0 4 1489 3129 0 0 40 /**
 * Sets an optional joint motor.
 */ 2 4 this 3 3359  5 motor 1 3353  
1300 0 0 4 1490 3129 0 0 68 /**
 * Sets optional limits for the angular motion of the joint.
 */ 2 4 this 3 3359  3 low 1 3364  
1301 0 0 4 1491 3129 0 0 68 /**
 * Sets optional limits for the angular motion of the joint.
 */ 2 4 this 3 3359  4 high 1 3364  
1302 0 0 4 1492 3129 0 0 68 /**
 * Use this to enable joint projection.  Default is PM_none.
 */ 2 4 this 3 3359  4 mode 1 2983  
1303 0 0 6 1493 3149 0 0 67 /**
 * Return the distance beyond which the joint is projected.
 */ 1 4 this 3 3360  
1304 0 0 6 1494 3149 0 0 64 /**
 * Return the angle beyond which the joint is projected.
 */ 1 4 this 3 3360  
1305 0 0 6 1495 3132 0 0 10 /**
 *
 */ 2 4 this 3 3360  4 flag 1 2986  
1306 0 0 7 1496 3366 2587 0 10 /**
 *
 */ 1 4 this 3 3360  
1307 0 0 7 1497 3355 2720 0 40 /**
 * Sets an optional joint motor.
 */ 1 4 this 3 3360  
1308 0 0 7 1498 3491 2645 0 10 /**
 *
 */ 1 4 this 3 3360  
1309 0 0 7 1499 3491 2645 0 10 /**
 *
 */ 1 4 this 3 3360  
1310 0 0 6 1500 2983 0 0 10 /**
 *
 */ 1 4 this 3 3360  
1311 0 0 7 1502 3379 2806 0 10 /**
 *
 */ 1 3 ptr 1 3515  
1312 0 0 7 1502 3379 2806 0 0 1 6 param0 0 3518  
1313 0 0 6 1504 3150 0 0 10 /**
 *
 */ 1 4 this 3 3518  
1314 0 0 6 1505 3135 0 0 10 /**
 *
 */ 2 4 this 3 3518  5 index 1 3150  
1315 0 0 6 1506 3135 0 0 10 /**
 *
 */ 2 4 this 3 3518  5 index 1 3150  
1316 0 0 6 1507 3125 0 0 10 /**
 *
 */ 2 4 this 3 3518  5 index 1 3150  
1317 0 0 6 1508 3150 0 0 10 /**
 *
 */ 2 4 this 3 3518  5 index 1 3150  
1318 0 0 7 1510 3386 0 0 10 /**
 *
 */ 0 
1319 0 0 7 1510 3386 0 0 0 1 6 param0 0 3520  
1320 0 0 4 1511 3129 0 0 49 /**
 * (re)sets the structure to the default.
 */ 1 4 this 3 3386  
1321 0 0 6 1512 3132 0 0 51 /**
 * Returns true if the descriptor is valid.
 */ 1 4 this 3 3520  
1322 0 0 7 1514 3384 2816 0 10 /**
 *
 */ 0 
1323 0 0 4 1516 3129 0 0 49 /**
 * (re)sets the structure to the default.
 */ 1 4 this 3 3384  
1324 0 0 6 1517 3132 0 0 51 /**
 * Returns true if the descriptor is valid.
 */ 1 4 this 3 3522  
1325 0 0 4 1518 3129 0 0 10 /**
 *
 */ 2 4 this 3 3384  4 mesh 1 3248  
1326 0 0 4 1519 3129 0 0 10 /**
 *
 */ 2 4 this 3 3384  4 name 1 3125  
1327 0 0 4 1520 3129 0 0 10 /**
 *
 */ 2 4 this 3 3384  3 pos 1 3143  
1328 0 0 4 1521 3129 0 0 10 /**
 *
 */ 2 4 this 3 3384  3 mat 1 3146  
1329 0 0 4 1522 3129 0 0 10 /**
 *
 */ 4 4 this 3 3384  1 h 1 3149  1 p 1 3149  1 r 1 3149  
1330 0 0 4 1523 3129 0 0 10 /**
 *
 */ 2 4 this 3 3384  7 density 1 3149  
1331 0 0 4 1524 3129 0 0 10 /**
 *
 */ 2 4 this 3 3384  9 stiffness 1 3149  
1332 0 0 4 1525 3129 0 0 10 /**
 *
 */ 2 4 this 3 3384  9 stiffness 1 3149  
1333 0 0 4 1526 3129 0 0 10 /**
 *
 */ 2 4 this 3 3384  7 damping 1 3149  
1334 0 0 4 1527 3129 0 0 10 /**
 *
 */ 2 4 this 3 3384  8 friction 1 3149  
1335 0 0 4 1528 3129 0 0 10 /**
 *
 */ 2 4 this 3 3384  10 tearFactor 1 3149  
1336 0 0 4 1529 3129 0 0 10 /**
 *
 */ 2 4 this 3 3384  6 radius 1 3149  
1337 0 0 4 1530 3129 0 0 10 /**
 *
 */ 2 4 this 3 3384  7 spacing 1 3149  
1338 0 0 4 1531 3129 0 0 10 /**
 *
 */ 2 4 this 3 3384  4 coef 1 3149  
1339 0 0 4 1532 3129 0 0 10 /**
 *
 */ 2 4 this 3 3384  4 coef 1 3149  
1340 0 0 4 1533 3129 0 0 121 /**
 * Number of solver iterations.  Small numbers make the simulation faster
 * while the soft body gets less stiff.
 */ 2 4 this 3 3384  11 interations 1 3150  
1341 0 0 4 1534 3129 0 0 56 /**
 * Raise or lower individual SoftBodyFlag flags.
 */ 3 4 this 3 3384  4 flag 1 2989  5 value 1 3132  
1342 0 0 6 1535 3125 0 0 10 /**
 *
 */ 1 4 this 3 3522  
1343 0 0 7 1536 3151 0 0 10 /**
 *
 */ 1 4 this 3 3522  
1344 0 0 7 1537 3152 0 0 10 /**
 *
 */ 1 4 this 3 3522  
1345 0 0 6 1538 3149 0 0 10 /**
 *
 */ 1 4 this 3 3522  
1346 0 0 6 1539 3149 0 0 10 /**
 *
 */ 1 4 this 3 3522  
1347 0 0 6 1540 3149 0 0 10 /**
 *
 */ 1 4 this 3 3522  
1348 0 0 6 1541 3149 0 0 10 /**
 *
 */ 1 4 this 3 3522  
1349 0 0 6 1542 3149 0 0 10 /**
 *
 */ 1 4 this 3 3522  
1350 0 0 6 1543 3149 0 0 10 /**
 *
 */ 1 4 this 3 3522  
1351 0 0 6 1544 3149 0 0 10 /**
 *
 */ 1 4 this 3 3522  
1352 0 0 6 1545 3149 0 0 10 /**
 *
 */ 1 4 this 3 3522  
1353 0 0 6 1546 3149 0 0 10 /**
 *
 */ 1 4 this 3 3522  
1354 0 0 6 1547 3149 0 0 10 /**
 *
 */ 1 4 this 3 3522  
1355 0 0 6 1548 3150 0 0 10 /**
 *
 */ 1 4 this 3 3522  
1356 0 0 6 1549 3132 0 0 10 /**
 *
 */ 2 4 this 3 3522  4 flag 1 2989  
1357 0 0 7 1551 3524 2852 0 10 /**
 *
 */ 0 
1358 0 0 7 1551 3524 2852 0 10 /**
 *
 */ 1 6 sphere 1 3202  
1359 0 0 6 1553 3132 0 0 59 /**
 * Tests if a point is contained within the sphere.
 */ 2 4 this 3 3202  1 p 1 3143  
1360 0 0 6 1553 3132 0 0 153 /**
 * Tests if an axis aligned box is contained within the sphere.  The axis
 * aligned box is defined by the minimum corner and the maximum corner.
 */ 3 4 this 3 3202  3 min 1 3143  3 max 1 3143  
1361 0 0 6 1553 3132 0 0 60 /**
 * Tests if a sphere is contained within the sphere.
 */ 2 4 this 3 3202  6 sphere 1 3202  
1362 0 0 6 1554 3132 0 0 98 /**
 * Tests if the sphere intersects another sphere.  Returns TRUE if the spheres
 * overlap.
 */ 2 4 this 3 3202  6 sphere 1 3202  
1363 0 0 6 1555 3132 0 0 48 /**
 * Returns TRUE if this sphere is valid.
 */ 1 4 this 3 3202  
1364 0 0 7 1556 3151 0 0 44 /**
 * Returns the center of the sphere.
 */ 1 4 this 3 3202  
1365 0 0 6 1557 3149 0 0 39 /**
 * Returns the sphere's radius.
 */ 1 4 this 3 3202  
1366 0 0 4 1558 3129 0 0 41 /**
 * Sets the center of the sphere.
 */ 2 4 this 3 3524  5 value 1 3151  
1367 0 0 4 1559 3129 0 0 36 /**
 * Sets the sphere's radius.
 */ 2 4 this 3 3524  5 value 1 3149  
1368 0 0 7 1561 3401 2861 0 10 /**
 *
 */ 0 
1369 0 0 4 1563 3129 0 0 46 /**
 * Radius of shape.  Must be positive.
 */ 2 4 this 3 3401  6 radius 1 3149  
1370 0 0 6 1564 3149 0 0 27 /**
 * Radius of shape.
 */ 1 4 this 3 3525  
1371 0 0 7 1566 3405 0 0 10 /**
 *
 */ 0 
1372 0 0 4 1567 3129 0 0 46 /**
 * Radius of shape.  Must be positive.
 */ 2 4 this 3 3405  6 radius 1 3149  
1373 0 0 6 1568 3149 0 0 27 /**
 * Radius of shape.
 */ 1 4 this 3 3527  
1374 0 0 7 1570 3409 2868 0 10 /**
 *
 */ 0 
1375 0 0 4 1572 3129 0 0 57 /**
 * Set the distance above which to project joint.
 */ 2 4 this 3 3409  8 distance 1 3149  
1376 0 0 4 1573 3129 0 0 59 /**
 * Sets or clears a single SphericalJointFlag flag.
 */ 3 4 this 3 3409  4 flag 1 2991  5 value 1 3132  
1377 0 0 4 1574 3129 0 0 74 /**
 * Set the swing limit axis defined in the joint space of actor 0.
 */ 2 4 this 3 3409  4 axis 1 3162  
1378 0 0 4 1575 3129 0 0 53 /**
 * Sets a spring that works against twisting.
 */ 2 4 this 3 3409  6 spring 1 3362  
1379 0 0 4 1576 3129 0 0 53 /**
 * Sets a spring that works against swinging.
 */ 2 4 this 3 3409  6 spring 1 3362  
1380 0 0 4 1577 3129 0 0 62 /**
 * Sets a spring that lets the joint get pulled apart.
 */ 2 4 this 3 3409  6 spring 1 3362  
1381 0 0 4 1578 3129 0 0 45 /**
 * Limits rotation around twist axis.
 */ 2 4 this 3 3409  3 low 1 3364  
1382 0 0 4 1579 3129 0 0 45 /**
 * Limits rotation around twist axis.
 */ 2 4 this 3 3409  4 high 1 3364  
1383 0 0 4 1580 3129 0 0 38 /**
 * Limits swing of twist axis.
 */ 2 4 this 3 3409  5 limit 1 3364  
1384 0 0 4 1581 3129 0 0 68 /**
 * Use this to enable joint projection.  Default is PM_none.
 */ 2 4 this 3 3409  4 mode 1 2983  
1385 0 0 6 1582 3149 0 0 10 /**
 *
 */ 1 4 this 3 3410  
1386 0 0 6 1583 3132 0 0 10 /**
 *
 */ 2 4 this 3 3410  4 flag 1 2991  
1387 0 0 7 1584 3169 0 0 10 /**
 *
 */ 1 4 this 3 3410  
1388 0 0 7 1585 3366 2587 0 10 /**
 *
 */ 1 4 this 3 3410  
1389 0 0 7 1586 3366 2587 0 10 /**
 *
 */ 1 4 this 3 3410  
1390 0 0 7 1587 3366 2587 0 10 /**
 *
 */ 1 4 this 3 3410  
1391 0 0 7 1588 3491 2645 0 10 /**
 *
 */ 1 4 this 3 3410  
1392 0 0 7 1589 3491 2645 0 10 /**
 *
 */ 1 4 this 3 3410  
1393 0 0 7 1590 3491 2645 0 38 /**
 * Limits swing of twist axis.
 */ 1 4 this 3 3410  
1394 0 0 6 1591 2983 0 0 10 /**
 *
 */ 1 4 this 3 3410  
1395 0 0 7 1593 3417 0 0 10 /**
 *
 */ 0 
1396 0 0 4 1594 3129 0 0 10 /**
 *
 */ 2 4 this 3 3417  4 mesh 1 3247  
1397 0 0 7 1596 3529 2892 0 10 /**
 *
 */ 0 
1398 0 0 7 1596 3529 2892 0 0 1 6 param0 0 3530  
1399 0 0 6 1598 3132 0 0 88 /**
 * Test if an oriented box contains a point.
 *
 * \param [in] box \param [in] p
 */ 3 4 this 3 3529  3 box 1 3200  1 p 1 3143  
1400 0 0 7 1599 3430 2316 0 119 /**
 * Create an oriented box from an axis aligned box and a transformation.
 *
 * \param [in] aabb \param [in] mat
 */ 3 4 this 3 3529  4 aabb 1 3196  3 mat 1 3146  
1401 0 0 7 1600 3169 0 0 240 /**
 * Compute and edge normals for an oriented box.  This is an averaged normal,
 * from the two faces sharing the edge.  The edge index should be from 0 to 11
 * (i.e.  a box has 12 edges).
 *
 * \param [in] box \param [in] edge_index
 */ 3 4 this 3 3529  3 box 1 3200  10 edge_index 1 3150  
1402 0 0 7 1601 3445 2371 0 72 /**
 * Compute a capsule which encloses a box.
 *
 * \param [in] box
 */ 2 4 this 3 3529  3 box 1 3200  
1403 0 0 6 1602 3132 0 0 125 /**
 * Test if box A is inside another box B. Returns TRUE if box A is inside box
 * B.
 *
 * \param [in] a \param [in] b
 */ 3 4 this 3 3529  1 a 1 3200  1 b 1 3200  
1404 0 0 7 1603 3430 2316 0 76 /**
 * Compute a box which encloses a capsule.
 *
 * \param [in] capsule
 */ 2 4 this 3 3529  7 capsule 1 3198  
1405 0 0 4 1604 3129 0 0 29 /**
 * Set FPU precision.
 */ 2 4 this 3 3529  1 b 1 3132  
1406 0 0 4 1605 3129 0 0 29 /**
 * Set FPU precision.
 */ 1 4 this 3 3529  
1407 0 0 4 1606 3129 0 0 29 /**
 * Set FPU precision.
 */ 1 4 this 3 3529  
1408 0 0 4 1607 3129 0 0 29 /**
 * Set FPU precision.
 */ 1 4 this 3 3529  
1409 0 0 4 1608 3129 0 0 29 /**
 * Set FPU precision.
 */ 1 4 this 3 3529  
1410 0 0 4 1609 3129 0 0 33 /**
 * Set FPU rounding mode.
 */ 1 4 this 3 3529  
1411 0 0 4 1610 3129 0 0 33 /**
 * Set FPU rounding mode.
 */ 1 4 this 3 3529  
1412 0 0 4 1611 3129 0 0 33 /**
 * Set FPU rounding mode.
 */ 1 4 this 3 3529  
1413 0 0 6 1612 3135 0 0 57 /**
 * Convert a floating point number to an integer.
 */ 2 4 this 3 3529  1 f 1 3149  
1414 0 0 6 1613 3135 0 0 57 /**
 * Convert a floating point number to an integer.
 */ 2 4 this 3 3529  1 f 1 3149  
1415 0 0 6 1614 3135 0 0 57 /**
 * Convert a floating point number to an integer.
 */ 2 4 this 3 3529  1 f 1 3149  
1416 0 0 6 1615 3149 0 0 102 /**
 * Compute the distance squared from a point to a ray.
 *
 * \param [in] ray \param [in] point
 */ 3 4 this 3 3529  3 ray 1 3204  5 point 1 3143  
1417 0 0 6 1616 3149 0 0 111 /**
 * Compute the distance squared from a point to a line segment.
 *
 * \param [in] seg \param [in] point
 */ 3 4 this 3 3529  3 seg 1 3443  5 point 1 3143  
1418 0 0 7 1617 3524 2852 0 114 /**
 * Compute an overall bounding sphere for a pair of spheres.
 *
 * \param [in] sphere0 \param [in] sphere1
 */ 3 4 this 3 3529  7 sphere0 1 3202  7 sphere1 1 3202  
1419 0 0 4 1618 3129 0 0 112 /**
 * Get the tangent vectors associated with a normal.
 *
 * \param [in] n \param [out] t1 \param [out] t2
 */ 4 4 this 3 3529  1 n 1 3162  2 t1 1 3169  2 t2 1 3169  
1420 0 0 7 1619 3168 0 0 120 /**
 * Computes a rotation matrix M so that: M * x = b (x and b are unit vectors).
 *
 * \param [in] x \param [in] b
 */ 3 4 this 3 3529  1 x 1 3162  1 b 1 3162  
1421 0 0 6 1620 3149 0 0 122 /**
 * Computes mass of a homogeneous sphere according to sphere density.
 *
 * \param [in] radius \param [in] density
 */ 3 4 this 3 3529  6 radius 1 3149  7 density 1 3149  
1422 0 0 6 1621 3149 0 0 118 /**
 * Computes density of a homogeneous sphere according to sphere mass
 *
 * \param [in] radius \param [in] mass
 */ 3 4 this 3 3529  6 radius 1 3149  4 mass 1 3149  
1423 0 0 6 1622 3149 0 0 116 /**
 * Computes mass of a homogeneous box according to box density.
 *
 * \param [in] radius \param [in] density
 */ 3 4 this 3 3529  7 extents 1 3162  7 density 1 3149  
1424 0 0 6 1623 3149 0 0 113 /**
 * Computes density of a homogeneous box according to box mass.
 *
 * \param [in] radius \param [in] mass
 */ 3 4 this 3 3529  7 extents 1 3162  4 mass 1 3149  
1425 0 0 6 1624 3149 0 0 128 /**
 * Computes mass of a homogeneous ellipsoid according to ellipsoid density.
 *
 * \param [in] radius \param [in] density
 */ 3 4 this 3 3529  7 extents 1 3162  7 density 1 3149  
1426 0 0 6 1625 3149 0 0 125 /**
 * Computes density of a homogeneous ellipsoid according to ellipsoid mass.
 *
 * \param [in] radius \param [in] mass
 */ 3 4 this 3 3529  7 extents 1 3162  4 mass 1 3149  
1427 0 0 6 1626 3149 0 0 126 /**
 * Computes mass of a homogeneous cylinder according to cylinder density.
 *
 * \param [in] radius \param [in] density
 */ 4 4 this 3 3529  6 radius 1 3149  6 length 1 3149  7 density 1 3149  
1428 0 0 6 1627 3149 0 0 123 /**
 * Computes density of a homogeneous cylinder according to cylinder mass.
 *
 * \param [in] radius \param [in] mass
 */ 4 4 this 3 3529  6 radius 1 3149  6 length 1 3149  4 mass 1 3149  
1429 0 0 6 1628 3149 0 0 118 /**
 * Computes mass of a homogeneous cone according to cone density.
 *
 * \param [in] radius \param [in] density
 */ 4 4 this 3 3529  6 radius 1 3149  6 length 1 3149  7 density 1 3149  
1430 0 0 6 1629 3149 0 0 115 /**
 * Computes density of a homogeneous cone according to cone mass.
 *
 * \param [in] radius \param [in] mass
 */ 4 4 this 3 3529  6 radius 1 3149  6 length 1 3149  4 mass 1 3149  
1431 0 0 7 1630 3169 0 0 144 /**
 * Computes diagonalized inertia tensor for a box.
 *
 * \param [in] mass \param [in] xlength \param [in] ylength \param [in]
 * zlength
 */ 5 4 this 3 3529  4 mass 1 3149  7 xlength 1 3149  7 ylength 1 3149  7 zlength 1 3149  
1432 0 0 7 1631 3169 0 0 122 /**
 * Computes diagonalized inertia tensor for a sphere.
 *
 * \param [in] mass \param [in] radius \param [in] hollow
 */ 4 4 this 3 3529  4 mass 1 3149  6 radius 1 3149  6 hollow 1 3132  
1433 0 0 6 1632 3132 0 0 310 /**
 * Boolean intersection test between two OBBs.  Uses the separating axis
 * theorem.  Disabling 'full_test' only performs 6 axis tests out of 15.
 *
 * \param [in] extents0 \param [in] center0 \param [in] rotation0 \param [in]
 * extents1 \param [in] center1 \param [in] rotation1 \param [in] full_test
 */ 8 4 this 3 3529  8 extents0 1 3162  7 center0 1 3143  9 rotation0 1 3165  8 extents1 1 3162  7 center1 1 3143  9 rotation1 1 3165  9 full_test 1 3132  
1434 0 0 6 1633 3132 0 0 174 /**
 * Boolean intersection test between a triangle and a box.
 *
 * \param [in] vertex0 \param [in] vertex1 \param [in] vertex2 \param [in]
 * center \param [in] extents
 */ 6 4 this 3 3529  7 vertex0 1 3143  7 vertex1 1 3143  7 vertex2 1 3143  6 center 1 3143  7 extents 1 3162  
1435 0 0 6 1634 3132 0 0 107 /**
 * Ray-plane intersection test.
 *
 * \param [in] ray \param [in] plane \param [out] point_on_plane
 */ 4 4 this 3 3529  3 ray 1 3204  5 plane 1 3504  14 point_on_plane 1 3151  
1436 0 0 6 1635 3132 0 0 245 /**
 * Ray-sphere intersection test.  Returns true if the ray intersects the
 * sphere, and the impact point if needed.
 *
 * \param [in] origin \param [in] dir \param [in] length \param [in] center
 * \param [in] radius \param [out] hit_pos
 */ 7 4 this 3 3529  6 origin 1 3143  3 dir 1 3162  6 length 1 3149  6 center 1 3143  6 radius 1 3149  7 hit_pos 1 3151  
1437 0 0 6 1636 3132 0 0 181 /**
 * Segment-AABB intersection test.  Also computes intersection point.
 *
 * \param [in] p1 \param [in] p2 \param [in] bbox_min \param [in] bbox_max
 * \param [out] intercept
 */ 6 4 this 3 3529  2 p1 1 3143  2 p2 1 3143  8 bbox_min 1 3143  8 bbox_max 1 3143  9 intercept 1 3151  
1438 0 0 6 1637 3132 0 0 168 /**
 * Ray-AABB intersection test.  Also computes intersection point.
 *
 * \param [in] min \param [in] max \param [in] origin \param [in] dir \param
 * [out] coord
 */ 6 4 this 3 3529  3 min 1 3143  3 max 1 3143  6 origin 1 3143  3 dir 1 3162  5 coord 1 3151  
1439 0 0 6 1638 3132 0 0 178 /**
 * Boolean segment-OBB intersection test.  Based on separating axis theorem.
 *
 * \param [in] p0 \param [in] p1 \param [in] center \param [in] extents \param
 * [in] rot
 */ 6 4 this 3 3529  2 p0 1 3143  2 p1 1 3143  6 center 1 3143  7 extents 1 3162  3 rot 1 3165  
1440 0 0 6 1639 3132 0 0 153 /**
 * Boolean segment-AABB intersection test.  Based on separating axis theorem.
 *
 * \param [in] p0 \param [in] p1 \param [in] min \param [in] max
 */ 5 4 this 3 3529  2 p0 1 3143  2 p1 1 3143  3 min 1 3143  3 max 1 3143  
1441 0 0 6 1640 3132 0 0 157 /**
 * Boolean ray-OBB intersection test.  Based on separating axis theorem.
 *
 * \param [in] ray \param [in] center \param [in] extents \param [in] rot
 */ 5 4 this 3 3529  3 ray 1 3204  6 center 1 3143  7 extents 1 3162  3 rot 1 3165  
1442 0 0 6 1641 3150 0 0 170 /**
 * Ray-capsule intersection test.  Returns number of intersection points (0,1
 * or 2) along the ray.
 *
 * \param [in] origin \param [in] dir \param [in] capsule
 */ 4 4 this 3 3529  6 origin 1 3143  3 dir 1 3162  7 capsule 1 3198  
1443 0 0 6 1642 3132 0 0 227 /**
 * Sphere-sphere sweep test.  Returns true if spheres intersect during their
 * linear motion along provided velocity vectors.
 *
 * \param [in] sphere0 \param [in] velocity0 \param [in] sphere1 \param [in]
 * velocity1
 */ 5 4 this 3 3529  7 sphere0 1 3202  9 velocity0 1 3162  7 sphere1 1 3202  9 velocity1 1 3162  
1444 0 0 6 1643 3132 0 0 356 /**
 * Ray-triangle intersection test.  Returns impact distance (t) as well as
 * barycentric coordinates (u,v) of impact point.  The test performs back face
 * culling or not according to 'cull'.
 *
 * \param [in] orig \param [in] dir \param [in] vert0 \param [in] vert1 \param
 * [in] vert2 \param [out] hit, with coordinates (t,u,v) \param [in] cull
 */ 8 4 this 3 3529  4 orig 1 3143  3 dir 1 3162  5 vert0 1 3143  5 vert1 1 3143  5 vert2 1 3143  3 hit 1 3169  4 cull 1 3132  
1445 0 0 6 1644 3132 0 0 323 /**
 * Box-vs-capsule sweep test.  Sweeps a box against a capsule, returns true if
 * box hit the capsule.  Also returns contact information.
 *
 * \param [in] box Box \param [in] lss Capsule \param [in] dir Unit-length
 * sweep direction \param [in] length Length of sweep \param [out] normal
 * Normal at impact point
 */ 6 4 this 3 3529  3 box 1 3200  3 lss 1 3198  3 dir 1 3162  6 length 1 3149  6 normal 1 3169  
1446 0 0 6 1645 3132 0 0 322 /**
 * Box-vs-sphere sweep test.  Sweeps a box against a sphere, returns true if
 * box hit the sphere.  Also returns contact information.
 *
 * \param [in] box Box \param [in] sphere Sphere \param [in] dir Unit-length
 * sweep direction \param [in] length Length of sweep \param [out] normal
 * Normal at impact point
 */ 6 4 this 3 3529  3 box 1 3200  6 sphere 1 3202  3 dir 1 3162  6 length 1 3149  6 normal 1 3169  
1447 0 0 6 1646 3132 0 0 360 /**
 * Capsule-vs-capsule sweep test.  Sweeps a capsule against a capsule, returns
 * true if capsule hit the other capsule.  Also returns contact information.
 *
 * \param [in] lss0 \param [in] lss1 \param [in] dir Unit-length sweep
 * direction \param [in] length Length of sweep \param [out] ip Impact point
 * \param [out] normal Normal at impact point
 */ 7 4 this 3 3529  4 lss0 1 3198  4 lss1 1 3198  3 dir 1 3162  6 length 1 3149  2 ip 1 3151  6 normal 1 3169  
1448 0 0 6 1647 3132 0 0 352 /**
 * Sphere-vs-capsule sweep test.  Sweeps a sphere against a capsule, returns
 * true if sphere hit the capsule.  Also returns contact information.
 *
 * \param [in] sphere \param [in] lss \param [in] dir Unit-length sweep
 * direction \param [in] length Length of sweep \param [out] ip Impact point
 * \param [out] normal Normal at impact point
 */ 7 4 this 3 3529  6 sphere 1 3202  3 lss 1 3198  3 dir 1 3162  6 length 1 3149  2 ip 1 3151  6 normal 1 3169  
1449 0 0 6 1648 3132 0 0 336 /**
 * Box-vs-box sweep test.  Sweeps a box against a box, returns true if box hit
 * the other box.  Also returns contact information.
 *
 * \param [in] box0 \param [in] box1 \param [in] dir Unit-length sweep
 * direction \param [in] length Length of sweep \param [out] ip Impact point
 * \param [out] normal Normal at impact point
 */ 7 4 this 3 3529  4 box0 1 3200  4 box1 1 3200  3 dir 1 3162  6 length 1 3149  2 ip 1 3151  6 normal 1 3169  
1450 0 0 6 1649 3149 0 0 284 /**
 * Point-vs-OBB distance computation.  Returns distance between a point and an
 * OBB.
 *
 * \param [in] point The point \param [in] center OBB center \param [in]
 * extents OBB extents \param [in] rot OBB rotation \param [out] params
 * Closest point on the box, in box space
 */ 6 4 this 3 3529  5 point 1 3143  6 center 1 3143  7 extents 1 3162  3 rot 1 3165  6 params 1 3151  
1451 0 0 7 1651 3532 0 0 10 /**
 *
 */ 0 
1452 0 0 7 1651 3532 0 0 0 1 6 param0 0 3533  
1453 0 0 4 1652 3129 0 0 49 /**
 * (re)sets the structure to the default.
 */ 1 4 this 3 3532  
1454 0 0 6 1653 3132 0 0 51 /**
 * Returns true if the descriptor is valid.
 */ 1 4 this 3 3533  
1455 0 0 7 1655 3422 0 0 10 /**
 *
 */ 0 
1456 0 0 4 1656 3129 0 0 46 /**
 * Radius of shape.  Must be positive.
 */ 2 4 this 3 3422  6 radius 1 3149  
1457 0 0 4 1657 3129 0 0 82 /**
 * Set the maximum extension distance of suspension along shape's -Y axis.
 */ 2 4 this 3 3422  16 suspensionTravel 1 3149  
1458 0 0 4 1658 3129 0 0 45 /**
 * Set the inverse mass of the wheel.
 */ 2 4 this 3 3422  16 inverseWheelMass 1 3149  
1459 0 0 4 1659 3129 0 0 55 /**
 * Set the sum engine torque on the wheel axle.
 */ 2 4 this 3 3422  11 motorTorque 1 3149  
1460 0 0 4 1660 3129 0 0 56 /**
 * Set the amount of torque applied for braking.
 */ 2 4 this 3 3422  11 brakeTorque 1 3149  
1461 0 0 4 1661 3129 0 0 102 /**
 * Set the steering angle, around shape Y axis.  The steering angle is
 * measured in degrees.
 */ 2 4 this 3 3422  10 steerAngle 1 3149  
1462 0 0 4 1662 3129 0 0 57 /**
 * Turn the specified wheel shape flag on or off.
 */ 3 4 this 3 3422  4 flag 1 2995  5 value 1 3132  
1463 0 0 4 1663 3129 0 0 66 /**
 * Set the data intended for car wheel suspension effects.
 */ 2 4 this 3 3422  6 spring 1 3362  
1464 0 0 6 1664 3149 0 0 27 /**
 * Radius of shape.
 */ 1 4 this 3 3535  
1465 0 0 6 1665 3149 0 0 10 /**
 *
 */ 1 4 this 3 3535  
1466 0 0 6 1666 3149 0 0 10 /**
 *
 */ 1 4 this 3 3535  
1467 0 0 6 1667 3149 0 0 10 /**
 *
 */ 1 4 this 3 3535  
1468 0 0 6 1668 3149 0 0 10 /**
 *
 */ 1 4 this 3 3535  
1469 0 0 6 1669 3149 0 0 10 /**
 *
 */ 1 4 this 3 3535  
1470 0 0 6 1670 3132 0 0 0 2 4 this 3 3535  4 flag 1 2995  
1471 0 0 7 1671 3366 2587 0 10 /**
 *
 */ 1 4 this 3 3535  
572
2965 10 PhysxEnums 0 141313 10 PhysxEnums 10 PhysxEnums 0 0 0 1 1472 1473 0 0 0 0 0 0 30 2966 2967 2968 2969 2970 2971 2972 2973 2974 2975 2976 2977 2978 2979 2980 2981 2982 2983 2984 2985 2986 2987 2988 2989 2990 2991 2992 2993 2994 2995 94
/**
 * This class exists just to provide scoping for the enums shared by PhysX
 * classes.
 */

2966 14 PhysxParameter 0 794624 26 PhysxEnums::PhysxParameter 26 PhysxEnums::PhysxParameter 2965 0 0 0 0 0 0 0 0 0 86 15 P_penalty_force 27 PhysxEnums::P_penalty_force 0
0 12 P_skin_width 24 PhysxEnums::P_skin_width 0
1 31 P_default_sleep_lin_vel_squared 43 PhysxEnums::P_default_sleep_lin_vel_squared 0
2 31 P_default_sleep_ang_vel_squared 43 PhysxEnums::P_default_sleep_ang_vel_squared 0
3 18 P_bounce_threshold 30 PhysxEnums::P_bounce_threshold 0
4 19 P_dyn_frict_scaling 31 PhysxEnums::P_dyn_frict_scaling 0
5 19 P_sta_frict_scaling 31 PhysxEnums::P_sta_frict_scaling 0
6 22 P_max_angular_velocity 34 PhysxEnums::P_max_angular_velocity 0
7 15 P_continuous_cd 27 PhysxEnums::P_continuous_cd 0
8 21 P_visualization_scale 33 PhysxEnums::P_visualization_scale 0
9 16 P_adaptive_force 28 PhysxEnums::P_adaptive_force 0
68 19 P_coll_veta_jointed 31 PhysxEnums::P_coll_veta_jointed 0
69 26 P_trigger_trigger_callback 38 PhysxEnums::P_trigger_trigger_callback 0
70 16 P_select_hw_algo 28 PhysxEnums::P_select_hw_algo 0
71 13 P_ccd_epsilon 25 PhysxEnums::P_ccd_epsilon 0
73 30 P_solver_convergence_threshold 42 PhysxEnums::P_solver_convergence_threshold 0
74 18 P_bbox_noise_level 30 PhysxEnums::P_bbox_noise_level 0
75 27 P_implicit_sweep_cache_size 39 PhysxEnums::P_implicit_sweep_cache_size 0
76 22 P_default_sleep_energy 34 PhysxEnums::P_default_sleep_energy 0
77 28 P_constant_fluid_max_packets 40 PhysxEnums::P_constant_fluid_max_packets 0
78 39 P_constant_fluid_max_particles_per_step 51 PhysxEnums::P_constant_fluid_max_particles_per_step 0
79 28 P_asynchronous_mesh_creation 40 PhysxEnums::P_asynchronous_mesh_creation 0
96 35 P_force_field_custom_kernel_epsilon 47 PhysxEnums::P_force_field_custom_kernel_epsilon 0
97 24 P_improved_spring_solver 36 PhysxEnums::P_improved_spring_solver 0
98 33 P_fast_massive_bp_volume_deletion 45 PhysxEnums::P_fast_massive_bp_volume_deletion 0
99 20 P_legacy_joint_drive 32 PhysxEnums::P_legacy_joint_drive 0
100 22 P_visualize_world_axes 34 PhysxEnums::P_visualize_world_axes 0
10 21 P_visualize_body_axes 33 PhysxEnums::P_visualize_body_axes 0
11 26 P_visualize_body_mass_axes 38 PhysxEnums::P_visualize_body_mass_axes 0
12 29 P_visualize_body_lin_velocity 41 PhysxEnums::P_visualize_body_lin_velocity 0
13 29 P_visualize_body_ang_velocity 41 PhysxEnums::P_visualize_body_ang_velocity 0
14 29 P_visualize_body_joint_groups 41 PhysxEnums::P_visualize_body_joint_groups 0
22 28 P_visualize_joint_local_axes 40 PhysxEnums::P_visualize_joint_local_axes 0
27 28 P_visualize_joint_world_axes 40 PhysxEnums::P_visualize_joint_world_axes 0
28 24 P_visualize_joint_limits 36 PhysxEnums::P_visualize_joint_limits 0
29 25 P_visualize_contact_point 37 PhysxEnums::P_visualize_contact_point 0
33 26 P_visualize_contact_normal 38 PhysxEnums::P_visualize_contact_normal 0
34 25 P_visualize_contact_error 37 PhysxEnums::P_visualize_contact_error 0
35 25 P_visualize_contact_force 37 PhysxEnums::P_visualize_contact_force 0
36 22 P_visualize_actor_axes 34 PhysxEnums::P_visualize_actor_axes 0
37 27 P_visualize_collision_aabbs 39 PhysxEnums::P_visualize_collision_aabbs 0
38 28 P_visualize_collision_shapes 40 PhysxEnums::P_visualize_collision_shapes 0
39 26 P_visualize_collision_axes 38 PhysxEnums::P_visualize_collision_axes 0
40 31 P_visualize_collision_compounds 43 PhysxEnums::P_visualize_collision_compounds 0
41 30 P_visualize_collision_vnormals 42 PhysxEnums::P_visualize_collision_vnormals 0
42 30 P_visualize_collision_fnormals 42 PhysxEnums::P_visualize_collision_fnormals 0
43 27 P_visualize_collision_edges 39 PhysxEnums::P_visualize_collision_edges 0
44 29 P_visualize_collision_spheres 41 PhysxEnums::P_visualize_collision_spheres 0
45 28 P_visualize_collision_static 40 PhysxEnums::P_visualize_collision_static 0
47 29 P_visualize_collision_dynamic 41 PhysxEnums::P_visualize_collision_dynamic 0
48 26 P_visualize_collision_free 38 PhysxEnums::P_visualize_collision_free 0
49 25 P_visualize_collision_ccd 37 PhysxEnums::P_visualize_collision_ccd 0
50 31 P_visualize_collision_skeletons 43 PhysxEnums::P_visualize_collision_skeletons 0
51 26 P_visualize_fluid_emitters 38 PhysxEnums::P_visualize_fluid_emitters 0
52 26 P_visualize_fluid_position 38 PhysxEnums::P_visualize_fluid_position 0
53 26 P_visualize_fluid_velocity 38 PhysxEnums::P_visualize_fluid_velocity 0
54 31 P_visualize_fluid_kernel_radius 43 PhysxEnums::P_visualize_fluid_kernel_radius 0
55 24 P_visualize_fluid_bounds 36 PhysxEnums::P_visualize_fluid_bounds 0
56 25 P_visualize_fluid_packets 37 PhysxEnums::P_visualize_fluid_packets 0
57 30 P_visualize_fluid_motion_limit 42 PhysxEnums::P_visualize_fluid_motion_limit 0
58 31 P_visualize_fluid_dyn_collision 43 PhysxEnums::P_visualize_fluid_dyn_collision 0
59 31 P_visualize_fluid_stc_collision 43 PhysxEnums::P_visualize_fluid_stc_collision 0
60 30 P_visualize_fluid_mesh_packets 42 PhysxEnums::P_visualize_fluid_mesh_packets 0
61 24 P_visualize_fluid_drains 36 PhysxEnums::P_visualize_fluid_drains 0
62 29 P_visualize_fluid_packet_data 41 PhysxEnums::P_visualize_fluid_packet_data 0
90 22 P_visualize_cloth_mesh 34 PhysxEnums::P_visualize_cloth_mesh 0
63 28 P_visualize_cloth_collisions 40 PhysxEnums::P_visualize_cloth_collisions 0
64 32 P_visualize_cloth_selfcollisions 44 PhysxEnums::P_visualize_cloth_selfcollisions 0
65 29 P_visualize_cloth_workpackets 41 PhysxEnums::P_visualize_cloth_workpackets 0
66 23 P_visualize_cloth_sleep 35 PhysxEnums::P_visualize_cloth_sleep 0
67 30 P_visualize_cloth_sleep_vertex 42 PhysxEnums::P_visualize_cloth_sleep_vertex 0
94 35 P_visualize_cloth_tearable_vertices 47 PhysxEnums::P_visualize_cloth_tearable_vertices 0
80 25 P_visualize_cloth_tearing 37 PhysxEnums::P_visualize_cloth_tearing 0
81 28 P_visualize_cloth_attachment 40 PhysxEnums::P_visualize_cloth_attachment 0
82 29 P_visualize_cloth_validbounds 41 PhysxEnums::P_visualize_cloth_validbounds 0
92 25 P_visualize_softbody_mesh 37 PhysxEnums::P_visualize_softbody_mesh 0
83 31 P_visualize_softbody_collisions 43 PhysxEnums::P_visualize_softbody_collisions 0
84 32 P_visualize_softbody_workpackets 44 PhysxEnums::P_visualize_softbody_workpackets 0
85 26 P_visualize_softbody_sleep 38 PhysxEnums::P_visualize_softbody_sleep 0
86 33 P_visualize_softbody_sleep_vertex 45 PhysxEnums::P_visualize_softbody_sleep_vertex 0
95 38 P_visualize_softbody_tearable_vertices 50 PhysxEnums::P_visualize_softbody_tearable_vertices 0
87 28 P_visualize_softbody_tearing 40 PhysxEnums::P_visualize_softbody_tearing 0
88 31 P_visualize_softbody_attachment 43 PhysxEnums::P_visualize_softbody_attachment 0
89 32 P_visualize_softbody_validbounds 44 PhysxEnums::P_visualize_softbody_validbounds 0
93 27 P_visualize_active_vertices 39 PhysxEnums::P_visualize_active_vertices 0
72 24 P_visualize_force_fields 36 PhysxEnums::P_visualize_force_fields 0
91 0 0

2967 14 PhysxActorFlag 0 794624 26 PhysxEnums::PhysxActorFlag 26 PhysxEnums::PhysxActorFlag 2965 0 0 0 0 0 0 0 0 0 7 20 AF_disable_collision 32 PhysxEnums::AF_disable_collision 0
1 19 AF_disable_response 31 PhysxEnums::AF_disable_response 0
2 11 AF_lock_com 23 PhysxEnums::AF_lock_com 0
4 26 AF_fluid_disable_collision 38 PhysxEnums::AF_fluid_disable_collision 0
8 23 AF_contact_modification 35 PhysxEnums::AF_contact_modification 0
16 22 AF_force_cone_friction 34 PhysxEnums::AF_force_cone_friction 0
32 28 AF_user_actor_pair_filtering 40 PhysxEnums::AF_user_actor_pair_filtering 0
64 0 0

2968 13 PhysxBodyFlag 0 794624 25 PhysxEnums::PhysxBodyFlag 25 PhysxEnums::PhysxBodyFlag 2965 0 0 0 0 0 0 0 0 0 14 18 BF_disable_gravity 30 PhysxEnums::BF_disable_gravity 0
1 15 Bf_frozen_pos_x 27 PhysxEnums::Bf_frozen_pos_x 0
2 15 BF_frozen_pos_y 27 PhysxEnums::BF_frozen_pos_y 0
4 15 BF_frozen_pos_z 27 PhysxEnums::BF_frozen_pos_z 0
8 15 BF_frozen_rot_x 27 PhysxEnums::BF_frozen_rot_x 0
16 15 BF_frozen_rot_y 27 PhysxEnums::BF_frozen_rot_y 0
32 15 BF_frozen_rot_z 27 PhysxEnums::BF_frozen_rot_z 0
64 13 BF_frozen_pos 25 PhysxEnums::BF_frozen_pos 0
256 13 BF_frozen_rot 25 PhysxEnums::BF_frozen_rot 0
131072 9 BF_frozen 21 PhysxEnums::BF_frozen 0
131328 12 BF_kinematic 24 PhysxEnums::BF_kinematic 0
128 16 BF_visualization 28 PhysxEnums::BF_visualization 0
256 19 BF_filter_sleep_vel 31 PhysxEnums::BF_filter_sleep_vel 0
1024 20 BF_energy_sleep_test 32 PhysxEnums::BF_energy_sleep_test 0
2048 0 0

2969 19 PhysxBroadPhaseType 0 794624 31 PhysxEnums::PhysxBroadPhaseType 31 PhysxEnums::PhysxBroadPhaseType 2965 0 0 0 0 0 0 0 0 0 2 14 BPT_sap_single 26 PhysxEnums::BPT_sap_single 0
0 13 BPT_sap_multi 25 PhysxEnums::BPT_sap_multi 0
1 0 0

2970 14 PhysxClothFlag 0 794624 26 PhysxEnums::PhysxClothFlag 26 PhysxEnums::PhysxClothFlag 2965 0 0 0 0 0 0 0 0 0 18 12 CLF_pressure 24 PhysxEnums::CLF_pressure 0
1 10 CLF_static 22 PhysxEnums::CLF_static 0
2 21 CLF_disable_collision 33 PhysxEnums::CLF_disable_collision 0
4 17 CLF_selfcollision 29 PhysxEnums::CLF_selfcollision 0
8 17 CLF_visualization 29 PhysxEnums::CLF_visualization 0
16 11 CLF_gravity 23 PhysxEnums::CLF_gravity 0
32 11 CLF_bending 23 PhysxEnums::CLF_bending 0
64 17 CLF_bending_ortho 29 PhysxEnums::CLF_bending_ortho 0
128 11 CLF_damping 23 PhysxEnums::CLF_damping 0
256 20 CLF_collision_twoway 32 PhysxEnums::CLF_collision_twoway 0
512 22 CLF_triangle_collision 34 PhysxEnums::CLF_triangle_collision 0
2048 12 CLF_tearable 24 PhysxEnums::CLF_tearable 0
4096 12 CLF_hardware 24 PhysxEnums::CLF_hardware 0
8192 14 CLF_comdamping 26 PhysxEnums::CLF_comdamping 0
16384 15 CLF_validbounds 27 PhysxEnums::CLF_validbounds 0
32768 19 CLF_fluid_collision 31 PhysxEnums::CLF_fluid_collision 0
65536 23 CLF_disable_dynamic_ccd 35 PhysxEnums::CLF_disable_dynamic_ccd 0
131072 10 CLF_adhere 22 PhysxEnums::CLF_adhere 0
262144 0 0

2971 20 PhysxContactPairFlag 0 794624 32 PhysxEnums::PhysxContactPairFlag 32 PhysxEnums::PhysxContactPairFlag 2965 0 0 0 0 0 0 0 0 0 12 15 CPF_ignore_pair 27 PhysxEnums::CPF_ignore_pair 0
1 25 CPF_notify_on_start_touch 37 PhysxEnums::CPF_notify_on_start_touch 0
2 23 CPF_notify_on_end_touch 35 PhysxEnums::CPF_notify_on_end_touch 0
4 19 CPF_notify_on_touch 31 PhysxEnums::CPF_notify_on_touch 0
8 20 CPF_notify_on_impact 32 PhysxEnums::CPF_notify_on_impact 0
16 18 CPF_notify_on_roll 30 PhysxEnums::CPF_notify_on_roll 0
32 19 CPF_notify_on_slide 31 PhysxEnums::CPF_notify_on_slide 0
64 17 CPF_notify_forces 29 PhysxEnums::CPF_notify_forces 0
128 35 CPF_notify_on_start_touch_threshold 47 PhysxEnums::CPF_notify_on_start_touch_threshold 0
256 33 CPF_notify_on_end_touch_threshold 45 PhysxEnums::CPF_notify_on_end_touch_threshold 0
512 29 CPF_notify_on_touch_threshold 41 PhysxEnums::CPF_notify_on_touch_threshold 0
1024 32 CPF_notify_contact_modifications 44 PhysxEnums::CPF_notify_contact_modifications 0
65536 0 0

2972 16 PhysxCombineMode 0 794624 28 PhysxEnums::PhysxCombineMode 28 PhysxEnums::PhysxCombineMode 2965 0 0 0 0 0 0 0 0 0 4 10 CM_average 22 PhysxEnums::CM_average 0
0 6 CM_min 18 PhysxEnums::CM_min 0
1 11 CM_multiply 23 PhysxEnums::CM_multiply 0
2 6 CM_max 18 PhysxEnums::CM_max 0
3 0 0

2973 21 PhysxD6JointDriveType 0 794624 33 PhysxEnums::PhysxD6JointDriveType 33 PhysxEnums::PhysxD6JointDriveType 2965 0 0 0 0 0 0 0 0 0 2 23 D6_joint_drive_position 35 PhysxEnums::D6_joint_drive_position 0
1 23 D6_joint_drive_velocity 35 PhysxEnums::D6_joint_drive_velocity 0
2 0 0

2974 16 PhysxD6JointFlag 0 794624 28 PhysxEnums::PhysxD6JointFlag 28 PhysxEnums::PhysxD6JointFlag 2965 0 0 0 0 0 0 0 0 0 2 20 D6_joint_slerp_drive 32 PhysxEnums::D6_joint_slerp_drive 0
1 22 D6_joint_gear_disabled 34 PhysxEnums::D6_joint_gear_disabled 0
2 0 0

2975 18 PhysxD6JointMotion 0 794624 30 PhysxEnums::PhysxD6JointMotion 30 PhysxEnums::PhysxD6JointMotion 2965 0 0 0 0 0 0 0 0 0 3 22 D6_joint_motion_locked 34 PhysxEnums::D6_joint_motion_locked 0
0 23 D6_joint_motion_limited 35 PhysxEnums::D6_joint_motion_limited 0
1 20 D6_joint_motion_free 32 PhysxEnums::D6_joint_motion_free 0
2 0 0

2976 22 PhysxDistanceJointFlag 0 794624 34 PhysxEnums::PhysxDistanceJointFlag 34 PhysxEnums::PhysxDistanceJointFlag 2965 0 0 0 0 0 0 0 0 0 3 24 DJF_max_distance_enabled 36 PhysxEnums::DJF_max_distance_enabled 0
1 24 DJF_mix_distance_enabled 36 PhysxEnums::DJF_mix_distance_enabled 0
2 18 DJF_spring_enabled 30 PhysxEnums::DJF_spring_enabled 0
4 0 0

2977 13 PhysxFilterOp 0 794624 25 PhysxEnums::PhysxFilterOp 25 PhysxEnums::PhysxFilterOp 2965 0 0 0 0 0 0 0 0 0 7 6 FO_and 18 PhysxEnums::FO_and 0
0 5 FO_or 17 PhysxEnums::FO_or 0
1 6 FO_xor 18 PhysxEnums::FO_xor 0
2 7 FO_nand 19 PhysxEnums::FO_nand 0
3 6 FO_nor 18 PhysxEnums::FO_nor 0
4 7 FO_nxor 19 PhysxEnums::FO_nxor 0
5 11 FO_swap_and 23 PhysxEnums::FO_swap_and 0
6 0 0

2978 26 PhysxForceFieldCoordinates 0 794624 38 PhysxEnums::PhysxForceFieldCoordinates 38 PhysxEnums::PhysxForceFieldCoordinates 2965 0 0 0 0 0 0 0 0 0 4 13 FFC_cartesian 25 PhysxEnums::FFC_cartesian 0
0 13 FFC_spherical 25 PhysxEnums::FFC_spherical 0
1 15 FFC_cylindrical 27 PhysxEnums::FFC_cylindrical 0
2 12 FFC_toroidal 24 PhysxEnums::FFC_toroidal 0
3 0 0

2979 29 PhysxForceFieldShapeGroupFlag 0 794624 41 PhysxEnums::PhysxForceFieldShapeGroupFlag 41 PhysxEnums::PhysxForceFieldShapeGroupFlag 2965 0 0 0 0 0 0 0 0 0 1 18 FFSG_exclude_group 30 PhysxEnums::FFSG_exclude_group 0
1 0 0

2980 14 PhysxForceMode 0 794624 26 PhysxEnums::PhysxForceMode 26 PhysxEnums::PhysxForceMode 2965 0 0 0 0 0 0 0 0 0 6 8 FM_force 20 PhysxEnums::FM_force 0
0 10 FM_impulse 22 PhysxEnums::FM_impulse 0
1 18 FM_velocity_change 30 PhysxEnums::FM_velocity_change 0
2 17 FM_smooth_impulse 29 PhysxEnums::FM_smooth_impulse 0
3 25 FM_smooth_velocity_change 37 PhysxEnums::FM_smooth_velocity_change 0
4 15 FM_acceleration 27 PhysxEnums::FM_acceleration 0
5 0 0

2981 14 PhysxJointFlag 0 794624 26 PhysxEnums::PhysxJointFlag 26 PhysxEnums::PhysxJointFlag 2965 0 0 0 0 0 0 0 0 0 2 20 JF_collision_enabled 32 PhysxEnums::JF_collision_enabled 0
1 16 JF_visualization 28 PhysxEnums::JF_visualization 0
2 0 0

2982 17 PhysxMaterialFlag 0 794624 29 PhysxEnums::PhysxMaterialFlag 29 PhysxEnums::PhysxMaterialFlag 2965 0 0 0 0 0 0 0 0 0 3 14 MF_anisotropic 26 PhysxEnums::MF_anisotropic 0
1 19 MF_disable_friction 31 PhysxEnums::MF_disable_friction 0
16 26 MF_disable_strong_friction 38 PhysxEnums::MF_disable_strong_friction 0
32 0 0

2983 19 PhysxProjectionMode 0 794624 31 PhysxEnums::PhysxProjectionMode 31 PhysxEnums::PhysxProjectionMode 2965 0 0 0 0 0 0 0 0 0 3 7 PM_none 19 PhysxEnums::PM_none 0
0 16 PM_point_mindist 28 PhysxEnums::PM_point_mindist 0
1 17 PM_linear_mindist 29 PhysxEnums::PM_linear_mindist 0
2 0 0

2984 21 PhysxPruningStructure 0 794624 33 PhysxEnums::PhysxPruningStructure 33 PhysxEnums::PhysxPruningStructure 2965 0 0 0 0 0 0 0 0 0 5 7 PS_none 19 PhysxEnums::PS_none 0
0 9 PS_octree 21 PhysxEnums::PS_octree 0
1 11 PS_quadtree 23 PhysxEnums::PS_quadtree 0
2 20 PS_dynamic_aabb_tree 32 PhysxEnums::PS_dynamic_aabb_tree 0
3 19 PS_static_aabb_tree 31 PhysxEnums::PS_static_aabb_tree 0
4 0 0

2985 20 PhysxPulleyJointFlag 0 794624 32 PhysxEnums::PhysxPulleyJointFlag 32 PhysxEnums::PhysxPulleyJointFlag 2965 0 0 0 0 0 0 0 0 0 2 12 PJF_is_rigid 24 PhysxEnums::PJF_is_rigid 0
1 17 PJF_motor_enabled 29 PhysxEnums::PJF_motor_enabled 0
2 0 0

2986 22 PhysxRevoluteJointFlag 0 794624 34 PhysxEnums::PhysxRevoluteJointFlag 34 PhysxEnums::PhysxRevoluteJointFlag 2965 0 0 0 0 0 0 0 0 0 3 17 RJF_limit_enabled 29 PhysxEnums::RJF_limit_enabled 0
1 17 RJF_motor_enabled 29 PhysxEnums::RJF_motor_enabled 0
2 18 RJF_spring_enabled 30 PhysxEnums::RJF_spring_enabled 0
4 0 0

2987 14 PhysxSceneFlag 0 794624 26 PhysxEnums::PhysxSceneFlag 26 PhysxEnums::PhysxSceneFlag 2965 0 0 0 0 0 0 0 0 0 7 14 SF_disable_sse 26 PhysxEnums::SF_disable_sse 0
1 21 SF_disable_collisions 33 PhysxEnums::SF_disable_collisions 0
2 19 SF_restricted_scene 31 PhysxEnums::SF_restricted_scene 0
32 22 SF_disable_scene_mutex 34 PhysxEnums::SF_disable_scene_mutex 0
64 22 SF_force_cone_friction 34 PhysxEnums::SF_force_cone_friction 0
128 21 SF_sequential_primary 33 PhysxEnums::SF_sequential_primary 0
256 25 SF_fluid_performance_hint 37 PhysxEnums::SF_fluid_performance_hint 0
512 0 0

2988 14 PhysxShapeFlag 0 794624 26 PhysxEnums::PhysxShapeFlag 26 PhysxEnums::PhysxShapeFlag 2965 0 0 0 0 0 0 0 0 0 21 19 SF_trigger_on_enter 31 PhysxEnums::SF_trigger_on_enter 0
1 19 SF_trigger_on_leave 31 PhysxEnums::SF_trigger_on_leave 0
2 18 SF_trigger_on_stay 30 PhysxEnums::SF_trigger_on_stay 0
4 17 SF_trigger_enable 29 PhysxEnums::SF_trigger_enable 0
7 16 SF_visualization 28 PhysxEnums::SF_visualization 0
8 20 SF_disable_collision 32 PhysxEnums::SF_disable_collision 0
16 21 SF_disable_raycasting 33 PhysxEnums::SF_disable_raycasting 0
64 19 SF_disable_response 31 PhysxEnums::SF_disable_response 0
4096 24 SF_disable_scene_queries 36 PhysxEnums::SF_disable_scene_queries 0
16384 22 SF_point_contact_force 34 PhysxEnums::SF_point_contact_force 0
128 18 SF_feature_indices 30 PhysxEnums::SF_feature_indices 0
32 22 SF_dynamic_dynamic_ccd 34 PhysxEnums::SF_dynamic_dynamic_ccd 0
8192 14 SF_fluid_drain 26 PhysxEnums::SF_fluid_drain 0
256 26 SF_fluid_disable_collision 38 PhysxEnums::SF_fluid_disable_collision 0
1024 15 SF_fluid_twoway 27 PhysxEnums::SF_fluid_twoway 0
2048 14 SF_cloth_drain 26 PhysxEnums::SF_cloth_drain 0
32768 26 SF_cloth_disable_collision 38 PhysxEnums::SF_cloth_disable_collision 0
65536 15 SF_cloth_twoway 27 PhysxEnums::SF_cloth_twoway 0
131072 17 SF_softbody_drain 29 PhysxEnums::SF_softbody_drain 0
262144 29 SF_softbody_disable_collision 41 PhysxEnums::SF_softbody_disable_collision 0
524288 18 SF_softbody_twoway 30 PhysxEnums::SF_softbody_twoway 0
1048576 0 0

2989 17 PhysxSoftBodyFlag 0 794624 29 PhysxEnums::PhysxSoftBodyFlag 29 PhysxEnums::PhysxSoftBodyFlag 2965 0 0 0 0 0 0 0 0 0 15 10 SBF_static 22 PhysxEnums::SBF_static 0
2 21 SBF_disable_collision 33 PhysxEnums::SBF_disable_collision 0
4 17 SBF_selfcollision 29 PhysxEnums::SBF_selfcollision 0
8 17 SBF_visualization 29 PhysxEnums::SBF_visualization 0
16 11 SBF_gravity 23 PhysxEnums::SBF_gravity 0
32 22 SBF_volume_conservtion 34 PhysxEnums::SBF_volume_conservtion 0
64 11 SBF_damping 23 PhysxEnums::SBF_damping 0
128 20 SBF_collision_twoway 32 PhysxEnums::SBF_collision_twoway 0
256 12 SBF_tearable 24 PhysxEnums::SBF_tearable 0
512 12 SBF_hardware 24 PhysxEnums::SBF_hardware 0
1024 14 SBF_comdamping 26 PhysxEnums::SBF_comdamping 0
2048 15 SBF_validbounds 27 PhysxEnums::SBF_validbounds 0
4096 19 SBF_fluid_collision 31 PhysxEnums::SBF_fluid_collision 0
8192 23 SBF_disable_dynamic_ccd 35 PhysxEnums::SBF_disable_dynamic_ccd 0
16384 10 SBF_adhere 22 PhysxEnums::SBF_adhere 0
32768 0 0

2990 15 PhysxShapesType 0 794624 27 PhysxEnums::PhysxShapesType 27 PhysxEnums::PhysxShapesType 2965 0 0 0 0 0 0 0 0 0 3 9 ST_static 21 PhysxEnums::ST_static 0
1 10 ST_dynamic 22 PhysxEnums::ST_dynamic 0
2 6 ST_all 18 PhysxEnums::ST_all 0
3 0 0

2991 23 PhysxSphericalJointFlag 0 794624 35 PhysxEnums::PhysxSphericalJointFlag 35 PhysxEnums::PhysxSphericalJointFlag 2965 0 0 0 0 0 0 0 0 0 6 23 SJF_twist_limit_enabled 35 PhysxEnums::SJF_twist_limit_enabled 0
1 23 SJF_swing_limit_enabled 35 PhysxEnums::SJF_swing_limit_enabled 0
2 24 SJF_twist_spring_enabled 36 PhysxEnums::SJF_twist_spring_enabled 0
4 24 SJF_swing_spring_enabled 36 PhysxEnums::SJF_swing_spring_enabled 0
8 24 SJF_joint_spring_enabled 36 PhysxEnums::SJF_joint_spring_enabled 0
16 33 SJF_perpendicular_dir_constraints 45 PhysxEnums::SJF_perpendicular_dir_constraints 0
32 0 0

2992 11 PhysxUpAxis 0 794624 23 PhysxEnums::PhysxUpAxis 23 PhysxEnums::PhysxUpAxis 2965 0 0 0 0 0 0 0 0 0 3 4 X_up 16 PhysxEnums::X_up 0
1 4 Y_up 16 PhysxEnums::Y_up 0
2 4 Z_up 16 PhysxEnums::Z_up 0
3 0 0

2993 27 PhysxVertexAttachmentStatus 0 794624 39 PhysxEnums::PhysxVertexAttachmentStatus 39 PhysxEnums::PhysxVertexAttachmentStatus 2965 0 0 0 0 0 0 0 0 0 3 8 VAS_none 20 PhysxEnums::VAS_none 0
0 10 VAS_global 22 PhysxEnums::VAS_global 0
1 9 VAS_shape 21 PhysxEnums::VAS_shape 0
2 0 0

2994 14 PhysxWheelFlag 0 794624 26 PhysxEnums::PhysxWheelFlag 26 PhysxEnums::PhysxWheelFlag 2965 0 0 0 0 0 0 0 0 0 4 18 WF_steerable_input 30 PhysxEnums::WF_steerable_input 0
1 17 WF_steerable_auto 29 PhysxEnums::WF_steerable_auto 0
2 24 WF_affected_by_handbrake 36 PhysxEnums::WF_affected_by_handbrake 0
4 14 WF_accelerated 26 PhysxEnums::WF_accelerated 0
8 0 0

2995 19 PhysxWheelShapeFlag 0 794624 31 PhysxEnums::PhysxWheelShapeFlag 31 PhysxEnums::PhysxWheelShapeFlag 2965 0 0 0 0 0 0 0 0 0 7 29 WSF_wheel_axis_contact_normal 41 PhysxEnums::WSF_wheel_axis_contact_normal 0
1 26 WSF_input_lat_slipvelocity 38 PhysxEnums::WSF_input_lat_slipvelocity 0
2 26 WSF_input_lng_slipvelocity 38 PhysxEnums::WSF_input_lng_slipvelocity 0
4 28 WSF_unscaled_spring_behavior 40 PhysxEnums::WSF_unscaled_spring_behavior 0
8 23 WSF_axle_speed_override 35 PhysxEnums::WSF_axle_speed_override 0
16 24 WSF_emulate_legacy_wheel 36 PhysxEnums::WSF_emulate_legacy_wheel 0
32 20 WSF_clamped_friction 32 PhysxEnums::WSF_clamped_friction 0
64 0 0

2996 11 PhysxObject 0 43009 11 PhysxObject 11 PhysxObject 0 0 0 0 0 0 7 1474 1475 1476 1477 1478 1479 1480 0 0 1 0 2997 0 0 0 0 10
/**
 *
 */

2997 19 TypedReferenceCount 0 2049 19 TypedReferenceCount 19 TypedReferenceCount 0 0 0 0 0 0 0 0 0 0 0 0 410
/**
 * A base class for things which need to inherit from both TypedObject and
 * from ReferenceCount.  It's convenient to define this intermediate base
 * class instead of multiply inheriting from the two classes each time they
 * are needed, so that we can sensibly pass around pointers to things which
 * are both TypedObjects and ReferenceCounters.
 *
 * See also TypedObject for detailed instructions.
 */

2998 10 PhysxActor 0 26625 10 PhysxActor 10 PhysxActor 0 0 0 1 1485 1486 0 92 1487 1488 1489 1490 1491 1492 1493 1494 1495 1496 1497 1498 1499 1500 1501 1502 1503 1504 1505 1506 1507 1508 1509 1510 1511 1512 1513 1514 1515 1516 1517 1518 1519 1520 1521 1522 1523 1524 1525 1526 1527 1528 1529 1530 1531 1532 1533 1534 1535 1536 1537 1538 1539 1540 1541 1542 1543 1544 1545 1546 1547 1548 1549 1550 1551 1552 1553 1554 1555 1556 1557 1558 1559 1560 1561 1562 1563 1564 1565 1566 1567 1568 1569 1570 1571 1572 1573 1574 1575 1576 1577 1578 1 3537 0 2 3 2996 1481 1482 3 2965 1483 1484 0 0 427
/**
 * Actors are the main simulation objects.  Actors are owned by a scene
 * (PhysxScene).
 *
 * An actor may optionally encapsulate a dynamic rigid body by setting the
 * body member of the actor's descriptor when it is created.  Otherwise the
 * actor will be static (fixed in the world).
 *
 * Instances of PhysxActor are created by calling PhysxScene::create_actor()
 * and destroyed by calling PhysxActor::release().
 */

2999 15 PhysxController 0 141313 15 PhysxController 15 PhysxController 0 0 0 0 1602 0 19 1583 1584 1585 1586 1587 1588 1589 1590 1591 1592 1593 1594 1595 1596 1597 1598 1599 1600 1601 0 0 2 3 2996 1579 1580 3 2965 1581 1582 0 0 57
/**
 * Abstract base class for character controllers.
 */

3000 18 PhysxBoxController 0 75777 18 PhysxBoxController 18 PhysxBoxController 0 0 0 1 1603 1602 0 3 1604 1605 1606 0 0 1 0 2999 0 0 0 0 36
/**
 * Box character controller.
 */

3001 20 PhysxForceFieldShape 0 141313 20 PhysxForceFieldShape 20 PhysxForceFieldShape 0 0 0 0 1622 0 11 1611 1612 1613 1614 1615 1616 1617 1618 1619 1620 1621 0 0 2 3 2996 1607 1608 3 2965 1609 1610 0 0 54
/**
 * Abstract base class for force field shapes.
 */

3002 23 PhysxBoxForceFieldShape 0 75777 23 PhysxBoxForceFieldShape 23 PhysxBoxForceFieldShape 0 0 0 1 1623 1622 0 4 1624 1625 1626 1627 0 0 1 0 3001 0 0 0 0 60
/**
 * A box shaped region used to define a force field.
 */

3003 10 PhysxShape 0 141313 10 PhysxShape 10 PhysxShape 0 0 0 0 1661 0 29 1632 1633 1634 1635 1636 1637 1638 1639 1640 1641 1642 1643 1644 1645 1646 1647 1648 1649 1650 1651 1652 1653 1654 1655 1656 1657 1658 1659 1660 0 0 2 3 2996 1628 1629 3 2965 1630 1631 0 0 42
/**
 * Abstract base class for shapes.
 */

3004 13 PhysxBoxShape 0 75777 13 PhysxBoxShape 13 PhysxBoxShape 0 0 0 1 1662 1661 0 4 1663 1664 1665 1666 0 0 1 0 3003 0 0 0 0 445
/**
 * A box shaped collision detection primitive.  Each shape is owned by the
 * actor which it is attached to.
 *
 * An instance can be created by calling the createShape() method of the
 * PhysxActor object that will own it, with a PhysxBoxShapeDesc object as the
 * parameter, or by adding the shape descriptor to the PhysxActorDesc class
 * before creating the actor.
 *
 * The shape is deleted by calling release() on the shape itself.
 */

3005 22 PhysxCapsuleController 0 75777 22 PhysxCapsuleController 22 PhysxCapsuleController 0 0 0 1 1667 1602 0 5 1668 1669 1670 1671 1672 0 0 1 0 2999 0 0 0 0 524
/**
 * A capsule character controller.
 *
 * The capsule is defined as a position, a vertical height, and a radius.  The
 * height is the same height as for PhysxCapsuleShape objects, i.e.  the
 * distance between the two sphere centers at the end of the capsule.  In
 * other words:
 *
 * p = pos (returned by controller) h = height r = radius
 *
 * p = center of capsule top sphere center = p.y + h*0.5 bottom sphere center
 * = p.y - h*0.5 top capsule point = p.y + h*0.5 + r bottom capsule point =
 * p.y - h*0.5 - r
 */

3006 27 PhysxCapsuleForceFieldShape 0 75777 27 PhysxCapsuleForceFieldShape 27 PhysxCapsuleForceFieldShape 0 0 0 1 1673 1622 0 6 1674 1675 1676 1677 1678 1679 0 0 1 0 3001 0 0 0 0 64
/**
 * A capsule shaped region used to define a force field.
 */

3007 17 PhysxCapsuleShape 0 75777 17 PhysxCapsuleShape 17 PhysxCapsuleShape 0 0 0 1 1680 1661 0 6 1681 1682 1683 1684 1685 1686 0 0 1 0 3003 0 0 0 0 694
/**
 * A capsule shaped collision detection primitive, also known as a line swept
 * sphere.  'radius' is the radius of the capsule's hemispherical ends and its
 * trunk.  'height' is the distance between the two hemispherical ends of the
 * capsule.  The height is along the capsule's Y axis.  Each shape is owned by
 * an actor that it is attached to.
 *
 * An instance can be created by calling the createShape() method of the
 * PhysxActor object that should own it, with a PhysxCapsuleShapeDesc object
 * as the parameter, or by adding the shape descriptor into the PhysxActorDesc
 * class before creating the actor.
 *
 * The shape is deleted by calling release() on the shape itself.
 */

3008 16 PhysxCcdSkeleton 0 75777 16 PhysxCcdSkeleton 16 PhysxCcdSkeleton 0 0 0 0 0 0 3 1687 1688 1689 0 0 1 0 2996 0 0 0 0 125
/**
 * A Convex Mesh.  Internally represented as a list of convex polygons.  The
 * number of polygons is limited to 256.
 */

3009 10 PhysxCloth 0 26625 10 PhysxCloth 10 PhysxCloth 0 0 0 1 1694 1695 0 40 1696 1697 1698 1699 1700 1701 1702 1703 1704 1705 1706 1707 1708 1709 1710 1711 1712 1713 1714 1715 1716 1717 1718 1719 1720 1721 1722 1723 1724 1725 1726 1727 1728 1729 1730 1731 1732 1733 1734 1735 0 0 2 3 2996 1690 1691 3 2965 1692 1693 0 0 10
/**
 *
 */

3010 14 PhysxClothMesh 0 75777 14 PhysxClothMesh 14 PhysxClothMesh 0 0 0 0 0 0 3 1736 1737 1738 0 0 1 0 2996 0 0 0 0 10
/**
 *
 */

3011 14 PhysxClothNode 0 75777 14 PhysxClothNode 14 PhysxClothNode 0 0 0 1 1739 0 0 2 1740 1741 0 0 1 0 3012 0 0 0 0 61
/**
 * Renderable geometry which represents a cloth mesh.
 */

3012 8 GeomNode 0 2049 8 GeomNode 8 GeomNode 0 0 0 0 0 0 0 0 0 0 0 0 208
/**
 * A node that holds Geom objects, renderable pieces of geometry.  This is the
 * primary kind of leaf node in the scene graph; almost all visible objects
 * will be contained in a GeomNode somewhere.
 */

3013 16 PhysxContactPair 0 75777 16 PhysxContactPair 16 PhysxContactPair 0 0 0 0 0 0 9 1742 1743 1744 1745 1746 1747 1748 1749 1750 1 3538 0 1 0 2997 0 0 0 0 128
/**
 * An instance of this class is send with contact reporting events.  It
 * contains detailed information on the contact.
 */

3014 17 PhysxContactPoint 0 75777 17 PhysxContactPoint 17 PhysxContactPoint 0 0 0 1 1751 0 0 7 1752 1753 1754 1755 1756 1757 1758 0 0 1 0 3015 0 0 0 0 97
/**
 * A helper structure for iterating over contact streams reported by
 * PhysxContactPair.
 */

3015 11 TypedObject 0 2049 11 TypedObject 11 TypedObject 0 0 0 0 0 0 0 0 0 0 0 0 2508
/**
 * This is an abstract class that all classes which use TypeHandle, and also
 * provide virtual functions to support polymorphism, should inherit from.
 * Each derived class should define get_type(), which should return the
 * specific type of the derived class.  Inheriting from this automatically
 * provides support for is_of_type() and is_exact_type().
 *
 * All classes that inherit directly or indirectly from TypedObject should
 * redefine get_type() and force_init_type(), as shown below.  Some classes
 * that do not inherit from TypedObject may still declare TypeHandles for
 * themselves by defining methods called get_class_type() and init_type().
 * Classes such as these may serve as base classes, but the dynamic type
 * identification system will be limited.  Classes that do not inherit from
 * TypedObject need not define the virtual functions get_type() and
 * force_init_type() (or any other virtual functions).
 *
 * There is a specific layout for defining the overrides from this class.
 * Keeping the definitions formatted just like these examples will allow
 * someone in the future to use a sed (or similar) script to make global
 * changes, if necessary.  Avoid rearranging the braces or the order of the
 * functions unless you're ready to change them in every file all at once.
 *
 * What follows are some examples that can be used in new classes that you
 * create.
 *
 * @par In the class definition (.h file):
 * @code
 * public:
 *   static TypeHandle get_class_type() {
 *     return _type_handle;
 *   }
 *   static void init_type() {
 *     <<<BaseClassOne>>>::init_type();
 *     <<<BaseClassTwo>>>::init_type();
 *     <<<BaseClassN>>>::init_type();
 *     register_type(_type_handle, "<<<ThisClassStringName>>>",
 *                   <<<BaseClassOne>>>::get_class_type(),
 *                   <<<BaseClassTwo>>>::get_class_type(),
 *                   <<<BaseClassN>>>::get_class_type());
 *   }
 *   virtual TypeHandle get_type() const {
 *     return get_class_type();
 *   }
 *   virtual TypeHandle force_init_type() {init_type(); return get_class_type();}
 *
 * private:
 *   static TypeHandle _type_handle;
 * @endcode
 *
 * @par In the class .cxx file:
 * @code
 * TypeHandle <<<ThisClassStringName>>>::_type_handle;
 * @endcode
 *
 * @par In the class config_<<<PackageName>>>.cxx file:
 * @code
 * ConfigureFn(config_<<<PackageName>>>) {
 *   <<<ClassOne>>>::init_type();
 *   <<<ClassTwo>>>::init_type();
 *   <<<ClassN>>>::init_type();
 * }
 * @endcode
 */

3016 12 PhysxManager 0 26625 12 PhysxManager 12 PhysxManager 0 0 0 1 1785 1759 0 25 1760 1761 1762 1763 1764 1765 1766 1767 1768 1769 1770 1771 1772 1773 1774 1775 1776 1777 1778 1779 1780 1781 1782 1783 1784 7 3539 3540 3541 3542 3543 3544 3545 0 1 0 2965 0 0 0 0 138
/**
 * The central interface to the PhysX subsystem.  Used e.  g.  for
 * setting/retrieving global parameters or for creating scenes.
 */

3017 23 PhysxControllerShapeHit 0 10241 23 PhysxControllerShapeHit 23 PhysxControllerShapeHit 0 0 0 1 1786 0 0 7 1787 1788 1789 1790 1791 1792 1793 0 0 1 0 3018 0 0 0 0 10
/**
 *
 */

3018 12 CallbackData 0 2049 12 CallbackData 12 CallbackData 0 0 0 0 0 0 0 0 0 0 0 0 348
/**
 * This is a generic data block that is passed along to a CallbackObject when
 * a callback is made.  It contains data specific to the particular callback
 * type in question.
 *
 * This is actually an abstract base class and contains no data.
 * Specializations of this class will contain the actual data relevant to each
 * callback type.
 */

3019 19 PhysxControllersHit 0 10241 19 PhysxControllersHit 19 PhysxControllersHit 0 0 0 1 1794 0 0 3 1795 1796 1797 0 0 1 0 3018 0 0 0 0 10
/**
 *
 */

3020 15 PhysxConvexMesh 0 75777 15 PhysxConvexMesh 15 PhysxConvexMesh 0 0 0 0 0 0 3 1798 1799 1800 0 0 1 0 2996 0 0 0 0 125
/**
 * A Convex Mesh.  Internally represented as a list of convex polygons.  The
 * number of polygons is limited to 256.
 */

3021 26 PhysxConvexForceFieldShape 0 75777 26 PhysxConvexForceFieldShape 26 PhysxConvexForceFieldShape 0 0 0 1 1801 1622 0 2 1802 1803 0 0 1 0 3001 0 0 0 0 61
/**
 * A convex shaped region used to define force field.
 */

3022 16 PhysxConvexShape 0 75777 16 PhysxConvexShape 16 PhysxConvexShape 0 0 0 1 1804 1661 0 2 1805 1806 0 0 1 0 3003 0 0 0 0 77
/**
 * A shapes which is used to represent an instance of an convex mesh.
 */

3023 10 PhysxJoint 0 141313 10 PhysxJoint 10 PhysxJoint 0 0 0 0 1830 0 19 1811 1812 1813 1814 1815 1816 1817 1818 1819 1820 1821 1822 1823 1824 1825 1826 1827 1828 1829 0 0 2 3 2996 1807 1808 3 2965 1809 1810 0 0 153
/**
 * Abstract base class for the different types of joints.  All joints are used
 * to connect two dynamic actors, or an actor and the environment.
 */

3024 21 PhysxCylindricalJoint 0 75777 21 PhysxCylindricalJoint 21 PhysxCylindricalJoint 0 0 0 1 1831 1830 0 3 1832 1833 1834 0 0 1 0 3023 0 0 0 0 148
/**
 * Cylindrical Joints permit relative translational movement between two
 * bodies along an axis, and also relative rotation along the axis.
 */

3025 12 PhysxD6Joint 0 75777 12 PhysxD6Joint 12 PhysxD6Joint 0 0 0 1 1835 1830 0 7 1836 1837 1838 1839 1840 1841 1842 0 0 1 0 3023 0 0 0 0 267
/**
 * A D6 joint is a general constraint between two actors.  It allows the user
 * to individually define the linear and rotational degrees of freedom.  It
 * also allows the user to configure the joint with limits and driven degrees
 * of freedom as they wish.
 */

3026 18 PhysxDebugGeomNode 0 75777 18 PhysxDebugGeomNode 18 PhysxDebugGeomNode 0 0 0 1 1843 0 0 36 1844 1845 1846 1847 1848 1849 1850 1851 1852 1853 1854 1855 1856 1857 1858 1859 1860 1861 1862 1863 1864 1865 1866 1867 1868 1869 1870 1871 1872 1873 1874 1875 1876 1877 1878 1879 0 0 1 0 3012 0 0 0 0 123
/**
 * Renderable geometry which represents visualizations of physics objects.
 * Intended to help with debugging code.
 */

3027 18 PhysxDistanceJoint 0 75777 18 PhysxDistanceJoint 18 PhysxDistanceJoint 0 0 0 1 1880 1830 0 3 1881 1882 1883 0 0 1 0 3023 0 0 0 0 93
/**
 * A distance joint maintains a certain distance between two points on two
 * actors.
 */

3028 15 PhysxFixedJoint 0 75777 15 PhysxFixedJoint 15 PhysxFixedJoint 0 0 0 1 1884 1830 0 3 1885 1886 1887 0 0 1 0 3023 0 0 0 0 111
/**
 * A fixed joint permits no relative movement between two bodies.  ie the
 * bodies are glued together.
 */

3029 15 PhysxForceField 0 75777 15 PhysxForceField 15 PhysxForceField 0 0 0 1 1888 0 0 8 1889 1890 1891 1892 1893 1894 1895 1896 1 3546 0 1 0 2996 0 0 0 0 269
/**
 * A force field effector.  Instances of this object automate the application
 * of forces onto rigid bodies, fluid, soft bodies and cloth.  Force fields
 * allow you to implement for example gusts of wind, dust devils, vacuum
 * cleaners or anti-gravity zones.
 */

3030 25 PhysxForceFieldShapeGroup 0 26625 25 PhysxForceFieldShapeGroup 25 PhysxForceFieldShapeGroup 0 0 0 1 1901 1902 0 11 1903 1904 1905 1906 1907 1908 1909 1910 1911 1912 1913 1 3547 0 2 3 2996 1897 1898 3 2965 1899 1900 0 0 10
/**
 *
 */

3031 16 PhysxHeightField 0 75777 16 PhysxHeightField 16 PhysxHeightField 0 0 0 0 0 0 4 1914 1915 1916 1917 0 0 1 0 2996 0 0 0 0 738
/**
 * A height field object.  Height fields work in a similar way as triangle
 * meshes specified to act as height fields, with some important differences:
 *
 * Triangle meshes can be made of nonuniform geometry, while height fields are
 * regular, rectangular grids.  This means that with PhysxHeightField, you
 * sacrifice flexibility in return for improved performance and decreased
 * memory consumption.
 *
 * Height fields are referenced by shape instances of type
 * PhysxHeightFieldShape.
 *
 * To create an instance of this class call
 * PhysxManager::create_height_field(), and PhysxHeightField::release() to
 * release it.  This is only possible once you have released all of its
 * PhysxHeightFiedShape instances before.
 */

3032 21 PhysxHeightFieldShape 0 75777 21 PhysxHeightFieldShape 21 PhysxHeightFieldShape 0 0 0 1 1918 1661 0 2 1919 1920 0 0 1 0 3003 0 0 0 0 493
/**
 * This class is a shape instance of a height field object of type
 * PhysxHeightField.  Each shape is owned by an actor that it is attached to.
 *
 * An instance can be created by calling the createShape() method of the
 * PhysxActor object that should own it, with a PhysxHeightFieldShapeDesc
 * object as the parameter, or by adding the shape descriptor into the
 * PhysxActorDesc class before creating the actor.
 *
 * The shape is deleted by calling release() on the shape itself.
 */

3033 13 PhysxMaterial 0 26625 13 PhysxMaterial 13 PhysxMaterial 0 0 0 1 1925 1926 0 25 1927 1928 1929 1930 1931 1932 1933 1934 1935 1936 1937 1938 1939 1940 1941 1942 1943 1944 1945 1946 1947 1948 1949 1950 1951 0 0 2 3 2996 1921 1922 3 2965 1923 1924 0 0 706
/**
 * A class for describing a shape's surface properties.
 *
 * You can create a material which has different friction coefficients
 * depending on the direction that a body in contact is trying to move in.
 * This is called anisotropic friction.
 *
 * Anisotropic friction is useful for modeling things like sledges, skis etc
 *
 * When you create an anisotropic material you specify the default friction
 * parameters and also friction parameters for the V axis.  The friction
 * parameters for the V axis are applied to motion along the direction of
 * anisotropy (dirOfAnisotropy).
 *
 * Default material: You can change the properties of the default material by
 * querying for material index 0.
 */

3034 15 PhysxPlaneShape 0 75777 15 PhysxPlaneShape 15 PhysxPlaneShape 0 0 0 1 1952 1661 0 3 1953 1954 1955 0 0 1 0 3003 0 0 0 0 954
/**
 * A plane collision detection primitive.  By default it is configured to be
 * the y == 0 plane.  You can then set a normal and a d to specify an
 * arbitrary plane.  d is the distance of the plane from the origin along the
 * normal, assuming the normal is normalized.  Thus the plane equation is:
 * normal.x * X + normal.y * Y + normal.z * Z = d
 *
 * Note: the plane does not represent an infinitely thin object, but rather a
 * completely solid negative half space (all points p for which normal.dot(p)
 * - d < 0 are inside the solid region.)
 *
 * Each shape is owned by an actor that it is attached to.
 *
 * An instance can be created by calling the createShape() method of the
 * PhysxActor object that should own it, with a PhysxPlaneShapeDesc object as
 * the parameter, or by adding the shape descriptor into the PhysxActorDesc
 * class before creating the actor.
 *
 * The shape is deleted by calling release() on the shape itself.
 */

3035 22 PhysxPointInPlaneJoint 0 75777 22 PhysxPointInPlaneJoint 22 PhysxPointInPlaneJoint 0 0 0 1 1956 1830 0 3 1957 1958 1959 0 0 1 0 3023 0 0 0 0 281
/**
 * A point in plane joint constrains a point on one body to only move inside a
 * plane attached to another body.  The starting point of the point is defined
 * as the anchor point.  The plane through this point is specified by its
 * normal which is the joint axis vector.
 */

3036 21 PhysxPointOnLineJoint 0 75777 21 PhysxPointOnLineJoint 21 PhysxPointOnLineJoint 0 0 0 1 1960 1830 0 3 1961 1962 1963 0 0 1 0 3023 0 0 0 0 263
/**
 * A point on line joint constrains a point on one body to only move along a
 * line attached to another body.  The starting point of the joint is defined
 * as the anchor point.  The line through this point is specified by its
 * direction (axis) vector.
 */

3037 19 PhysxPrismaticJoint 0 75777 19 PhysxPrismaticJoint 19 PhysxPrismaticJoint 0 0 0 1 1964 1830 0 3 1965 1966 1967 0 0 1 0 3023 0 0 0 0 142
/**
 * A prismatic joint permits relative translational movement between two
 * bodies along an axis, but no relative rotational movement.
 */

3038 16 PhysxPulleyJoint 0 75777 16 PhysxPulleyJoint 16 PhysxPulleyJoint 0 0 0 1 1968 1830 0 7 1969 1970 1971 1972 1973 1974 1975 0 0 1 0 3023 0 0 0 0 91
/**
 * A pulley joint simulates a rope between two objects passing over two
 * pulleys.
 */

3039 18 PhysxRevoluteJoint 0 75777 18 PhysxRevoluteJoint 18 PhysxRevoluteJoint 0 0 0 1 1976 1830 0 14 1977 1978 1979 1980 1981 1982 1983 1984 1985 1986 1987 1988 1989 1990 0 0 1 0 3023 0 0 0 0 262
/**
 * A joint which behaves in a similar way to a hinge or axel.  A hinge joint
 * removes all but a single rotational degree of freedom from two objects.
 * The axis along which the two bodies may rotate is specified with a point
 * and a direction vector.
 */

3040 18 PhysxOverlapReport 0 26625 18 PhysxOverlapReport 18 PhysxOverlapReport 0 0 0 1 1998 1997 0 4 1993 1994 1995 1996 1 3548 0 1 3 3041 1991 1992 0 0 195
/**
 * Objects of this class are returned by the 'overlap shape' methods, for
 * example overlapSphereShapes.  They contain an iterable list of all sshapes
 * that the raycast query produced.
 */

3041 21 PhysxUserEntityReport 0 1050625 21 PhysxUserEntityReport 21 PhysxUserEntityReport 0 0 0 0 0 0 0 0 0 0 0 0 0

3042 9 PhysxMask 0 26625 9 PhysxMask 9 PhysxMask 0 0 0 1 1999 2000 0 6 2001 2002 2003 2004 2005 2006 0 0 0 0 0 32
/**
 * 32-bit bitmask class.
 */

3043 15 PhysxGroupsMask 0 26625 15 PhysxGroupsMask 15 PhysxGroupsMask 0 0 0 1 2007 2008 0 14 2009 2010 2011 2012 2013 2014 2015 2016 2017 2018 2019 2020 2021 2022 0 0 0 0 0 33
/**
 * 128-bit bitmask class.
 */

3044 10 PhysxScene 0 26625 10 PhysxScene 10 PhysxScene 0 0 0 1 2027 2028 0 78 2029 2030 2031 2032 2033 2034 2035 2036 2037 2038 2039 2040 2041 2042 2043 2044 2045 2046 2047 2048 2049 2050 2051 2052 2053 2054 2055 2056 2057 2058 2059 2060 2061 2062 2063 2064 2065 2066 2067 2068 2069 2070 2071 2072 2073 2074 2075 2076 2077 2078 2079 2080 2081 2082 2083 2084 2085 2086 2087 2088 2089 2090 2091 2092 2093 2094 2095 2096 2097 2098 2099 2100 2101 2102 2103 2104 2105 2106 9 3549 3550 3551 3552 3553 3554 3555 3556 3557 0 2 3 2996 2023 2024 3 2965 2025 2026 0 0 461
/**
 * A scene is a collection of bodies, constraints, and effectors which can
 * interact.
 *
 * The scene simulates the behavior of these objects over time.  Several
 * scenes may exist at the same time, but each body, constraint, or effector
 * object is specific to a scene -- they may not be shared.
 *
 * For example, attempting to create a joint in one scene and then using it to
 * attach bodies from a different scene results in undefined behavior.
 */

3045 13 PhysxSoftBody 0 26625 13 PhysxSoftBody 13 PhysxSoftBody 0 0 0 1 2111 2112 0 42 2113 2114 2115 2116 2117 2118 2119 2120 2121 2122 2123 2124 2125 2126 2127 2128 2129 2130 2131 2132 2133 2134 2135 2136 2137 2138 2139 2140 2141 2142 2143 2144 2145 2146 2147 2148 2149 2150 2151 2152 2153 2154 0 0 2 3 2996 2107 2108 3 2965 2109 2110 0 0 10
/**
 *
 */

3046 17 PhysxSoftBodyMesh 0 75777 17 PhysxSoftBodyMesh 17 PhysxSoftBodyMesh 0 0 0 0 0 0 3 2155 2156 2157 0 0 1 0 2996 0 0 0 0 10
/**
 *
 */

3047 17 PhysxSoftBodyNode 0 75777 17 PhysxSoftBodyNode 17 PhysxSoftBodyNode 0 0 0 1 2158 0 0 2 2159 2160 0 0 1 0 3012 0 0 0 0 65
/**
 * Renderable geometry which represents a soft body mesh.
 */

3048 26 PhysxSphereForceFieldShape 0 75777 26 PhysxSphereForceFieldShape 26 PhysxSphereForceFieldShape 0 0 0 1 2161 1622 0 4 2162 2163 2164 2165 0 0 1 0 3001 0 0 0 0 41
/**
 * A spherical force field shape.
 */

3049 16 PhysxSphereShape 0 75777 16 PhysxSphereShape 16 PhysxSphereShape 0 0 0 1 2166 1661 0 4 2167 2168 2169 2170 0 0 1 0 3003 0 0 0 0 453
/**
 * A sphere shaped collision detection primitive.  Each shape is owned by an
 * actor that it is attached to.
 *
 * An instance can be created by calling the createShape() method of the
 * PhysxActor object that should own it, with a PhysxSphereShapeDesc object as
 * the parameter, or by adding the shape descriptor into the PhysxActorDesc
 * class before creating the actor.
 *
 * The shape is deleted by calling release() on the shape itself.
 */

3050 19 PhysxSphericalJoint 0 75777 19 PhysxSphericalJoint 19 PhysxSphericalJoint 0 0 0 1 2171 1830 0 7 2172 2173 2174 2175 2176 2177 2178 0 0 1 0 3023 0 0 0 0 223
/**
 * A sphere joint constrains two points on two bodies to coincide.  This
 * point, specified in world space (this guarantees that the points coincide
 * to start with) is the only parameter that has to be specified.
 */

3051 17 PhysxTriangleMesh 0 75777 17 PhysxTriangleMesh 17 PhysxTriangleMesh 0 0 0 0 0 0 3 2179 2180 2181 0 0 1 0 2996 0 0 0 0 10
/**
 *
 */

3052 22 PhysxTriangleMeshShape 0 75777 22 PhysxTriangleMeshShape 22 PhysxTriangleMeshShape 0 0 0 1 2182 1661 0 2 2183 2184 0 0 1 0 3003 0 0 0 0 77
/**
 * A shapes which is used to represent an instance of an convex mesh.
 */

3053 12 PhysxVehicle 0 75777 12 PhysxVehicle 12 PhysxVehicle 0 0 0 1 2185 0 0 2 2186 2187 0 0 1 0 2996 0 0 0 0 10
/**
 *
 */

3054 10 PhysxWheel 0 75777 10 PhysxWheel 10 PhysxWheel 0 0 0 1 2188 0 0 1 2189 0 0 1 0 2996 0 0 0 0 10
/**
 *
 */

3055 15 PhysxWheelShape 0 75777 15 PhysxWheelShape 15 PhysxWheelShape 0 0 0 1 2190 1661 0 21 2191 2192 2193 2194 2195 2196 2197 2198 2199 2200 2201 2202 2203 2204 2205 2206 2207 2208 2209 2210 2211 0 0 1 0 3003 0 0 0 0 1437
/**
 * A special shape used for simulating a car wheel.  The -Y axis should be
 * directed toward the ground.
 *
 * A ray is cast from the shape's origin along the -Y axis.  When the ray
 * strikes something, and the distance is:
 *
 * - less than wheelRadius from the shape origin: a hard contact is created -
 * between wheelRadius and (suspensionTravel + wheelRadius): a soft suspension
 * contact is created - greater than (suspensionTravel + wheelRadius): no
 * contact is created.
 *
 * Thus at the point of greatest possible suspension compression the wheel
 * axle will pass through at the shape's origin.  At the point greatest
 * suspension extension the wheel axle will be a distance of suspensionTravel
 * from the shape's origin.
 *
 * The suspension's targetValue is 0 for real cars, which means that the
 * suspension tries to extend all the way.  Otherwise one can specify values
 * [0,1] for suspensions which have a spring to pull the wheel up when it is
 * extended too far.  0.5 will then fall halfway along suspensionTravel.
 *
 * The +Z axis is the 'forward' direction of travel for the wheel.  -Z is
 * backwards.  The wheel rolls forward when rotating around the positive
 * direction around the X axis.
 *
 * A positive wheel steering angle corresponds to a positive rotation around
 * the shape's Y axis.  (Castor angles are not modeled.)
 *
 * The coordinate frame of the shape is rigidly fixed on the car.
 */

3056 14 PhysxActorDesc 0 26625 14 PhysxActorDesc 14 PhysxActorDesc 0 0 0 1 2212 2213 0 14 2214 2215 2216 2217 2218 2219 2220 2221 2222 2223 2224 2225 2226 2227 0 0 0 0 0 37
/**
 * Descriptor for PhysxActor.
 */

3057 13 PhysxBodyDesc 0 26625 13 PhysxBodyDesc 13 PhysxBodyDesc 0 0 0 1 2228 2229 0 36 2230 2231 2232 2233 2234 2235 2236 2237 2238 2239 2240 2241 2242 2243 2244 2245 2246 2247 2248 2249 2250 2251 2252 2253 2254 2255 2256 2257 2258 2259 2260 2261 2262 2263 2264 2265 0 0 1 0 2965 0 0 0 0 78
/**
 * Descriptor for the optional rigid body dynamic state of PhysxActor.
 */

3058 14 PhysxShapeDesc 0 43009 14 PhysxShapeDesc 14 PhysxShapeDesc 0 0 0 0 0 0 23 2270 2271 2272 2273 2274 2275 2276 2277 2278 2279 2280 2281 2282 2283 2284 2285 2286 2287 2288 2289 2290 2291 2292 0 0 2 3 2965 2266 2267 3 3059 2268 2269 0 0 132
/**
 * Abstract base class for shape descriptors.  Descriptors for all the
 * different shape types are derived from this class.
 */

3059 14 ReferenceCount 0 2049 14 ReferenceCount 14 ReferenceCount 0 0 0 0 0 0 0 0 0 0 0 0 203
/**
 * A base class for all things that want to be reference-counted.
 * ReferenceCount works in conjunction with PointerTo to automatically delete
 * objects when the last pointer to them goes away.
 */

3060 12 PhysxBounds3 0 26625 12 PhysxBounds3 12 PhysxBounds3 0 0 0 1 2293 2294 0 20 2295 2296 2297 2298 2299 2300 2301 2302 2303 2304 2305 2306 2307 2308 2309 2310 2311 2312 2313 2314 0 0 0 0 0 246
/**
 * Represention of a axis aligned bounding box.  The box is stored as minimum
 * and maximum extent corners.  Alternate representation would be center and
 * dimensions.  May be empty or nonempty.  If not empty, min <= max has to
 * hold.
 */

3061 8 PhysxBox 0 26625 8 PhysxBox 8 PhysxBox 0 0 0 1 2315 2316 0 9 2317 2318 2319 2320 2321 2322 2323 2324 2325 0 0 0 0 0 262
/**
 * Represents an oriented bounding box, as a center point, extents(radii) and
 * a rotation.  i.e.  the center of the box is at the center point, the box is
 * rotated around this point with the rotation and it is 2*extents in width,
 * height and depth.
 */

3062 19 PhysxControllerDesc 0 26625 19 PhysxControllerDesc 19 PhysxControllerDesc 0 0 0 0 2326 0 12 2327 2328 2329 2330 2331 2332 2333 2334 2335 2336 2337 2338 0 0 0 0 0 55
/**
 * Descriptor class for a character controller.
 */

3063 22 PhysxBoxControllerDesc 0 75777 22 PhysxBoxControllerDesc 22 PhysxBoxControllerDesc 0 0 0 1 2339 2326 0 2 2340 2341 0 0 1 0 3062 0 0 0 0 51
/**
 * Descriptor class for PhysxBoxController.
 */

3064 24 PhysxForceFieldShapeDesc 0 43009 24 PhysxForceFieldShapeDesc 24 PhysxForceFieldShapeDesc 0 0 0 0 0 0 9 2342 2343 2344 2345 2346 2347 2348 2349 2350 0 0 0 0 0 82
/**
 * Abstract base class for descriptors for force field shapes descriptors.
 */

3065 27 PhysxBoxForceFieldShapeDesc 0 26625 27 PhysxBoxForceFieldShapeDesc 27 PhysxBoxForceFieldShapeDesc 0 0 0 1 2351 2352 0 2 2353 2354 0 0 1 0 3064 0 0 0 0 50
/**
 * Descriptor for a box force field shape.
 */

3066 17 PhysxBoxShapeDesc 0 75777 17 PhysxBoxShapeDesc 17 PhysxBoxShapeDesc 0 0 0 1 2355 0 0 2 2356 2357 0 0 1 0 3058 0 0 0 0 46
/**
 * Descriptor class for PhysxBoxShape.
 */

3067 12 PhysxSegment 0 26625 12 PhysxSegment 12 PhysxSegment 0 0 0 1 2358 2359 0 10 2360 2361 2362 2363 2364 2365 2366 2367 2368 2369 0 0 0 0 0 37
/**
 * Represents a line segment.
 */

3068 12 PhysxCapsule 0 26625 12 PhysxCapsule 12 PhysxCapsule 0 0 0 1 2370 2371 0 12 2372 2373 2374 2375 2376 2377 2378 2379 2380 2381 2382 2383 0 0 0 0 0 32
/**
 * Represents a capsule.
 */

3069 26 PhysxCapsuleControllerDesc 0 75777 26 PhysxCapsuleControllerDesc 26 PhysxCapsuleControllerDesc 0 0 0 1 2384 2326 0 4 2385 2386 2387 2388 0 0 1 0 3062 0 0 0 0 55
/**
 * Descriptor class for PhysxCapsuleController.
 */

3070 31 PhysxCapsuleForceFieldShapeDesc 0 26625 31 PhysxCapsuleForceFieldShapeDesc 31 PhysxCapsuleForceFieldShapeDesc 0 0 0 1 2389 2390 0 4 2391 2392 2393 2394 0 0 1 0 3064 0 0 0 0 54
/**
 * Descriptor for a capsule force field shape.
 */

3071 21 PhysxCapsuleShapeDesc 0 75777 21 PhysxCapsuleShapeDesc 21 PhysxCapsuleShapeDesc 0 0 0 1 2395 0 0 4 2396 2397 2398 2399 0 0 1 0 3058 0 0 0 0 50
/**
 * Descriptor class for PhysxCapsuleShape.
 */

3072 13 PhysxMeshPool 0 26625 13 PhysxMeshPool 13 PhysxMeshPool 0 0 0 1 2400 2401 0 9 2402 2403 2404 2405 2406 2407 2408 2409 2410 0 0 0 0 0 242
/**
 * This class unifies all references to the same filename, so that multiple
 * attempts to load the same mesh will return the same pointer.  The mesh
 * filename is automatically resolved before an attempt to load the mesh is
 * made.
 */

3073 20 PhysxCcdSkeletonDesc 0 26625 20 PhysxCcdSkeletonDesc 20 PhysxCcdSkeletonDesc 0 0 0 1 2411 2412 0 6 2413 2414 2415 2416 2417 2418 0 0 0 0 0 10
/**
 *
 */

3074 14 PhysxClothDesc 0 26625 14 PhysxClothDesc 14 PhysxClothDesc 0 0 0 1 2419 2420 0 30 2421 2422 2423 2424 2425 2426 2427 2428 2429 2430 2431 2432 2433 2434 2435 2436 2437 2438 2439 2440 2441 2442 2443 2444 2445 2446 2447 2448 2449 2450 0 0 1 0 2965 0 0 0 0 37
/**
 * Descriptor for PhysxCloth.
 */

3075 18 PhysxClothMeshDesc 0 26625 18 PhysxClothMeshDesc 18 PhysxClothMeshDesc 0 0 0 1 2451 2452 0 6 2453 2454 2455 2456 2457 2458 0 0 0 0 0 10
/**
 *
 */

3076 24 PhysxConstraintDominance 0 26625 24 PhysxConstraintDominance 24 PhysxConstraintDominance 0 0 0 1 2459 2460 0 4 2461 2462 2463 2464 0 0 0 0 0 273
/**
 * Expresses the dominance relationship of a constraint.  For the time being
 * only three settings are permitted:. (1.0f, 1.0f), (0.0f, 1.0f), and (1.0f,
 * 0.0f).
 *
 * See PhysxScene::set_dominance_group_pair for a detailed explanation of
 * dominance behaviour.
 */

3077 30 PhysxConvexForceFieldShapeDesc 0 26625 30 PhysxConvexForceFieldShapeDesc 30 PhysxConvexForceFieldShapeDesc 0 0 0 1 2465 2466 0 1 2467 0 0 1 0 3064 0 0 0 0 55
/**
 * A descriptor for a convex force field shape.
 */

3078 19 PhysxConvexMeshDesc 0 26625 19 PhysxConvexMeshDesc 19 PhysxConvexMeshDesc 0 0 0 1 2468 2469 0 4 2470 2471 2472 2473 0 0 0 0 0 10
/**
 *
 */

3079 20 PhysxConvexShapeDesc 0 75777 20 PhysxConvexShapeDesc 20 PhysxConvexShapeDesc 0 0 0 1 2474 0 0 1 2475 0 0 1 0 3058 0 0 0 0 49
/**
 * Descriptor class for PhysxConvexShape.
 */

3080 14 PhysxJointDesc 0 43009 14 PhysxJointDesc 14 PhysxJointDesc 0 0 0 0 0 0 22 2478 2479 2480 2481 2482 2483 2484 2485 2486 2487 2488 2489 2490 2491 2492 2493 2494 2495 2496 2497 2498 2499 0 0 1 3 2965 2476 2477 0 0 53
/**
 * Abstract base class for joint descriptors.
 */

3081 25 PhysxCylindricalJointDesc 0 26625 25 PhysxCylindricalJointDesc 25 PhysxCylindricalJointDesc 0 0 0 1 2500 2501 0 0 0 0 1 0 3080 0 0 0 0 74
/**
 * Descriptor class for sliding joint.  See PhysxCylindricalJoint.
 */

3082 16 PhysxD6JointDesc 0 26625 16 PhysxD6JointDesc 16 PhysxD6JointDesc 0 0 0 1 2502 2503 0 52 2504 2505 2506 2507 2508 2509 2510 2511 2512 2513 2514 2515 2516 2517 2518 2519 2520 2521 2522 2523 2524 2525 2526 2527 2528 2529 2530 2531 2532 2533 2534 2535 2536 2537 2538 2539 2540 2541 2542 2543 2544 2545 2546 2547 2548 2549 2550 2551 2552 2553 2554 2555 0 0 1 0 3080 0 0 0 0 10
/**
 *
 */

3083 19 PhysxJointDriveDesc 0 26625 19 PhysxJointDriveDesc 19 PhysxJointDriveDesc 0 0 0 1 2556 2557 0 8 2558 2559 2560 2561 2562 2563 2564 2565 0 0 1 0 2965 0 0 0 0 64
/**
 * Used to describe drive properties for a PhysxD6Joint.
 */

3084 23 PhysxJointLimitSoftDesc 0 26625 23 PhysxJointLimitSoftDesc 23 PhysxJointLimitSoftDesc 0 0 0 1 2566 2567 0 8 2568 2569 2570 2571 2572 2573 2574 2575 0 0 0 0 0 35
/**
 * Describes a joint limit.
 */

3085 22 PhysxDistanceJointDesc 0 26625 22 PhysxDistanceJointDesc 22 PhysxDistanceJointDesc 0 0 0 1 2576 2577 0 8 2578 2579 2580 2581 2582 2583 2584 2585 0 0 1 0 3080 0 0 0 0 72
/**
 * Descriptor class for distance joint.  See PhysxDistanceJoint.
 */

3086 15 PhysxSpringDesc 0 26625 15 PhysxSpringDesc 15 PhysxSpringDesc 0 0 0 1 2586 2587 0 6 2588 2589 2590 2591 2592 2593 0 0 0 0 0 139
/**
 * Describes a joint spring.  The spring is implicitly integrated, so even
 * high spring and damper coefficients should be robust.
 */

3087 19 PhysxFixedJointDesc 0 26625 19 PhysxFixedJointDesc 19 PhysxFixedJointDesc 0 0 0 1 2594 2595 0 0 0 0 1 0 3080 0 0 0 0 150
/**
 * Descriptor class for fixed joint.  A fixed joint permits no relative
 * movement between two bodies, i.  e.  the bodies are glued together.
 */

3088 19 PhysxForceFieldDesc 0 26625 19 PhysxForceFieldDesc 19 PhysxForceFieldDesc 0 0 0 1 2596 2597 0 19 2598 2599 2600 2601 2602 2603 2604 2605 2606 2607 2608 2609 2610 2611 2612 2613 2614 2615 2616 0 0 1 0 2965 0 0 0 0 45
/**
 * Descriptor class for force fields.
 */

3089 29 PhysxForceFieldShapeGroupDesc 0 26625 29 PhysxForceFieldShapeGroupDesc 29 PhysxForceFieldShapeGroupDesc 0 0 0 1 2617 2618 0 7 2619 2620 2621 2622 2623 2624 2625 0 0 1 0 2965 0 0 0 0 10
/**
 *
 */

3090 20 PhysxHeightFieldDesc 0 26625 20 PhysxHeightFieldDesc 20 PhysxHeightFieldDesc 0 0 0 1 2626 2627 0 9 2628 2629 2630 2631 2632 2633 2634 2635 2636 0 0 0 0 0 241
/**
 * Descriptor class for height fields.  The height field data is copied when a
 * PhysxHeightField object is created from this descriptor.  After the call
 * the user may discard the original height data (e.g.  release the PNGImage).
 */

3091 25 PhysxHeightFieldShapeDesc 0 75777 25 PhysxHeightFieldShapeDesc 25 PhysxHeightFieldShapeDesc 0 0 0 1 2637 0 0 6 2638 2639 2640 2641 2642 2643 0 0 1 0 3058 0 0 0 0 54
/**
 * Descriptor class for PhysxHeightFieldShape.
 */

3092 19 PhysxJointLimitDesc 0 26625 19 PhysxJointLimitDesc 19 PhysxJointLimitDesc 0 0 0 1 2644 2645 0 6 2646 2647 2648 2649 2650 2651 0 0 0 0 0 35
/**
 * Describes a joint limit.
 */

3093 12 PhysxKitchen 0 26625 12 PhysxKitchen 12 PhysxKitchen 0 0 0 1 2652 2653 0 6 2654 2655 2656 2657 2658 2659 0 0 0 0 0 10
/**
 *
 */

3094 21 PhysxTriangleMeshDesc 0 26625 21 PhysxTriangleMeshDesc 21 PhysxTriangleMeshDesc 0 0 0 1 2660 2661 0 6 2662 2663 2664 2665 2666 2667 0 0 0 0 0 10
/**
 *
 */

3095 21 PhysxSoftBodyMeshDesc 0 26625 21 PhysxSoftBodyMeshDesc 21 PhysxSoftBodyMeshDesc 0 0 0 1 2668 2669 0 5 2670 2671 2672 2673 2674 0 0 0 0 0 10
/**
 *
 */

3096 14 PhysxSceneDesc 0 26625 14 PhysxSceneDesc 14 PhysxSceneDesc 0 0 0 1 2675 2676 0 20 2677 2678 2679 2680 2681 2682 2683 2684 2685 2686 2687 2688 2689 2690 2691 2692 2693 2694 2695 2696 0 0 1 0 2965 0 0 0 0 37
/**
 * Descriptor for PhysxScene.
 */

3097 17 PhysxMaterialDesc 0 26625 17 PhysxMaterialDesc 17 PhysxMaterialDesc 0 0 0 1 2697 2698 0 20 2699 2700 2701 2702 2703 2704 2705 2706 2707 2708 2709 2710 2711 2712 2713 2714 2715 2716 2717 2718 0 0 1 0 2965 0 0 0 0 62
/**
 * Descriptor class for materials.  See PhysxMaterial.
 */

3098 14 PhysxMotorDesc 0 26625 14 PhysxMotorDesc 14 PhysxMotorDesc 0 0 0 1 2719 2720 0 6 2721 2722 2723 2724 2725 2726 0 0 0 0 0 212
/**
 * Describes a joint motor.  Some joints can be motorized, this allows them to
 * apply a force to cause attached actors to move.  Joints which can be
 * motorized: - PhysxPulleyJoint - PhysxRevoluteJoint
 */

3099 10 PhysxPlane 0 26625 10 PhysxPlane 10 PhysxPlane 0 0 0 1 2727 2728 0 13 2729 2730 2731 2732 2733 2734 2735 2736 2737 2738 2739 2740 2741 0 0 0 0 0 10
/**
 *
 */

3100 19 PhysxPlaneShapeDesc 0 75777 19 PhysxPlaneShapeDesc 19 PhysxPlaneShapeDesc 0 0 0 1 2742 0 0 1 2743 0 0 1 0 3058 0 0 0 0 48
/**
 * Descriptor class for PhysxPlaneShape.
 */

3101 26 PhysxPointInPlaneJointDesc 0 26625 26 PhysxPointInPlaneJointDesc 26 PhysxPointInPlaneJointDesc 0 0 0 1 2744 2745 0 0 0 0 1 0 3080 0 0 0 0 82
/**
 * Descriptor class for point-in-plane joint.  See PhysxPointInPlaneJoint.
 */

3102 25 PhysxPointOnLineJointDesc 0 26625 25 PhysxPointOnLineJointDesc 25 PhysxPointOnLineJointDesc 0 0 0 1 2746 2747 0 0 0 0 1 0 3080 0 0 0 0 80
/**
 * Descriptor class for point-on-line joint.  See PhysxPointOnLineJoint.
 */

3103 23 PhysxPrismaticJointDesc 0 26625 23 PhysxPrismaticJointDesc 23 PhysxPrismaticJointDesc 0 0 0 1 2748 2749 0 0 0 0 1 0 3080 0 0 0 0 74
/**
 * Descriptor class for prismatic joint.  See PhysxPrismaticJoint.
 */

3104 20 PhysxPulleyJointDesc 0 26625 20 PhysxPulleyJointDesc 20 PhysxPulleyJointDesc 0 0 0 1 2750 2751 0 12 2752 2753 2754 2755 2756 2757 2758 2759 2760 2761 2762 2763 0 0 1 0 3080 0 0 0 0 70
/**
 * Descriptor class for distance joint.  See PhysxPulleyJoint.
 */

3105 8 PhysxRay 0 26625 8 PhysxRay 8 PhysxRay 0 0 0 1 2764 2765 0 6 2766 2767 2768 2769 2770 2771 0 0 0 0 0 108
/**
 * Represents an ray as an origin and direction.  The ray will be infinite if
 * no length is given.
 */

3106 15 PhysxRaycastHit 0 26625 15 PhysxRaycastHit 15 PhysxRaycastHit 0 0 0 1 2772 2773 0 5 2774 2775 2776 2777 2778 0 0 0 0 0 113
/**
 * This structure captures results for a single raycast query.  See PhysxScene
 * for raycasting methods.
 */

3107 18 PhysxRaycastReport 0 26625 18 PhysxRaycastReport 18 PhysxRaycastReport 0 0 0 1 2786 2785 0 4 2781 2782 2783 2784 1 3558 0 1 3 3108 2779 2780 0 0 154
/**
 * Objects of this class are returned by the 'raycast all' methods.  They
 * contain an iterable list of all hits that the raycast query produced.
 */

3108 19 NxUserRaycastReport 0 2049 19 NxUserRaycastReport 19 NxUserRaycastReport 0 0 0 0 0 0 0 0 0 0 0 0 0

3109 22 PhysxRevoluteJointDesc 0 26625 22 PhysxRevoluteJointDesc 22 PhysxRevoluteJointDesc 0 0 0 1 2787 2788 0 16 2789 2790 2791 2792 2793 2794 2795 2796 2797 2798 2799 2800 2801 2802 2803 2804 0 0 1 0 3080 0 0 0 0 72
/**
 * Descriptor class for distance joint.  See PhysxRevoluteJoint.
 */

3110 16 PhysxSceneStats2 0 26625 16 PhysxSceneStats2 16 PhysxSceneStats2 0 0 0 1 2805 2806 0 5 2807 2808 2809 2810 2811 0 0 0 0 0 10
/**
 *
 */

3111 16 PhysxVehicleDesc 0 75777 16 PhysxVehicleDesc 16 PhysxVehicleDesc 0 0 0 1 2812 0 0 2 2813 2814 0 0 1 0 3059 0 0 0 0 10
/**
 *
 */

3112 17 PhysxSoftBodyDesc 0 26625 17 PhysxSoftBodyDesc 17 PhysxSoftBodyDesc 0 0 0 1 2815 2816 0 34 2817 2818 2819 2820 2821 2822 2823 2824 2825 2826 2827 2828 2829 2830 2831 2832 2833 2834 2835 2836 2837 2838 2839 2840 2841 2842 2843 2844 2845 2846 2847 2848 2849 2850 0 0 1 0 2965 0 0 0 0 40
/**
 * Descriptor for PhysxSoftBody.
 */

3113 11 PhysxSphere 0 26625 11 PhysxSphere 11 PhysxSphere 0 0 0 1 2851 2852 0 7 2853 2854 2855 2856 2857 2858 2859 0 0 0 0 0 70
/**
 * Represents a sphere defined by its center point and radius.
 */

3114 30 PhysxSphereForceFieldShapeDesc 0 26625 30 PhysxSphereForceFieldShapeDesc 30 PhysxSphereForceFieldShapeDesc 0 0 0 1 2860 2861 0 2 2862 2863 0 0 1 0 3064 0 0 0 0 55
/**
 * A descriptor for a sphere force field shape.
 */

3115 20 PhysxSphereShapeDesc 0 75777 20 PhysxSphereShapeDesc 20 PhysxSphereShapeDesc 0 0 0 1 2864 0 0 2 2865 2866 0 0 1 0 3058 0 0 0 0 49
/**
 * Descriptor class for PhysxSphereShape.
 */

3116 23 PhysxSphericalJointDesc 0 26625 23 PhysxSphericalJointDesc 23 PhysxSphericalJointDesc 0 0 0 1 2867 2868 0 20 2869 2870 2871 2872 2873 2874 2875 2876 2877 2878 2879 2880 2881 2882 2883 2884 2885 2886 2887 2888 0 0 1 0 3080 0 0 0 0 73
/**
 * Descriptor class for distance joint.  See PhysxSphericalJoint.
 */

3117 26 PhysxTriangleMeshShapeDesc 0 75777 26 PhysxTriangleMeshShapeDesc 26 PhysxTriangleMeshShapeDesc 0 0 0 1 2889 0 0 1 2890 0 0 1 0 3058 0 0 0 0 55
/**
 * Descriptor class for PhysxTriangleMeshShape.
 */

3118 12 PhysxUtilLib 0 26625 12 PhysxUtilLib 12 PhysxUtilLib 0 0 0 1 2891 2892 0 52 2893 2894 2895 2896 2897 2898 2899 2900 2901 2902 2903 2904 2905 2906 2907 2908 2909 2910 2911 2912 2913 2914 2915 2916 2917 2918 2919 2920 2921 2922 2923 2924 2925 2926 2927 2928 2929 2930 2931 2932 2933 2934 2935 2936 2937 2938 2939 2940 2941 2942 2943 2944 0 0 0 0 0 10
/**
 *
 */

3119 14 PhysxWheelDesc 0 75777 14 PhysxWheelDesc 14 PhysxWheelDesc 0 0 0 1 2945 0 0 2 2946 2947 0 0 1 0 3059 0 0 0 0 10
/**
 *
 */

3120 19 PhysxWheelShapeDesc 0 75777 19 PhysxWheelShapeDesc 19 PhysxWheelShapeDesc 0 0 0 1 2948 0 0 16 2949 2950 2951 2952 2953 2954 2955 2956 2957 2958 2959 2960 2961 2962 2963 2964 0 0 1 0 3058 0 0 0 0 48
/**
 * Descriptor class for PhysxWheelShape.
 */

3121 12 PhysxEnums * 0 8576 12 PhysxEnums * 12 PhysxEnums * 0 0 2965 0 0 0 0 0 0 0 0 0 0

3122 18 PhysxEnums const * 0 8576 18 PhysxEnums const * 18 PhysxEnums const * 0 0 3123 0 0 0 0 0 0 0 0 0 0

3123 16 PhysxEnums const 0 8832 16 PhysxEnums const 16 PhysxEnums const 0 0 2965 0 0 0 0 0 0 0 0 0 0

3124 13 PhysxObject * 0 8576 13 PhysxObject * 13 PhysxObject * 0 0 2996 0 0 0 0 0 0 0 0 0 0

3125 13 atomic string 0 2 13 atomic string 13 atomic string 0 7 0 0 0 0 0 0 0 0 0 0 0

3126 10 PyObject * 0 8576 10 PyObject * 10 PyObject * 0 0 3127 0 0 0 0 0 0 0 0 0 0

3127 8 PyObject 0 2105344 8 PyObject 8 PyObject 0 0 3128 0 0 0 0 0 0 0 0 0 0

3128 7 _object 0 1024 7 _object 7 _object 0 0 0 0 0 0 0 0 0 0 0 0 0

3129 4 void 0 8194 4 void 4 void 0 6 0 0 0 0 0 0 0 0 0 0 0

3130 19 PhysxObject const * 0 8576 19 PhysxObject const * 19 PhysxObject const * 0 0 3131 0 0 0 0 0 0 0 0 0 0

3131 17 PhysxObject const 0 8832 17 PhysxObject const 17 PhysxObject const 0 0 2996 0 0 0 0 0 0 0 0 0 0

3132 4 bool 0 8194 4 bool 4 bool 0 4 0 0 0 0 0 0 0 0 0 0 0

3133 9 ostream * 0 8576 9 ostream * 9 ostream * 0 0 3134 0 0 0 0 0 0 0 0 0 0

3134 7 ostream 0 2048 7 ostream 7 ostream 0 0 0 0 0 0 0 0 0 0 0 0 0

3135 3 int 0 8194 3 int 3 int 0 1 0 0 0 0 0 0 0 0 0 0 0

3136 10 TypeHandle 0 16779264 10 TypeHandle 10 TypeHandle 0 0 0 0 0 0 0 0 0 0 0 0 732
/**
 * TypeHandle is the identifier used to differentiate C++ class types.  Any
 * C++ classes that inherit from some base class, and must be differentiated
 * at run time, should store a static TypeHandle object that can be queried
 * through a static member function named get_class_type().  Most of the time,
 * it is also desirable to inherit from TypedObject, which provides some
 * virtual functions to return the TypeHandle for a particular instance.
 *
 * At its essence, a TypeHandle is simply a unique identifier that is assigned
 * by the TypeRegistry.  The TypeRegistry stores a tree of TypeHandles, so
 * that ancestry of a particular type may be queried, and the type name may be
 * retrieved for run-time display.
 */

3137 12 TypeHandle * 0 8576 12 TypeHandle * 12 TypeHandle * 0 0 3136 0 0 0 0 0 0 0 0 0 0

3138 12 PhysxActor * 0 8576 12 PhysxActor * 12 PhysxActor * 0 0 2998 0 0 0 0 0 0 0 0 0 0

3139 18 PhysxActor const * 0 8576 18 PhysxActor const * 18 PhysxActor const * 0 0 3140 0 0 0 0 0 0 0 0 0 0

3140 16 PhysxActor const 0 8832 16 PhysxActor const 16 PhysxActor const 0 0 2998 0 0 0 0 0 0 0 0 0 0

3141 15 PhysxBodyDesc * 0 8576 15 PhysxBodyDesc * 15 PhysxBodyDesc * 0 0 3057 0 0 0 0 0 0 0 0 0 0

3142 16 PhysxActorDesc * 0 8576 16 PhysxActorDesc * 16 PhysxActorDesc * 0 0 3056 0 0 0 0 0 0 0 0 0 0

3143 16 LPoint3f const * 0 8576 16 LPoint3f const * 16 LPoint3f const * 0 0 3144 0 0 0 0 0 0 0 0 0 0

3144 14 LPoint3f const 0 8832 14 LPoint3f const 14 LPoint3f const 0 0 3145 0 0 0 0 0 0 0 0 0 0

3145 8 LPoint3f 0 2048 8 LPoint3f 8 LPoint3f 0 0 0 0 0 0 0 0 0 0 0 0 337
/**
 * This is a three-component point in space (as opposed to a three-component
 * vector, which represents a direction and a distance).  Some of the methods
 * are slightly different between LPoint3 and LVector3; in particular,
 * subtraction of two points yields a vector, while addition of a vector and a
 * point yields a point.
 */

3146 17 LMatrix4f const * 0 8576 17 LMatrix4f const * 17 LMatrix4f const * 0 0 3147 0 0 0 0 0 0 0 0 0 0

3147 15 LMatrix4f const 0 8832 15 LMatrix4f const 15 LMatrix4f const 0 0 3148 0 0 0 0 0 0 0 0 0 0

3148 9 LMatrix4f 0 2048 9 LMatrix4f 9 LMatrix4f 0 0 0 0 0 0 0 0 0 0 0 0 45
/**
 * This is a 4-by-4 transform matrix.
 */

3149 5 float 0 8194 5 float 5 float 0 2 0 0 0 0 0 0 0 0 0 0 0

3150 12 unsigned int 0 8198 12 unsigned int 12 unsigned int 0 1 0 0 0 0 0 0 0 0 0 0 0

3151 10 LPoint3f * 0 8576 10 LPoint3f * 10 LPoint3f * 0 0 3145 0 0 0 0 0 0 0 0 0 0

3152 11 LMatrix4f * 0 8576 11 LMatrix4f * 11 LMatrix4f * 0 0 3148 0 0 0 0 0 0 0 0 0 0

3153 12 LQuaternionf 0 2048 12 LQuaternionf 12 LQuaternionf 0 0 0 0 0 0 0 0 0 0 0 0 44
/**
 * This is the base quaternion class
 */

3154 14 LQuaternionf * 0 8576 14 LQuaternionf * 14 LQuaternionf * 0 0 3153 0 0 0 0 0 0 0 0 0 0

3155 12 PhysxScene * 0 8576 12 PhysxScene * 12 PhysxScene * 0 0 3044 0 0 0 0 0 0 0 0 0 0

3156 16 NodePath const * 0 8576 16 NodePath const * 16 NodePath const * 0 0 3157 0 0 0 0 0 0 0 0 0 0

3157 14 NodePath const 0 8832 14 NodePath const 14 NodePath const 0 0 3158 0 0 0 0 0 0 0 0 0 0

3158 8 NodePath 0 2048 8 NodePath 8 NodePath 0 0 0 0 0 0 0 0 0 0 0 0 762
/**
 * NodePath is the fundamental system for disambiguating instances, and also
 * provides a higher-level interface for manipulating the scene graph.
 *
 * A NodePath is a list of connected nodes from the root of the graph to any
 * sub-node.  Each NodePath therefore uniquely describes one instance of a
 * node.
 *
 * NodePaths themselves are lightweight objects that may easily be copied and
 * passed by value.  Their data is stored as a series of NodePathComponents
 * that are stored on the nodes.  Holding a NodePath will keep a reference
 * count to all the nodes in the path.  However, if any node in the path is
 * removed or reparented (perhaps through a different NodePath), the NodePath
 * will automatically be updated to reflect the changes.
 */

3159 10 NodePath * 0 8576 10 NodePath * 10 NodePath * 0 0 3158 0 0 0 0 0 0 0 0 0 0

3160 16 PhysxShapeDesc * 0 8576 16 PhysxShapeDesc * 16 PhysxShapeDesc * 0 0 3058 0 0 0 0 0 0 0 0 0 0

3161 12 PhysxShape * 0 8576 12 PhysxShape * 12 PhysxShape * 0 0 3003 0 0 0 0 0 0 0 0 0 0

3162 17 LVector3f const * 0 8576 17 LVector3f const * 17 LVector3f const * 0 0 3163 0 0 0 0 0 0 0 0 0 0

3163 15 LVector3f const 0 8832 15 LVector3f const 15 LVector3f const 0 0 3164 0 0 0 0 0 0 0 0 0 0

3164 9 LVector3f 0 2048 9 LVector3f 9 LVector3f 0 0 0 0 0 0 0 0 0 0 0 0 338
/**
 * This is a three-component vector distance (as opposed to a three-component
 * point, which represents a particular point in space).  Some of the methods
 * are slightly different between LPoint3 and LVector3; in particular,
 * subtraction of two points yields a vector, while addition of a vector and a
 * point yields a point.
 */

3165 17 LMatrix3f const * 0 8576 17 LMatrix3f const * 17 LMatrix3f const * 0 0 3166 0 0 0 0 0 0 0 0 0 0

3166 15 LMatrix3f const 0 8832 15 LMatrix3f const 15 LMatrix3f const 0 0 3167 0 0 0 0 0 0 0 0 0 0

3167 9 LMatrix3f 0 2048 9 LMatrix3f 9 LMatrix3f 0 0 0 0 0 0 0 0 0 0 0 0 231
/**
 * This is a 3-by-3 transform matrix.  It typically will represent either a
 * rotation-and-scale (no translation) matrix in 3-d, or a full affine matrix
 * (rotation, scale, translation) in 2-d, e.g.  for a texture matrix.
 */

3168 11 LMatrix3f * 0 8576 11 LMatrix3f * 11 LMatrix3f * 0 0 3167 0 0 0 0 0 0 0 0 0 0

3169 11 LVector3f * 0 8576 11 LVector3f * 11 LVector3f * 0 0 3164 0 0 0 0 0 0 0 0 0 0

3170 17 PhysxController * 0 8576 17 PhysxController * 17 PhysxController * 0 0 2999 0 0 0 0 0 0 0 0 0 0

3171 23 PhysxController const * 0 8576 23 PhysxController const * 23 PhysxController const * 0 0 3172 0 0 0 0 0 0 0 0 0 0

3172 21 PhysxController const 0 8832 21 PhysxController const 21 PhysxController const 0 0 2999 0 0 0 0 0 0 0 0 0 0

3173 20 PhysxBoxController * 0 8576 20 PhysxBoxController * 20 PhysxBoxController * 0 0 3000 0 0 0 0 0 0 0 0 0 0

3174 26 PhysxBoxController const * 0 8576 26 PhysxBoxController const * 26 PhysxBoxController const * 0 0 3175 0 0 0 0 0 0 0 0 0 0

3175 24 PhysxBoxController const 0 8832 24 PhysxBoxController const 24 PhysxBoxController const 0 0 3000 0 0 0 0 0 0 0 0 0 0

3176 22 PhysxForceFieldShape * 0 8576 22 PhysxForceFieldShape * 22 PhysxForceFieldShape * 0 0 3001 0 0 0 0 0 0 0 0 0 0

3177 28 PhysxForceFieldShape const * 0 8576 28 PhysxForceFieldShape const * 28 PhysxForceFieldShape const * 0 0 3178 0 0 0 0 0 0 0 0 0 0

3178 26 PhysxForceFieldShape const 0 8832 26 PhysxForceFieldShape const 26 PhysxForceFieldShape const 0 0 3001 0 0 0 0 0 0 0 0 0 0

3179 17 PhysxForceField * 0 8576 17 PhysxForceField * 17 PhysxForceField * 0 0 3029 0 0 0 0 0 0 0 0 0 0

3180 27 PhysxForceFieldShapeGroup * 0 8576 27 PhysxForceFieldShapeGroup * 27 PhysxForceFieldShapeGroup * 0 0 3030 0 0 0 0 0 0 0 0 0 0

3181 25 PhysxBoxForceFieldShape * 0 8576 25 PhysxBoxForceFieldShape * 25 PhysxBoxForceFieldShape * 0 0 3002 0 0 0 0 0 0 0 0 0 0

3182 31 PhysxBoxForceFieldShape const * 0 8576 31 PhysxBoxForceFieldShape const * 31 PhysxBoxForceFieldShape const * 0 0 3183 0 0 0 0 0 0 0 0 0 0

3183 29 PhysxBoxForceFieldShape const 0 8832 29 PhysxBoxForceFieldShape const 29 PhysxBoxForceFieldShape const 0 0 3002 0 0 0 0 0 0 0 0 0 0

3184 29 PhysxBoxForceFieldShapeDesc * 0 8576 29 PhysxBoxForceFieldShapeDesc * 29 PhysxBoxForceFieldShapeDesc * 0 0 3065 0 0 0 0 0 0 0 0 0 0

3185 18 PhysxShape const * 0 8576 18 PhysxShape const * 18 PhysxShape const * 0 0 3186 0 0 0 0 0 0 0 0 0 0

3186 16 PhysxShape const 0 8832 16 PhysxShape const 16 PhysxShape const 0 0 3003 0 0 0 0 0 0 0 0 0 0

3187 20 PhysxShapeFlag const 0 8832 32 PhysxEnums::PhysxShapeFlag const 32 PhysxEnums::PhysxShapeFlag const 0 0 2988 0 0 0 0 0 0 0 0 0 0

3188 18 unsigned short int 0 8262 18 unsigned short int 18 unsigned short int 0 1 0 0 0 0 0 0 0 0 0 0 0

3189 21 PhysxMaterial const * 0 8576 21 PhysxMaterial const * 21 PhysxMaterial const * 0 0 3190 0 0 0 0 0 0 0 0 0 0

3190 19 PhysxMaterial const 0 8832 19 PhysxMaterial const 19 PhysxMaterial const 0 0 3033 0 0 0 0 0 0 0 0 0 0

3191 23 PhysxGroupsMask const * 0 8576 23 PhysxGroupsMask const * 23 PhysxGroupsMask const * 0 0 3192 0 0 0 0 0 0 0 0 0 0

3192 21 PhysxGroupsMask const 0 8832 21 PhysxGroupsMask const 21 PhysxGroupsMask const 0 0 3043 0 0 0 0 0 0 0 0 0 0

3193 18 PhysxCcdSkeleton * 0 8576 18 PhysxCcdSkeleton * 18 PhysxCcdSkeleton * 0 0 3008 0 0 0 0 0 0 0 0 0 0

3194 17 PhysxGroupsMask * 0 8576 17 PhysxGroupsMask * 17 PhysxGroupsMask * 0 0 3043 0 0 0 0 0 0 0 0 0 0

3195 14 PhysxBounds3 * 0 8576 14 PhysxBounds3 * 14 PhysxBounds3 * 0 0 3060 0 0 0 0 0 0 0 0 0 0

3196 20 PhysxBounds3 const * 0 8576 20 PhysxBounds3 const * 20 PhysxBounds3 const * 0 0 3197 0 0 0 0 0 0 0 0 0 0

3197 18 PhysxBounds3 const 0 8832 18 PhysxBounds3 const 18 PhysxBounds3 const 0 0 3060 0 0 0 0 0 0 0 0 0 0

3198 20 PhysxCapsule const * 0 8576 20 PhysxCapsule const * 20 PhysxCapsule const * 0 0 3199 0 0 0 0 0 0 0 0 0 0

3199 18 PhysxCapsule const 0 8832 18 PhysxCapsule const 18 PhysxCapsule const 0 0 3068 0 0 0 0 0 0 0 0 0 0

3200 16 PhysxBox const * 0 8576 16 PhysxBox const * 16 PhysxBox const * 0 0 3201 0 0 0 0 0 0 0 0 0 0

3201 14 PhysxBox const 0 8832 14 PhysxBox const 14 PhysxBox const 0 0 3061 0 0 0 0 0 0 0 0 0 0

3202 19 PhysxSphere const * 0 8576 19 PhysxSphere const * 19 PhysxSphere const * 0 0 3203 0 0 0 0 0 0 0 0 0 0

3203 17 PhysxSphere const 0 8832 17 PhysxSphere const 17 PhysxSphere const 0 0 3113 0 0 0 0 0 0 0 0 0 0

3204 16 PhysxRay const * 0 8576 16 PhysxRay const * 16 PhysxRay const * 0 0 3205 0 0 0 0 0 0 0 0 0 0

3205 14 PhysxRay const 0 8832 14 PhysxRay const 14 PhysxRay const 0 0 3105 0 0 0 0 0 0 0 0 0 0

3206 17 PhysxRaycastHit * 0 8576 17 PhysxRaycastHit * 17 PhysxRaycastHit * 0 0 3106 0 0 0 0 0 0 0 0 0 0

3207 15 PhysxBoxShape * 0 8576 15 PhysxBoxShape * 15 PhysxBoxShape * 0 0 3004 0 0 0 0 0 0 0 0 0 0

3208 21 PhysxBoxShape const * 0 8576 21 PhysxBoxShape const * 21 PhysxBoxShape const * 0 0 3209 0 0 0 0 0 0 0 0 0 0

3209 19 PhysxBoxShape const 0 8832 19 PhysxBoxShape const 19 PhysxBoxShape const 0 0 3004 0 0 0 0 0 0 0 0 0 0

3210 19 PhysxBoxShapeDesc * 0 8576 19 PhysxBoxShapeDesc * 19 PhysxBoxShapeDesc * 0 0 3066 0 0 0 0 0 0 0 0 0 0

3211 24 PhysxCapsuleController * 0 8576 24 PhysxCapsuleController * 24 PhysxCapsuleController * 0 0 3005 0 0 0 0 0 0 0 0 0 0

3212 30 PhysxCapsuleController const * 0 8576 30 PhysxCapsuleController const * 30 PhysxCapsuleController const * 0 0 3213 0 0 0 0 0 0 0 0 0 0

3213 28 PhysxCapsuleController const 0 8832 28 PhysxCapsuleController const 28 PhysxCapsuleController const 0 0 3005 0 0 0 0 0 0 0 0 0 0

3214 29 PhysxCapsuleForceFieldShape * 0 8576 29 PhysxCapsuleForceFieldShape * 29 PhysxCapsuleForceFieldShape * 0 0 3006 0 0 0 0 0 0 0 0 0 0

3215 35 PhysxCapsuleForceFieldShape const * 0 8576 35 PhysxCapsuleForceFieldShape const * 35 PhysxCapsuleForceFieldShape const * 0 0 3216 0 0 0 0 0 0 0 0 0 0

3216 33 PhysxCapsuleForceFieldShape const 0 8832 33 PhysxCapsuleForceFieldShape const 33 PhysxCapsuleForceFieldShape const 0 0 3006 0 0 0 0 0 0 0 0 0 0

3217 33 PhysxCapsuleForceFieldShapeDesc * 0 8576 33 PhysxCapsuleForceFieldShapeDesc * 33 PhysxCapsuleForceFieldShapeDesc * 0 0 3070 0 0 0 0 0 0 0 0 0 0

3218 19 PhysxCapsuleShape * 0 8576 19 PhysxCapsuleShape * 19 PhysxCapsuleShape * 0 0 3007 0 0 0 0 0 0 0 0 0 0

3219 25 PhysxCapsuleShape const * 0 8576 25 PhysxCapsuleShape const * 25 PhysxCapsuleShape const * 0 0 3220 0 0 0 0 0 0 0 0 0 0

3220 23 PhysxCapsuleShape const 0 8832 23 PhysxCapsuleShape const 23 PhysxCapsuleShape const 0 0 3007 0 0 0 0 0 0 0 0 0 0

3221 23 PhysxCapsuleShapeDesc * 0 8576 23 PhysxCapsuleShapeDesc * 23 PhysxCapsuleShapeDesc * 0 0 3071 0 0 0 0 0 0 0 0 0 0

3222 24 PhysxCcdSkeleton const * 0 8576 24 PhysxCcdSkeleton const * 24 PhysxCcdSkeleton const * 0 0 3223 0 0 0 0 0 0 0 0 0 0

3223 22 PhysxCcdSkeleton const 0 8832 22 PhysxCcdSkeleton const 22 PhysxCcdSkeleton const 0 0 3008 0 0 0 0 0 0 0 0 0 0

3224 12 PhysxCloth * 0 8576 12 PhysxCloth * 12 PhysxCloth * 0 0 3009 0 0 0 0 0 0 0 0 0 0

3225 18 PhysxCloth const * 0 8576 18 PhysxCloth const * 18 PhysxCloth const * 0 0 3226 0 0 0 0 0 0 0 0 0 0

3226 16 PhysxCloth const 0 8832 16 PhysxCloth const 16 PhysxCloth const 0 0 3009 0 0 0 0 0 0 0 0 0 0

3227 16 PhysxClothNode * 0 8576 16 PhysxClothNode * 16 PhysxClothNode * 0 0 3011 0 0 0 0 0 0 0 0 0 0

3228 22 PhysxClothMesh const * 0 8576 22 PhysxClothMesh const * 22 PhysxClothMesh const * 0 0 3229 0 0 0 0 0 0 0 0 0 0

3229 20 PhysxClothMesh const 0 8832 20 PhysxClothMesh const 20 PhysxClothMesh const 0 0 3010 0 0 0 0 0 0 0 0 0 0

3230 16 PhysxClothMesh * 0 8576 16 PhysxClothMesh * 16 PhysxClothMesh * 0 0 3010 0 0 0 0 0 0 0 0 0 0

3231 16 Filename const * 0 8576 16 Filename const * 16 Filename const * 0 0 3232 0 0 0 0 0 0 0 0 0 0

3232 14 Filename const 0 8832 14 Filename const 14 Filename const 0 0 3233 0 0 0 0 0 0 0 0 0 0

3233 8 Filename 0 2048 8 Filename 8 Filename 0 0 0 0 0 0 0 0 0 0 0 0 550
/**
 * The name of a file, such as a texture file or an Egg file.  Stores the full
 * pathname, and includes functions for extracting out the directory prefix
 * part and the file extension and stuff.
 *
 * A Filename is also aware of the mapping between the Unix-like filename
 * convention we use internally, and the local OS's specific filename
 * convention, and it knows how to perform basic OS-specific I/O, like testing
 * for file existence and searching a searchpath, as well as the best way to
 * open an fstream for reading or writing.
 */

3234 24 PhysxContactPair const * 0 8576 24 PhysxContactPair const * 24 PhysxContactPair const * 0 0 3235 0 0 0 0 0 0 0 0 0 0

3235 22 PhysxContactPair const 0 8832 22 PhysxContactPair const 22 PhysxContactPair const 0 0 3013 0 0 0 0 0 0 0 0 0 0

3236 18 PhysxContactPair * 0 8576 18 PhysxContactPair * 18 PhysxContactPair * 0 0 3013 0 0 0 0 0 0 0 0 0 0

3237 19 PhysxContactPoint * 0 8576 19 PhysxContactPoint * 19 PhysxContactPoint * 0 0 3014 0 0 0 0 0 0 0 0 0 0

3238 25 PhysxContactPoint const * 0 8576 25 PhysxContactPoint const * 25 PhysxContactPoint const * 0 0 3239 0 0 0 0 0 0 0 0 0 0

3239 23 PhysxContactPoint const 0 8832 23 PhysxContactPoint const 23 PhysxContactPoint const 0 0 3014 0 0 0 0 0 0 0 0 0 0

3240 20 PhysxManager const * 0 8576 20 PhysxManager const * 20 PhysxManager const * 0 0 3241 0 0 0 0 0 0 0 0 0 0

3241 18 PhysxManager const 0 8832 18 PhysxManager const 18 PhysxManager const 0 0 3016 0 0 0 0 0 0 0 0 0 0

3242 14 PhysxManager * 0 8576 14 PhysxManager * 14 PhysxManager * 0 0 3016 0 0 0 0 0 0 0 0 0 0

3243 16 PhysxSceneDesc * 0 8576 16 PhysxSceneDesc * 16 PhysxSceneDesc * 0 0 3096 0 0 0 0 0 0 0 0 0 0

3244 22 PhysxHeightFieldDesc * 0 8576 22 PhysxHeightFieldDesc * 22 PhysxHeightFieldDesc * 0 0 3090 0 0 0 0 0 0 0 0 0 0

3245 18 PhysxHeightField * 0 8576 18 PhysxHeightField * 18 PhysxHeightField * 0 0 3031 0 0 0 0 0 0 0 0 0 0

3246 17 PhysxConvexMesh * 0 8576 17 PhysxConvexMesh * 17 PhysxConvexMesh * 0 0 3020 0 0 0 0 0 0 0 0 0 0

3247 19 PhysxTriangleMesh * 0 8576 19 PhysxTriangleMesh * 19 PhysxTriangleMesh * 0 0 3051 0 0 0 0 0 0 0 0 0 0

3248 19 PhysxSoftBodyMesh * 0 8576 19 PhysxSoftBodyMesh * 19 PhysxSoftBodyMesh * 0 0 3046 0 0 0 0 0 0 0 0 0 0

3249 22 PhysxCcdSkeletonDesc * 0 8576 22 PhysxCcdSkeletonDesc * 22 PhysxCcdSkeletonDesc * 0 0 3073 0 0 0 0 0 0 0 0 0 0

3250 28 NxControllerShapeHit const * 0 8576 28 NxControllerShapeHit const * 28 NxControllerShapeHit const * 0 0 3251 0 0 0 0 0 0 0 0 0 0

3251 26 NxControllerShapeHit const 0 8832 26 NxControllerShapeHit const 26 NxControllerShapeHit const 0 0 3252 0 0 0 0 0 0 0 0 0 0

3252 20 NxControllerShapeHit 0 2048 20 NxControllerShapeHit 20 NxControllerShapeHit 0 0 0 0 0 0 0 0 0 0 0 0 0

3253 25 PhysxControllerShapeHit * 0 8576 25 PhysxControllerShapeHit * 25 PhysxControllerShapeHit * 0 0 3017 0 0 0 0 0 0 0 0 0 0

3254 31 PhysxControllerShapeHit const * 0 8576 31 PhysxControllerShapeHit const * 31 PhysxControllerShapeHit const * 0 0 3255 0 0 0 0 0 0 0 0 0 0

3255 29 PhysxControllerShapeHit const 0 8832 29 PhysxControllerShapeHit const 29 PhysxControllerShapeHit const 0 0 3017 0 0 0 0 0 0 0 0 0 0

3256 7 LPoint3 0 2105344 7 LPoint3 7 LPoint3 0 0 3145 0 0 0 0 0 0 0 0 0 0

3257 9 LPoint3 * 0 8576 9 LPoint3 * 9 LPoint3 * 0 0 3256 0 0 0 0 0 0 0 0 0 0

3258 8 LVector3 0 2105344 8 LVector3 8 LVector3 0 0 3164 0 0 0 0 0 0 0 0 0 0

3259 10 LVector3 * 0 8576 10 LVector3 * 10 LVector3 * 0 0 3258 0 0 0 0 0 0 0 0 0 0

3260 11 PN_stdfloat 0 2105344 11 PN_stdfloat 11 PN_stdfloat 0 0 3149 0 0 0 0 0 0 0 0 0 0

3261 24 NxControllersHit const * 0 8576 24 NxControllersHit const * 24 NxControllersHit const * 0 0 3262 0 0 0 0 0 0 0 0 0 0

3262 22 NxControllersHit const 0 8832 22 NxControllersHit const 22 NxControllersHit const 0 0 3263 0 0 0 0 0 0 0 0 0 0

3263 16 NxControllersHit 0 2048 16 NxControllersHit 16 NxControllersHit 0 0 0 0 0 0 0 0 0 0 0 0 0

3264 21 PhysxControllersHit * 0 8576 21 PhysxControllersHit * 21 PhysxControllersHit * 0 0 3019 0 0 0 0 0 0 0 0 0 0

3265 27 PhysxControllersHit const * 0 8576 27 PhysxControllersHit const * 27 PhysxControllersHit const * 0 0 3266 0 0 0 0 0 0 0 0 0 0

3266 25 PhysxControllersHit const 0 8832 25 PhysxControllersHit const 25 PhysxControllersHit const 0 0 3019 0 0 0 0 0 0 0 0 0 0

3267 23 PhysxConvexMesh const * 0 8576 23 PhysxConvexMesh const * 23 PhysxConvexMesh const * 0 0 3268 0 0 0 0 0 0 0 0 0 0

3268 21 PhysxConvexMesh const 0 8832 21 PhysxConvexMesh const 21 PhysxConvexMesh const 0 0 3020 0 0 0 0 0 0 0 0 0 0

3269 28 PhysxConvexForceFieldShape * 0 8576 28 PhysxConvexForceFieldShape * 28 PhysxConvexForceFieldShape * 0 0 3021 0 0 0 0 0 0 0 0 0 0

3270 34 PhysxConvexForceFieldShape const * 0 8576 34 PhysxConvexForceFieldShape const * 34 PhysxConvexForceFieldShape const * 0 0 3271 0 0 0 0 0 0 0 0 0 0

3271 32 PhysxConvexForceFieldShape const 0 8832 32 PhysxConvexForceFieldShape const 32 PhysxConvexForceFieldShape const 0 0 3021 0 0 0 0 0 0 0 0 0 0

3272 32 PhysxConvexForceFieldShapeDesc * 0 8576 32 PhysxConvexForceFieldShapeDesc * 32 PhysxConvexForceFieldShapeDesc * 0 0 3077 0 0 0 0 0 0 0 0 0 0

3273 18 PhysxConvexShape * 0 8576 18 PhysxConvexShape * 18 PhysxConvexShape * 0 0 3022 0 0 0 0 0 0 0 0 0 0

3274 24 PhysxConvexShape const * 0 8576 24 PhysxConvexShape const * 24 PhysxConvexShape const * 0 0 3275 0 0 0 0 0 0 0 0 0 0

3275 22 PhysxConvexShape const 0 8832 22 PhysxConvexShape const 22 PhysxConvexShape const 0 0 3022 0 0 0 0 0 0 0 0 0 0

3276 22 PhysxConvexShapeDesc * 0 8576 22 PhysxConvexShapeDesc * 22 PhysxConvexShapeDesc * 0 0 3079 0 0 0 0 0 0 0 0 0 0

3277 12 PhysxJoint * 0 8576 12 PhysxJoint * 12 PhysxJoint * 0 0 3023 0 0 0 0 0 0 0 0 0 0

3278 18 PhysxJoint const * 0 8576 18 PhysxJoint const * 18 PhysxJoint const * 0 0 3279 0 0 0 0 0 0 0 0 0 0

3279 16 PhysxJoint const 0 8832 16 PhysxJoint const 16 PhysxJoint const 0 0 3023 0 0 0 0 0 0 0 0 0 0

3280 23 PhysxCylindricalJoint * 0 8576 23 PhysxCylindricalJoint * 23 PhysxCylindricalJoint * 0 0 3024 0 0 0 0 0 0 0 0 0 0

3281 29 PhysxCylindricalJoint const * 0 8576 29 PhysxCylindricalJoint const * 29 PhysxCylindricalJoint const * 0 0 3282 0 0 0 0 0 0 0 0 0 0

3282 27 PhysxCylindricalJoint const 0 8832 27 PhysxCylindricalJoint const 27 PhysxCylindricalJoint const 0 0 3024 0 0 0 0 0 0 0 0 0 0

3283 27 PhysxCylindricalJointDesc * 0 8576 27 PhysxCylindricalJointDesc * 27 PhysxCylindricalJointDesc * 0 0 3081 0 0 0 0 0 0 0 0 0 0

3284 33 PhysxCylindricalJointDesc const * 0 8576 33 PhysxCylindricalJointDesc const * 33 PhysxCylindricalJointDesc const * 0 0 3285 0 0 0 0 0 0 0 0 0 0

3285 31 PhysxCylindricalJointDesc const 0 8832 31 PhysxCylindricalJointDesc const 31 PhysxCylindricalJointDesc const 0 0 3081 0 0 0 0 0 0 0 0 0 0

3286 14 PhysxD6Joint * 0 8576 14 PhysxD6Joint * 14 PhysxD6Joint * 0 0 3025 0 0 0 0 0 0 0 0 0 0

3287 20 PhysxD6Joint const * 0 8576 20 PhysxD6Joint const * 20 PhysxD6Joint const * 0 0 3288 0 0 0 0 0 0 0 0 0 0

3288 18 PhysxD6Joint const 0 8832 18 PhysxD6Joint const 18 PhysxD6Joint const 0 0 3025 0 0 0 0 0 0 0 0 0 0

3289 18 PhysxD6JointDesc * 0 8576 18 PhysxD6JointDesc * 18 PhysxD6JointDesc * 0 0 3082 0 0 0 0 0 0 0 0 0 0

3290 24 PhysxD6JointDesc const * 0 8576 24 PhysxD6JointDesc const * 24 PhysxD6JointDesc const * 0 0 3291 0 0 0 0 0 0 0 0 0 0

3291 22 PhysxD6JointDesc const 0 8832 22 PhysxD6JointDesc const 22 PhysxD6JointDesc const 0 0 3082 0 0 0 0 0 0 0 0 0 0

3292 20 LQuaternionf const * 0 8576 20 LQuaternionf const * 20 LQuaternionf const * 0 0 3293 0 0 0 0 0 0 0 0 0 0

3293 18 LQuaternionf const 0 8832 18 LQuaternionf const 18 LQuaternionf const 0 0 3153 0 0 0 0 0 0 0 0 0 0

3294 20 PhysxDebugGeomNode * 0 8576 20 PhysxDebugGeomNode * 20 PhysxDebugGeomNode * 0 0 3026 0 0 0 0 0 0 0 0 0 0

3295 26 PhysxDebugGeomNode const * 0 8576 26 PhysxDebugGeomNode const * 26 PhysxDebugGeomNode const * 0 0 3296 0 0 0 0 0 0 0 0 0 0

3296 24 PhysxDebugGeomNode const 0 8832 24 PhysxDebugGeomNode const 24 PhysxDebugGeomNode const 0 0 3026 0 0 0 0 0 0 0 0 0 0

3297 20 PhysxDistanceJoint * 0 8576 20 PhysxDistanceJoint * 20 PhysxDistanceJoint * 0 0 3027 0 0 0 0 0 0 0 0 0 0

3298 26 PhysxDistanceJoint const * 0 8576 26 PhysxDistanceJoint const * 26 PhysxDistanceJoint const * 0 0 3299 0 0 0 0 0 0 0 0 0 0

3299 24 PhysxDistanceJoint const 0 8832 24 PhysxDistanceJoint const 24 PhysxDistanceJoint const 0 0 3027 0 0 0 0 0 0 0 0 0 0

3300 24 PhysxDistanceJointDesc * 0 8576 24 PhysxDistanceJointDesc * 24 PhysxDistanceJointDesc * 0 0 3085 0 0 0 0 0 0 0 0 0 0

3301 30 PhysxDistanceJointDesc const * 0 8576 30 PhysxDistanceJointDesc const * 30 PhysxDistanceJointDesc const * 0 0 3302 0 0 0 0 0 0 0 0 0 0

3302 28 PhysxDistanceJointDesc const 0 8832 28 PhysxDistanceJointDesc const 28 PhysxDistanceJointDesc const 0 0 3085 0 0 0 0 0 0 0 0 0 0

3303 17 PhysxFixedJoint * 0 8576 17 PhysxFixedJoint * 17 PhysxFixedJoint * 0 0 3028 0 0 0 0 0 0 0 0 0 0

3304 23 PhysxFixedJoint const * 0 8576 23 PhysxFixedJoint const * 23 PhysxFixedJoint const * 0 0 3305 0 0 0 0 0 0 0 0 0 0

3305 21 PhysxFixedJoint const 0 8832 21 PhysxFixedJoint const 21 PhysxFixedJoint const 0 0 3028 0 0 0 0 0 0 0 0 0 0

3306 21 PhysxFixedJointDesc * 0 8576 21 PhysxFixedJointDesc * 21 PhysxFixedJointDesc * 0 0 3087 0 0 0 0 0 0 0 0 0 0

3307 27 PhysxFixedJointDesc const * 0 8576 27 PhysxFixedJointDesc const * 27 PhysxFixedJointDesc const * 0 0 3308 0 0 0 0 0 0 0 0 0 0

3308 25 PhysxFixedJointDesc const 0 8832 25 PhysxFixedJointDesc const 25 PhysxFixedJointDesc const 0 0 3087 0 0 0 0 0 0 0 0 0 0

3309 23 PhysxForceField const * 0 8576 23 PhysxForceField const * 23 PhysxForceField const * 0 0 3310 0 0 0 0 0 0 0 0 0 0

3310 21 PhysxForceField const 0 8832 21 PhysxForceField const 21 PhysxForceField const 0 0 3029 0 0 0 0 0 0 0 0 0 0

3311 33 PhysxForceFieldShapeGroup const * 0 8576 33 PhysxForceFieldShapeGroup const * 33 PhysxForceFieldShapeGroup const * 0 0 3312 0 0 0 0 0 0 0 0 0 0

3312 31 PhysxForceFieldShapeGroup const 0 8832 31 PhysxForceFieldShapeGroup const 31 PhysxForceFieldShapeGroup const 0 0 3030 0 0 0 0 0 0 0 0 0 0

3313 31 PhysxForceFieldShapeGroupDesc * 0 8576 31 PhysxForceFieldShapeGroupDesc * 31 PhysxForceFieldShapeGroupDesc * 0 0 3089 0 0 0 0 0 0 0 0 0 0

3314 26 PhysxForceFieldShapeDesc * 0 8576 26 PhysxForceFieldShapeDesc * 26 PhysxForceFieldShapeDesc * 0 0 3064 0 0 0 0 0 0 0 0 0 0

3315 24 PhysxHeightField const * 0 8576 24 PhysxHeightField const * 24 PhysxHeightField const * 0 0 3316 0 0 0 0 0 0 0 0 0 0

3316 22 PhysxHeightField const 0 8832 22 PhysxHeightField const 22 PhysxHeightField const 0 0 3031 0 0 0 0 0 0 0 0 0 0

3317 23 PhysxHeightFieldShape * 0 8576 23 PhysxHeightFieldShape * 23 PhysxHeightFieldShape * 0 0 3032 0 0 0 0 0 0 0 0 0 0

3318 29 PhysxHeightFieldShape const * 0 8576 29 PhysxHeightFieldShape const * 29 PhysxHeightFieldShape const * 0 0 3319 0 0 0 0 0 0 0 0 0 0

3319 27 PhysxHeightFieldShape const 0 8832 27 PhysxHeightFieldShape const 27 PhysxHeightFieldShape const 0 0 3032 0 0 0 0 0 0 0 0 0 0

3320 27 PhysxHeightFieldShapeDesc * 0 8576 27 PhysxHeightFieldShapeDesc * 27 PhysxHeightFieldShapeDesc * 0 0 3091 0 0 0 0 0 0 0 0 0 0

3321 15 PhysxMaterial * 0 8576 15 PhysxMaterial * 15 PhysxMaterial * 0 0 3033 0 0 0 0 0 0 0 0 0 0

3322 25 PhysxMaterialDesc const * 0 8576 25 PhysxMaterialDesc const * 25 PhysxMaterialDesc const * 0 0 3323 0 0 0 0 0 0 0 0 0 0

3323 23 PhysxMaterialDesc const 0 8832 23 PhysxMaterialDesc const 23 PhysxMaterialDesc const 0 0 3097 0 0 0 0 0 0 0 0 0 0

3324 19 PhysxMaterialDesc * 0 8576 19 PhysxMaterialDesc * 19 PhysxMaterialDesc * 0 0 3097 0 0 0 0 0 0 0 0 0 0

3325 17 PhysxPlaneShape * 0 8576 17 PhysxPlaneShape * 17 PhysxPlaneShape * 0 0 3034 0 0 0 0 0 0 0 0 0 0

3326 23 PhysxPlaneShape const * 0 8576 23 PhysxPlaneShape const * 23 PhysxPlaneShape const * 0 0 3327 0 0 0 0 0 0 0 0 0 0

3327 21 PhysxPlaneShape const 0 8832 21 PhysxPlaneShape const 21 PhysxPlaneShape const 0 0 3034 0 0 0 0 0 0 0 0 0 0

3328 21 PhysxPlaneShapeDesc * 0 8576 21 PhysxPlaneShapeDesc * 21 PhysxPlaneShapeDesc * 0 0 3100 0 0 0 0 0 0 0 0 0 0

3329 24 PhysxPointInPlaneJoint * 0 8576 24 PhysxPointInPlaneJoint * 24 PhysxPointInPlaneJoint * 0 0 3035 0 0 0 0 0 0 0 0 0 0

3330 30 PhysxPointInPlaneJoint const * 0 8576 30 PhysxPointInPlaneJoint const * 30 PhysxPointInPlaneJoint const * 0 0 3331 0 0 0 0 0 0 0 0 0 0

3331 28 PhysxPointInPlaneJoint const 0 8832 28 PhysxPointInPlaneJoint const 28 PhysxPointInPlaneJoint const 0 0 3035 0 0 0 0 0 0 0 0 0 0

3332 28 PhysxPointInPlaneJointDesc * 0 8576 28 PhysxPointInPlaneJointDesc * 28 PhysxPointInPlaneJointDesc * 0 0 3101 0 0 0 0 0 0 0 0 0 0

3333 34 PhysxPointInPlaneJointDesc const * 0 8576 34 PhysxPointInPlaneJointDesc const * 34 PhysxPointInPlaneJointDesc const * 0 0 3334 0 0 0 0 0 0 0 0 0 0

3334 32 PhysxPointInPlaneJointDesc const 0 8832 32 PhysxPointInPlaneJointDesc const 32 PhysxPointInPlaneJointDesc const 0 0 3101 0 0 0 0 0 0 0 0 0 0

3335 23 PhysxPointOnLineJoint * 0 8576 23 PhysxPointOnLineJoint * 23 PhysxPointOnLineJoint * 0 0 3036 0 0 0 0 0 0 0 0 0 0

3336 29 PhysxPointOnLineJoint const * 0 8576 29 PhysxPointOnLineJoint const * 29 PhysxPointOnLineJoint const * 0 0 3337 0 0 0 0 0 0 0 0 0 0

3337 27 PhysxPointOnLineJoint const 0 8832 27 PhysxPointOnLineJoint const 27 PhysxPointOnLineJoint const 0 0 3036 0 0 0 0 0 0 0 0 0 0

3338 27 PhysxPointOnLineJointDesc * 0 8576 27 PhysxPointOnLineJointDesc * 27 PhysxPointOnLineJointDesc * 0 0 3102 0 0 0 0 0 0 0 0 0 0

3339 33 PhysxPointOnLineJointDesc const * 0 8576 33 PhysxPointOnLineJointDesc const * 33 PhysxPointOnLineJointDesc const * 0 0 3340 0 0 0 0 0 0 0 0 0 0

3340 31 PhysxPointOnLineJointDesc const 0 8832 31 PhysxPointOnLineJointDesc const 31 PhysxPointOnLineJointDesc const 0 0 3102 0 0 0 0 0 0 0 0 0 0

3341 21 PhysxPrismaticJoint * 0 8576 21 PhysxPrismaticJoint * 21 PhysxPrismaticJoint * 0 0 3037 0 0 0 0 0 0 0 0 0 0

3342 27 PhysxPrismaticJoint const * 0 8576 27 PhysxPrismaticJoint const * 27 PhysxPrismaticJoint const * 0 0 3343 0 0 0 0 0 0 0 0 0 0

3343 25 PhysxPrismaticJoint const 0 8832 25 PhysxPrismaticJoint const 25 PhysxPrismaticJoint const 0 0 3037 0 0 0 0 0 0 0 0 0 0

3344 25 PhysxPrismaticJointDesc * 0 8576 25 PhysxPrismaticJointDesc * 25 PhysxPrismaticJointDesc * 0 0 3103 0 0 0 0 0 0 0 0 0 0

3345 31 PhysxPrismaticJointDesc const * 0 8576 31 PhysxPrismaticJointDesc const * 31 PhysxPrismaticJointDesc const * 0 0 3346 0 0 0 0 0 0 0 0 0 0

3346 29 PhysxPrismaticJointDesc const 0 8832 29 PhysxPrismaticJointDesc const 29 PhysxPrismaticJointDesc const 0 0 3103 0 0 0 0 0 0 0 0 0 0

3347 18 PhysxPulleyJoint * 0 8576 18 PhysxPulleyJoint * 18 PhysxPulleyJoint * 0 0 3038 0 0 0 0 0 0 0 0 0 0

3348 24 PhysxPulleyJoint const * 0 8576 24 PhysxPulleyJoint const * 24 PhysxPulleyJoint const * 0 0 3349 0 0 0 0 0 0 0 0 0 0

3349 22 PhysxPulleyJoint const 0 8832 22 PhysxPulleyJoint const 22 PhysxPulleyJoint const 0 0 3038 0 0 0 0 0 0 0 0 0 0

3350 22 PhysxPulleyJointDesc * 0 8576 22 PhysxPulleyJointDesc * 22 PhysxPulleyJointDesc * 0 0 3104 0 0 0 0 0 0 0 0 0 0

3351 28 PhysxPulleyJointDesc const * 0 8576 28 PhysxPulleyJointDesc const * 28 PhysxPulleyJointDesc const * 0 0 3352 0 0 0 0 0 0 0 0 0 0

3352 26 PhysxPulleyJointDesc const 0 8832 26 PhysxPulleyJointDesc const 26 PhysxPulleyJointDesc const 0 0 3104 0 0 0 0 0 0 0 0 0 0

3353 22 PhysxMotorDesc const * 0 8576 22 PhysxMotorDesc const * 22 PhysxMotorDesc const * 0 0 3354 0 0 0 0 0 0 0 0 0 0

3354 20 PhysxMotorDesc const 0 8832 20 PhysxMotorDesc const 20 PhysxMotorDesc const 0 0 3098 0 0 0 0 0 0 0 0 0 0

3355 16 PhysxMotorDesc * 0 8576 16 PhysxMotorDesc * 16 PhysxMotorDesc * 0 0 3098 0 0 0 0 0 0 0 0 0 0

3356 20 PhysxRevoluteJoint * 0 8576 20 PhysxRevoluteJoint * 20 PhysxRevoluteJoint * 0 0 3039 0 0 0 0 0 0 0 0 0 0

3357 26 PhysxRevoluteJoint const * 0 8576 26 PhysxRevoluteJoint const * 26 PhysxRevoluteJoint const * 0 0 3358 0 0 0 0 0 0 0 0 0 0

3358 24 PhysxRevoluteJoint const 0 8832 24 PhysxRevoluteJoint const 24 PhysxRevoluteJoint const 0 0 3039 0 0 0 0 0 0 0 0 0 0

3359 24 PhysxRevoluteJointDesc * 0 8576 24 PhysxRevoluteJointDesc * 24 PhysxRevoluteJointDesc * 0 0 3109 0 0 0 0 0 0 0 0 0 0

3360 30 PhysxRevoluteJointDesc const * 0 8576 30 PhysxRevoluteJointDesc const * 30 PhysxRevoluteJointDesc const * 0 0 3361 0 0 0 0 0 0 0 0 0 0

3361 28 PhysxRevoluteJointDesc const 0 8832 28 PhysxRevoluteJointDesc const 28 PhysxRevoluteJointDesc const 0 0 3109 0 0 0 0 0 0 0 0 0 0

3362 23 PhysxSpringDesc const * 0 8576 23 PhysxSpringDesc const * 23 PhysxSpringDesc const * 0 0 3363 0 0 0 0 0 0 0 0 0 0

3363 21 PhysxSpringDesc const 0 8832 21 PhysxSpringDesc const 21 PhysxSpringDesc const 0 0 3086 0 0 0 0 0 0 0 0 0 0

3364 27 PhysxJointLimitDesc const * 0 8576 27 PhysxJointLimitDesc const * 27 PhysxJointLimitDesc const * 0 0 3365 0 0 0 0 0 0 0 0 0 0

3365 25 PhysxJointLimitDesc const 0 8832 25 PhysxJointLimitDesc const 25 PhysxJointLimitDesc const 0 0 3092 0 0 0 0 0 0 0 0 0 0

3366 17 PhysxSpringDesc * 0 8576 17 PhysxSpringDesc * 17 PhysxSpringDesc * 0 0 3086 0 0 0 0 0 0 0 0 0 0

3367 26 PhysxOverlapReport const * 0 8576 26 PhysxOverlapReport const * 26 PhysxOverlapReport const * 0 0 3368 0 0 0 0 0 0 0 0 0 0

3368 24 PhysxOverlapReport const 0 8832 24 PhysxOverlapReport const 24 PhysxOverlapReport const 0 0 3040 0 0 0 0 0 0 0 0 0 0

3369 20 PhysxOverlapReport * 0 8576 20 PhysxOverlapReport * 20 PhysxOverlapReport * 0 0 3040 0 0 0 0 0 0 0 0 0 0

3370 11 PhysxMask * 0 8576 11 PhysxMask * 11 PhysxMask * 0 0 3042 0 0 0 0 0 0 0 0 0 0

3371 17 PhysxMask const * 0 8576 17 PhysxMask const * 17 PhysxMask const * 0 0 3372 0 0 0 0 0 0 0 0 0 0

3372 15 PhysxMask const 0 8832 15 PhysxMask const 15 PhysxMask const 0 0 3042 0 0 0 0 0 0 0 0 0 0

3373 14 NxGroupsMask * 0 8576 14 NxGroupsMask * 14 NxGroupsMask * 0 0 3374 0 0 0 0 0 0 0 0 0 0

3374 12 NxGroupsMask 0 2048 12 NxGroupsMask 12 NxGroupsMask 0 0 0 0 0 0 0 0 0 0 0 0 669
/**
	\brief 128-bit mask used for collision filtering.

	The collision filtering equation for 2 shapes S0 and S1 is:

	<pre> (G0 op0 K0) op2 (G1 op1 K1) == b </pre>

	with

	<ul>
	<li> G0 = NxGroupsMask for shape S0. See ::setGroupsMask </li>
	<li> G1 = NxGroupsMask for shape S1. See ::setGroupsMask </li>
	<li> K0 = filtering constant 0. See ::setFilterConstant0 </li>
	<li> K1 = filtering constant 1. See ::setFilterConstant1 </li>
	<li> b = filtering boolean. See ::setFilterBool </li>
	<li> op0, op1, op2 = filtering operations. See ::setFilterOps </li>
	</ul>

	If the filtering equation is true, collision detection is enabled.

	@see NxScene::setFilterOps()
	*/

3375 18 PhysxScene const * 0 8576 18 PhysxScene const * 18 PhysxScene const * 0 0 3376 0 0 0 0 0 0 0 0 0 0

3376 16 PhysxScene const 0 8832 16 PhysxScene const 16 PhysxScene const 0 0 3044 0 0 0 0 0 0 0 0 0 0

3377 16 CallbackObject * 0 8576 16 CallbackObject * 16 CallbackObject * 0 0 3378 0 0 0 0 0 0 0 0 0 0

3378 14 CallbackObject 0 2048 14 CallbackObject 14 CallbackObject 0 0 0 0 0 0 0 0 0 0 0 0 276
/**
 * This is a generic object that can be assigned to a callback at various
 * points in the rendering process.  This is actually a base class for a
 * handful of specialized callback object types.  You can also subclass it
 * yourself to make your own callback handler.
 */

3379 18 PhysxSceneStats2 * 0 8576 18 PhysxSceneStats2 * 18 PhysxSceneStats2 * 0 0 3110 0 0 0 0 0 0 0 0 0 0

3380 16 PhysxJointDesc * 0 8576 16 PhysxJointDesc * 16 PhysxJointDesc * 0 0 3080 0 0 0 0 0 0 0 0 0 0

3381 21 PhysxControllerDesc * 0 8576 21 PhysxControllerDesc * 21 PhysxControllerDesc * 0 0 3062 0 0 0 0 0 0 0 0 0 0

3382 21 PhysxForceFieldDesc * 0 8576 21 PhysxForceFieldDesc * 21 PhysxForceFieldDesc * 0 0 3088 0 0 0 0 0 0 0 0 0 0

3383 16 PhysxClothDesc * 0 8576 16 PhysxClothDesc * 16 PhysxClothDesc * 0 0 3074 0 0 0 0 0 0 0 0 0 0

3384 19 PhysxSoftBodyDesc * 0 8576 19 PhysxSoftBodyDesc * 19 PhysxSoftBodyDesc * 0 0 3112 0 0 0 0 0 0 0 0 0 0

3385 15 PhysxSoftBody * 0 8576 15 PhysxSoftBody * 15 PhysxSoftBody * 0 0 3045 0 0 0 0 0 0 0 0 0 0

3386 18 PhysxVehicleDesc * 0 8576 18 PhysxVehicleDesc * 18 PhysxVehicleDesc * 0 0 3111 0 0 0 0 0 0 0 0 0 0

3387 14 PhysxVehicle * 0 8576 14 PhysxVehicle * 14 PhysxVehicle * 0 0 3053 0 0 0 0 0 0 0 0 0 0

3388 20 PhysxRaycastReport * 0 8576 20 PhysxRaycastReport * 20 PhysxRaycastReport * 0 0 3107 0 0 0 0 0 0 0 0 0 0

3389 26 PhysxConstraintDominance * 0 8576 26 PhysxConstraintDominance * 26 PhysxConstraintDominance * 0 0 3076 0 0 0 0 0 0 0 0 0 0

3390 21 PhysxSoftBody const * 0 8576 21 PhysxSoftBody const * 21 PhysxSoftBody const * 0 0 3391 0 0 0 0 0 0 0 0 0 0

3391 19 PhysxSoftBody const 0 8832 19 PhysxSoftBody const 19 PhysxSoftBody const 0 0 3045 0 0 0 0 0 0 0 0 0 0

3392 19 PhysxSoftBodyNode * 0 8576 19 PhysxSoftBodyNode * 19 PhysxSoftBodyNode * 0 0 3047 0 0 0 0 0 0 0 0 0 0

3393 25 PhysxSoftBodyMesh const * 0 8576 25 PhysxSoftBodyMesh const * 25 PhysxSoftBodyMesh const * 0 0 3394 0 0 0 0 0 0 0 0 0 0

3394 23 PhysxSoftBodyMesh const 0 8832 23 PhysxSoftBodyMesh const 23 PhysxSoftBodyMesh const 0 0 3046 0 0 0 0 0 0 0 0 0 0

3395 12 Geom const * 0 8576 12 Geom const * 12 Geom const * 0 0 3396 0 0 0 0 0 0 0 0 0 0

3396 10 Geom const 0 8832 10 Geom const 10 Geom const 0 0 3397 0 0 0 0 0 0 0 0 0 0

3397 4 Geom 0 2048 4 Geom 4 Geom 0 0 0 0 0 0 0 0 0 0 0 0 418
/**
 * A container for geometry primitives.  This class associates one or more
 * GeomPrimitive objects with a table of vertices defined by a GeomVertexData
 * object.  All of the primitives stored in a particular Geom are drawn from
 * the same set of vertices (each primitive uses a subset of all of the
 * vertices in the table), and all of them must be rendered at the same time,
 * in the same graphics state.
 */

3398 28 PhysxSphereForceFieldShape * 0 8576 28 PhysxSphereForceFieldShape * 28 PhysxSphereForceFieldShape * 0 0 3048 0 0 0 0 0 0 0 0 0 0

3399 34 PhysxSphereForceFieldShape const * 0 8576 34 PhysxSphereForceFieldShape const * 34 PhysxSphereForceFieldShape const * 0 0 3400 0 0 0 0 0 0 0 0 0 0

3400 32 PhysxSphereForceFieldShape const 0 8832 32 PhysxSphereForceFieldShape const 32 PhysxSphereForceFieldShape const 0 0 3048 0 0 0 0 0 0 0 0 0 0

3401 32 PhysxSphereForceFieldShapeDesc * 0 8576 32 PhysxSphereForceFieldShapeDesc * 32 PhysxSphereForceFieldShapeDesc * 0 0 3114 0 0 0 0 0 0 0 0 0 0

3402 18 PhysxSphereShape * 0 8576 18 PhysxSphereShape * 18 PhysxSphereShape * 0 0 3049 0 0 0 0 0 0 0 0 0 0

3403 24 PhysxSphereShape const * 0 8576 24 PhysxSphereShape const * 24 PhysxSphereShape const * 0 0 3404 0 0 0 0 0 0 0 0 0 0

3404 22 PhysxSphereShape const 0 8832 22 PhysxSphereShape const 22 PhysxSphereShape const 0 0 3049 0 0 0 0 0 0 0 0 0 0

3405 22 PhysxSphereShapeDesc * 0 8576 22 PhysxSphereShapeDesc * 22 PhysxSphereShapeDesc * 0 0 3115 0 0 0 0 0 0 0 0 0 0

3406 21 PhysxSphericalJoint * 0 8576 21 PhysxSphericalJoint * 21 PhysxSphericalJoint * 0 0 3050 0 0 0 0 0 0 0 0 0 0

3407 27 PhysxSphericalJoint const * 0 8576 27 PhysxSphericalJoint const * 27 PhysxSphericalJoint const * 0 0 3408 0 0 0 0 0 0 0 0 0 0

3408 25 PhysxSphericalJoint const 0 8832 25 PhysxSphericalJoint const 25 PhysxSphericalJoint const 0 0 3050 0 0 0 0 0 0 0 0 0 0

3409 25 PhysxSphericalJointDesc * 0 8576 25 PhysxSphericalJointDesc * 25 PhysxSphericalJointDesc * 0 0 3116 0 0 0 0 0 0 0 0 0 0

3410 31 PhysxSphericalJointDesc const * 0 8576 31 PhysxSphericalJointDesc const * 31 PhysxSphericalJointDesc const * 0 0 3411 0 0 0 0 0 0 0 0 0 0

3411 29 PhysxSphericalJointDesc const 0 8832 29 PhysxSphericalJointDesc const 29 PhysxSphericalJointDesc const 0 0 3116 0 0 0 0 0 0 0 0 0 0

3412 25 PhysxTriangleMesh const * 0 8576 25 PhysxTriangleMesh const * 25 PhysxTriangleMesh const * 0 0 3413 0 0 0 0 0 0 0 0 0 0

3413 23 PhysxTriangleMesh const 0 8832 23 PhysxTriangleMesh const 23 PhysxTriangleMesh const 0 0 3051 0 0 0 0 0 0 0 0 0 0

3414 24 PhysxTriangleMeshShape * 0 8576 24 PhysxTriangleMeshShape * 24 PhysxTriangleMeshShape * 0 0 3052 0 0 0 0 0 0 0 0 0 0

3415 30 PhysxTriangleMeshShape const * 0 8576 30 PhysxTriangleMeshShape const * 30 PhysxTriangleMeshShape const * 0 0 3416 0 0 0 0 0 0 0 0 0 0

3416 28 PhysxTriangleMeshShape const 0 8832 28 PhysxTriangleMeshShape const 28 PhysxTriangleMeshShape const 0 0 3052 0 0 0 0 0 0 0 0 0 0

3417 28 PhysxTriangleMeshShapeDesc * 0 8576 28 PhysxTriangleMeshShapeDesc * 28 PhysxTriangleMeshShapeDesc * 0 0 3117 0 0 0 0 0 0 0 0 0 0

3418 12 PhysxWheel * 0 8576 12 PhysxWheel * 12 PhysxWheel * 0 0 3054 0 0 0 0 0 0 0 0 0 0

3419 17 PhysxWheelShape * 0 8576 17 PhysxWheelShape * 17 PhysxWheelShape * 0 0 3055 0 0 0 0 0 0 0 0 0 0

3420 23 PhysxWheelShape const * 0 8576 23 PhysxWheelShape const * 23 PhysxWheelShape const * 0 0 3421 0 0 0 0 0 0 0 0 0 0

3421 21 PhysxWheelShape const 0 8832 21 PhysxWheelShape const 21 PhysxWheelShape const 0 0 3055 0 0 0 0 0 0 0 0 0 0

3422 21 PhysxWheelShapeDesc * 0 8576 21 PhysxWheelShapeDesc * 21 PhysxWheelShapeDesc * 0 0 3120 0 0 0 0 0 0 0 0 0 0

3423 22 PhysxActorDesc const * 0 8576 22 PhysxActorDesc const * 22 PhysxActorDesc const * 0 0 3424 0 0 0 0 0 0 0 0 0 0

3424 20 PhysxActorDesc const 0 8832 20 PhysxActorDesc const 20 PhysxActorDesc const 0 0 3056 0 0 0 0 0 0 0 0 0 0

3425 21 PhysxBodyDesc const * 0 8576 21 PhysxBodyDesc const * 21 PhysxBodyDesc const * 0 0 3426 0 0 0 0 0 0 0 0 0 0

3426 19 PhysxBodyDesc const 0 8832 19 PhysxBodyDesc const 19 PhysxBodyDesc const 0 0 3057 0 0 0 0 0 0 0 0 0 0

3427 22 PhysxShapeDesc const * 0 8576 22 PhysxShapeDesc const * 22 PhysxShapeDesc const * 0 0 3428 0 0 0 0 0 0 0 0 0 0

3428 20 PhysxShapeDesc const 0 8832 20 PhysxShapeDesc const 20 PhysxShapeDesc const 0 0 3058 0 0 0 0 0 0 0 0 0 0

3429 16 ReferenceCount * 0 8576 16 ReferenceCount * 16 ReferenceCount * 0 0 3059 0 0 0 0 0 0 0 0 0 0

3430 10 PhysxBox * 0 8576 10 PhysxBox * 10 PhysxBox * 0 0 3061 0 0 0 0 0 0 0 0 0 0

3431 27 PhysxControllerDesc const * 0 8576 27 PhysxControllerDesc const * 27 PhysxControllerDesc const * 0 0 3432 0 0 0 0 0 0 0 0 0 0

3432 25 PhysxControllerDesc const 0 8832 25 PhysxControllerDesc const 25 PhysxControllerDesc const 0 0 3062 0 0 0 0 0 0 0 0 0 0

3433 24 PhysxBoxControllerDesc * 0 8576 24 PhysxBoxControllerDesc * 24 PhysxBoxControllerDesc * 0 0 3063 0 0 0 0 0 0 0 0 0 0

3434 30 PhysxBoxControllerDesc const * 0 8576 30 PhysxBoxControllerDesc const * 30 PhysxBoxControllerDesc const * 0 0 3435 0 0 0 0 0 0 0 0 0 0

3435 28 PhysxBoxControllerDesc const 0 8832 28 PhysxBoxControllerDesc const 28 PhysxBoxControllerDesc const 0 0 3063 0 0 0 0 0 0 0 0 0 0

3436 32 PhysxForceFieldShapeDesc const * 0 8576 32 PhysxForceFieldShapeDesc const * 32 PhysxForceFieldShapeDesc const * 0 0 3437 0 0 0 0 0 0 0 0 0 0

3437 30 PhysxForceFieldShapeDesc const 0 8832 30 PhysxForceFieldShapeDesc const 30 PhysxForceFieldShapeDesc const 0 0 3064 0 0 0 0 0 0 0 0 0 0

3438 35 PhysxBoxForceFieldShapeDesc const * 0 8576 35 PhysxBoxForceFieldShapeDesc const * 35 PhysxBoxForceFieldShapeDesc const * 0 0 3439 0 0 0 0 0 0 0 0 0 0

3439 33 PhysxBoxForceFieldShapeDesc const 0 8832 33 PhysxBoxForceFieldShapeDesc const 33 PhysxBoxForceFieldShapeDesc const 0 0 3065 0 0 0 0 0 0 0 0 0 0

3440 25 PhysxBoxShapeDesc const * 0 8576 25 PhysxBoxShapeDesc const * 25 PhysxBoxShapeDesc const * 0 0 3441 0 0 0 0 0 0 0 0 0 0

3441 23 PhysxBoxShapeDesc const 0 8832 23 PhysxBoxShapeDesc const 23 PhysxBoxShapeDesc const 0 0 3066 0 0 0 0 0 0 0 0 0 0

3442 14 PhysxSegment * 0 8576 14 PhysxSegment * 14 PhysxSegment * 0 0 3067 0 0 0 0 0 0 0 0 0 0

3443 20 PhysxSegment const * 0 8576 20 PhysxSegment const * 20 PhysxSegment const * 0 0 3444 0 0 0 0 0 0 0 0 0 0

3444 18 PhysxSegment const 0 8832 18 PhysxSegment const 18 PhysxSegment const 0 0 3067 0 0 0 0 0 0 0 0 0 0

3445 14 PhysxCapsule * 0 8576 14 PhysxCapsule * 14 PhysxCapsule * 0 0 3068 0 0 0 0 0 0 0 0 0 0

3446 28 PhysxCapsuleControllerDesc * 0 8576 28 PhysxCapsuleControllerDesc * 28 PhysxCapsuleControllerDesc * 0 0 3069 0 0 0 0 0 0 0 0 0 0

3447 34 PhysxCapsuleControllerDesc const * 0 8576 34 PhysxCapsuleControllerDesc const * 34 PhysxCapsuleControllerDesc const * 0 0 3448 0 0 0 0 0 0 0 0 0 0

3448 32 PhysxCapsuleControllerDesc const 0 8832 32 PhysxCapsuleControllerDesc const 32 PhysxCapsuleControllerDesc const 0 0 3069 0 0 0 0 0 0 0 0 0 0

3449 39 PhysxCapsuleForceFieldShapeDesc const * 0 8576 39 PhysxCapsuleForceFieldShapeDesc const * 39 PhysxCapsuleForceFieldShapeDesc const * 0 0 3450 0 0 0 0 0 0 0 0 0 0

3450 37 PhysxCapsuleForceFieldShapeDesc const 0 8832 37 PhysxCapsuleForceFieldShapeDesc const 37 PhysxCapsuleForceFieldShapeDesc const 0 0 3070 0 0 0 0 0 0 0 0 0 0

3451 29 PhysxCapsuleShapeDesc const * 0 8576 29 PhysxCapsuleShapeDesc const * 29 PhysxCapsuleShapeDesc const * 0 0 3452 0 0 0 0 0 0 0 0 0 0

3452 27 PhysxCapsuleShapeDesc const 0 8832 27 PhysxCapsuleShapeDesc const 27 PhysxCapsuleShapeDesc const 0 0 3071 0 0 0 0 0 0 0 0 0 0

3453 15 PhysxMeshPool * 0 8576 15 PhysxMeshPool * 15 PhysxMeshPool * 0 0 3072 0 0 0 0 0 0 0 0 0 0

3454 21 PhysxMeshPool const * 0 8576 21 PhysxMeshPool const * 21 PhysxMeshPool const * 0 0 3455 0 0 0 0 0 0 0 0 0 0

3455 19 PhysxMeshPool const 0 8832 19 PhysxMeshPool const 19 PhysxMeshPool const 0 0 3072 0 0 0 0 0 0 0 0 0 0

3456 28 PhysxCcdSkeletonDesc const * 0 8576 28 PhysxCcdSkeletonDesc const * 28 PhysxCcdSkeletonDesc const * 0 0 3457 0 0 0 0 0 0 0 0 0 0

3457 26 PhysxCcdSkeletonDesc const 0 8832 26 PhysxCcdSkeletonDesc const 26 PhysxCcdSkeletonDesc const 0 0 3073 0 0 0 0 0 0 0 0 0 0

3458 22 PhysxClothDesc const * 0 8576 22 PhysxClothDesc const * 22 PhysxClothDesc const * 0 0 3459 0 0 0 0 0 0 0 0 0 0

3459 20 PhysxClothDesc const 0 8832 20 PhysxClothDesc const 20 PhysxClothDesc const 0 0 3074 0 0 0 0 0 0 0 0 0 0

3460 20 PhysxClothMeshDesc * 0 8576 20 PhysxClothMeshDesc * 20 PhysxClothMeshDesc * 0 0 3075 0 0 0 0 0 0 0 0 0 0

3461 26 PhysxClothMeshDesc const * 0 8576 26 PhysxClothMeshDesc const * 26 PhysxClothMeshDesc const * 0 0 3462 0 0 0 0 0 0 0 0 0 0

3462 24 PhysxClothMeshDesc const 0 8832 24 PhysxClothMeshDesc const 24 PhysxClothMeshDesc const 0 0 3075 0 0 0 0 0 0 0 0 0 0

3463 16 LPoint2f const * 0 8576 16 LPoint2f const * 16 LPoint2f const * 0 0 3464 0 0 0 0 0 0 0 0 0 0

3464 14 LPoint2f const 0 8832 14 LPoint2f const 14 LPoint2f const 0 0 3465 0 0 0 0 0 0 0 0 0 0

3465 8 LPoint2f 0 2048 8 LPoint2f 8 LPoint2f 0 0 0 0 0 0 0 0 0 0 0 0 50
/**
 * This is a two-component point in space.
 */

3466 32 PhysxConstraintDominance const * 0 8576 32 PhysxConstraintDominance const * 32 PhysxConstraintDominance const * 0 0 3467 0 0 0 0 0 0 0 0 0 0

3467 30 PhysxConstraintDominance const 0 8832 30 PhysxConstraintDominance const 30 PhysxConstraintDominance const 0 0 3076 0 0 0 0 0 0 0 0 0 0

3468 21 PhysxConvexMeshDesc * 0 8576 21 PhysxConvexMeshDesc * 21 PhysxConvexMeshDesc * 0 0 3078 0 0 0 0 0 0 0 0 0 0

3469 27 PhysxConvexMeshDesc const * 0 8576 27 PhysxConvexMeshDesc const * 27 PhysxConvexMeshDesc const * 0 0 3470 0 0 0 0 0 0 0 0 0 0

3470 25 PhysxConvexMeshDesc const 0 8832 25 PhysxConvexMeshDesc const 25 PhysxConvexMeshDesc const 0 0 3078 0 0 0 0 0 0 0 0 0 0

3471 22 PhysxJointDesc const * 0 8576 22 PhysxJointDesc const * 22 PhysxJointDesc const * 0 0 3472 0 0 0 0 0 0 0 0 0 0

3472 20 PhysxJointDesc const 0 8832 20 PhysxJointDesc const 20 PhysxJointDesc const 0 0 3080 0 0 0 0 0 0 0 0 0 0

3473 27 PhysxJointDriveDesc const * 0 8576 27 PhysxJointDriveDesc const * 27 PhysxJointDriveDesc const * 0 0 3474 0 0 0 0 0 0 0 0 0 0

3474 25 PhysxJointDriveDesc const 0 8832 25 PhysxJointDriveDesc const 25 PhysxJointDriveDesc const 0 0 3083 0 0 0 0 0 0 0 0 0 0

3475 31 PhysxJointLimitSoftDesc const * 0 8576 31 PhysxJointLimitSoftDesc const * 31 PhysxJointLimitSoftDesc const * 0 0 3476 0 0 0 0 0 0 0 0 0 0

3476 29 PhysxJointLimitSoftDesc const 0 8832 29 PhysxJointLimitSoftDesc const 29 PhysxJointLimitSoftDesc const 0 0 3084 0 0 0 0 0 0 0 0 0 0

3477 21 PhysxJointDriveDesc * 0 8576 21 PhysxJointDriveDesc * 21 PhysxJointDriveDesc * 0 0 3083 0 0 0 0 0 0 0 0 0 0

3478 25 PhysxJointLimitSoftDesc * 0 8576 25 PhysxJointLimitSoftDesc * 25 PhysxJointLimitSoftDesc * 0 0 3084 0 0 0 0 0 0 0 0 0 0

3479 27 PhysxForceFieldDesc const * 0 8576 27 PhysxForceFieldDesc const * 27 PhysxForceFieldDesc const * 0 0 3480 0 0 0 0 0 0 0 0 0 0

3480 25 PhysxForceFieldDesc const 0 8832 25 PhysxForceFieldDesc const 25 PhysxForceFieldDesc const 0 0 3088 0 0 0 0 0 0 0 0 0 0

3481 37 PhysxForceFieldShapeGroupDesc const * 0 8576 37 PhysxForceFieldShapeGroupDesc const * 37 PhysxForceFieldShapeGroupDesc const * 0 0 3482 0 0 0 0 0 0 0 0 0 0

3482 35 PhysxForceFieldShapeGroupDesc const 0 8832 35 PhysxForceFieldShapeGroupDesc const 35 PhysxForceFieldShapeGroupDesc const 0 0 3089 0 0 0 0 0 0 0 0 0 0

3483 28 PhysxHeightFieldDesc const * 0 8576 28 PhysxHeightFieldDesc const * 28 PhysxHeightFieldDesc const * 0 0 3484 0 0 0 0 0 0 0 0 0 0

3484 26 PhysxHeightFieldDesc const 0 8832 26 PhysxHeightFieldDesc const 26 PhysxHeightFieldDesc const 0 0 3090 0 0 0 0 0 0 0 0 0 0

3485 16 PNMImage const * 0 8576 16 PNMImage const * 16 PNMImage const * 0 0 3486 0 0 0 0 0 0 0 0 0 0

3486 14 PNMImage const 0 8832 14 PNMImage const 14 PNMImage const 0 0 3487 0 0 0 0 0 0 0 0 0 0

3487 8 PNMImage 0 2048 8 PNMImage 8 PNMImage 0 0 0 0 0 0 0 0 0 0 0 0 1516
/**
 * The name of this class derives from the fact that we originally implemented
 * it as a layer on top of the "pnm library", based on netpbm, which was built
 * to implement pbm, pgm, and pbm files, and is the underlying support of a
 * number of public-domain image file converters.  Nowadays we are no longer
 * derived directly from the pnm library, mainly to allow support of C++
 * iostreams instead of the C stdio FILE interface.
 *
 * Conceptually, a PNMImage is a two-dimensional array of xels, which are the
 * PNM-defined generic pixel type.  Each xel may have a red, green, and blue
 * component, or (if the image is grayscale) a gray component.  The image may
 * be read in, the individual xels manipulated, and written out again, or a
 * black image may be constructed from scratch.
 *
 * A PNMImage has a color space and a maxval, the combination of which defines
 * how a floating-point linear color value is encoded as an integer value in
 * memory.  The functions ending in _val operate on encoded colors, whereas
 * the regular ones work with linear floating-point values.  All operations
 * are color space correct unless otherwise specified.
 *
 * The image is of size XSize() by YSize() xels, numbered from top to bottom,
 * left to right, beginning at zero.
 *
 * Files can be specified by filename, or by an iostream pointer.  The
 * filename "-" refers to stdin or stdout.
 *
 * This class is not inherently thread-safe; use it from a single thread or
 * protect access using a mutex.
 */

3488 9 short int 0 8258 9 short int 9 short int 0 1 0 0 0 0 0 0 0 0 0 0 0

3489 33 PhysxHeightFieldShapeDesc const * 0 8576 33 PhysxHeightFieldShapeDesc const * 33 PhysxHeightFieldShapeDesc const * 0 0 3490 0 0 0 0 0 0 0 0 0 0

3490 31 PhysxHeightFieldShapeDesc const 0 8832 31 PhysxHeightFieldShapeDesc const 31 PhysxHeightFieldShapeDesc const 0 0 3091 0 0 0 0 0 0 0 0 0 0

3491 21 PhysxJointLimitDesc * 0 8576 21 PhysxJointLimitDesc * 21 PhysxJointLimitDesc * 0 0 3092 0 0 0 0 0 0 0 0 0 0

3492 14 PhysxKitchen * 0 8576 14 PhysxKitchen * 14 PhysxKitchen * 0 0 3093 0 0 0 0 0 0 0 0 0 0

3493 20 PhysxKitchen const * 0 8576 20 PhysxKitchen const * 20 PhysxKitchen const * 0 0 3494 0 0 0 0 0 0 0 0 0 0

3494 18 PhysxKitchen const 0 8832 18 PhysxKitchen const 18 PhysxKitchen const 0 0 3093 0 0 0 0 0 0 0 0 0 0

3495 29 PhysxTriangleMeshDesc const * 0 8576 29 PhysxTriangleMeshDesc const * 29 PhysxTriangleMeshDesc const * 0 0 3496 0 0 0 0 0 0 0 0 0 0

3496 27 PhysxTriangleMeshDesc const 0 8832 27 PhysxTriangleMeshDesc const 27 PhysxTriangleMeshDesc const 0 0 3094 0 0 0 0 0 0 0 0 0 0

3497 29 PhysxSoftBodyMeshDesc const * 0 8576 29 PhysxSoftBodyMeshDesc const * 29 PhysxSoftBodyMeshDesc const * 0 0 3498 0 0 0 0 0 0 0 0 0 0

3498 27 PhysxSoftBodyMeshDesc const 0 8832 27 PhysxSoftBodyMeshDesc const 27 PhysxSoftBodyMeshDesc const 0 0 3095 0 0 0 0 0 0 0 0 0 0

3499 23 PhysxTriangleMeshDesc * 0 8576 23 PhysxTriangleMeshDesc * 23 PhysxTriangleMeshDesc * 0 0 3094 0 0 0 0 0 0 0 0 0 0

3500 23 PhysxSoftBodyMeshDesc * 0 8576 23 PhysxSoftBodyMeshDesc * 23 PhysxSoftBodyMeshDesc * 0 0 3095 0 0 0 0 0 0 0 0 0 0

3501 22 PhysxSceneDesc const * 0 8576 22 PhysxSceneDesc const * 22 PhysxSceneDesc const * 0 0 3502 0 0 0 0 0 0 0 0 0 0

3502 20 PhysxSceneDesc const 0 8832 20 PhysxSceneDesc const 20 PhysxSceneDesc const 0 0 3096 0 0 0 0 0 0 0 0 0 0

3503 12 PhysxPlane * 0 8576 12 PhysxPlane * 12 PhysxPlane * 0 0 3099 0 0 0 0 0 0 0 0 0 0

3504 18 PhysxPlane const * 0 8576 18 PhysxPlane const * 18 PhysxPlane const * 0 0 3505 0 0 0 0 0 0 0 0 0 0

3505 16 PhysxPlane const 0 8832 16 PhysxPlane const 16 PhysxPlane const 0 0 3099 0 0 0 0 0 0 0 0 0 0

3506 10 PhysxRay * 0 8576 10 PhysxRay * 10 PhysxRay * 0 0 3105 0 0 0 0 0 0 0 0 0 0

3507 20 NxRaycastHit const * 0 8576 20 NxRaycastHit const * 20 NxRaycastHit const * 0 0 3508 0 0 0 0 0 0 0 0 0 0

3508 18 NxRaycastHit const 0 8832 18 NxRaycastHit const 18 NxRaycastHit const 0 0 3509 0 0 0 0 0 0 0 0 0 0

3509 12 NxRaycastHit 0 2048 12 NxRaycastHit 12 NxRaycastHit 0 0 0 0 0 0 0 0 0 0 0 0 0

3510 23 PhysxRaycastHit const * 0 8576 23 PhysxRaycastHit const * 23 PhysxRaycastHit const * 0 0 3511 0 0 0 0 0 0 0 0 0 0

3511 21 PhysxRaycastHit const 0 8832 21 PhysxRaycastHit const 21 PhysxRaycastHit const 0 0 3106 0 0 0 0 0 0 0 0 0 0

3512 26 PhysxRaycastReport const * 0 8576 26 PhysxRaycastReport const * 26 PhysxRaycastReport const * 0 0 3513 0 0 0 0 0 0 0 0 0 0

3513 24 PhysxRaycastReport const 0 8832 24 PhysxRaycastReport const 24 PhysxRaycastReport const 0 0 3107 0 0 0 0 0 0 0 0 0 0

3514 21 NxUserRaycastReport * 0 8576 21 NxUserRaycastReport * 21 NxUserRaycastReport * 0 0 3108 0 0 0 0 0 0 0 0 0 0

3515 21 NxSceneStats2 const * 0 8576 21 NxSceneStats2 const * 21 NxSceneStats2 const * 0 0 3516 0 0 0 0 0 0 0 0 0 0

3516 19 NxSceneStats2 const 0 8832 19 NxSceneStats2 const 19 NxSceneStats2 const 0 0 3517 0 0 0 0 0 0 0 0 0 0

3517 13 NxSceneStats2 0 2048 13 NxSceneStats2 13 NxSceneStats2 0 0 0 0 0 0 0 0 0 0 0 0 0

3518 24 PhysxSceneStats2 const * 0 8576 24 PhysxSceneStats2 const * 24 PhysxSceneStats2 const * 0 0 3519 0 0 0 0 0 0 0 0 0 0

3519 22 PhysxSceneStats2 const 0 8832 22 PhysxSceneStats2 const 22 PhysxSceneStats2 const 0 0 3110 0 0 0 0 0 0 0 0 0 0

3520 24 PhysxVehicleDesc const * 0 8576 24 PhysxVehicleDesc const * 24 PhysxVehicleDesc const * 0 0 3521 0 0 0 0 0 0 0 0 0 0

3521 22 PhysxVehicleDesc const 0 8832 22 PhysxVehicleDesc const 22 PhysxVehicleDesc const 0 0 3111 0 0 0 0 0 0 0 0 0 0

3522 25 PhysxSoftBodyDesc const * 0 8576 25 PhysxSoftBodyDesc const * 25 PhysxSoftBodyDesc const * 0 0 3523 0 0 0 0 0 0 0 0 0 0

3523 23 PhysxSoftBodyDesc const 0 8832 23 PhysxSoftBodyDesc const 23 PhysxSoftBodyDesc const 0 0 3112 0 0 0 0 0 0 0 0 0 0

3524 13 PhysxSphere * 0 8576 13 PhysxSphere * 13 PhysxSphere * 0 0 3113 0 0 0 0 0 0 0 0 0 0

3525 38 PhysxSphereForceFieldShapeDesc const * 0 8576 38 PhysxSphereForceFieldShapeDesc const * 38 PhysxSphereForceFieldShapeDesc const * 0 0 3526 0 0 0 0 0 0 0 0 0 0

3526 36 PhysxSphereForceFieldShapeDesc const 0 8832 36 PhysxSphereForceFieldShapeDesc const 36 PhysxSphereForceFieldShapeDesc const 0 0 3114 0 0 0 0 0 0 0 0 0 0

3527 28 PhysxSphereShapeDesc const * 0 8576 28 PhysxSphereShapeDesc const * 28 PhysxSphereShapeDesc const * 0 0 3528 0 0 0 0 0 0 0 0 0 0

3528 26 PhysxSphereShapeDesc const 0 8832 26 PhysxSphereShapeDesc const 26 PhysxSphereShapeDesc const 0 0 3115 0 0 0 0 0 0 0 0 0 0

3529 14 PhysxUtilLib * 0 8576 14 PhysxUtilLib * 14 PhysxUtilLib * 0 0 3118 0 0 0 0 0 0 0 0 0 0

3530 20 PhysxUtilLib const * 0 8576 20 PhysxUtilLib const * 20 PhysxUtilLib const * 0 0 3531 0 0 0 0 0 0 0 0 0 0

3531 18 PhysxUtilLib const 0 8832 18 PhysxUtilLib const 18 PhysxUtilLib const 0 0 3118 0 0 0 0 0 0 0 0 0 0

3532 16 PhysxWheelDesc * 0 8576 16 PhysxWheelDesc * 16 PhysxWheelDesc * 0 0 3119 0 0 0 0 0 0 0 0 0 0

3533 22 PhysxWheelDesc const * 0 8576 22 PhysxWheelDesc const * 22 PhysxWheelDesc const * 0 0 3534 0 0 0 0 0 0 0 0 0 0

3534 20 PhysxWheelDesc const 0 8832 20 PhysxWheelDesc const 20 PhysxWheelDesc const 0 0 3119 0 0 0 0 0 0 0 0 0 0

3535 27 PhysxWheelShapeDesc const * 0 8576 27 PhysxWheelShapeDesc const * 27 PhysxWheelShapeDesc const * 0 0 3536 0 0 0 0 0 0 0 0 0 0

3536 25 PhysxWheelShapeDesc const 0 8832 25 PhysxWheelShapeDesc const 25 PhysxWheelShapeDesc const 0 0 3120 0 0 0 0 0 0 0 0 0 0

0
0
22
3537 10 get_shapes 0 1515 1517 22 PhysxActor::get_shapes 0

3538 18 get_contact_points 0 1748 1749 36 PhysxContactPair::get_contact_points 0

3539 10 get_scenes 0 1767 1769 24 PhysxManager::get_scenes 0

3540 17 get_height_fields 0 1770 1772 31 PhysxManager::get_height_fields 0

3541 17 get_convex_meshes 0 1773 1774 31 PhysxManager::get_convex_meshes 0

3542 19 get_triangle_meshes 0 1775 1776 33 PhysxManager::get_triangle_meshes 0

3543 16 get_cloth_meshes 0 1777 1778 30 PhysxManager::get_cloth_meshes 0

3544 20 get_soft_body_meshes 0 1779 1780 34 PhysxManager::get_soft_body_meshes 0

3545 17 get_ccd_skeletons 0 1781 1783 31 PhysxManager::get_ccd_skeletons 0

3546 16 get_shape_groups 0 1893 1894 33 PhysxForceField::get_shape_groups 0

3547 10 get_shapes 0 1908 1910 37 PhysxForceFieldShapeGroup::get_shapes 0

3548 12 get_overlaps 0 1993 1996 32 PhysxOverlapReport::get_overlaps 0

3549 10 get_actors 0 2047 2049 22 PhysxScene::get_actors 0

3550 10 get_joints 0 2050 2052 22 PhysxScene::get_joints 0

3551 13 get_materials 0 2053 2056 25 PhysxScene::get_materials 0

3552 15 get_controllers 0 2058 2060 27 PhysxScene::get_controllers 0

3553 16 get_force_fields 0 2061 2063 28 PhysxScene::get_force_fields 0

3554 28 get_force_field_shape_groups 0 2064 2066 40 PhysxScene::get_force_field_shape_groups 0

3555 10 get_cloths 0 2067 2069 22 PhysxScene::get_cloths 0

3556 15 get_soft_bodies 0 2070 2072 27 PhysxScene::get_soft_bodies 0

3557 12 get_vehicles 0 2073 2075 24 PhysxScene::get_vehicles 0

3558 8 get_hits 0 2781 2784 28 PhysxRaycastReport::get_hits 0

